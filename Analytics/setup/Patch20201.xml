<?xml version="1.0" encoding="UTF-8"?>
<Export generator="IRIS" version="26">
<Class name="%DeepSee.Component.pivotTable">
<Description><![CDATA[
Pivot table component.<br/>
This component gives users the ability to view and interact with a DeepSee cube
or subject area.<br/>
The data displayed by the pivot table can be supplied in various ways.
This is specified using the <property>dataSource</property>:
<ul>
<li>"manual" - Setting the value of the <property>userMDX</property> property to
a valid MDX statement will cause the pivotTable to display the results of the query.
This includes DRILLTHROUGH queries (which provide a listing of source data values).</li>
<li>"automatic" - The user can drag and drop member specifications onto one of the various
drop zones (supplied by the pivotController component) and the pivot table will automatically construct and execute an MDX query.
In this case, you must supply a value for the <property>cubeName</property> property.<br/>
This is the mode in which the DeepSee Analyzer works.</li>
</ul>]]></Description>
<IncludeCode>%DeepSee</IncludeCode>
<Super>%ZEN.Component.component</Super>
<System>3</System>
<TimeCreated>60121,64139.466364</TimeCreated>

<Property name="absolutePositioning">
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Parameter name="NAMESPACE">
<Default>http://www.intersystems.com/deepsee</Default>
</Parameter>

<Parameter name="DOMAIN">
<Description>
Localization domain</Description>
<Default>%DeepSee</Default>
</Parameter>

<Parameter name="DEFAULTENCLOSINGCLASS">
<Default>dsPivotEnclosingDiv</Default>
</Parameter>

<Parameter name="MAXCOLUMNS">
<Default>100</Default>
</Parameter>

<Parameter name="MAXLISTINGROWS">
<Default>1000</Default>
</Parameter>

<Property name="dataSource">
<Description>
Specifies how this pivot table gets data from a DeepSee source.</Description>
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"automatic"</InitialExpression>
<Parameter name="VALUELIST" value=",manual,automatic"/>
</Property>

<Property name="singleTable">
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="staleCache">
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="reinitialized">
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="dataSourceName">
<Description>
Name of data source associated with this pivot.</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
</Property>

<Property name="mdx">
<Description><![CDATA[
If defined and <property>dataSource</property> is set to "manual", then 
this is the MDX statement used to provide the contents of the pivot table.]]></Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENENCRYPT" value="1"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="userMDX">
<Description>
If defined, then this holds the user-supplied MDX statement used to 
provide the contents of the pivot table.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="kpi">
<Description>
If defined, then this is the name of the DeepSee KPI class used to provide 
the contents of the pivot table.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="currentQueryText">
<Description>
Text of most recently executed query</Description>
<Type>%DeepSee.Component.queryChunk</Type>
<Collection>array</Collection>
</Property>

<Property name="resolvedQueryText">
<Description>
Resolved text of most recently executed query</Description>
<Type>%DeepSee.Component.queryChunk</Type>
<Collection>array</Collection>
</Property>

<Property name="columnList">
<Description><![CDATA[
If defined, then this is a list of columns to display when displaying a KPI-based pivot.
Each item in the list can also define a caption: "property:caption,..."
as well as a format: "property:caption:format,..." <br/>
"," and ":" can be escaped with "\," and "\:"]]></Description>
<Type>%ZEN.Datatype.csv</Type>
</Property>

<Property name="valueColumn">
<Description><![CDATA[
If defined, then this is the name of the column that provides the value for 
a row within this pivot. This value is used when a row is selected, and a dashboard
*action* is invoked on the pivot.<br/>
This only applies to KPI-based pivots.
If not provided, then the first column is used.]]></Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="hideMeasures">
<Description>
Indicates if and how measures should be displayed
0 = Always
1 = If More Than 1 Measure
2 = Never</Description>
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="hiddenMeasureText">
<Type>%ZEN.Datatype.string</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="rowCaptionList">
<Type>%ZEN.Datatype.string</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="showPlan">
<Description>
If true, execute a show plan for the query.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="cellWidth">
<Description>
This is the minimum width (in pixels) used for all cells within the table.
The default is 120.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>120</InitialExpression>
</Property>

<Property name="rowLabelSpan">
<Description><![CDATA[
This specifies how parent row labels with multiple child labels are displayed.<br/>
If true, then one parent label is displayed for each set of children.
If false, then the parent row label is repeated for each child.]]></Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="columnLabelSpan">
<Description><![CDATA[
This specifies how parent column labels with multiple child labels are displayed.<br/>
If true, then one parent label is displayed for each set of children.
If false, then the parent row label is repeated for each child.]]></Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="cellHeight">
<Description>
This is the height (in pixels) used for all cells within the table.
The default is 22.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>22</InitialExpression>
</Property>

<Property name="showEmptyRows">
<Description><![CDATA[
If true, display rows containing only empty values.<br/>
If <var>mdx</var> is specified, this is ignored.]]></Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="showEmptyColumns">
<Description><![CDATA[
If true, display columns containing only empty values.<br/>
If <var>mdx</var> is specified, this is ignored.]]></Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="cubeName">
<Description>
Name of the cube that will provide data for this pivot table.</Description>
<Type>%ZEN.Datatype.className</Type>
<Parameter name="ZENEXPRESSION" value="1"/>
</Property>

<Property name="caption">
<Description>
Caption to display. If not specified, the caption for the cube will be used.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="listing">
<Description>
Name of listing to use for the current detail listing. If empty, the default listing is used.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="defaultListing">
<Description>
Name of listing to use for the default detail listing. If empty, the default listing for the cube is used.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="listingEnabled">
<Description>
If true, then listings are enabled for this pivot.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="listingSelect">
<Description>
Specifies the select mode for a detail listing: none, "single", or "multi".</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="VALUELIST" value=",single,multi"/>
</Property>

<Property name="listingType">
<Description>
Specifies the type of detail listing to show: "table", or "map".</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<InitialExpression>"table"</InitialExpression>
<Parameter name="VALUELIST" value=",table,map"/>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="listingRows">
<Description>
Maximum number of total rows to display within a detail listing.
If empty, the default value (1000) is used.</Description>
<Type>%ZEN.Datatype.integer</Type>
</Property>

<Property name="listingPageSize">
<Description>
Number of rows to display within one page of a detail listing.
If empty, the default value (100) is used.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>100</InitialExpression>
</Property>

<Property name="pivotSelect">
<Description><![CDATA[
Specifies the select mode for the pivot table: none, "single", or "multi".
Turning this on displays check boxes for each row in the pivot table.
This is different from the built-in cell range selection mechanism.<br/>
This only applies to KPI-based pivots.]]></Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="VALUELIST" value=",single,multi"/>
</Property>

<Property name="cubeKey">
<Description>
Internal property used to remember the normalized cube name for this table.</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="queryKey">
<Description>
Internal property used to remember the query key for this table.</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="listingKey">
<Description>
Internal property used to caching listing results for this table.</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="pivotNonce">
<Description>
Internal property to track this specific pivot instance. This is used to cancel query execution.</Description>
<Type>%ZEN.Datatype.integer</Type>
<Internal>1</Internal>
<InitialExpression>$R(1000000000)</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="totalValue">
<Description>
Internal property used to track the current total of cell values.</Description>
<Type>%ZEN.Datatype.float</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="cellCount">
<Description>
Internal property used to track the number of cells.</Description>
<Type>%ZEN.Datatype.integer</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="columnsTruncated">
<Description>
Internal property used to track if we truncated the number of displayed columns.</Description>
<Type>%ZEN.Datatype.integer</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="queryStatus">
<Description>
Internal property used to track the current query status.</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="queryComplete">
<Description>
Internal property used to track the completion percentage of the current query.</Description>
<Type>%ZEN.Datatype.float</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="queryCalls">
<Description>
Internal property used to track number of calls to track the current query.</Description>
<Type>%ZEN.Datatype.integer</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="queryPending">
<Description>
Internal property used to track whether the current query has pending results 
(such as async KPIs being computed).</Description>
<Type>%ZEN.Datatype.boolean</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="showStatus">
<Description>
If true, show status area along the bottom of the table.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="showPivotStats">
<Description>
If true, show pivot cell count and total in status area along the bottom of the table.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="showQuery">
<Description><![CDATA[
If true, show the query used to get results for this table.<br/>
This is a intended for use as a troubleshooting aid.]]></Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="canDrillDown">
<Description>
If true, user can drill down by double-clicking on row captions.
This is only enabled for queries automatically generated by the pivot table.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<Internal>1</Internal>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="rowAxisOptions">
<Description>
This is used to define functions to apply to the entire row axis.</Description>
<Type>pivotLevel</Type>
</Property>

<Property name="columnAxisOptions">
<Description>
This is used to define functions to apply to the entire column axis.</Description>
<Type>pivotLevel</Type>
</Property>

<Property name="rowLevels">
<Description>
This contains the definition of the row dimensions for this pivot table.</Description>
<Type>pivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="rowLevel"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="columnLevels">
<Description>
This contains the definition of the column dimensions for this pivot table.</Description>
<Type>pivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="columnLevel"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="filters">
<Description>
This contains the definition of the filters for this pivot table.</Description>
<Type>pivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="filter"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="sqlRestriction">
<Description>
This contains an SQL restriction that should be applied to this pivot table.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLNAME" value="sqlRestriction"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="contextFilterSpec">
<Description>
Externally applied filter spec. This should contain a valid %FILTER clause.
If it starts with "%FILTER" then it is one or more %FILTER clauses.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="overrideColumnSpec">
<Description>
Externally applied COLUMNS spec. This should contain a valid MDX expression (without "ON COLUMNS").</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="overrideColumnText">
<Description>
Text value associated with overrideColumnSpec. Used as a label.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="overrideRowSpec">
<Description>
Externally applied ROWS spec. This should contain a valid MDX expression (without "ON ROWS").</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="overrideRowText">
<Description>
Text value associated with overrideRowSpec. Used as a label.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="measures">
<Description>
This contains the default measure(s) (e.g., "[Measures].[Sales]") to show for this pivot table.</Description>
<Type>pivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="measure"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="measureLocation">
<Description>
When there are multiple measures in the measures list, speficies where to 
place them: "rows", or "columns".</Description>
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"columns"</InitialExpression>
<Parameter name="VALUELIST" value="rows,columns"/>
</Property>

<Property name="drillLevels">
<Description>
This contains the current set of "drill into" levels for this pivot table.</Description>
<Type>pivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="drillLevel"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="drillRowNumbers">
<Type>%ZEN.Datatype.string</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="listingFilters">
<Description>
This is the set of filters that describe the cell(s) used for the current listing for this pivot table.</Description>
<Type>pivotLevel</Type>
<Internal>1</Internal>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="listingFilter"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="listingFields">
<Description>
This is the set of fields that describe the columnns used for the current custom listing for this pivot table.</Description>
<Type>pivotLevel</Type>
<Internal>1</Internal>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="listingField"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="canUseListingFields">
<Description>
If true, user can select their own fields for listing.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="pageSize">
<Description>
Number of pivot result rows to show at one time.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>100</InitialExpression>
</Property>

<Property name="currPage">
<Description>
This is the number (1-based) of the "page" within the query
results that is currently displayed.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="sortColumn">
<Description>
If not 0, then sort the results by the values within this column.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="sortDir">
<Description>
If column sorting is on, then this is the sort direction.</Description>
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"ASC"</InitialExpression>
<Parameter name="VALUELIST" value="ASC,DESC"/>
</Property>

<Property name="currListingPage">
<Description>
This is the number (1-based) of the "page" within the listing that is currently displayed.
If this is set to -1, then the first page will be displayed AND the listing will be recomputed.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>-1</InitialExpression>
</Property>

<Property name="listingSortColumn">
<Description>
If not 0, then sort the listing table by the values within this column.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="listingSortDir">
<Description>
If listing column sorting is on, then this is the sort direction.</Description>
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"ASC"</InitialExpression>
<Parameter name="VALUELIST" value="ASC,DESC"/>
</Property>

<Property name="rowCount">
<Description><![CDATA[
If present, this is the number of rows returned by the current
query. This is calculated in both user query and
automatic query modes.<br/>]]></Description>
<Type>%ZEN.Datatype.integer</Type>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="jsonRows">
<Description>
Maximum number of data rows emitted as JSON to drive charts.
If empty, the default value (2500) is used.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>2500</InitialExpression>
</Property>

<Property name="listingRowCount">
<Description>
If present, this is the total number of rows returned by the current listing.</Description>
<Type>%ZEN.Datatype.integer</Type>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="columnCount">
<Description><![CDATA[
If present, this is the number of columns returned by the current
query. This is calculated in both user query and
automatic query modes.<br/>]]></Description>
<Type>%ZEN.Datatype.integer</Type>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="formatRules">
<Description>
This contains any conditional formatting rules for the table.</Description>
<Type>pivotCondition</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="formatRule"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="calculatedMembers">
<Description>
This contains any local calculated members for the table.</Description>
<Type>calculatedMember</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="calculatedMember"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="selectedRange">
<Description><![CDATA[
This specifies the current selected range of cells as a
comma-separated list of integers. The list is of the form:<br/>
startRow,startCol,endRow,endCol,allRows,allCols<br/>
All cells numbers are 1-based and represent the ordinal position of cells as they
are displayed and not their position within the underlying query 
(e.g., when columns are sorted, these are still 1,2,3).<br/>
If allRows is 1, then all rows for indicated columns are selected.<br/>
If allCols is 1, then all columns for indicated rows are selected.<br/>
If the range is equal to "", then no cells are selected.]]></Description>
<Type>%ZEN.Datatype.csv</Type>
</Property>

<Property name="selectedCellBackground">
<Description>
Background color applied to the selected cell range.</Description>
<Type>%ZEN.Datatype.style</Type>
<InitialExpression>"rgb(47,98,128)"</InitialExpression>
</Property>

<Property name="selectedCellColor">
<Description>
Color applied to the selected cell range.</Description>
<Type>%ZEN.Datatype.style</Type>
<InitialExpression>"white"</InitialExpression>
</Property>

<Property name="columnHeaderStyle">
<Description>
Optional style to apply to column headers.</Description>
<Type>%ZEN.Datatype.style</Type>
</Property>

<Property name="rowHeaderStyle">
<Description>
Optional style to apply to row headers.</Description>
<Type>%ZEN.Datatype.style</Type>
</Property>

<Property name="cellStyle">
<Description>
Optional style to apply to cells.</Description>
<Type>%ZEN.Datatype.style</Type>
</Property>

<Property name="tableStyle">
<Description>
Optional style to apply to entire table</Description>
<Type>%ZEN.Datatype.style</Type>
<InitialExpression>"background-color:white"</InitialExpression>
</Property>

<Property name="showZebra">
<Description>
If true, show zebra striping.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="showRowCaption">
<Description>
If true, show a caption above the row headers.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="rowCaptionText">
<Description>
Holder for row caption text.</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="evenRowStyle">
<Description>
Optional style to apply to even rows in zebra stripe mode.</Description>
<Type>%ZEN.Datatype.style</Type>
</Property>

<Property name="colorScale">
<Description>
If set, this is the name of the color-scaling scheme to apply.
red-to-black,green-to-black,blue-to-black,salmon-to-black,purple-to-black,gray-to-black
or "custom:r1,g1,b1:r2,g2,b2".</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="analyzerMode">
<Description>
Special flag to indicate use of pivot within the Analyzer.
For now this turns on a background image.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="backgroundImage">
<Description>
Optional image to show in background of pivot table.</Description>
<Type>%ZEN.Datatype.uri</Type>
</Property>

<Property name="backgroundOpacity">
<Description>
Opacity (0 to 1) of pivot table background image.</Description>
<Type>%ZEN.Datatype.float</Type>
<InitialExpression>0.12</InitialExpression>
</Property>

<Property name="isDrillThrough">
<Description><![CDATA[
When set true, the current query is executed as a DRILLTHROUGH.<br/>
If the current data source is a KPI, then execute a listing provided by the KPI (if available).]]></Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="parameters">
<Description>
User-defined set of parameters. These values are passed on
to the user callback functions that provides the contents of 
this table. Typically this is used to hold search parameters.</Description>
<Type>%ZEN.Auxiliary.parameter</Type>
<Collection>array</Collection>
<Parameter name="XMLKEYNAME" value="paramName"/>
<Parameter name="XMLNAME" value="parameter"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="%message">
<Description>
If set, then only one cell is displayed with this message text.</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="rowTotals">
<Description>
If true, then display row totals.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="columnTotals">
<Description>
If true, then display column totals.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="rowTotalAgg">
<Description>
Indicate which aggregate to use for row totals: sum,min,max,count,avg,pct.</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<InitialExpression>"sum"</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="columnTotalAgg">
<Description>
Indicate which aggregate to use for column totals: sum,min,max,count,avg,pct.</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<InitialExpression>"sum"</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="rowTotalSource">
<Description>
Indicate the source for row totals: "page" or "all".</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<InitialExpression>"page"</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="%ResultSet">
<Description>
Current DeepSee result set being processed.</Description>
<Type>%DeepSee.ResultSet</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="%KPIController">
<Description>
Current data controller used to get KPI data.</Description>
<Type>%ZEN.Auxiliary.dataController</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="data">
<Description>
The client-side object graph referred to by this property contains the most recent
data for this pivot table.</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="oncellClick">
<Description><![CDATA[
oncellClick event handler:
This event handler is called by the pivot
when the user clicks the mouse on a cell within the pivot table.<br/>
The event handler is passed an argument, <var>pivot</var>,
that is <i>this</i> pivot table object.]]></Description>
<Type>%ZEN.Datatype.eventHandler</Type>
</Property>

<Property name="oncellDblClick">
<Description><![CDATA[
oncellDblClick event handler:
This event handler is called by the pivot
when the user double clicks the mouse on a cell within the pivot table.<br/>
The event handler is passed an argument, <var>pivot</var>,
that is <i>this</i> pivot table object.]]></Description>
<Type>%ZEN.Datatype.eventHandler</Type>
</Property>

<Property name="ondrill">
<Description><![CDATA[
ondrill event handler:
This event handler is called by the pivot
whenever the drill down state of the pivot is changed.<br/>
The event handler is passed an argument, <var>pivot</var>,
that is <i>this</i> pivot table object.]]></Description>
<Type>%ZEN.Datatype.eventHandler</Type>
</Property>

<Property name="onlistingSelect">
<Description><![CDATA[
onlistingSelect event handler:
This event handler is called by the pivot
when the user selects or unselected an item within a pivot listing.<br/>
The event handler is passed an argument, <var>pivot</var>,
that is <i>this</i> pivot table object.]]></Description>
<Type>%ZEN.Datatype.eventHandler</Type>
</Property>

<Property name="isPaging">
<Description>
Internal flag. Set true when paging among query results.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="initialExecute">
<Description>
If true, then automatically execute queries when this pivot is first displayed.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="autoExecute">
<Description>
If true then automatically execute queries when filters, rows, or columns are changed.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="previewMode">
<Description>
Initial value of previewMode setting for the Analyzer</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="allowPreviewInteraction">
<Description>
Allow the user to interact with the pivot even in preview mode.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="previewRowCount">
<Description>
The row limit used to truncate while in SAMPLE mode.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>25</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="rowsTruncated">
<Description>
This flag is set when the resultset has seen its rows truncated by a HEAD function.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="changesPending">
<Description>
If autoExecute is off, then this tracks that a refresh is needed.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="selectedRowValues">
<Description>
Internal property used to remember the set of selected row values.</Description>
<Type>%ZEN.Datatype.string</Type>
<Internal>1</Internal>
<Parameter name="XMLPROJECTION" value="none"/>
<Parameter name="ZENSETTING" value="0"/>
</Property>

<Property name="printTitle">
<Description>
Title to display when pivot is printed.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printSubtitle">
<Description>
Subtitle to display when pivot is printed.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printOrientation">
<Description>
Orientation when pivot is printed: "portrait" or "landscape".</Description>
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printSubtitleOn">
<Description>
Display the subtitle when exporting to PDF</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showUser">
<Description>
Display the user when exporting to PDF</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printPageSize">
<Description>
Page size when pivot is printed. This takes the form "8.5x11 in" (w x h).</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printMarginTop">
<Description>
Page top margin when pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printMarginLeft">
<Description>
Page left margin when pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printMarginRight">
<Description>
Page right margin when pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printMarginBottom">
<Description>
Page bottom margin when pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printLabelWidth">
<Description>
Width of row labels when the pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printCellWidth">
<Description>
Width of data cells when the pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="maxRows">
<Description>
Max rows exported to PDF</Description>
<Type>%ZEN.Datatype.integer</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderLeftCell">
<Description>
Table borders</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderRightCell">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderTopCell">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderBottomCell">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderLeftCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderRightCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderTopCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderBottomCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderLeftRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderRightRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderTopRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderBottomRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Table styles -- added by WAL100

]]></Content>
</UDLText>

<Property name="fontFamilyCell">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="fontSizeCell">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="fontFamilyCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="fontSizeCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="fontFamilyRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="fontSizeRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showFilters">
<Description>
showFilters - byTable, byTitle, off</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showListingFilters">
<Description>
showListingFilters - on, off</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showDate">
<Description>
showDate - on, off</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showZebraStripes">
<Description>
showZebraStripes - on, off</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="listingFontSize">
<Description>
Font fize used in listing</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="filterTableStyle">
<Description>
filterTableStyle</Description>
<Type>%ZEN.Datatype.style</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="filterTableCaptionStyle">
<Description>
filterTableCaptionStyle;</Description>
<Type>%ZEN.Datatype.style</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="filterTableItemStyle">
<Description>
filterTableItemStyle;</Description>
<Type>%ZEN.Datatype.style</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="nowDisplayFormat">
<Description>
nowDisplayFormat</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showPivot">
<Description>
If true, then write out HTML for this pivot
otherwise only serve up JSON data (to drive other components).</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="crossJoinRowLimit">
<Description>
Maximum number of rows to display for a CROSSJOIN.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>2000</InitialExpression>
</Property>

<Property name="headFunctionAdded">
<Description>
Flag to indicate a HEAD function has been added to an axis by the Analyzer</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="pivotVariables">
<Description>
Run-time value of pivot variables used by this pivot.</Description>
<Type>%String</Type>
<Internal>1</Internal>
<Collection>array</Collection>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="maxChartSize">
<Description>
Certain chart types may have different maximum sizes that make sense.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>400</InitialExpression>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<XData name="Style">
<Description>
defines the style sheet used by this component.</Description>
<Data><![CDATA[
<style type="text/css">

	/* WAL */
	/* WAL nub */
div.dsNub {
	background: #C0C0C0;
	background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
	background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
	background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
	background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
	background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
	background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */
	
	text-align: left;
	vertical-align: bottom;
	color: #404040;
	font-size: 7pt;
	overflow: hidden;
}

div.dsNubInner {
	font-weight: bold;
	padding-left:2px;
	vertical-align: bottom;
	display: table-cell;
	
	border-bottom: 1px solid #D0D0D0;
}	

div.dsNubZebra {
	
	border-right: 1px solid #D0D0D0;
	border-bottom: 1px solid #D0D0D0;

	background: #F0F0F0;
	background-image: none;
	text-align: left;
	vertical-align: bottom;

	color: #404040;
	font-size: 7pt;
	
	padding-left: 2px;
	overflow: hidden;
}

div.dsNub:hover,
div.dsNubZebra:hover {
	background: #FFEEAA;
}

div.dsPivotCompleteTable .dsPivotRowEven:hover,
div.dsPivotCompleteTable .dsPivotRowOdd:hover {
	background: #FFEEAA;
}


div.dsPivotCompleteTableDiv .dsPivotRowEven:hover,
div.dsPivotCompleteTableDiv .dsPivotRowOdd:hover {
	background: #FFEEAA;
}

.topTable, .sideTable, .dataTable, .nubTable {
	position: absolute;	
}

/* column label */
/*div.dsPivotColumn,*/
div.dsPivotColumnSort {
	font-weight: bold;
	font-size: 10pt;
	padding: 0px;
	text-align: center;
	vertical-align: middle;

	background: #C0C0C0;
	background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
	background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
	background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
	background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
	background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
	background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */
}
div.dsPivotColumnSort:hover {
	background: #FFEEAA;
}


div.dsPivotCompleteTable .dsPivotColumnZebra {
	border-right: 1px solid #D0D0D0;
	border-bottom: 1px solid #D0D0D0;
	font-weight: bold;
	color: #404040;
	padding: 0px;
	text-align: center;
	vertical-align: middle;
	background: #F0F0F4;
	background-image: none;
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
}

div.dsPivotCompleteTableDiv .dsPivotColumnZebra {
	border-right: 1px solid #D0D0D0;
	border-bottom: 1px solid #D0D0D0;
	font-weight: bold;
	color: #404040;
	padding: 0px;
	text-align: center;
	vertical-align: middle;
	background: #F0F0F4;
	background-image: none;
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
}

.dataTable .dsPivotRowEven {
	color: #404040;
	text-align: right;
	vertical-align: middle;
	background: #F0F0F4;
	background-image: none;
	border-right: none;
	border-bottom: none;
}

.dataTable .dsPivotRowOdd {
	color: #404040;
	text-align: right;
	vertical-align: middle;
	background: white;
	background-image: none;
	border-right: none;
	border-bottom: none;
}
.dataTable .dsPivotRowEven:hover{
	background: #FFEEAA;
}

.dataTable .dsPivotRowOdd:hover {
		background: #FFEEAA;
}

/* zebra stuff */
div.dsPivotCompleteTable .dsPivotColumnSortZebra {
	font-weight: bold;
	color: #404040;
	padding: 0px;
	text-align: center;
	vertical-align: middle;
	background: #F0F0F4;
	overflow: hidden;
	background-image: none;

	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
}

div.dsPivotCompleteTableDiv .dsPivotColumnSortZebra {
	font-weight: bold;
	font-size: 10pt;
	color: #404040;
	padding: 0px;
	text-align: center;
	vertical-align: middle;
	background: #F0F0F4;
	overflow: hidden;
	background-image: none;

	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
}

.sideTable .dsPivotRowEven {
	font-weight: bold;
	color: #404040;
	text-align: left;
	vertical-align: middle;
	background: #F0F0F4;
	background-image: none;
	border-right: none;
	border-bottom: none;
}

.sideTable .dsPivotRowOdd {
	font-weight: bold;
	color: #404040;
	text-align: left;
	vertical-align: middle;
	background: white;
	background-image: none;
	border-right: none;
	border-bottom: none;
}

div.dsPivotCompleteTable .dsPivotColumn:hover,
div.dsPivotCompleteTable .dsPivotRow:hover	{
	background: #FFEEAA;
	color: #404080;
}


div.dsPivotCompleteTableDiv .dsPivotColumn:hover,
div.dsPivotCompleteTableDiv .dsPivotRow:hover	{
	background: #FFEEAA;
	color: #404080;
}

div.dsPivotCompleteTable .dsPivotNum:hover,
div.dsPivotCompleteTable .dsPivotColumnZebra:hover,
div.dsPivotCompleteTable .dsPivotColumnSortZebra:hover {
	background: #FFEEAA;
}

div.dsPivotCompleteTableDiv .dsPivotNum:hover,
div.dsPivotCompleteTableDiv .dsPivotColumnZebra:hover,
div.dsPivotCompleteTableDiv .dsPivotColumnSortZebra:hover {
	background: #FFEEAA;
}

/* wrapper around row header */
/* WAL */
/* this makes sure the clickable area takes up the full amount of space */
/* PFS058 - Add white-space:nowrap to account for 1px difference in WebKit vs Gecko, padding will prevent display errors */
div.dsPivotRowDiv {
	padding-top: 2px;
	padding-left: 2px;
	padding-right: 10px;
	height:100%;
	width:100%;
	vertical-align: middle;
	display:table-cell;
	white-space:nowrap;
}

/* wrapper around column header */
/* PFS030 - Add text-align: center; to center column header text */
div.dsPivotColumnDiv {
	padding-top: 2px;
	padding-left: 2px;
	padding-right: 2px;
	padding-bottom: 2px;
	overflow: hidden;
	background: none;
	text-align: center;
	display:table-cell;
}

div.dsPivotColumnOuter {
	display: table;
	height: 100%;
	width: 100%;
}

/* WAL -- div version */
div.dsPivotCompleteTable {
	position: absolute;
	left:0;
	top:0;
	background: #D0D0D0;
	font-size: 10pt;
	padding: 0px;
	height: auto;
	font-family: Arial;
	border-collapse: collapse;
	box-shadow: 2px 2px 25px rgba(0,0,0,0.25);
	/*border-right: 1px solid #D0D0D0;
	border-bottom: 1px solid #D0D0D0;*/
}

/* row label */
div.dsPivotCompleteTable .dsPivotRow {
	text-align: left;
	vertical-align: middle;
	font-weight: bold;
	background: #C0C0C0;
	background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
	background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
	background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
	background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
	background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
	background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */

	border-bottom: 1px solid #D0D0D0;
}	

/* pick up row height from the cell height? */
div.dsPivotCompleteTable .dsPivotRow {
	/*height: 22px;*/
	overflow: hidden;
	vertical-align: middle;

	border-right: 1px solid #D0D0D0;
	border-bottom: 1px solid #D0D0D0;

	-webkit-transition-property: background;
	-webkit-transition-duration: 0s;
	-webkit-transition-timing-function: ease;
	-moz-transition-property: background;
	-moz-transition-duration: 0s;
	-moz-transition-timing-function: ease;
	transition-property: background;
	transition-duration: 0s;
	transition-timing-function: ease;

	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
}

/* row label */
div.dsPivotCompleteTableDiv .dsPivotRow {
	text-align: left;
	vertical-align: middle;
	font-weight: bold;
	font-size: 10pt;
	background: #C0C0C0;
	background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
	background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
	background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
	background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
	background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
	background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */

	border-bottom: 1px solid #D0D0D0;
}	

/* pick up row height from the cell height? */
div.dsPivotCompleteTableDiv .dsPivotRow {
	/*height: 22px;*/
	overflow: hidden;
	vertical-align: middle;

	border-right: 1px solid #D0D0D0;
	border-bottom: 1px solid #D0D0D0;

	-webkit-transition-property: background;
	-webkit-transition-duration: 0s;
	-webkit-transition-timing-function: ease;
	-moz-transition-property: background;
	-moz-transition-duration: 0s;
	-moz-transition-timing-function: ease;
	transition-property: background;
	transition-duration: 0s;
	transition-timing-function: ease;

	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
}

div.dsPivotCompleteTable .dsPivotColumn {
	text-align: left;
	vertical-align: middle;
	font-weight: bold;
	background: #C0C0C0;
	background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
	background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
	background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
	background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
	background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
	background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */

	border-bottom: 1px solid #D0D0D0;
}	

div.dsPivotCompleteTable .dsPivotColumn {
	/*height: 22px;*/
	overflow: hidden;
	vertical-align: middle;

	border-right: 1px solid #D0D0D0;
	border-bottom: 1px solid #D0D0D0;
	
	/*display: inline-block;*/

	-webkit-transition-property: background;
	-webkit-transition-duration: 0s;
	-webkit-transition-timing-function: ease;
	-moz-transition-property: background;
	-moz-transition-duration: 0s;
	-moz-transition-timing-function: ease;
	transition-property: background;
	transition-duration: 0s;
	transition-timing-function: ease;

	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
}


div.dsPivotCompleteTableDiv .dsPivotColumn {
	font-weight: bold;
	font-size: 10pt;
	background: #C0C0C0;
	background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
	background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
	background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
	background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
	background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
	background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */

	border-bottom: 1px solid #D0D0D0;
}	

div.dsPivotCompleteTableDiv .dsPivotColumn {
	/*height: 22px;*/
	overflow: hidden;

	border-right: 1px solid #D0D0D0;
	border-bottom: 1px solid #D0D0D0;
	
	/*display: inline-block;*/

	-webkit-transition-property: background;
	-webkit-transition-duration: 0s;
	-webkit-transition-timing-function: ease;
	-moz-transition-property: background;
	-moz-transition-duration: 0s;
	-moz-transition-timing-function: ease;
	transition-property: background;
	transition-duration: 0s;
	transition-timing-function: ease;

	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
}

.dsPivotNum {
	text-align: right;
}

div.dsPivotCompleteTable .dsptCellDiv {
	width: 100%;
	height: 100%;
	padding-top: 1px;
	/*
	padding-right: 2px;
	/*padding-left: 2px;
	
	padding-bottom: 1px;
	*/
	text-align: right;
	overflow: hidden;
	word-wrap: break-word;
}

div.dsPivotCompleteTable  .dsptCellDiv:hover {
	background: #FFEEAA;
}


div.dsPivotCompleteTable .dsPivotNum {
	
	border-right: 1px solid #E9E9E9;
	border-bottom: 1px solid #E9E9E9;

	overflow: hidden;
	vertical-align: middle;
	
	background: white;
	font-size: 10pt;

	-webkit-transition-property: background;
	-webkit-transition-duration: 0.25s;
	-webkit-transition-timing-function: ease;
	-moz-transition-property: background;
	-moz-transition-duration: 0.25s;
	-moz-transition-timing-function: ease;
	transition-property: background;
	transition-duration: 0.25s;
	transition-timing-function: ease;
}

div.dsPivotCompleteTable .dsPivotString {
	
	border-right: 1px solid #E9E9E9;
	border-bottom: 1px solid #E9E9E9;

	overflow: hidden;
	vertical-align: middle;
	
	background: white;
	font-size: 10pt;

	-webkit-transition-property: background;
	-webkit-transition-duration: 0.25s;
	-webkit-transition-timing-function: ease;
	-moz-transition-property: background;
	-moz-transition-duration: 0.25s;
	-moz-transition-timing-function: ease;
	transition-property: background;
	transition-duration: 0.25s;
	transition-timing-function: ease;
}
/* WAL */

	.dsPivotEnclosingDiv {
		/* hack for IE to make scroll bars appear */
		display: block;
		overflow: hidden;
	}

	.dsPivotTableWrapper {
		position: relative;

		height:100%;
		width:100%;
		display:block;
		overflow:hidden;
	}

	/* background image within wrapper */
	.dsPivotTableImage {
		position: absolute;
		top: 0px;
		left: 0px;
		height: 100%;
		width: 100%;
		background-image: none;
		background-repeat: no-repeat;
		background-size: 100% 100%;
		opacity: 0.1;
		filter: alpha(opacity=10);
	}


	/* used to display error message on bottom */
	.dsPivotError {
		position: absolute;
		padding: 2px;
		border-top: 1px solid black;
		font-weight: bold;
		color: red;
		background: white;
	}

	/* error displayed in main body of pivot */
	.pivotError {
		color: #404040;
		font-size: 24px;
		padding: 10px;
	}

	table.dsPivotTable {
		border: none;
		font-size: 10pt;
		table-layout:fixed;
		padding: 0px;
		height: auto;
		box-shadow: 2px 2px 25px rgba(0,0,0,0.25);
	}

	table.dsPivotDataTable {
		background: white;
		font-size: 10pt;
		table-layout:fixed;
		padding: 0px;
		box-shadow: 2px 2px 25px rgba(0,0,0,0.25);
	}

	table.dsPivotDataTableCB {
		background: white;
		font-size: 10pt;
		table-layout:fixed;
		padding: 0px;
		box-shadow: 2px 2px 25px rgba(0,0,0,0.25);
	}

	.dsPivotSummary {
		font-size: 0.8em;
		margin: 20px;
	}

	/* message box displayed while pivot is updating. */
	.dsPivotMessage {
		z-index: 3;
		padding: 10px;
		top: 100px;
		left: 100px;
		position: absolute;
		border: 1px solid #808080;
		background: #F0F0FF;
		opacity: 0.9;
		color: #404040;
		padding: 2px;
		font-size: 1.2em;
		border-radius: 4px;
		box-shadow: 2px 2px 2px #808080;
	}

	/* percentage complete */
	.dsptPct {
		font-size: 2.0em;
		font-weight: bold;
	}

	.dsptDropMsg:hover {
		background: #FFEEAA;
	}

	.dsPivotRowSection {
		padding-top: 2px;
		padding-left: 5px;
		font-weight: bold;
	}

	/* column label */
	table th.dsPivotColumn,
	table th.dsPivotColumnSort {
		padding: 0px;
		text-align: center;
		vertical-align: middle;

		background: #C0C0C0;
		background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
		background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
		background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
		background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
		background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
		background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */
	}

	/* wrapper around column header */
	.dsPivotColumnDiv {
		padding-top: 2px;
		padding-left: 2px;
		padding-right: 2px;
		padding-bottom: 2px;
		overflow: hidden;
		background: none;
		display:table-cell;
	}
	
	/* zebra styles */
	.dsptRowOdd td {
		border-right: none;
		border-bottom: none;
	}

	.dsptRowEven td {
		background: #F0F0F4;
	}

	.dsptRowEven td {
		border-right: none;
		border-bottom: none;
	}

	table.dsPivotTable th.dsPivotColumnZebra {
		color: #404040;
		padding: 0px;
		text-align: center;
		vertical-align: middle;
		background: #F0F0F4;
		background-image: none;
		-moz-user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	table.dsPivotTable th.dsPivotColumnSortZebra {
		color: #404040;
		padding: 0px;
		text-align: center;
		vertical-align: middle;
		background: #F0F0F4;
		overflow: hidden;
		background-image: none;

		-moz-user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	table.dsPivotTable th.dsPivotRowEven {
		color: #404040;
		text-align: left;
		vertical-align: middle;
		background: #F0F0F4;
		background-image: none;
		border-right: none;
		border-bottom: none;
	}

	table.dsPivotTable th.dsPivotRowOdd {
		color: #404040;
		text-align: left;
		vertical-align: middle;
		background: white;
		background-image: none;
		border-right: none;
		border-bottom: none;
	}
	
	/* row label */
	table.dsPivotTable th.dsPivotRow {
		text-align: left;
		vertical-align: middle;
		background: #C0C0C0;
		background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
		background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
		background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
		background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
		background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
		background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */

		border-bottom: 1px solid #D0D0D0;
	}
	
	th.dsPivotRow {
		text-align: left;
		vertical-align: middle;
		background: #C0C0C0;
		background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
		background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
		background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
		background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
		background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
		background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */

		border-bottom: 1px solid #D0D0D0;
	}

	/* wrapper around row header */
	.dsPivotRowDiv {
		padding-top: 2px;
		padding-left: 2px;
		padding-right: 10px;
	}

	table.dsPivotTable th:hover {
		background: #FFEEAA;
		color: #404080;
	}

	table.dsPivotTable td, 
	table.dsPivotTable th {
		height: 22px;
		overflow: hidden;
		vertical-align: middle;

		border-right: 1px solid #D0D0D0;
		border-bottom: 1px solid #D0D0D0;

		-webkit-transition-property: background;
		-webkit-transition-duration: 0.25s;
		-webkit-transition-timing-function: ease;
		-moz-transition-property: background;
		-moz-transition-duration: 0.25s;
		-moz-transition-timing-function: ease;
		transition-property: background;
		transition-duration: 0.25s;
		transition-timing-function: ease;

		-moz-user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	table.dsPivotDataTable td {
		border-right: 1px solid #E8E8E8;
		border-bottom: 1px solid #E8E8E8;
		width: 100px;
		height: 22px;
		overflow: hidden;
		vertical-align: middle;

		-webkit-transition-property: background;
		-webkit-transition-duration: 0.25s;
		-webkit-transition-timing-function: ease;
		-moz-transition-property: background;
		-moz-transition-duration: 0.25s;
		-moz-transition-timing-function: ease;
		transition-property: background;
		transition-duration: 0.25s;
		transition-timing-function: ease;
	}
	
	table.dsPivotDataTable td:hover {
		background: #FFEEAA;
	}

	table.dsPivotDataTableCB td {
		border-right: 1px solid #E8E8E8;
		border-bottom: 1px solid #E8E8E8;
		width: 100px;
		height: 22px;
		overflow: hidden;
		vertical-align: middle;

		-webkit-transition-property: background;
		-webkit-transition-duration: 0.25s;
		-webkit-transition-timing-function: ease;
		-moz-transition-property: background;
		-moz-transition-duration: 0.25s;
		-moz-transition-timing-function: ease;
		transition-property: background;
		transition-duration: 0.25s;
		transition-timing-function: ease;
	}

	.dsPivotString {
	}

	.dsPivotDate {
	}

	.dsPivotNum {
		text-align: right;
	}

	.dsPivotIcon {
		text-align: center;
	}

	span.dsptDrillUp {
		cursor: pointer;
		padding-left: 4px;
		padding-right: 4px;
	}

	span.dsptDrillUp:hover {
		background: #DDCC88;
		border-radius: 4px;
	}

	span.dsptDrillUp:active {
		background: darkblue;
		color: white;
	}

	/* outer-most div used for layout */
	/* this div will also need to be resized based on the size of the table */
	.dsptOuterDiv {
		position: relative;
		width: 400px;
		height: 400px;
		overflow: hidden;
		visibility: hidden;
		z-index: 1;
	}
	
	.dsptHeaderDiv {
		position: absolute;
		top: 0px;
		left: 0px;
		right: 0px;
		height: 22px;
		overflow: hidden;
		text-align: center;
		font-weight: bold;

		border-right: 1px solid gray;
		border-bottom: 1px solid gray;

		background: #C0C0C0;
		background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
		background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
		background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
		background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
		background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
		background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */
	}

	.dsptTopLeftDiv {
		position: absolute;
		top: 0px;
		left: 0px;
		overflow: hidden;

		padding: 0px;

		background: #C0C0C0;
		background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
		background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
		background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
		background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
		background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
		background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */

		text-align: center;
		vertical-align: bottom;
		border-right: 1px solid #D0D0D0;
		border-bottom: 1px solid #D0D0D0;

		color: #404040;
		font-size: 10pt;
		font-weight: bold;
		cursor: pointer;
	}

	.dsptTopLeftDivZebra {
		position: absolute;
		top: 0px;
		left: 0px;
		overflow: hidden;

		padding: 0px;
		background: #F0F0F0;
		background-image: none;
		text-align: center;
		vertical-align: bottom;
		border-right: 1px solid #D0D0D0;
		border-bottom: 1px solid #D0D0D0;

		color: #404040;
		font-size: 10pt;
		font-weight: bold;
		cursor: pointer;
	}

	.dsptTopLeftDiv:hover,
	.dsptTopLeftDivZebra:hover {
		background: #FFEEAA;
	}

	/* wrapper around nub text */
	.dsNubDiv {
		position: absolute;
		bottom: 0px;
		left: 0px;
		text-align: left;
		vertical-align: bottom;
		color: #404040;
		font-size: 9pt;
		overflow: hidden;
		padding-bottom: 2px;
	}

	div.dsNubDiv table td {
		text-align: left;
		vertical-align: bottom;
		color: #404040;
		font-weight: bold;
		font-size: 7pt;
		padding-left: 2px;
		overflow: hidden;
	}

	.dsptTopRightDiv {
		position: absolute;
		top: 0px;
		left: 100px;
		width: 300px;
		height: 5px;
		overflow-y: hidden;
		overflow-x: hidden;
	}

	.dsptBottomLeftDiv {
		position: absolute;
		top: 5px;
		left: 0px;
		width: 100px;
		height: 345px;
		overflow-y: hidden;
		overflow-x: hidden;
		border-bottom: 1px solid #D0D0D0;
	}

	.dsptBottomRightDiv {
		position: absolute;
		top: 5px;
		left: 100px;
		width: 300px;
		height: 345px;
		overflow: hidden;
		border-bottom: 1px solid #D0D0D0;
	}

	/* this runs along the bottom of the component */
	.dsptStatusDiv {
		border-top: 1px solid #808080;

		background: #C0C0C0;
		background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
		background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
		background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
		background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
		background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
		background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */

		position: absolute;
		top: 350px;
		left: 0px;
		right: 0px;
		height: 32px;
		overflow: hidden;
		padding: 1px;
		-moz-user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	.dsptStatusLabel {
		font-size: 11px;
	}

	.dsptStatusValue {
		padding-left: 5px;
		font-weight: bold;
		font-size: 11px;
	}

	.dsptDropMsg,
	.dsptDropMsg:link,
	.dsptDropMsg:active,
	.dsptDropMsg:visited {
		font-size: 0.8em;
		color: #909090;
		font-style: italic;	
		text-decoration: none;
	}

	.dsptTitle {
		font-weight: bold;
		font-size: 1.1em;
		border-left: 1px solid darkgray;
	}

	/* image */
	.dsptIconBar {
		vertical-align: bottom;
	}

	.dsptIcon,.dsptIconDisabled,.dsptIconHover {
		border: 1px solid transparent;
		vertical-align: bottom;
		margin-left: 1px;
		margin-right: 1px;
		padding: 1px;

		border: 1px solid transparent;
		border-radius: 4px;
		-webkit-transition-property: background,opacity,transform;
		-webkit-transition-duration: 0.5s;
		-webkit-transition-timing-function: ease;
		-moz-transition-property: background,opacity,transform;
		-moz-transition-duration: 0.5s;
		-moz-transition-timing-function: ease;
		transition-property: background,opacity,transform;
		transition-duration: 0.5s;
		transition-timing-function: ease;
	}

	.dsptIcon {
		cursor: pointer;
	}

	.dsptIcon:hover, .dsptIconHover {
		background: #FFEEAA;
		border: 1px solid rgba(120,120,120,0.25);
		vertical-align: bottom;
	}

	.dsptIcon:active,.dsptIconHover:active {
		background: white;
		border: 1px solid white;
		box-shadow: 2px 2px 2px #FFEEAA, -2px -2px 2px #FFEEAA;
	}

	.dsptIconDisabled {
		opacity:0.40;
		filter:alpha(opacity=40);
	}

	/* scroll bars: use 22px instead of "auto" for ie! */
	.dsptVtScroll {
		z-index: 2;
		position: absolute;
		width: 22px;
		overflow-y: scroll;
		overflow-x: hidden;
	}
	.dsptVtScrollInner {
		height: 100px;
		width: 15px;
	}

	.dsptHzScroll {
		z-index: 2;
		position: absolute;
		height: auto;
		overflow-x: scroll;
		overflow-y: hidden;
		height: 20px;
	}
	.dsptHzScrollInner {
		height: 15px;
		width: 100px;
	}

	/* listing table */
	table.dsListingTable {
		background: white;
		font-size: 10pt;
		table-layout:fixed;
	}

	table.dsListingTable tr.selectedRow {
		background: rgb(47,98,128);
	}

	table.dsListingTable tr.evenRow {
		background: #F8F8F8;
	}

	table.dsListingTable tr.oddRow {
		background: white;
	}

	table.dsListingTable th {
		color: #404040;
		text-align: left;
		padding: 0px;
	}

	table.dsListingTable th.dsListingColumn,
	table.dsListingTable th.dsListingColumnSort {
		background: #C0C0C0;
		background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
		background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
		background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
		background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
		background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
		background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */
	}

	table.dsListingTable td {
		padding: 0px;
		padding-top: 2px;
		padding-bottom: 2px;
		color: #404040;
	}

	table.dsListingTable td.number {
		text-align: right;
		color: #404040;
	}

	table.dsListingTable tr.selectedRow td {
		color: white;
	}

	table.dsListingTable tr.selectedRow td.number {
		color: white;
	}

	.dsptCellDiv {
		padding-right: 2px;
		padding-left: 2px;
		padding-top: 1px;
		padding-bottom: 1px;
		text-align: right;
		overflow: hidden;
		word-wrap: break-word;
	}

	.dsptListCellDiv {
		padding-right: 4px;
		padding-left: 4px;
		padding-top: 1px;
		padding-bottom: 1px;
		background: none;
		text-align: left;
		overflow: hidden;
	}

	.dsptPlanItem {
		font-size: 11pt;
		border: 1px solid #404040; 
		border-radius: 4px;
		padding: 4px;
		box-shadow: 2px 2px 2px #808080;
	}

	table td.dsptShowMore {
		font-size: 10pt;
		font-weight: bold;
		color: #404040;
		border: 1px solid #808080; 
		border-radius: 4px;
		padding: 2px;
		background: #F0F0F0;
	}

	.dsptShowMore:hover {
		background: #FFEEAA;
	}

	.dsptShowMore:active {
		background: white;
		box-shadow: 2px 2px 2px white, -2px -2px 2px white;
	}
	
	/* + WAL106 -- div that wraps the single table */
	.dsPivotCompleteTableDiv {
		position: absolute;
		width: 400px;
		height: 400px;
		overflow: hidden;
		visibility: hidden;
		z-index: 1;
	}
	/* - WAL106 */

	/* + WAL106 -- styling for single pivot table */
	table.dsPivotCompleteTable {
		position: relative;
		/*border: none;*/
		background: #D0D0D0;
		font-size: 10pt;
		table-layout:fixed;
		padding: 0px;
		height: auto;
		font-family: Arial;
		border-collapse: collapse;
		box-shadow: 2px 2px 25px rgba(0,0,0,0.25);
		border-right: 1px solid #D0D0D0;
		border-bottom: 1px solid #D0D0D0;
	}
	/* - WAL106 -- styling for single pivot table */
	
	/* WAL -- div version */
	div.dsPivotCompleteTable {
		
		width: 400px;
		height: 400px;
		
		position: relative;
		/*border: none;*/
		background: #D0D0D0;
		font-size: 10pt;
		padding: 0px;
		height: auto;
		font-family: Arial;
		border-collapse: collapse;
		box-shadow: 2px 2px 25px rgba(0,0,0,0.25);
		/*border-right: 1px solid #D0D0D0;
		border-bottom: 1px solid #D0D0D0;*/
	}
	
	/* WAL */
	.topLabels {
		position: absolute;	
	}
	
	/* + WAL106 -- top/side table styling */
	table.dsPivotCompleteTable th {
		height: 22px;
		overflow: hidden;
		vertical-align: middle;

		border-right: 1px solid #D0D0D0;
		border-bottom: 1px solid #D0D0D0;

		-webkit-transition-property: background;
		-webkit-transition-duration: 0.25s;
		-webkit-transition-timing-function: ease;
		-moz-transition-property: background;
		-moz-transition-duration: 0.25s;
		-moz-transition-timing-function: ease;
		transition-property: background;
		transition-duration: 0.25s;
		transition-timing-function: ease;

		-moz-user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}
	
	/* row label */
	table.dsPivotCompleteTable th.dsPivotRow {
		text-align: left;
		vertical-align: middle;
		background: #C0C0C0;
		background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
		background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
		background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
		background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
		background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
		background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */

		border-bottom: 1px solid #D0D0D0;
	}
	
	table.dsPivotCompleteTable th.dsPivotColumnZebra {
		color: #404040;
		padding: 0px;
		text-align: center;
		vertical-align: middle;
		background: #F0F0F4;
		background-image: none;
		-moz-user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}
	
	/* zebra stuff */
	table.dsPivotCompleteTable th.dsPivotColumnSortZebra {
		color: #404040;
		padding: 0px;
		text-align: center;
		vertical-align: middle;
		background: #F0F0F4;
		overflow: hidden;
		background-image: none;

		-moz-user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}
	
	table.dsPivotCompleteTable th.dsPivotRowEven {
		color: #404040;
		text-align: left;
		vertical-align: middle;
		background: #F0F0F4;
		background-image: none;
		border-right: none;
		border-bottom: none;
	}

	table.dsPivotCompleteTable th.dsPivotRowOdd {
		color: #404040;
		text-align: left;
		vertical-align: middle;
		background: white;
		background-image: none;
		border-right: none;
		border-bottom: none;
	}
	
	table.dsPivotCompleteTable th:hover {
		background: #FFEEAA;
		color: #404080;
	}
	/* + WAL106 - top/side table styling */
	
	/* + WAL106 data table styling */	 
	table.dsPivotCompleteTable td {
		border-right: 1px solid #E8E8E8;
		border-bottom: 1px solid #E8E8E8;
		width: 100px;
		height: 22px;
		overflow: hidden;
		vertical-align: middle;
		
		background: white;
		font-size: 10pt;

		-webkit-transition-property: background;
		-webkit-transition-duration: 0.25s;
		-webkit-transition-timing-function: ease;
		-moz-transition-property: background;
		-moz-transition-duration: 0.25s;
		-moz-transition-timing-function: ease;
		transition-property: background;
		transition-duration: 0.25s;
		transition-timing-function: ease;
	}
	
	table.dsPivotCompleteTableKPI td {
		border-right: 1px solid #E8E8E8;
		border-bottom: 1px solid #E8E8E8;
		width: 100px;
		height: 22px;
		overflow: hidden;
		vertical-align: middle;
		
		background: white;
		font-size: 10pt;

		-webkit-transition-property: background;
		-webkit-transition-duration: 0.25s;
		-webkit-transition-timing-function: ease;
		-moz-transition-property: background;
		-moz-transition-duration: 0.25s;
		-moz-transition-timing-function: ease;
		transition-property: background;
		transition-duration: 0.25s;
		transition-timing-function: ease;
	}

	/* zebra stuff */
	table.dsPivotCompleteTable td.dsPivotRowEven {
		color: #404040;
		text-align: left;
		vertical-align: middle;
		background: #F0F0F4;
		background-image: none;
		border-right: none;
		border-bottom: none;
	}

	table.dsPivotCompleteTable td.dsPivotRowOdd {
		color: #404040;
		text-align: left;
		vertical-align: middle;
		background: white;
		background-image: none;
		border-right: none;
		border-bottom: none;
	}
	
	table.dsPivotCompleteTable td:hover {
		background: #FFEEAA;
	}
	/* - WAL106 data table styling */
	
	/* + WAL106 nub table styling */
	table.dsPivotCompleteTable th.dsNub {

		background: #C0C0C0;
		background: -moz-linear-gradient(top,  #f8f8f8 0%, #c0c0c0 100%); /* FF3.6+ */
		background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#c0c0c0)); /* Chrome,Safari4+ */
		background: -webkit-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Chrome10+,Safari5.1+ */
		background: -o-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* Opera 11.10+ */
		background: -ms-linear-gradient(top,  #f8f8f8 0%,#c0c0c0 100%); /* IE10+ */
		background: linear-gradient(to bottom,  #f8f8f8 0%,#c0c0c0 100%); /* W3C */
		
		text-align: left;
		vertical-align: bottom;
		color: #404040;
		font-size: 7pt;
		padding-left: 2px;
		overflow: hidden;
		
		/*border: none; */
		/* WAL106 -- override right border when needed in %DrawTable */
		border-right: 1px solid #D0D0D0;
		border-bottom: 1px solid #D0D0D0;
	}
	
	table.dsPivotCompleteTable th.dsNubZebra {

		background: #F0F0F0;
		background-image: none;
		text-align: left;
		vertical-align: bottom;

		color: #404040;
		font-size: 7pt;
		
		padding-left: 2px;
		overflow: hidden;
	}
	
	table.dsPivotCompleteTable th.dsNub:hover,
	table.dsPivotCompleteTable th.dsNubZebra:hover {
		background: #FFEEAA;
	}
	/* - WAL106 nub table styling */

	/* +DTB701 */
	.coverPaneActive {
		position:absolute;
		left:0px;
		right:0px;
		top:0px;
		bottom:0px;
		opacity:.2;
		background:grey;
		display:block;
	}
	
	.coverPaneInactive {
		position:absolute;
		left:0px;
		top:0px;
		width:0px;
		height:0px;
		display:block;
	}
	/* -DTB701 */

	</style>
]]></Data>
</XData>

<Method name="deferredExecuteQuery">
<Description>
Execute a query after a short pause (to allow for window updates, etc.</Description>
<Internal>1</Internal>
<FormalSpec>force</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	window.setTimeout('zenPage.getComponent('+this.index+').executeQuery('+(force?'true':'false')+');',10);
]]></Implementation>
</Method>

<Method name="executeQuery">
<Description><![CDATA[
Execute the current query for this pivot table and
update the display.<br/>
If <var>force</var> is true, then force the query
to be prepared.]]></Description>
<FormalSpec>force</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (force) {
		this.currPage = 1;
		this.currListingPage = -1;
		this.isPaging = false;
		this.queryKey = '';
	}
	else if (!this.autoExecute && !this.isPaging) {
		// do nothing
		this.changesPending = true;
		this.updateController();
		return;
	}

	this.changesPending = false;
	this.queryCalls = 0;
	this.queryStatus = 0;
	if (this.isDrillThrough) {
		this.showMessage($$$Text('Generating listing...'),'',true);
	}
	else {
		this.showMessage($$$Text('Working...'),'');
	}
	this._runningQuery = true;
	// JMD1023 - make async
	// this.refreshContents(true);
	// JMD1101 - make sync again!
	
	var prevCanDrillDown = this.canDrillDown;
	this.refreshContents(true);
	this.canDrillDown = prevCanDrillDown;
	this.updateController();
	
	// reset limit
	this.crossJoinRowLimit = parseInt(this.pageSize,10) * 20;
	// DTB714 - Reset table's previewMode from the environment setting
	this.previewMode = zenPage.previewMode;
]]></Implementation>
</Method>

<Method name="executeListing">
<Description>
Execute a drill through for the current selected cell.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.showMessage($$$Text('Generating listing...'),'',true);
	this.refreshContents();
]]></Implementation>
</Method>

<Method name="cancelQuery">
<Description>
Cancel the current query for this pivot table and
update the display.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (null == this._inCancel) {
		if (this._queryTimerId) {
			this._inCancel = true;
			this.stopQueryTimer();
			this.showMessage($$$Text('Cancelling...'),'');
			this.sendEventToViews('endWait');
			var ok = this.KillQuery(this.cubeName,this.queryKey,'');
			if (!ok) {
				alert($$$Text('Unable to cancel query...'));
			}
			delete this._inCancel;
			this.resetTable();
		}
		else if (this._runningQuery && false) {
			// query is not fully set up yet
			this._inCancel = true;
			this.stopQueryTimer();
			var ok = this.KillQuery('','',this.pivotNonce);
			if (!ok) {
				alert($$$Text('Unable to cancel query...'));
			}
			delete this._inCancel;
		}
	}
]]></Implementation>
</Method>

<Method name="swapRowsAndColumns">
<Description>
Swap the row and column definitions for this table and refresh it.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// do not allow swap when drilled down
	if (this.drillLevels.length>0) {
		return;
	}

	if (this.rowLevels.length > 0 || this.columnLevels.length > 0) {
		this.pushState();

		var temp = this.rowLevels;
		this.rowLevels = this.columnLevels;
		this.columnLevels = temp;
		temp = this.rowAxisOptions;
		this.rowAxisOptions = this.columnAxisOptions;
		this.columnAxisOptions = temp;

		this.currPage = 1;
		this.currListingPage = -1;
		this.selectedRange = '';
		this.sortColumn = 0;
		this.sortDir = 'ASC';
		this.executeQuery(this.autoExecute);
	}
]]></Implementation>
</Method>

<Method name="getSelectedRange">
<Description><![CDATA[
Return the range of selected cells or null if nothing selected.<br/>
The range is returned as an array of startRow,startCol,endRow,endCol,allRows,allCols.]]></Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (''==this.selectedRange) {
		return null;
	}
	return this.selectedRange.split(',');
]]></Implementation>
</Method>

<Method name="resetTable">
<Description>
Reset this table to default settings.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.pushState();
	this.isPaging = false;
	this.currPage = 1;
	this.currListingPage = -1;
	this.queryKey = '';
	this.queryCalls = 0;
	this.measures = new Array();
	this.measureLocation = 'columns';
	this.selectedRange = '';
	this.sortColumn = 0;
	this.sortDir = 'ASC';
	this.filters = new Array();
	this.rowLevels = new Array();
	this.columnLevels = new Array();
	this.drillLevels = new Array();
	this.drillRowNumbers = new Array(); // WAL224
	this.listingFilters = new Array();
	this.crossJoinRowLimit = parseInt(this.pageSize,10) * 20; 	// JMD1129, JMD1304

	this.pivotVariables = {};

	this.overrideRowSpec = '';
	this.overrideColumnSpec = '';
	this.overrideRowText = '';
	this.overrideColumnText = '';

	this.rowAxisOptions = zenPage.createComponentNS('http://www.intersystems.com/deepsee','pivotLevel');
	this.columnAxisOptions = zenPage.createComponentNS('http://www.intersystems.com/deepsee','pivotLevel');

	if (this.isDrillThrough) {
		this.mdx = '';
		this.isDrillThrough = false;
		this.executeQuery(true);
	}
	else {
		this.executeQuery();
	}

	if (zenPage.UpdateFilterControls) {
		var msg = zenPage.UpdateFilterControls(this.cubeName,zen('filterGroup'),this);
		if (''!==msg) {
			alert(msg);
		}
	}
]]></Implementation>
</Method>

<Method name="canDrillThrough">
<Description>
Test if this pivot supports drill through.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// JMD1031 Allow listing in manual mode
	if (''===this.kpi) {
		return this.listingEnabled;
	}
	else if(''!==this.kpi) {
		return true;
	}
	return false;
]]></Implementation>
</Method>

<Method name="drillThrough">
<Description>
Toggle drill through state of this pivot.
If not in drill through mode, execute a drill through: show a listing for the current selected range of cells.
else restore normal view.
Return true if the operation took place.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return this.setDrillThrough(!this.isDrillThrough);
]]></Implementation>
</Method>

<Method name="setDrillThrough">
<Description><![CDATA[
Set the drill through state of this pivot to <var>flag</var>.<br/>
If true, execute a drill through: show a listing for the current selected range of cells.
else restore normal view.
Return true if the operation took place.]]></Description>
<FormalSpec>flag,force</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	force = ('undefined' == typeof force) ? false : force;
	if (!this.canDrillThrough()) {
		return false;
	}

	if (flag == this.isDrillThrough && !force) {
		return false;
	}
	
	if (flag) {
		if ('' == this.selectedRange && '' == this.kpi) {
			alert($$$Text('Please select a cell to display a listing for.\nNote that you can select multiple cells by holding the CTRL key down while clicking the mouse.'));
			return false;
		}

		this.selectedRowValues = '';
		if ('' != this.kpi) {
			// get values for selected rows
			var list = this.getSelectedItems();
			// escape ',' in values with \,
			if (list) {
				for (var n = 0; n < list.length; n++) {
					if (list[n] && list[n]!='' && 'string'==typeof list[n]) {
						list[n] = list[n].replace(/\,/g,'\\,');
					}
				} 
			}
			this.selectedRowValues = list ? list.join(',') : '';
		}

		// DTB118 - drillUp no longer uses goBack(), the listing can be remembered. 
		this.pushState();
			
		// reset sort
		this.listingSortColumn = '';
		this.listingSortDir = 'ASC';
		this.isDrillThrough = true;

		this.executeListing();
	}
	else {
		if (this.drillLevels.length==0) {
			this.pushState();
		}
		this.mdx = '';
		this.queryKey = '';
		this.isDrillThrough = false;

		this.executeQuery(true);
	}
	return true;
]]></Implementation>
</Method>

<Method name="showMDXQuery">
<Description>
Toggle display of the current query.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.setProperty('showQuery',!this.getProperty('showQuery'));
	this.refreshContents();
]]></Implementation>
</Method>

<Method name="%LocalizeElements">
<Description>
Make sure any text within this list of pivot levels is localized!</Description>
<Internal>1</Internal>
<FormalSpec>pCubeClass:%String,pList:%ListOfObjects</FormalSpec>
<Implementation><![CDATA[
	For n = 1:1:pList.Count() {
		Set tPivotLevel = pList.GetAt(n)
		If ($IsObject(tPivotLevel)&&(tPivotLevel.spec'="")) {
			Set tValue = tPivotLevel.value
			If $E(tValue,1,8)="$$$FIELD" {
				// DTB309 - This is a saved listing field. Query its localized caption from the cube.
				Set tCaption = $classmethod(pCubeClass,"%GetListingFieldCaption",$E(tValue,10,*))
			}
			Else {
				// Standard MDX pivotLevel
				Set tSC = ##class(%DeepSee.Query.Parser).%ParseMemberSpec(tPivotLevel.spec,.tSpecInfo,.tQuoted)
				Set tDim = $$$UPPER($G(tSpecInfo(1)))
				Set tHier = $$$UPPER($G(tSpecInfo(2)))
				Set:tHier="%TOPMEMBERS" tHier = ""
				Set tLevel = $$$UPPER($G(tSpecInfo(3)))
				Set tKey = $$$UPPER($G(tSpecInfo(4)))

				// check for property reference
				Set tProp = ""
				If ($P($$$UPPER(tPivotLevel.spec),".CURRENTMEMBER.PROPERTIES(""",2)'="") {
					Set tProp = $P($$$UPPER(tPivotLevel.spec),".CURRENTMEMBER.PROPERTIES(""",2)
					Set tProp = $P(tProp,""")",1)
				}
				Set tCaption = ""
				If ((tDim="MEASURES")&&(tHier'="")) {
					Set tCaption = $classmethod(pCubeClass,"%GetMemberCaption",tDim,tHier)
				}
				// + WAL042 -- handle ALL member
				ElseIf ((tLevel="")&&(tHier["ALL")) {
					Set tCaption = $classmethod(pCubeClass,"%GetMemberCaption",tDim,tHier)
				}
				// - WAL042
				ElseIf (tLevel'="") {
					If (tProp'="") {
						Set tCaption = $classmethod(pCubeClass,"%GetMemberCaption",tDim,tHier,tLevel,tProp)
					}
					// JMD857
					ElseIf ((tKey="MEMBERS")||(tKey="ALLMEMBERS")) {
						Set tCaption = $classmethod(pCubeClass,"%GetMemberCaption",tDim,tHier,tLevel)
					}
				}
			}

			// PFS091 - Always update caption, even if tCaption is empty
			Set tPivotLevel.caption = tCaption
			// WAL246 -- comment this out since it causes problems with excel/pdf export
			//           filter names
			//Set tPivotLevel.text = tCaption		// DTB309 - Both of these get used
			Do ..%LocalizeElements(pCubeClass, tPivotLevel.childLevels)
		}
	}
]]></Implementation>
</Method>

<Method name="%DrawHTML">
<Description>
Draw HTML for this component.</Description>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tQueryText = ""
		Set tErrorMsg = ""
		Set tTableDrawn = 0
		Set ..totalValue = "ERROR"
		Set tCubeName = $$$ZENVAL(..cubeName)
		Set tCubeIndex = $S((tCubeName'=""):$$$DeepSeeIndex(tCubeName),(..cubeKey'=""):..cubeKey,1:"")		// DTB618
		Set tIsPaging = ..isPaging
		Set ..isPaging = 0
		Set ..columnsTruncated = 0
		Set ..queryPending = 0
		Set tPending = 0
		Set tExecuteBaseQuery = 0		// DTB107

		// if there is a pending error message, show it
		If (..%message'="") {
			Set tErrorMsg = ..%message
			Set ..%message = ""
			Quit
		}
		Set ..%message = ""

		// reset cancel flag
		New %dsPivotNonce
		If (..pivotNonce'="") {
			Set %dsPivotNonce = ..pivotNonce
			Kill ^DeepSee.Cancel(..pivotNonce)
			//Lock +^DeepSee.Pivot(..pivotNonce)
		}

		// !!! let other requests get through
		// need for cancel, but interferes with dashboards !!!
		// Do %session.Unlock(0)

		// create a new session (or use the one currently in scope)
		Set tSession = $G($$$DeepSeeSession)
		If ('$IsObject(tSession)) {
			Do ##class(%DeepSee.Session).%CreateSession($S($IsObject($G(%session)):%session.SessionId,1:$J),.tSC)
			If $$$ISERR(tSC) {
				Set tErrorMsg = $$$Text("Error creating DeepSee session.","%DeepSee")
			}
			Set tSession = $G($$$DeepSeeSession)
		}

		// n.b., create session before drawing KPI so that user init code is run
		If (..kpi'="") {
			// JMD978: If initial execute is off, don't run the query
			If (('..initialExecute) && ($G(%zenContext) = "page")) {
				Quit
			}
			Set tSC = ..%DrawKPITable()
			Quit
		}

		If ((..userMDX=" ")||((..userMDX="")&&(tCubeName=""))) {
			Set tErrorMsg = $$$Text("Please select a subject area to display.","%DeepSee")
			Quit
		}

		// Set cubeKey to normalized cube index name
		Set tAutoMode = 0
		If (..userMDX'="") {
			// JMD1031 add userMDX
			Set tAutoMode = 1

			// JMD1057 test for missing cubename
			If ($$$ZENVAL(..cubeName)="") {
				// find the cube name from the query
				Set tQuery = ##class(%DeepSee.Query.query).%New()
				Set tSC = ##class(%DeepSee.Query.Parser).%ParseMDX(..userMDX,tQuery)
				If $$$ISERR(tSC) {
					Set:..%message="" ..%message = $System.Status.GetErrorText(tSC) _ " (10)"
					Quit
				}
				Set tCubeName = tQuery.cube
				Set ..cubeName = tCubeName
			}
			Set ..mdx = ..userMDX
		}
		ElseIf ((tCubeName'="") && (..dataSource="automatic")) {
			Set tAutoMode = 1
		}
		Set ..cubeKey = $$$DeepSeeIndex($$$UPPER(tCubeName))
		
		// test if the cube is available
		If (tCubeName'="") {
			If ('##class(%DeepSee.Utils).%IsCubeAvailable(tCubeName,.tReason)) {
				Set tErrorMsg = tReason
				Quit
			}
		}
		If (..mdx = " ") {
			Set tErrorMsg = " "
			Quit
		}

		// JMD: make sure any references to cube elements are localized
		Set tCubeClass = ##class(%DeepSee.Utils).%GetCubeClass(tCubeName)
		Do ..%LocalizeElements(tCubeClass,..rowLevels)
		Do ..%LocalizeElements(tCubeClass,..columnLevels)
		Do ..%LocalizeElements(tCubeClass,..measures)
		Do ..%LocalizeElements(tCubeClass,..filters)
		Do ..%LocalizeElements(tCubeClass,..listingFields)		// DTB309 - Localize listingFields too

		&html<<div class="dsPivotTableWrapper">>

		#; scroll bars (initially hidden)
		&html<<div class="dsptVtScroll" style="display:none;" id="#(..%MakeId("vtScroll"))#" onscroll="zenPage.getComponent(#(..index)#).cellScrollVt();"><div class="dsptVtScrollInner" id="#(..%MakeId("vtScrollInner"))#">&nbsp;</div></div>>
		&html<<div class="dsptHzScroll" style="display:none;" id="#(..%MakeId("hzScroll"))#" onscroll="zenPage.getComponent(#(..index)#).cellScrollHz();"><div class="dsptHzScrollInner" id="#(..%MakeId("hzScrollInner"))#">&nbsp;</div></div>>

		#; convert parameters to local array
		Set key = ..parameters.Next("")
		While (key'="") {
			Set value = ..parameters.GetAt(key).value
			Set tParms(key) = $$$ZENVAL(value)
			Set key = ..parameters.Next(key)
		}

		#; get filter information
		If (tAutoMode) {
			Set tSC = ..%GetFilterInfo(.tFilterInfo,.tAdvancedFilters)
			If $$$ISERR(tSC) Quit
		}
		
		If (..queryKey '= "") {
			// re-open existing query
			Set tRS = ##class(%DeepSee.ResultSet).%New()
			Set tRS.%Recompute = 1
			Set ..%ResultSet = tRS
			Set tSC = tRS.%PrepareKey(##class(%DeepSee.CubeVersion.Utils).%GetVersionedCubeName(..cubeName),..queryKey)
			If $$$ISERR(tSC) {
				// This condition is encountered if a reset happens between load of the MDX
				// and execution of the listing
				// try anew
				Set ..queryKey = ""
				Set tSC = $$$OK
				// reset listing filters
				Set tExecuteBaseQuery = 1		// DTB107
				Do ..listingFilters.Clear()
			}
			ElseIf (..isDrillThrough) {
				// DTB857 - Execute the query prepared by key to make results available
				Set tSC = tRS.%ExecuteParameters(.tParms)		// DTB857 (2) - Use %ExecuteParameters
				If $$$ISERR(tSC) Quit
					
				// JMD1360: listing filters are the filters based on the 
				// selected cell(s) for the drillthrough; not the filter control values
				// only compute the listing filters the first time
				If (..listingFilters.Count()=0) {
					Do ..listingFilters.Clear()

					// create drill through out of current query
					Set r1 = +$P(..selectedRange,",",1)
					Set c1 = +$P(..selectedRange,",",2)
					Set r2 = +$P(..selectedRange,",",3)
					Set c2 = +$P(..selectedRange,",",4)
					Set tAllRows = +$P(..selectedRange,",",5)
					Set tAllCols = +$P(..selectedRange,",",6)
					Set:r1=0 r1=1
					Set:c1=0 c1=1
					Set:r2=0 r2=r1
					Set:c2=0 c2=c1
					
					// + WAL170
					Set tSC = tRS.%GetFiltersForCellRange(.tListingFilters,r1,c1,r2,c2,,tAllRows,tAllCols,..sortColumn,..sortDir,.tPlugInInfo)
					Merge tPlugInInfo("FILTERS") = tListingFilters
					// - WAL170
					
					Set tSC = tRS.%GetFiltersForCellRange(.tListingFilters,r1,c1,r2,c2,,tAllRows,tAllCols,..sortColumn,..sortDir)
					
					If $$$ISERR(tSC) {
						Set:..%message="" ..%message = $System.Status.GetErrorText(tSC) _ " (1)"
						Quit
					}
					
					// + WAL190				
					Set tSC = ..%CollectMeasures(..queryKey,.tCollectedMeasures,1)
					If $$$ISERR(tSC) Quit
					// - WAL190

					// JMD1360: we do not need the slicer for the cell range
					// we will recompute it from the filters
					// JMD1387: if we are running a user query then
					// we need to keep the slicer
					If (..userMDX="") {
						// DTB157 - Do not put any measures in listingFilters since they add no contextual information
						// to the set of facts selected
						Kill tListingFilters(0)
					}
					Else {	
						// DTB108 - check the slicer term in the user query.
						// If it contains $$CMBR keys, remove this term and reconstruct 
						// the executable slicer terms from the original query text
						If ($G(tListingFilters(0))["$$CMBR") {			// DTB117 - protect with $G()
							Kill tListingFilters(0)
							Set tTempRS = ##class(%DeepSee.ResultSet).%New()
							Set tSC = tTempRS.%ParseMDX(..GetCurrentQueryText(),.tTempQuery)
							For ii= 1:1:tTempQuery.filters.Count() {
								Set tListingFilters(-ii) = tTempQuery.filters.GetAt(ii).%ToString()
							}
							Kill tTempRS
						}
					}

					Set kf = $O(tListingFilters(""))
					While (kf'="") {
						Set tClause = tListingFilters(kf)
						If (tClause'="") {
							// JMD1211: quick workaround for some listing issues
							// ignore any unprocessed CMBRS
							If (tClause'["$$CMBR") {
								Set ..mdx = ..mdx _ " %FILTER " _ tClause
								
								// JMD993: save this filter in the listingFilters array
								Set tLFilter = ##class(%DeepSee.Component.pivotLevel).%New()
								Set tLFilter.spec = tClause
								Do ..listingFilters.Insert(tLFilter)
								Do:$IsObject($G(%page)) %page.%AddComponent(tLFilter)
							}
						}
						Set kf = $O(tListingFilters(kf))
					}

					// + WAL190 -- add any listing influencing measures to the query
					Set tMeasure = $O(tCollectedMeasures(""))
					While (tMeasure'="") {
						
						If ($G(tCollectedMeasures(tMeasure,"calcListingFilter"))'="") {
							Set tClause = tCollectedMeasures(tMeasure,"calcListingFilter")
						}
						Else {
							// + WAL190 (2)
							// + WAL236 (2) -- add $G
							If (($G(tCollectedMeasures(tMeasure,"listingFilterOperator"))="MAX") || ($G(tCollectedMeasures(tMeasure,"listingFilterOperator"))="MIN")) {
								If ((r1=r2)&&(c1=c2)) {
									Set tValue = tRS.%GetOrdinalValue(c1,r1)
									Set tClause = "%Search.&[[Measures].["_tMeasure_"]="_tValue_"]"
								}
								Else {
									Set tClause=""
								}
							}
							// - WAL190 (2)
							ElseIf ($G(tCollectedMeasures(tMeasure,"listingFilterOperator"))'="") { // WAL220
								Set tClause = "%Search.&[[Measures].["_tMeasure_"]"_tCollectedMeasures(tMeasure,"listingFilterOperator")_tCollectedMeasures(tMeasure,"listingFilter")_"]"
							}
						}
						If ($G(tClause)'="") {  // WAL190 (3) -- add $G
							Set tLFilter = ##class(%DeepSee.Component.pivotLevel).%New()
							Set tLFilter.spec = tClause
							Do ..listingFilters.Insert(tLFilter)
							Do:$IsObject($G(%page)) %page.%AddComponent(tLFilter)
						}
						Set tMeasure = $O(tCollectedMeasures(tMeasure))	
					}
					// - WAL190
				}
				Set tWITH = ""

				// WITH clause if any
				For n = 1:1:..calculatedMembers.Count() {
					Set tCalcMbr = ..calculatedMembers.GetAt(n)
					Set tDimName = ##class(%DeepSee.Query.Parser).%UnquoteIdent(tCalcMbr.dimension)
					Set tMemberName = ##class(%DeepSee.Query.Parser).%UnquoteIdent(tCalcMbr.memberName)
					If ((tDimName'="")&&(tMemberName'="")) {
						// DTB158 - Escape identifiers before quoting
						Set tWITH = tWITH _ " MEMBER ["_$$$dsEscapeIdent(tDimName)_"].["_$$$dsEscapeIdent(tMemberName)_"] AS '" _ tCalcMbr.valueExpression _ "'"
					}
					If (tCalcMbr.formatString'="") {
						Set tWITH = tWITH _ ",FORMAT_STRING='"_$Replace(tCalcMbr.formatString,"'","''")_"'"
					}
					If (+tCalcMbr.solveOrder>0) {
						Set tWITH = tWITH _ ",SOLVE_ORDER="_tCalcMbr.solveOrder
					}
				}

				Set:tWITH'="" tWITH = " WITH " _ tWITH _ " "

				Set ..queryKey = ""
				Set tMaxRows = ""
				If (+..listingRows>0) {
					Set tMaxRows = " MAXROWS "_..listingRows
				}
				Set ..mdx = "DRILLTHROUGH"_tMaxRows_tWITH_" SELECT FROM [" _ tRS.%GetCubeName() _"]"

				// check for custom field list
				Set tRETURN = "$LISTING"
				If ((..listing="$$$CUSTOM")&&(..listingFields.Count()>0)) {
					Set tRETURN = ""
					For lf=1:1:..listingFields.Count() {
						Set tSpec = ..listingFields.GetAt(lf).spec
						Set tAlias = ..listingFields.GetAt(lf).caption		// DTB509
						Set tRETURN = tRETURN _ $S(tRETURN="":"",1:",") _ tSpec
						
						Set tSpecHasAlias = ($L(tSpec," ")>1)&'($E($ZSTRIP(tSpec,"<>W"),*)=")")		// DTB508 - New test for alias
						If ((tAlias'="")&&'tSpecHasAlias) {
							Set tRETURN = tRETURN _ " """ _ tAlias _ """"
						}
					}
				}
				If (..listingSortColumn>0) {
					If (tRETURN="$LISTING") {
						Set ..mdx = ..mdx _ " RETURN "_tRETURN_" %ORDER BY " _ ..listingSortColumn _ " " _ ..listingSortDir
					}
					Else {
						Set ..mdx = ..mdx _ " %ORDER BY " _ ..listingSortColumn _ " " _ ..listingSortDir
					}
				}
			}
			Else {
				// DTB857 - Execute the query prepared by key to make results available
				Set tSC = tRS.%ExecuteParameters(.tParms)		// DTB857 (2) - Use %ExecuteParameters
				If $$$ISERR(tSC) Quit
				
				// reset listing filters
				Do ..listingFilters.Clear()

				If (tIsPaging) {
					// do not recompute when paging
					Set tRS.%Recompute = 0
				}
				Set ..queryStatus = tRS.%GetStatus(.tComplete,,.tPending)
				Set ..queryComplete = tComplete
				Set ..queryPending = tPending
				If (..queryStatus = 30) {
					// finish computing
					Set tSC = tRS.%ExecuteAsynch(,.tParms)		// DTB704 - Straight to %ExecuteAsynch		// DTB868 - Add processing of parms

					Set ..queryStatus = tRS.%GetStatus(.tComplete,,.tPending)
					Set ..queryComplete = tComplete		// DTB868 - Store percent complete in state
					Set ..queryKey = tRS.%GetQueryKey()
				}
				// + WAL266 (3) 
				ElseIf (..staleCache && '..reinitialized) { // WAL304 -- add '..reinitialized
					Set $$$DeepSeeResultsGLVN($$$UPPER(##class(%DeepSee.CubeVersion.Utils).%GetVersionedCubeName(..cubeName)),..queryKey,"timestamp")=0
					Set tSC = tRS.%PrepareKey(##class(%DeepSee.CubeVersion.Utils).%GetVersionedCubeName(..cubeName),..queryKey,1)
					Set tSC = tRS.%ExecuteAsynch(,.tParms)		// DTB704 - Straight to %ExecuteAsynch		// DTB857 - Add available parms
					
					Set ..queryStatus = tRS.%GetStatus(.tComplete,,.tPending)
					Set ..queryComplete = tComplete		// DTB868 - Store percent complete in state
					Set ..queryKey = tRS.%GetQueryKey()
					Set ..staleCache=0 
					Set ..reinitialized=1
				}
				// - WAL266 (3)
			}
		}
		
		If (..queryKey = "") {
			
			Set tStart = $ZH
			Set ..queryStatus = 0
			Set ..queryComplete = 0
			Set ..queryPending = 0
			Set tComplexQuery = 0

			#; Create the result set to get data
			Set tRS = ..%CreateResultSet(.tSC,.tParms,.tFilterInfo,.tAdvancedFilters,.tQueryText,,,.tComplexQuery,tExecuteBaseQuery)
			If $$$ISERR(tSC) {
				Set:..%message="" ..%message = $System.Status.GetErrorText(tSC) _ " (2)"
				Set ..error = ..%message			// DTB150
				
				Quit
			}

			Set ..%ResultSet = tRS
			
			// + WAL202 -- consider related cube queries to be complex queries
			//             creating the join index *might* be expensive, so run the query in 
			//             the background
			// + WAL204 -- also run compound cube queries in the background since they might
			//             be unexpectedly expensive
			Set:(..%ResultSet.%Query.%hasRelationship) tComplexQuery = 1
			Set:(##class(%DeepSee.Utils).%IsCubeCompound(..cubeName)) tComplexQuery = 1
			// - WAL202/WAL204
			
			If $$$UPPER(tRS.%GetQueryText())["%SEARCH.&[" {
				// DTB663 - Trigger background processing for searchable measures
				Set tComplexQuery = 1
			}
			
			// If initial execute is off, don't run the query
			If (('..initialExecute) && ($G(%zenContext) = "page")) {
				Quit
			}

			Set tRS.%Recompute = 1

			Set %dsUpToDate = 1 // WAL266 (3)

			#; make sure parameters are executed before we go further
			#; for now, we do not supply parameters
			Kill tParms
			Set tSC = tRS.%ExecuteParameters(.tParms)
			If $$$ISERR(tSC) {
				Set ^DeepSee.QueryLog($UserName,$I(^DeepSee.QueryLog($UserName))) = ..GetCurrentQueryText("resolved")  // WAL075
				Set:..%message="" ..%message = $System.Status.GetErrorText(tSC) _ " (3)"
				Set ..error = ..%message			// DTB150
				Quit
			}

			// + WAL266 (3)
			Set:($G(%dsUpToDate)=0) ..staleCache = 1
			Set %dsUpToDate=1
			// - WAL266 (3)

			Set ..queryStatus = tRS.%GetStatus(.tComplete,,.tPending)
			Set ..queryComplete = tComplete		// DTB868 - Log percent complete in the state 
			Set ..queryKey = tRS.%GetQueryKey()

			Set tIsSlave = 0		// DTB863 - There is no such thing as a slave query anymore, ResultSet locks make this obsolete
			If ('tIsSlave) {
				// execute in background
				If ((..%message="")&&((..queryStatus < 100) || tRS.%Recompute)) {		// DTB863 - Respond to forced recompute as discovered by the resultset 
					// JMD1156: if this is a "bad" query,
					// then compute its axes in the background!
					Set tBadQuery = 0
					If ('..isDrillThrough) {
						Set tBadQuery = +$G(tComplexQuery)
					}

					If tBadQuery && (..queryStatus < 30) {		// DTB704
						// just the axes
						// WAL018 - Use resolved query text
						Set tSC = tRS.%ExecuteAsynch(,.tParms,,1,..GetCurrentQueryText("resolved"))  // WAL075		// DTB868 - Execute with avialable parms 
					}
					Else {
						// DTB704 - Use %ExecuteAsynch
						Set tSC = tRS.%ExecuteAsynch(,.tParms)		// DTB868 - Execute with avialable parms
					}

					If $$$ISERR(tSC) {
						Set ..%message = $System.Status.GetErrorText(tSC) _ " (4)"
						Set ..error = ..%message			// DTB150
						Quit
					}
					ElseIf ('tBadQuery) {
						// wait a small time for the answer
						For n=1:1:8 {
							Hang 0.05
							Set ..queryStatus = tRS.%GetStatus(.tComplete,,.tPending)
							Set ..queryComplete = tComplete
							Set ..queryPending = tPending
							Quit:..queryStatus>30
						}
					}
				}
			}
		}

		// show listing?
		Set tSQL = ""
		If (tRS.%IsDrillThrough() && '..showPlan) {
			Set ^DeepSee.QueryLog($UserName,$I(^DeepSee.QueryLog($UserName))) = ..GetCurrentQueryText("resolved")  // WAL075

			// + WAL170
			If ($G(tPlugInInfo("NAME"))'="") Set tRS.%PlugInContextName = tPlugInInfo("NAME")
			If ($G(tPlugInInfo("PROP"))'="") Set tRS.%PlugInContextProp = tPlugInInfo("PROP")
			Merge tRS.%PlugInFilters = tPlugInInfo("FILTERS")
			Merge tRS.%PlugInArguments = tPlugInInfo("ARGUMENTS") // WAL262 -- pass along plugIn arguments
			// - WAL170

			// JMD1331
			Set tSC = ..%MaterializeListing(tRS)
			If $$$ISERR(tSC) {
				Set tSQL = tRS.%GetListingSQL()
				Quit
			}
			//Set tSC = ..%DrawListing(tRS)
			Set tSC = ..%DrawListing()
			If $$$ISERR(tSC) {
				Set tSQL = tRS.%GetListingSQL()
			}
			Quit
		}

		// log
		Set ^DeepSee.QueryLog($UserName,$I(^DeepSee.QueryLog($UserName))) = ..GetCurrentQueryText("resolved")  // WAL075

		Set tAxisCount = 0
		If (..queryStatus > 30) {
			// axes are available
			#; get axis info: tAxis(axisno) = axisnode
			Set tAxisCount = tRS.%GetAxisCount(.tAxis)
			Set tVolume = tRS.%GetCellCount(..cubeKey,..queryKey,.tSC)

			If (..queryStatus>=100) {		// DTB873 - Check for status complete before displaying any final messages
				If $$$ISERR(tSC) {	// DTB167 - Only report an error if the query is complete
					Set:..%message="" ..%message = $System.Status.GetErrorText(tSC) _ " (5)"
				}
				ElseIf (tVolume = 0) {
					Set:..%message="" ..%message = $$$Text("No results","%DeepSee") _ " (6)"
				}
			}
		}
		Else {
			Set:..%message="" ..%message = $$$Text("Computing axis members...","%DeepSee")
		}

		If (..showPlan && (..queryStatus >= 100)) {
			Set tSC = ..%ShowPlan(tRS)
			Quit
		}

		#; JMD900
		If (+$G(tPending) && (..queryStatus >= 100)) {
			Do ##class(%DeepSee.Query.Engine).%UpdatePendingResults(..cubeName,..queryKey,.tPending)
			Set ..queryPending = tPending
		}
		// + WAL304 -- *this* is a fine time to reinitialize the variables
		If (..queryStatus >= 100) {
			Set ..reinitialized = 0
		}
		// - WAL304

		#; draw the table
		Set (tColAxis,tRowAxis) = ""
		Set tColAxis = $G(tAxis(1))
		Set tRowAxis = $G(tAxis(2))

		#; if sorting is enabled, build sort index here
		Set tCubeIndex = ..cubeKey
		Set tQueryKey = ..queryKey

		Set tUseSort = 0
		If ((tAxisCount>1)&&(..sortColumn>0)) {
			Set tRowCount = ..%GetAxisSize(2)
			If (tRowCount > 1) {
				Set tUseSort = 1
				// JMD1468 save sort in cache global
				If '$D($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"sort",..sortColumn,..sortDir)) {
					Kill ^||ds.sort
					For r=1:1:tRowCount {
						Set tValue = tRS.%GetOrdinalValue(..sortColumn,r)
						Set:tValue="" tValue=1E-14
						Set ^||ds.sort(tValue,r) = ""
					}

					Kill $$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"sort",..sortColumn,..sortDir)
					Set tDir = $S(..sortDir="DESC":-1,1:1)
					Set n = 0
					Set k = $O(^||ds.sort(""),tDir)
					While (k'="") {
						Set r = $O(^||ds.sort(k,""),tDir)
						While (r'="") {
							Set $$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"sort",..sortColumn,..sortDir,$I(n)) = r
							Set r = $O(^||ds.sort(k,r),tDir)
						}
						Set k = $O(^||ds.sort(k),tDir)
					}
				}
			}
		}

		If (..%message="") {
			// DTB716 - Only draw the table if there is no error at this point
			Set tTableDrawn = 1
			Set tSC = ..%DrawTable(tAxisCount,tColAxis,tRowAxis,.tFilterInfo,tUseSort)
			If $$$ISERR(tSC) Quit
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	If (..pivotNonce'="") {
		// Lock -^DeepSee.Pivot(..pivotNonce)
	}

	If $$$ISERR(tSC) {
		// PFS077 - Protect against tRS undefined when ..%message is populated upon calling %DrawHTML
		If (($G(tCubeIndex)'="")&&$IsObject($G(tRS))&&(tRS.%QueryKey'="")) {
			// DTB602 - Cancel any query that might have been running
			Do ##class(%DeepSee.ResultSet).%CancelQuery(tCubeIndex,tRS.%QueryKey)
		}
		
		If (..%message="") {
			Do $System.Status.DecomposeStatus(tSC,.tErr)
			Set tErrorMsg = $G(tErr(1)) _ " (8) "
		}
		Else {
			Set tErrorMsg = ..%message
		}
		Set ^DeepSee.PivotError = tErrorMsg
	}
	
	If (..%message'="") && (tErrorMsg="") {
		// DTB716 - Expose the stored error message if there has not been a more recent message set 
		Set tErrorMsg = ..%message
	}

	If (tErrorMsg '= "") {
		If ('tTableDrawn) {
			&html<<div class="pivotError" id="#(..%MakeId("errorDiv"))#">>
			Write $ZCVT(tErrorMsg,"O","HTML")
			&html<</div>>
		}
		Else {
			&html<<div class="dsPivotError" id="#(..%MakeId("errorDiv"))#">>
			Write $ZCVT(tErrorMsg,"O","HTML")
			&html<</div>>
		}
		If (..showQuery) {
			&html<<textarea rows="3" style="width:100%;">>
			Write $ZCVT(tQueryText,"O","HTML")
			&html<</textarea>>
		}

		If ($G(tSQL)'="") {
			&html<<div rows="3" style="color:red; width:100%;">>
			Write $ZCVT(tSQL,"O","HTML")
			Set ^DeepSee.SQLError = tSQL
			&html<</div>>
		}
	}
	// JMD1462
	If (%page.cssLevel>=3)&&(tErrorMsg="") {
		Set tBackgroundOpacity = ..backgroundOpacity
		Set tBackgroundImage = ..backgroundImage
		If (+..analyzerMode) {
			Set tBackgroundOpacity = 0.12
			Set tBackgroundImage = "deepsee/pivottable.jpg"
		}
		If ((tBackgroundOpacity>0)&&(tBackgroundImage'="")) {
			&html<<div class="dsPivotTableImage" style="background-image:url(#(tBackgroundImage)#);opacity:#(+tBackgroundOpacity)#;"></div>>
		}
	}

	&html<</div>>
]]></Implementation>
</Method>

<Method name="%DrawTable">
<Description><![CDATA[
Draw the tables that make up this component.<br/>
<var>pAxisCount</var> is the number of axes within the result.<br/>
<var>pColAxis</var> specifies which axis should be used for columns.<br/>
<var>pRowAxis</var> specifies which axis should be used for rows.<br/>
<var>pFilterInfo</var> is an array of filter information.<br/>
<var>pUseSort</var> indicates that row sorting is in play.]]></Description>
<FormalSpec><![CDATA[pAxisCount:%Integer,pColAxis:%Integer,pRowAxis:%Integer,&pFilterInfo,pUseSort:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {	
		// WAL106
		Set ..singleTable = 1			
		
		Set tCubeIndex = ..cubeKey
		Set tShowNodeNums = +$G(^DeepSee.Settings("ShowNodes")) // debugging

		Set tCellHeight = ..cellHeight

		Set tColumnTotals = ..columnTotals
		Set tRowTotals = ..rowTotals

		#; ordinal numbers for axes
		Set tColAxisNo = 1
		Set tRowAxisNo = 2
		Set tRowRoot = pRowAxis
		Set tColRoot = pColAxis
		Set tColLabelSpan = ..columnLabelSpan
		Set tRowLabelSpan = ..rowLabelSpan&&('pUseSort)

		Set tColAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,..queryKey,"axis",tColAxisNo))
		Set tRowAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,..queryKey,"axis",tRowAxisNo))

		// DTB716 - Do one last check for an error in the results global
		Set tQueryStatus = $G($$$DeepSeeResultsGLVN(tCubeIndex,..queryKey,"error"))
		If tQueryStatus'="" {
			Set ..%message = $System.Status.GetErrorText(tQueryStatus)
			Set ..error = ..%message
		}

		If (..%message '= "") {
			// 1 cell, displaying message
			Set tRowCount = 1
			Set tColCount = 1
			Set tRowLevels = 1
			Set tColLevels = 1
			Set tPageSize = ..pageSize
			Set tStartRow = 1
			Set tEndRow = 1
			Set tMaxCols = 8
			Set tCellWidth = 500 // make sure there is room
		}
		Else {
			#; compute size/shape of columns & rows
			Set tTempStatus = ..%ResultSet.%GetStatus()		// DTB868 - Copy to local cache if the query is complete
			Set tRowCount = ..%GetAxisSize(tRowAxisNo)
			Set tColCount = ..%GetAxisSize(tColAxisNo)

			Set tRowCount = $S(tRowCount>0:tRowCount,1:1)
			Set tColCount = $S(tColCount>0:tColCount,1:1)
			Set ..rowCount = tRowCount

			If (..queryStatus < 100) {
				// only show partial table until complete
				Set tPageSize = $S(..pageSize<25:..pageSize,1:25)
				Set tMaxCols = 8
				Set tStartRow = 1
			}
			Else {
				Set tPageSize = ..pageSize
				Set tMaxCols = ..#MAXCOLUMNS
				Set tStartRow = ((..currPage-1) * ..pageSize) + 1
			}
			Set tEndRow = tStartRow + tPageSize - 1
			Set tEndRow = $S(tEndRow>tRowCount:tRowCount,1:tEndRow) 

			#; get details for each axis
			Set tSC = ..%GetAxisSpecs(tColAxisNo,tColLabelSpan,1,tMaxCols,.tColLevels,.tColInfoX)
			If $$$ISERR(tSC) Quit
			
			Set tSC = ..%GetAxisSpecs(tRowAxisNo,tRowLabelSpan,tStartRow,tEndRow,.tRowLevels,.tRowInfoX,pUseSort)
			If $$$ISERR(tSC) Quit
		}

		#; if we support drag & drop we need additional mouse event handling
		Set dnd = %page.dragAndDrop

		#; message box
		&html<<div id="#(..%MakeId("message"))#" class="dsPivotMessage" style="display: none;">&nbsp;</div>>

		#; Use divs to layout 4 tables
		#; (plus status area on the bottom)
		&html<<div class="dsptOuterDiv" id="#(..%MakeId("outerDiv"))#">>

		Set tDrillCount = ..drillLevels.Count()
		Set tCanDrillUp = (tDrillCount>0)
		Set tDrillHelp = $$$TextHTML("Drill up from the current level")
		Set tUnselectHelp = $$$TextHTML("Click here to unselect cells")

		// force load of images used by message box
		&html<
			<div style="display:none;">
			<img src="deepsee/cancel_24.png"/>
			<img src="deepsee/insert_table_64.png"/>
			<img src="deepsee/insert_table_fav_64.png"/>
			<img src="deepsee/insert_table_clock_64.png"/>
			</div>
		>

		Set tTLStyle = ..columnHeaderStyle
		Set:(tTLStyle["background") tTLStyle = tTLStyle_"background-image:none;"

		// turn off border if there is a header style
		// (with ie hacks!)
		If ((tTLStyle'="")&&(..showZebra)) {
			// JMD1470: remove
			If ($$$ZENISIE) {
				//Set tTLStyle = tTLStyle _ "border: none; border-bottom: none;border-right: none;"
			}
			Else {
				//Set tTLStyle = tTLStyle _ "border-bottom: 1px solid transparent;border-right: 1px solid transparent;"
			}
		}
				
		// + WAL114 -- determine here whether we need to hide measures or not
		//             use a combination of %CountMeasures and ..hideMeasures to make this determination
		Set tHideMeasures = ..%HideMeasures()		// DTB175
		Set tHiddenMeasureText = "" // + WAL118
		// - WAL114
		
		Set ..rowCaptionList = "" // WAL241
		
		#; nub
		#; show caption for row headers, if available
		If ((+..showRowCaption)||(..showRowCaption="")) {
			Set nr = 0
			If (..overrideRowSpec="") {
				Set tLevel = ..rowLevels.GetAt(1)
				While $IsObject(tLevel) {
					If (tLevel.drillLevel = tDrillCount) {
						// + WAL240 -- handle case when we have text but not caption
						//             this applies to related cubes
						If (tLevel.caption'="") {
							Set tRowCaptions($I(nr)) = tLevel.caption
							Do ..rowCaptionList.SetAt(tLevel.caption,nr) // WAL241
						}
						ElseIf(tLevel.text'="") {
							Set tRowCaptions($I(nr)) = tLevel.text
							Do ..rowCaptionList.SetAt(tLevel.text,nr) // WAL241
						}
						// - WAL240
					}
					Set tLevel = tLevel.childLevels.GetAt(1)
				}
			}
			ElseIf (..overrideRowText'="") {
				Set tRowCaptions($I(nr)) = ..overrideRowText
				Do ..rowCaptionList.SetAt(..overrideRowText,nr) // WAL241
			}
			
			// PFS059 - Fill tRowCaptions with empty nodes if the first row level is not the longest
			// DTB842 - Do not accumulate captions for the original levels if a drill down
			// is in effect.
			Set tDepth = $S(tDrillCount:0,1:..%GetMaxRowLevelDepth(..rowLevels))
			For i = 1:1:tDepth {
				While nr<tDepth {
					Set tRowCaptions($I(nr)) = ""
					Do ..rowCaptionList.SetAt("",nr)
				}
			}
			
			Do ..%CountMeasures(.tMeasureCount)
			If ('tHideMeasures)&&(..measureLocation="rows")&&(tMeasureCount>=1) {
				Set tRowCaptions($I(nr)) = $$$Text("Measures","%DeepSee")		// DTB666 - Measures caption for the nub table
			}
		}

		Set tRowCaptionText = ""
		Set tNubTableAttributes("captions",1)="" // WAL
		Set tNubTableAttributes("ids",1) = ..%MakeId("rcap_"_1)
			
		Set tStyle = ..columnHeaderStyle
		Set:(tStyle["background") tStyle = tStyle_"background-image:none;"
			
		// WAL
		Set tNubTableAttributes("style") = tStyle
		Set tNubTableHTML("metadata","style") = tStyle
		
		If ((..userMDX="") && $D(tRowCaptions) && ($G(nr)>0) && $D(tRowInfoX)) {		// DTB846 - check for actual row info

			Set k = $O(tRowCaptions(""))
			Kill tNubTableAttributes("captions",1) // WAL
			While (k'="") {
				Set tNubTableHTML("content",k) = "<td nowrap=""1"" id="""_..%MakeId("rcap_"_nr)_""" style="""_tStyle_""">"
				Set nr = nr - 1
				Set tNubTableHTML("content",k,"captions") = $ZCVT(tRowCaptions(k),"O","HTML")
				Set tNubTableHTML("content",k,"style") = tStyle
				
				// WAL
				Set tNubTableAttributes("captions",k)=$ZCVT(tRowCaptions(k),"O","HTML")
				Set tNubTableAttributes("style",k) = tStyle
				Set tNubTableAttributes("ids",k) = ..%MakeId("rcap_"_(k))
				
				Set k = $O(tRowCaptions(k))
			}
		}
		
		Set tNubTableHTML("metadata","unselect") = tUnselectHelp // + WAL114
		Set tNubTableHTML("metadata","zebra")=..showZebra // + WAL114
		Set ..rowCaptionText = tRowCaptionText
	
		// WAL
		Set tNubTableAttributes("title") = $ZCVT(tUnselectHelp,"O","HTML")
		Set tNubTableAttributes("class") = $S(..showZebra:"dsNubZebra",1:"dsNub")
		Set tNubTableAttributes("onclick") = "zenPage.getComponent("_..index_").cellClickHandler(event,'','');"

		#; column headers
		Set tColSpan = 0
		
		Set hw = $S(..cellWidth="":100,1:..cellWidth)
		If '$D(tColInfoX) {
			Set tColumnTotals = 0
			Set tStyle = ""
			// JMD1465 Set tStyle = tStyle_"width:"_hw_"px;"
			Set tStyle = tStyle_..columnHeaderStyle
			Set:tStyle["background" tStyle = tStyle_"background-image:none;"
			Set tDStyle = tStyle // WAL capture before quoting
			Set:tStyle'="" tStyle = "style="_$$$quote(tStyle)
			#; no columns
			If (..%message '= "") {
				Set tName = "&#160;"
				Set tTitle = ""
			}
			Else {
				Set tName = $$$Text("All","%DeepSee")
				Set tTitle = tName
			}
			Set tColClass = $S(..showZebra:"dsPivotColumnZebra",1:"dsPivotColumn")
			// WAL -- hw means width I believe
			Set id = ..%MakeId("col_"_"1:1")
			Set tTopTableHTML(1,1) = "<th id="""_id_""" "_tStyle_" class="""_tColClass_""" nowrap=""1"" colspan=""1"" rowspan=""1"" title="""_$ZCVT(tTitle,"O","HTML")_"""><div class=""dsPivotColumnOuter""><div class=""dsPivotColumnDiv"">"_tName_"&nbsp;</div></div></th>"
			
			// WAL
			Set tTopTableAttributes(1,1,"id") = id
			Set tTopTableAttributes(1,1,"style") = tDStyle
			Set tTopTableAttributes(1,1,"class") = tColClass
			Set tTopTableAttributes(1,1,"colspan") = 1
			Set tTopTableAttributes(1,1,"rowspan") = 1
			Set tTopTableAttributes(1,1,"title") = $ZCVT(tTitle,"O","HTML")
			Set tTopTableAttributes(1,1,"contents","class") = "dsPivotColumnDiv"
			Set tTopTableAttributes(1,1,"contents","contents") = tName_"&nbsp;"
		}
		Else {
			// + WAL152 -- will I skip level 1 of the sort column??? If so take note of this 
			//             so we render the sort column appropriately
			Set tSkipSort = 0
			If (..sortColumn'=0) {
				Set tInfo = $G(tColInfoX(1,..sortColumn))
				If (tInfo'="") {
					Set tSortNodeNo = +$LG(tInfo,1)
					Set tType = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tSortNodeNo),1)
					Set:(tHideMeasures&&((tType="msr")||(tType="agg")||(tType="exp")||(tType="lit"))) tSkipSort = 1
				}
			}
			// - WAL152
		
			For tLevel = tColLevels:-1:1 {
				// force width of header to avoid browser paint issue
				Set tStyle = "width:"_hw_"px;"
				Set tDivStyle = "vertical-align:middle;"
				If (..columnHeaderStyle'="") {
					Set tStyle = tStyle_..columnHeaderStyle
				}
				
				#; labels within this level
				Set n = $O(tColInfoX(tLevel,""))
				Set tEndCol = 0		// DTB850
				Set tCol = 0
				Set c = 0
				Set mc = 0
				While (n '= "") {
					Set:(n>tEndCol) tEndCol=n		// DTB850
					Set tColStyle = tStyle
					Set tNodeNo = +$LG(tColInfoX(tLevel,n),1)
					Set tColSpan = +$LG(tColInfoX(tLevel,n),2)
					Set tRowSpan = +$LG(tColInfoX(tLevel,n),3)
					
					// + WAL180 (2)
					Set tHasChildren = +$LG(tColInfoX(tLevel,n),4)
					Set tChildRowSpan = 1
					If (tHasChildren) {
						For tThisLevel = tLevel:-1:1 {
							Set:$D(tColInfoX(tThisLevel)) tChildRowSpan = $LG(tColInfoX(tThisLevel,n),3)
							Set:$D(tColInfoX(tThisLevel)) tChildNodeNo = $LG(tColInfoX(tThisLevel,n),1)
							If (tChildRowSpan > 1) {
								Quit
							} 	
						}	
					}
					Set tSkipChild = 0
					If (tChildRowSpan > 1) {
						Set tChildType = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tChildNodeNo),1)
						Set tSkipChild = (tHideMeasures&&((tChildType="msr")||(tChildType="exp")||(tChildType="lit")))		// DTB666 - Remove "agg"
					}
					// - WAL180 (2)

					Set c = c + tColSpan
					
					Set tType = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tNodeNo),1)
					
					// + WAL114 -- skip? yes if its a measure, hideMeasures is on, AND this isn't the only thing on columns
					If ((tColLevels=1)||'(tHideMeasures&&((tType="msr")||(tType="exp")||(tType="lit")))) {		// DTB666 - Remove "agg"
						Set tName = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tNodeNo),5)
						// JMD1475
						Set tDesc = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tNodeNo),23)
						Set tTooltip = $S(tDesc'="":(tName_" - "_tDesc),1:tName)
						Set tTooltip2 = $$$Text("Double-click to sort by this column")

						// go up and find first node with a format / header style
						Set tFormat = ""
						Set tColHeaderStyle = ""
						Set tTestNodeNo = tNodeNo
						While ((tTestNodeNo'="")) {
							Set tSNodeType = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tTestNodeNo)),1)
							If ((tSNodeType="msr")||(tSNodeType="exp")||(tSNodeType="cmbr")) {
								Set:(tFormat="") tFormat = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tTestNodeNo)),12)
							}
							Set:(tColHeaderStyle="") tColHeaderStyle = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tTestNodeNo)),19)
							Set tTestNodeNo = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tTestNodeNo)),4)
						}

						Set tColStyle = tColStyle _ tColHeaderStyle 
						If ($P(tFormat,"^",4)'="") {
							Set tColStyle = tColStyle _$P(tFormat,"^",4)
						}
						Set:tShowNodeNums tName = tName _ " ["_tNodeNo_"]"
						If (..showZebra) {
							Set tCls = $S(((..sortColumn=n)&&((tLevel=1)||(tSkipSort&&(tLevel=2)))):"dsPivotColumnSortZebra",1:"dsPivotColumnZebra") // WAL152
						}
						Else {
							Set tCls = $S(((..sortColumn=n)&&((tLevel=1)||(tSkipSort&&(tLevel=2)))):"dsPivotColumnSort",1:"dsPivotColumn") // WAL152
						}
						Set tSortChar = $S((..sortColumn=n)&&((tLevel=1)||(tSkipSort&&(tLevel=2))):$S(..sortDir="DESC":"&#x25BC;",1:"&#x25B2;"),1:"") // WAL152

						If (..%HideMeasures()&&(..measureLocation="columns"))&&(tType="agg")&&(tRowSpan>1)&&'+$G(tColReduced(n)) {
							// DTB666 - Reduce row span to account for hidden measures.
							// Only do this once per column.
							Set tRowSpan = tRowSpan-1
							Set tColReduced(n)=1
						}

						Set:(tColStyle["background") tColStyle = tColStyle_"background-image:none;"
						
						Set tDColStyle = tColStyle // WAL -- intercept style for adjustment later
						
						Set:tColStyle'="" tColStyle = "style="_$$$quote(tColStyle)
						Set tIStyle = ""
						Set tDIStyle = tDivStyle   // WAL -- intercept style for later
						Set:tDivStyle'="" tIStyle = "style="_$$$quote(tDivStyle)
						Set:(tSkipChild) tRowSpan = tRowSpan + (tChildRowSpan-1) // + WAL180 (2)
						
						// WAL -- I think using n for a span indicator is fine
						Set id = ..%MakeId("col_"_tLevel_":"_n)
						Set tTopTableHTML(tLevel,n) = "<th id="""_id_""" class="""_tCls_""" colspan="""_tColSpan_""" rowspan="""_tRowSpan_""" "_tColStyle_" title="""_$ZCVT(tTooltip,"O","HTML")_" &#10;"_tTooltip2_""" onclick=""zenPage.getComponent("_..index_").columnClickHandler(event,"_n_");"" ondblclick=""zenPage.getComponent("_..index_").columnDblClickHandler(event,"_n_");""><div class=""dsPivotColumnOuter""><div class=""dsPivotColumnDiv"" "_tIStyle_">"_$ZCVT(tName,"O","HTML")_"&nbsp;"_tSortChar_"</div></div></th>"
						
						// WAL
						Set tTopTableAttributes(tLevel,n,"id") = id
						Set tTopTableAttributes(tLevel,n,"style") = tDColStyle
						Set tTopTableAttributes(tLevel,n,"class") = tCls
						Set tTopTableAttributes(tLevel,n,"colspan") = tColSpan
						Set tTopTableAttributes(tLevel,n,"rowspan") = tRowSpan
						Set tTopTableAttributes(tLevel,n,"title") = $ZCVT(tTooltip,"O","HTML")_" &#10;"_tTooltip2
						Set tTopTableAttributes(tLevel,n,"onclick") = "zenPage.getComponent("_..index_").columnClickHandler(event,"_n_");"
						Set tTopTableAttributes(tLevel,n,"ondblclick") = "zenPage.getComponent("_..index_").columnDblClickHandler(event,"_n_");"
						Set tTopTableAttributes(tLevel,n,"contents","class") = "dsPivotColumnDiv"
						Set tTopTableAttributes(tLevel,n,"contents","style") = tDIStyle
						Set tTopTableAttributes(tLevel,n,"contents","contents") = $ZCVT(tName,"O","HTML")_"&nbsp;"_tSortChar
					}
					Else {
						// + WAL118 -- remember the label for the hidden measure
						If ($LG($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tNodeNo),5)'="") {
							Set tHiddenMeasureText($LG($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tNodeNo),5)) = ""
						}
						// - WAL118
					}
					// - WAL114
					Set n = $O(tColInfoX(tLevel,n))
				}
				// total
				If (tColumnTotals&&(tLevel=tColLevels)) {
					Set msgTotal = $Case(..columnTotalAgg,
						"avg":$$$Text("Average","%DeepSee"),
						"count":$$$Text("Count","%DeepSee"),
						"min":$$$Text("Min","%DeepSee"),
						"max":$$$Text("Max","%DeepSee"),
						"pct":$$$Text("% of Total","%DeepSee"),
						:$$$Text("Total","%DeepSee"))

					Set tColStyle = tStyle
					Set:(tColStyle["background") tColStyle = tColStyle_"background-image:none;"
					
					Set tDColStyle = ""
					
					Set:tColStyle'="" tColStyle = "style="_$$$quote(tColStyle)
					Set tDColStyle = tColStyle // WAL
					Set tColClass = $S(..showZebra:"dsPivotColumnZebra",1:"dsPivotColumn")
					Set tIStyle = ""
					Set tDIStyle = tDivStyle // WAL -- intercept for later
					Set:tDivStyle'="" tIStyle = "style="_$$$quote(tDivStyle)
					
					// + WAL180 -- adjust span for column total header if we are hiding measures
					Set tColTotalSpan = $S((..%HideMeasures() && (tColLevels>1) && (..measureLocation = "columns")):tColLevels-1,1:tColLevels)
					// make sure total header collates last
					// if you have this many columns the total header is the least of your worries
					
					// PFS044 - Generate ID to use in both tTopTableHTML and tTopTableAttributes
					Set id = ..%MakeId("coltotal")
					
					// WAL
					Set n = tEndCol+1		// DTB850
					Set tTopTableHTML(tLevel,n) = "<th id="""_id_""" rowspan="""_tColTotalSpan_""" nowrap=""1"" "_tColStyle_" class="""_tColClass_"""><div class=""dsPivotColumnOuter""><div class=""dsPivotColumnDiv"" "_tIStyle_">&nbsp;"_msgTotal_"&nbsp;</div></div></th>"
					// - WAL180
					
					// PFS044 - Use unique value of n for total column
					// WAL
					Set tTopTableAttributes(tLevel,n,"id") = id
					Set tTopTableAttributes(tLevel,n,"style") = tDColStyle
					Set tTopTableAttributes(tLevel,n,"class") = tColClass
					Set tTopTableAttributes(tLevel,n,"colspan") = 1
					Set tTopTableAttributes(tLevel,n,"rowspan") = tColTotalSpan
					Set tTopTableAttributes(tLevel,n,"contents","class") = "dsPivotColumnDiv"
					Set tTopTableAttributes(tLevel,n,"contents","style") = tDIStyle
					Set tTopTableAttributes(tLevel,n,"contents","contents") = "&nbsp;"_msgTotal_"&nbsp;"
				}
			}
		}

		#; side table: row labels
		#; row headers
		For x = 1:1:tRowLevels {
			Set tNumRows(x) = 0
		}

		For tRow = tStartRow:1:tEndRow {
			Set tStyle = ..rowHeaderStyle
			
			// WAL
			Set tSideTableHTML(tRow) = "<tr id="""_..%MakeId("tr_"_tRow)_""">"

			If ('$D(tRowInfoX)) {
				// no rows
				Set tRowTotals = 0
				If (..%message '= "")||$D(tColInfoX) {
					// DTB141 - Don't label rows if there is something on columns
					Set tName = "&#160;"
					Set tTitle = ""
				}
				Else {
					Set tName = $$$Text("Count","%DeepSee")
					Set tTitle = tName
				}
				Set:(tStyle["background") tStyle = tStyle_"background-image:none;"
				
				Set tDStyle = tStyle // WAL -- intercept for attributes
				
				Set:tStyle'="" tStyle = "style="_$$$quote(tStyle)
				Set tRowClass = $S(..showZebra:"dsPivotRowOdd",1:"dsPivotRow")
				
				// PFS045 - Assign proper row id when nothing placed on rows
				Set id = ..%MakeId("row_"_1_":"_1)
				
				// WAL
				Set tSideTableHTML(1,1) = "<th id="""_id_""" class="""_tRowClass_""" nowrap=""1"" "_tStyle_" rowspan=""1"" colSpan=""1"" title="""_$ZCVT(tTitle,"O","HTML")_"""><div class=""dsPivotRowDiv"" onclick=""zenPage.getComponent("_..index_").rowClickHandler(event,1);"">"_tName_"&nbsp;</div></th>"
				Set tNumRows(1) = 1
				
				// WAL
				Set tSideTableAttributes(1,1,"id") = id
				Set tSideTableAttributes(1,1,"class") = tRowClass
				Set tSideTableAttributes(1,1,"style") = tDStyle
				Set tSideTableAttributes(1,1,"rowspan") = 1
				Set tSideTableAttributes(1,1,"colspan") = 1
				Set tSideTableAttributes(1,1,"title") = $ZCVT(tTitle,"O","HTML")
				Set tSideTableAttributes(1,1,"contents","class") = "dsPivotRowDiv"
				Set tSideTableAttributes(1,1,"contents","onclick") = "zenPage.getComponent("_..index_").rowClickHandler(event,1);"
				Set tSideTableAttributes(1,1,"contents","contents") = tName_"&nbsp;"
			}
			Else {
				Set tTotalSpan = 0
				For tLevel = tRowLevels:-1:1 {
					// WAL029 - Increment nodes in all lower levels for this row before moving to the next row 
					// If (tTotalSpan >= tRowLevels) Quit
					If (tTotalSpan >= tRowLevels) { 
						Set tLevelCount = tLevel
						While (tLevelCount>=1) {
							Set tNumRows(tLevelCount) = tNumRows(tLevelCount) + 1
							Set tLevelCount=tLevelCount-1	
						}
						Quit
					}
					
					// WAL029
					If (tRow >= +$G(tNextRow(tLevel))) {
						Set tRowStyle = tStyle
						Set tRowItem(tLevel) = $O(tRowInfoX(tLevel,$G(tRowItem(tLevel))))
						If (tRowItem(tLevel)'="") {
							Set tNodeNo = +$LG(tRowInfoX(tLevel,tRowItem(tLevel)),1)
							Set tRowNo = +$LG(tRowInfoX(tLevel,tRowItem(tLevel)),5)
							Set:tRowNo="" tRowNo = tRow
							Set tRowSpan = +$LG(tRowInfoX(tLevel,tRowItem(tLevel)),2)
							Set tColSpan = +$LG(tRowInfoX(tLevel,tRowItem(tLevel)),3)
							Set tTotalSpan = tTotalSpan + tColSpan
							Set tHasChildren = +$LG(tRowInfoX(tLevel,tRowItem(tLevel)),4)
							// + WAL180 (2)
							Set tChildColSpan = 1
							If (tHasChildren) {
								For tThisLevel = tLevel:-1:1 {
									Set:$D(tRowInfoX(tThisLevel)) tChildColSpan = $LG(tRowInfoX(tThisLevel,tRowItem(tLevel)),3)
									Set:$D(tRowInfoX(tThisLevel)) tChildNodeNo = $LG(tRowInfoX(tThisLevel,tRowItem(tLevel)),1)
									If (tChildColSpan > 1) {
										Quit
									} 	
								}	
							}
							// - WAL180 (2)
							If ('tHasChildren && (tLevel>1)) {
								Set tNextRow(tLevel-1) = tRow + 1
								For kk=tLevel-2:-1:1 {
									Set tNextRow(kk) = tRow + 1
								}
							}
							Set tNextRow(tLevel) = tRow + tRowSpan
							
							If (tRow >= tStartRow) {
								// + WAL114 -- what type of node is this??
								Set tType = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tNodeNo),1)
								// + WAL114 -- skip? yes if its a measure, hideMeasures is on AND this isn't the only thing on rows
								
								// + WAL180 (2)
								Set tSkipChild = 0
								If (tChildColSpan > 1) {
									Set tChildType = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tChildNodeNo),1)	
									Set tSkipChild = (tHideMeasures&&(..measureLocation="rows")&&		// DTB661 - Only apply this to measures placed on rows
											((tChildType="msr")||(tChildType="exp")||(tChildType="lit")))		// DTB666 - Remove "agg"
								}
								// - WAL180 (2)
								
								// + WAL206 -- add (..measureLocation="rows") to the condition, use ..%HideMeasures()
								// DTB666 - Take "agg" out of the condition
								If ((tRowLevels=1)||'(..%HideMeasures()&&(..measureLocation="rows")&&((tType="msr")||(tType="exp")||(tType="lit")))) {
								// - WAL206
									Set tName = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tNodeNo),5)
									// JMD1475
									Set tDesc = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tNodeNo),23)
									Set tTooltip = $S(tDesc'="":(tName_" - "_tDesc),1:tName)
									Set tFormat = ""
									Set tRowHeaderStyle = ""
									Set tTestNodeNo = tNodeNo
									
									If (..%HideMeasures()&&(..measureLocation="rows"))&&(tType="agg")&&(tColSpan>1)&&'+$G(tRowReduced(tRow)) {
										// DTB666 - Reduce the colspan of an aggregate node. Only do this once per row.
										Set tColSpan = tColSpan-1
										If (tRow=1) {
											Set tLevelCounter = 1
											Set tTestLevelNo = $O(tRowInfoX(""),-1)
											While (tTestLevelNo'="")&&(tTestLevelNo'=tLevel) {
												// DTB666 - Look through the original row axis information to count which position
												// This aggregate is in.
												Set tLevelCounter = tLevelCounter+1
												Set tTestLevelNo = $O(tRowInfoX(tTestLevelNo),-1)
											}

											If (tNubTableHTML("metadata","colSpans",tLevelCounter)>1) {
												// DTB666 - Reduce the colspan of this node in the nub table as well
												Set tNubTableHTML("metadata","colSpans",tLevelCounter) = tNubTableHTML("metadata","colSpans",tLevelCounter)-1
											}
										}
										
										Set tRowReduced(tRow) = 1		// DTB666 - Log that this row was reduced
									}
									
									While ((tTestNodeNo'="")) {
										Set tSNodeType = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tTestNodeNo)),1)
										If ((tSNodeType="msr")||(tSNodeType="exp")||(tSNodeType="cmbr")) {
											Set:(tFormat="") tFormat = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tTestNodeNo)),12)
										}
										Set:(tRowHeaderStyle="") tRowHeaderStyle = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tTestNodeNo)),19)
										Set tTestNodeNo = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tTestNodeNo)),4)
									}
									Set tRowStyle = tRowStyle _ tRowHeaderStyle
									If ($P(tFormat,"^",4)'="") {
										Set tRowStyle = tRowStyle _$P(tFormat,"^",4)
									}
									Set:tShowNodeNums tName = tName _ " ["_tNodeNo_"]"
									If (..showZebra && (..rowHeaderStyle'="")) {
										Set tRowStyle = tRowStyle _ $S('(tNumRows(tLevel)#2):"background:white;",1:"")
									}
									Set:(tRowStyle["background") tRowStyle = tRowStyle_"background-image:none;"
									
									Set tDRowStyle = tRowStyle // WAL
									
									Set:tRowStyle'="" tRowStyle = "style="_$$$quote(tRowStyle)
									Set tRowClass = $S(..showZebra:$S('(tNumRows(tLevel)#2):"dsPivotRowOdd",1:"dsPivotRowEven"),1:"dsPivotRow")
									Set:(tSkipChild) tColSpan = tColSpan + (tChildColSpan-1) // + WAL180 (2)
									// JMD1055: force entire th into one long line
									If (tCanDrillUp && (tLevel=1)) {
										// DTB118 - use removeDrillLevel()
										// WAL221 -- use tRow as index for rowClickHandler
										// WAL224 -- pass event to removeDrillLevel()
										// WAL237 -- switch argument for removeDrillLevel() from
										//           event,index to index,event
										//           because other calls to removeDrillLevel don't pass event (and don't need to)
										
										// WAL
										Set id = ..%MakeId("row_"_tLevel_":"_tRow)
										Set tSideTableHTML(tRow,tLevel) = "<th id="""_id_""" class="""_tRowClass_""" rowNo="""_tRowNo_""" nowrap=""1"" "_tRowStyle_" rowspan="""_tRowSpan_""" colSpan="""_tColSpan_""" title="""_$ZCVT(tTooltip,"O","HTML")_"""><div class=""dsPivotRowDiv"" onclick=""zenPage.getComponent("_..index_").rowClickHandler(event,"_(tRow)_");"" ondblclick=""zenPage.getComponent("_..index_").rowDblClickHandler(event,"_tLevel_","_tRowNo_");""><span title="""_tDrillHelp_""" onclick=""zenPage.getComponent("_..index_").removeDrillLevel("_(tDrillCount-1)_",event);"" class=""dsptDrillUp"">&nbsp;&#9664;&nbsp;</span>"_$ZCVT(tName,"O","HTML")_"</div></th>"
									
										Set tSideTableAttributes(tRow,tLevel,"id")=id
										Set tSideTableAttributes(tRow,tLevel,"class")=tRowClass
										Set tSideTableAttributes(tRow,tLevel,"rowNo")=tRowNo
										Set tSideTableAttributes(tRow,tLevel,"style")=tDRowStyle
										Set tSideTableAttributes(tRow,tLevel,"rowspan")=tRowSpan
										Set tSideTableAttributes(tRow,tLevel,"colspan")=tColSpan
										Set tSideTableAttributes(tRow,tLevel,"title")=$ZCVT(tTooltip,"O","HTML")
										Set tSideTableAttributes(tRow,tLevel,"contents","class")="dsPivotRowDiv"
										Set tSideTableAttributes(tRow,tLevel,"contents","onclick")="zenPage.getComponent("_..index_").rowClickHandler(event,"_(tRow)_");"
										Set tSideTableAttributes(tRow,tLevel,"contents","ondblclick")="zenPage.getComponent("_..index_").rowDblClickHandler(event,"_tLevel_","_tRowNo_");"
										Set tSideTableAttributes(tRow,tLevel,"contents","contents") = "<span title="""_tDrillHelp_""" onclick=""zenPage.getComponent("_..index_").removeDrillLevel("_(tDrillCount-1)_",event);"" class=""dsptDrillUp"">&nbsp;&#9664;&nbsp;</span>"_$ZCVT(tName,"O","HTML")
									}
									Else {
										// WAL221 -- use tRow as index for rowClickHandler
										
										Set id = ..%MakeId("row_"_tLevel_":"_tRow)
										// WAL
										Set tSideTableHTML(tRow,tLevel) = "<th id="""_..%MakeId("row_"_tLevel_":"_tRow)_""" class="""_tRowClass_""" rowNo="""_tRowNo_""" nowrap=""1"" "_tRowStyle_" rowspan="""_tRowSpan_""" colSpan="""_tColSpan_""" title="""_$ZCVT(tTooltip,"O","HTML")_"""><div class=""dsPivotRowDiv"" onclick=""zenPage.getComponent("_..index_").rowClickHandler(event,"_(tRow)_");"" ondblclick=""zenPage.getComponent("_..index_").rowDblClickHandler(event,"_tLevel_","_tRowNo_");"">&nbsp;"_$ZCVT(tName,"O","HTML")_"</div></th>"
									
										// I believe the only difference between this and the above is the contents,
										// so I should change the code to simplify for this case
										Set tSideTableAttributes(tRow,tLevel,"id")=id
										Set tSideTableAttributes(tRow,tLevel,"class")=tRowClass
										Set tSideTableAttributes(tRow,tLevel,"rowNo")=tRowNo
										Set tSideTableAttributes(tRow,tLevel,"style")=tDRowStyle
										Set tSideTableAttributes(tRow,tLevel,"rowspan")=tRowSpan
										Set tSideTableAttributes(tRow,tLevel,"colspan")=tColSpan
										Set tSideTableAttributes(tRow,tLevel,"title")=$ZCVT(tTooltip,"O","HTML")
										Set tSideTableAttributes(tRow,tLevel,"contents","class")="dsPivotRowDiv"
										Set tSideTableAttributes(tRow,tLevel,"contents","onclick")="zenPage.getComponent("_..index_").rowClickHandler(event,"_(tRow)_");"
										Set tSideTableAttributes(tRow,tLevel,"contents","ondblclick")="zenPage.getComponent("_..index_").rowDblClickHandler(event,"_tLevel_","_tRowNo_");"
										Set tSideTableAttributes(tRow,tLevel,"contents","contents") = "&nbsp;"_$ZCVT(tName,"O","HTML")
									}
								}
								// + WAL114 -- if hiding measures adjust nub table captions
								//             else case means that tHideMeasures=1 AND we have 
								//             found a measure
								//             So we need to remove the row label for the measure
								//             we are removing
								Else {
									
									// + WAL118 -- remember the label for the hidden measure
									// + WAL130 -- fix copy paste error, use row axis key
									If ($LG($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tNodeNo),5)'="") { 
										Set tHiddenMeasureText($LG($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tNodeNo),5)) = ""
										Set tRowReduced(tRow) = 1		// DTB666 - Log that a measure was removed from the row
									}
									// - WAL130
									// - WAL118
									
									If ($G(tKill)="") {
										Set tItem = ""
										For i=1:1:tLevel {
											Set tItem = $O(tNubTableHTML("content",tItem),-1)	
										}
										
										Set tNubLevel = $O(tNubTableHTML("content",""))
										Set tNubLevelCount = 0
										While (tNubLevel'="") {
											Set tNubLevelCount = $i(tNubLevelCount)
											Set tNubLevel = $O(tNubTableHTML("content",tNubLevel))
										}
										// If this node doesn't have a caption there are likely no row captions,
										// so don't kill anything
										// If there is a different number of nub headers and row headers deal with this later in %MergeTables
										If (($G(tItem)'="") && ($G(tNubTableHTML("content",tItem,"captions"))'="") && '(tNubLevelCount < tRowLevels)) {
											Kill tNubTableHTML("content",tItem)
											Set tKill = 1
										}
									}
								}
								// - WAL114
								Set tNumRows(tLevel) = tNumRows(tLevel) + 1
							}
						}
					}
				} // for tLevel
			}
		}

		// total
		If (tRowTotals) {
			Set msgTotal = $Case(..rowTotalAgg,
				"avg":$$$Text("Average","%DeepSee"),
				"count":$$$Text("Count","%DeepSee"),
				"min":$$$Text("Min","%DeepSee"),
				"max":$$$Text("Max","%DeepSee"),
				"pct":$$$Text("% of Total","%DeepSee"),
				:$$$Text("Total","%DeepSee"))
			If ((..rowTotalAgg="sum")&&(..rowTotalSource="all")) {
				Set msgTotal = $$$Text("Grand Total","%DeepSee")
			}

			Set tRowStyle = ..rowHeaderStyle
			If (..showZebra && (..rowHeaderStyle'="")) {
				Set tRowStyle = tRowStyle _ $S('(tNumRows(1)#2):"background:white;",1:"")
			}
			Set:(tRowStyle["background") tRowStyle = tRowStyle_"background-image:none;"
			Set tDRowStyle = tRowStyle // WAL
			Set:tRowStyle'="" tRowStyle = "style="_$$$quote(tRowStyle)
			Set tRowClass = $S(..showZebra:$S('(tNumRows(1)#2):"dsPivotRowOdd",1:"dsPivotRowEven"),1:"dsPivotRow")
			// don't close row (WAL106)
			// + WAL180 -- adjust column span for row total header if we are hiding measures from rows
			Set tRowTotalSpan = $S((..%HideMeasures() && (tRowLevels>1) && (..measureLocation = "rows")):tRowLevels-1,1:tRowLevels)
			
			Set id = ..%MakeId("rowtotal")
			// WAL
			Set tSideTableHTML("rowtotal") = "<tr><th id="""_id_""" colspan="""_tRowTotalSpan_""" class="""_tRowClass_""" "_tRowStyle_"><div class=""dsPivotRowDiv"">&nbsp;"_msgTotal_"</div></th>"
			// - WAL180
			
			Set tSideTableAttributes((tEndRow+1),tRowLevels,"id")=id
			Set tSideTableAttributes((tEndRow+1),tRowLevels,"class")=tRowClass
			Set tSideTableAttributes((tEndRow+1),tRowLevels,"colspan")=tRowTotalSpan
			Set tSideTableAttributes((tEndRow+1),tRowLevels,"style")=tDRowStyle
			Set tSideTableAttributes((tEndRow+1),tRowLevels,"id")=id
			Set tSideTableAttributes((tEndRow+1),tRowLevels,"contents","class")="dsPivotRowDiv"
			Set tSideTableAttributes((tEndRow+1),tRowLevels,"contents","contents")="&nbsp;"_msgTotal
		}
		
		// + WAL118 -- remember which measures were hidden so the client code can adjust
		//             tooltips and legends accordingly
		Set tSC = ..hiddenMeasureText.Clear()
		Set tKey = ""
		Set tMeasureText = $O(tHiddenMeasureText(""))
		While (tMeasureText'="") {
			Do ..hiddenMeasureText.SetAt(tMeasureText,$i(tKey))
			Set tMeasureText = $O(tHiddenMeasureText(tMeasureText))	
		}
		// - WAL118

		#; cell table
		Set tCellRowCount = tRowCount
		Set:tCellRowCount>tPageSize tCellRowCount = tPageSize
		Set:tColCount>tMaxCols tColCount = tMaxCols
		Set tSC = ..%DrawDataTable(pAxisCount,tColRoot,tRowRoot,tStartRow,tEndRow,tColumnTotals,tRowTotals,pUseSort,tMaxCols,.tDataTableHTML,.tDataTableHTMLAttributes)
		If $$$ISERR(tSC) Quit

		// + WAL106 -- merge the html arrays for the 4 tables into a single table
		Set tSC = ..%MergeTables(.tNubTableHTML,.tTopTableHTML,.tSideTableHTML,.tDataTableHTML, .tNubTableAttributes, .tTopTableAttributes, .tSideTableAttributes, .tDataTableHTMLAttributes)
		If $$$ISERR(tSC) Quit
		// - WAL106

		// JMD1129 truncated rows?
		// DTB710 - Use the new property to keep track of row truncation
		Set:tRowAxisKey'="" ..rowsTruncated = +$G($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"truncated"))

		#; status area
		Set tPageCount = (tRowCount \ tPageSize) + $S(tRowCount#tPageSize:1,1:0)
		If (..showStatus || (tPageCount>1) || ..rowsTruncated) {		// DTB710
			Set tStatusStyle = ""
		}
		Else {
			Set tStatusStyle = "height:0px;border-top:none;"
		}
		&html<<div class="dsptStatusDiv" style="#(tStatusStyle)#" id="#(..%MakeId("statusDiv"))#">>
		If (..showQuery) {
			Set tQueryText = ""
			Set:^DeepSee.QueryLog($UserName)'="" tQueryText = $G(^DeepSee.QueryLog($UserName,^DeepSee.QueryLog($UserName)))
			&html<<textarea rows="3" style="width:100%;" id="#(..%MakeId("queryText"))#">>
			Write $ZCVT(tQueryText,"O","HTML"),!
			&html<</textarea>>
		}

		// only show if needed
		If ((tPageCount>1)||..showPivotStats||..rowsTruncated) {		// DTB710 - Use new property
			Set tSC = ..%DrawStatusArea(tPageCount,"pivot",..rowsTruncated)
		}
		&html<</div>> // outer

		&html<</div>> // outer
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetMaxRowLevelDepth">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRow,pDepth:%Integer=0</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tDepth = pDepth
	For i=1:1:pRow.Count() {
		Set tTemp = ..%GetMaxRowLevelDepth(pRow.GetAt(i).childLevels,pDepth+1)
		Set:(tTemp>tDepth) tDepth = tTemp
	}
	Quit tDepth
]]></Implementation>
</Method>

<Method name="%CalculateSpans">
<FormalSpec><![CDATA[&pTopTableHTML,&pSideTableHTML,*pRowSpan,*pColSpan,*pFirstSpan=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tNode = $O(pTopTableHTML(""),-1)
		Set tNubRowSpan=0
		Set tNubRow = $O(pTopTableHTML(""))
		While (tNubRow'="") {
			Set:$O(pTopTableHTML(tNubRow,""))'="MaxLength" tNubRowSpan=$i(tNubRowSpan)
			Set tNubRow = $O(pTopTableHTML(tNubRow))	
		}
		// + WAL169
		// + WAL114
		Set tSideTableIdx = $O(pSideTableHTML("")) 
		If tSideTableIdx'="" {
			Set tLevel = $O(pSideTableHTML(tSideTableIdx,""))
			While tLevel '= "" {
				Set pFirstSpan = $I(pFirstSpan)
				Set tLevel = $O(pSideTableHTML(tSideTableIdx,tLevel))
			}
		}
		Set tMaxSpan = 0
		While (tSideTableIdx'="") {
			Set tNubColLevel = $O(pSideTableHTML(tSideTableIdx,""))
			Set tNubColSpan=0
			While (tNubColLevel'="") {
				Set tNubColSpan = $i(tNubColSpan)
				Set tNubColLevel = $O(pSideTableHTML(tSideTableIdx,tNubColLevel))
			}
			If (tNubColSpan > tMaxSpan) Set tMaxSpan = tNubColSpan
			Set tSideTableIdx = $O(pSideTableHTML(tSideTableIdx))
		}
		Set tNubColSpan = tMaxSpan
		
		// output variables
		Set pRowSpan = tNubRowSpan
		Set pColSpan = tNubColSpan
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()	
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="DivMerge">
<FormalSpec>tNubTable="",tTopTable="",tSideTable="",tDataTable="",pNubTableHTML,pTopTableHTML,pSideTableHTML,pDataTableHTML</FormalSpec>
<Implementation><![CDATA[
	// I think I can generalize this by having an iterate/emit method. It will need to be able to
	// be parameterized with a transformation
	//
	// Will be in pivot table class
	// might have to pick up updated width/height in some cases
	
	Set tSC = ..%CalculateSpans(.tTopTable, .tSideTable, .tRowSpan, .tColSpan, .tFirstSpan)

	// test style sheet
	//W "<link href=""stylesheet.css"" rel=""stylesheet"">"
	
	// just given these divs, I should be able to position everything within my emit method

		Set tIgnore("colspan") = ""
		Set tIgnore("rowspan") = ""
		
		Set tTopTableLeft = ..cellWidth * tColSpan
		Set tSideTableTop = ..cellHeight * tRowSpan
		Set tSideTableWidth = tTopTableLeft
		Set tTopTableHeight = tSideTableTop
		
	// Need to be able to pass a transformation to each of these iterations
	//
		// For zebra, remove borders for side and data tables ( pass 0 for arg 6 )
		// check ..showZebra for this
		
		// PFS048 - Reorder and use old dataTable
		&html<<div id="#(..%MakeId("sideTable"))#" class="sideTable" style="#("overflow:hidden;position:absolute;top:"_ tSideTableTop _"px;height:600px;width:"_ tTopTableLeft _"px;z-index:2;")#">>
			Set tSC = ..%Emit(.tSideTable,"side",.tIgnore,tRowSpan,tColSpan)
		&html<</div>>
	
		&html<<div id="#(..%MakeId("topTable"))#" style="#("overflow:hidden;position:absolute;left:"_ tTopTableLeft _"px;top:0px;width:600px;height:"_ (tSideTableTop-1) _"px;z-index:2;")#">>
			Set tSC = ..%Emit(.tTopTable,"top",.tIgnore,tRowSpan,tColSpan)
		&html<</div>>
		
		&html<<div id="#(..%MakeId("nubTable"))#" style="#("overflow:hidden;position:absolute;left:0px;top:0px;height:"_ tSideTableTop _"px;width:"_(tSideTableWidth-1)_";z-index:3;")#">>
			Set tSC = ..%DrawNub(.tNubTable,tRowSpan,tColSpan,tFirstSpan)
		&html<</div>>
]]></Implementation>
</Method>

<Method name="%DrawNub">
<FormalSpec><![CDATA[&pNub,pRowSpan:%String,pColSpan:%String,pFirstSpan:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		
		Set tHTML = "<div "
		Set tHTML = tHTML _ "class=" _ $$$quote(pNub("class"))
		Set tHTML = tHTML _ " style="_ $$$quote("width:"_((..cellWidth*pColSpan)-1)_"px;height:"_((..cellHeight*pRowSpan)-1)_"px;"_$S($G(pNub("style"))'="":pNub("style"),1:""))
		Set tHTML = tHTML _ "title=" _ $$$quote(pNub("title")) 
		Set:$G(pNub("onclick"))'="" tHTML = tHTML _ "onclick=" _ $$$quote(pNub("onclick")) 
		
		Set tHTML = tHTML  _ ">"
		
		Set tCount = 1

		Set tLastCaption = $O(pNub("captions",""),-1)
		// write captions, dump contents, or both
		While (tCount<=tLastCaption) {
			Set tHTML = tHTML _ "<div class=""dsNubInner"" id=""new"_pNub("ids",tCount)_""" style=""width:"_(..cellWidth-1) _ "px;left:"_(..cellWidth*(tCount-1))_"px;"_$select(tCount=tLastCaption:"border-right: 1px solid #D0D0D0;",1:"")_""">"_ $ZCVT(pNub("captions",tCount),"O","HTML") _"</div>"
			Set tCount = $I(tCount)
		}
		If $D(pNub("contents")) {
			Set tHTML = tHTML _ pNub("contents")	
		}
		
		Set tHTML = tHTML  _ "</div>"
		&html<#(tHTML)#>
		
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()	
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Emit">
<FormalSpec><![CDATA[&pTable,pTransform:%String="",&pIgnore="",pRowSpan:%String,pColSpan:%String,pBorderWidth:%String=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Need to handle special cases, like 
		Set tNodeDirection = $S(pTransform="top":-1,1:1)		// DTB829 - Control the direction of element processing based on the table position
		Set tNode = $O(pTable(""),tNodeDirection)
		Set tOuterOffset = tNode-1
		While tNode'="" {
			Set tNode2 = $O(pTable(tNode,""))
			While (tNode2'="") {
				// WAL -- this handles paging offsets. When paging, the side and data table
				//        end up with indices where the position I need is off by (currPage*pages), 
				//        so I remember the offset from the first index (above).
				//        If the first index is 1 (page 1) then applying the index does nothing. Otherwise
				//        it scales the page down to the position I need.
				// Set up iterators
				// only use these for placement; never for references
				// handle paging if exists
				If (pTransform="data") || (pTransform="side") {
					Set tOuter = tNode - tOuterOffset
					Set tInner = tNode2
				}
				ElseIf (pTransform="top") {
					Set tLast = $O(pTable(""),-1)
					Set tOuterOffset = tLast - pRowSpan
					Set tOuter = tNode - tOuterOffset
					Set tInner = tNode2
				}
				Else {
					Set tOuter = tNode
					Set tInner = tNode2
				}

				// Start string
				Set tHTML = "<div"
				
				// Make these available for entire processing of the node
				Set tRowSpan = $G(pTable(tNode,tNode2,"rowspan"),1)
				Set tColSpan = $G(pTable(tNode,tNode2,"colspan"),1)
				
				// main loop -- handle all attributes
				Set tAttr = $O(pTable(tNode,tNode2,""))
				While tAttr '= "" {
					If pTransform'="" {
						// Check and apply -- ignore any attributes specified in the
						
						// adjust style
						If tAttr="style" {
							// add to style
							Set tStyle = pTable(tNode,tNode2,tAttr)
						
							// Since I'm doing inline styles I need to strip the quotes
							// if there are any (conditional formatting might add them,
							// user formatting might add them
							Set tStyle = $Replace(tStyle,"""","")
							
							If pTransform="top" {
								Set tStyle = "position:absolute;" _ tStyle
								Set tStyle = "left:" _ ((tInner-1) * ..cellWidth) _ "px;" _ tStyle 
								Set tStyle = "top:" _ ((pRowSpan-tOuter) * ..cellHeight) _ "px;" _ tStyle
								
								// the -pBorderWidth below preserves the border. I don't know why this is only needed in this case
								Set tStyle = tStyle _ "width:"_((..cellWidth*tColSpan)-pBorderWidth)_"px;"
								Set tStyle = tStyle _ "height:"_(..cellHeight*tRowSpan)_"px;"
							}
							ElseIf pTransform="side" {
								Set tStyle = "position:absolute;" _ tStyle
								Set tStyle = "top:" _ ((tOuter-1) * ..cellHeight) _ "px;" _ tStyle
								Set tStyle = "left:" _ ((pColSpan-tInner) * ..cellWidth) _ "px;" _ tStyle 
								// set width?
								Set tStyle = tStyle _ "width:"_((..cellWidth*tColSpan)-pBorderWidth)_"px;"
								// -pBorderWidth to leave room for border
								Set tStyle = tStyle _ "height:"_((..cellHeight*tRowSpan)-pBorderWidth)_"px;"
							}
							// -pBorderWidth in following styles leaves room for the border
							ElseIf pTransform="data" {
								Set tStyle = "position:absolute;" _ tStyle
								Set tStyle = "top:" _ ((tOuter-1) * ..cellHeight) _ "px;" _ tStyle
								Set tStyle = "left:" _ ((tInner-1) * ..cellWidth) _ "px;" _ tStyle
								Set tStyle = tStyle _ "height:" _ (..cellHeight-pBorderWidth) _ "px;"
								Set tStyle = tStyle _ "width:" _ (..cellWidth-pBorderWidth) _ "px;"
							}
							//Set:tAttr'="contents" tHTML = tHTML _ " " _ tAttr _ "=" _ $$$quote(tStyle)
							Set:tAttr'="contents" tHTML = tHTML _ " " _ tAttr _ "=" _ $$$quote(tStyle)
						}
						// PFS - Add new to beginning so we can reference old table for sizes
						ElseIf tAttr="id" {
							Set tHTML = tHTML _ " " _ tAttr _ "=" _ $$$quote("new"_pTable(tNode,tNode2,tAttr))
						}
						// OR, write out what we find, if it isn't ignored
						ElseIf '$D(pIgnore(tAttr)) {
							Set:tAttr'="contents" tHTML = tHTML _ " " _ tAttr _ "=" _ $$$quote(pTable(tNode,tNode2,tAttr))
						}
					}	
					Else {
						Set:tAttr'="contents" tHTML = tHTML _ " " _ tAttr _ "=" _ $$$quote(pTable(tNode,tNode2,tAttr))
					}
					Set tAttr = $O(pTable(tNode,tNode2,tAttr))
				}
				
				// close div
				Set tHTML = tHTML _ ">"
				
				// contents loop
				// if true we have contents to emit
				If $D(pTable(tNode,tNode2,"contents")) {
					
					// open contents div
					Set tHTML = tHTML _ "<div"
					
					Set tContentsAttr = $O(pTable(tNode,tNode2,"contents",""))
					While tContentsAttr'="" {
						// write out a div containing the contents
						Set:tContentsAttr'="contents" tHTML = tHTML _ " " _ tContentsAttr _ "=" _ $$$quote(pTable(tNode,tNode2,"contents",tContentsAttr))
						Set tContentsAttr = $O(pTable(tNode,tNode2,"contents",tContentsAttr))
					}
					
					// close contents div and write contents
					Set tHTML = tHTML _ ">" _ pTable(tNode,tNode2,"contents","contents") _  "</div>"
				}
				
				// close html
				Set tHTML = tHTML _ "</div>"
				
				// Actually emit the HTML that has been built for this node
				&html<#(tHTML)#>
				
				Set tNode2 = $O(pTable(tNode,tNode2))	
			}	
			Set tNode = $O(pTable(tNode),tNodeDirection)		// DTB829 - Add node processing direction	
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()	
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%MergeTables">
<FormalSpec><![CDATA[&pNubTableHTML:%String,&pTopTableHTML:%String,&pSideTableHTML:%String,&pDataTableHTML:%String,&pNubTableAttributes:%String,&pTopTableAttributes:%String,&pSideTableAttributes:%String,&pDataTableAttributes:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK	
	Try {
		&html<<div class="dsPivotCompleteTableDiv" id="#(..%MakeId("dsPivotCompleteTableDiv"))#">>
		&html<<div id="#(..%MakeId("dsPivotCompleteTable"))#" class="dsPivotCompleteTableDiv">>
		
		// WAL106 -- Merge logic

		&html<<div class="dsPivotCompleteTableDiv" id="#(..%MakeId("dataTableDiv"))#" style="position:absolute;z-index:1;">>
		&html<<table id="#(..%MakeId("dataTable"))#" class="dsPivotCompleteTable">>
		Set tSideDepth = $O(pSideTableHTML(1,""),-1)		// DTB861
		Set tNub=$O(pNubTableHTML("content",""))
		Set tLastNub = $O(pNubTableHTML("content",""),-1)
		If (tLastNub>tSideDepth) {
			// DTB861 - The nub table might have extra entries based on the particular row header content of the current
			// results page. Remove extra nubs to avoid alignment problems with the top headers and the data.
			Set tRemoveCount = tLastNub-tSideDepth
			For tNubKillNo=(tLastNub):-1:(tLastNub-tRemoveCount+1) {
				Kill pNubTableHTML("content",tNubKillNo)
			}
		}
		
		Set tNubRowLast = $O(pTopTableHTML(""),-1)
		Set tSC = ..%CalculateSpans(.pTopTableHTML, .pSideTableHTML, .tNubRowCount, .tNubColSpan)
		Set tNode = $O(pTopTableHTML(""),-1)
		While (tNode'="") {
			// start a new row
			&html<<tr>>
			// write the nub
			If (tNode=tNubRowLast) {
				If ($G(pNubTableHTML("metadata","zebra"))) {
					Set tCls = "dsNubZebra"
				}
				Else {
					Set tCls = "dsNub"
				}
				If ($G(pNubTableHTML("metadata","style"))) {
					Set tStyle = pNubTableHTML("metadata","style")	
				}
				Else {
					Set tStyle = ""
				}
				If ($G(pNubTableHTML("metadata","unselect"))'="") {
					Set tUnselectHelp = pNubTableHTML("metadata","unselect")
				}
				Else {
					Set tUnselectHelp = ""
				}
				
				// This makes the nubtable look good for zebra stuff
				// one nub for the whole column section
				Set tNub=$O(pNubTableHTML("content",""))
				Set tLastNub = $O(pNubTableHTML("content",""),-1)
				
				// Also need to trigger this if we are in a situation where the table isn't ready to be written out yet
				// ..%message '= "" means that we aren't actually drawing the pivot table yet
				// don't want to just create a nub in that case
				// also need to not show the nub when the data table is not complete (we drew the empty table)
				If ((tNub="") || (..%message'="") || ($G(pDataTableHTML("empty"))'="")) {
					
					// + WAL113 -- do we have rows?
					If (tNubColSpan>1) {
						// pad nub table
						&html<<th class="#(tCls)#" colspan="#(tNubColSpan)#" rowspan="#(tNubRowCount)#" style="#(tStyle)#" nowrap="1" id="#(..%MakeId("rcap_1"))#" title="#($ZCVT(tUnselectHelp,"O","HTML"))#" onclick="zenPage.getComponent(#(..index)#).cellClickHandler(event,'','');">>
						// + WAL252
						If (($G(tNub)'="") && ($G(pNubTableHTML("content",tNub,"input"))'="")) {
							&html<#(pNubTableHTML("content",tNub,"input"))#>
						}
						// - WAL252
						&html<</th>>
					}
					Else {
						// empty nub table
						Set:(tNubRowCount<1) tNubRowCount = 1
						&html<<th class="#(tCls)#" rowspan="#(tNubRowCount)#" style="#(tStyle)#" nowrap="1" id="#(..%MakeId("rcap_1"))#" title="#($ZCVT(tUnselectHelp,"O","HTML"))#" onclick="zenPage.getComponent(#(..index)#).cellClickHandler(event,'','');">>
						// + WAL252
						If (($G(tNub)'="") && ($G(pNubTableHTML("content",tNub,"input"))'="")) {
							&html<#(pNubTableHTML("content",tNub,"input"))#>
						}	
						// - WAL252					
						&html<</th>>	
					}
					// - WAL113
				}
				Else {
					While ((tNub '= "")&&(+tNub)) {
						Set tStyle = pNubTableHTML("content",tNub,"style")
						If tStyle=""
						// + WAL114
						// If this isn't the last nub cell, don't give it a right border
						// Condition checks to see if it is the last nub we have AND if we won't need any padding
						If ((tLastNub'=tNub)||(tLastNub<tNubColSpan)) { Set tStyle=tStyle_"border-right:none;" }
						// - WAL114
						&html<<th class="#(tCls)#" rowspan="#(tNubRowCount)#" id="#(..%MakeId("rcap_"_tNub))#" style="#(tStyle)#" title="#($ZCVT(tUnselectHelp,"O","HTML"))#" onclick="zenPage.getComponent(#(..index)#).cellClickHandler(event,'','');" nowrap="1" >>
						If ($D(pNubTableHTML("content",tNub,"captions"))) {
							&html<#(pNubTableHTML("content",tNub,"captions"))#>
						}
						// + WAL252
						If ($G(pNubTableHTML("content",tNub,"input"))'="") {
							&html<#(pNubTableHTML("content",tNub,"input"))#>
						}
						// - WAL252
						&html<</th>>
						
						Set tNub=$O(pNubTableHTML("content",tNub))
					}
					// + WAL114 -- if the nub has fewer captions than cells, just pad with empty cells
					Set tLastNubUsed = tLastNub
					While (tLastNubUsed<tNubColSpan) {
						Set tLastNubUsed = $i(tLastNubUsed)
						If tLastNubUsed=tNubColSpan { Set tStyle = "" }
						&html<<th class="#(tCls)#" rowspan="#(tNubRowCount)#" style="#(tStyle)#" nowrap="1" id="#(..%MakeId("rcap_1"))#" title="#($ZCVT(tUnselectHelp,"O","HTML"))#" onclick="zenPage.getComponent(#(..index)#).cellClickHandler(event,'','');">>
						&html<</th>>
					}
					// - WAL114
				}
			}
			Set tNode2 = $O(pTopTableHTML(tNode,"")) 
			While (tNode2'="") {
				&html<#(pTopTableHTML(tNode,tNode2))#>
				Set tNode2 = $O(pTopTableHTML(tNode,tNode2)) 	
			}
			&html<</tr>>
			Set tNode = $O(pTopTableHTML(tNode),-1)
		}

		Set tNode = $O(pSideTableHTML(""))
		While (tNode'="") {
			&html<#(pSideTableHTML(tNode))#>
			Set tNode2 = $O(pSideTableHTML(tNode,""),-1) 
			While (tNode2'="") {
				&html<#(pSideTableHTML(tNode,tNode2))#>			
				Set tNode2 = $O(pSideTableHTML(tNode,tNode2),-1)	
			}
			
			// then write out the data
			Set tDataNode = $O(pDataTableHTML(tNode,"")) 
			While (tDataNode '="") {
				&html<#(pDataTableHTML(tNode,tDataNode))#>
				Set tDataNode = $O(pDataTableHTML(tNode,tDataNode)) 
			}
			// Write total if exists
			If ($D(pDataTableHTML("ctot",tNode))) {
				&html<#(pDataTableHTML("ctot",tNode))#>	
			}
			
			// Handle row totals
			If (tNode="rowtotal") {
				Set tDataNode = $O(pDataTableHTML("rtot","")) 
				While (tDataNode '="") {
					&html<#(pDataTableHTML("rtot",tDataNode))#>
					Set tDataNode = $O(pDataTableHTML("rtot",tDataNode)) 	
				}
				If ($D(pDataTableHTML("gtot"))) {
					&html<#(pDataTableHTML("gtot"))#>
				}
			}
			
			&html<</tr>>
			Set tNode = $O(pSideTableHTML(tNode))
		}
		&html<</table>>
		&html<</div>> 
		
		If $G(^%DIV,1) {
			Set ..absolutePositioning = 1
			Do ..DivMerge(.pNubTableAttributes, .pTopTableAttributes, .pSideTableAttributes, .pDataTableAttributes, .pNubTableHTML, .pTopTableHTML, .pSideTableHTML, .pDataTableHTML)
		}
		
		&html<</div>> 
		&html<</div>> 
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()	
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%DrawKPITable">
<Description>
Draw table using KPI class as a source.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Set to 100 first in case we error out
		Set ..queryStatus = 100
		Set ..queryComplete = 100
		Set ..queryPending = 0
		
		//Set ..singleTable = 0 // WAL106
		Set ..singleTable = 1 // WAL252

		Set msgKPIError = $$$TextHTML("Error getting data from KPI:","%DeepSee")

		// pull range apart
		Set tRangeRow1 = $P(..selectedRange,",",1)
		Set tRangeCol1 = $P(..selectedRange,",",2)
		Set tRangeRow2 = $P(..selectedRange,",",3)
		Set tRangeCol2 = $P(..selectedRange,",",4)

		#; set up format conditions
		Set tFormatRuleCount = ..formatRules.Count()
		
		// show checkboxes?
		Set tShowCB = (..pivotSelect'="")

		#; set up color scaling
		Set tMinRed = 0
		Set tMaxRed = 255
		Set tMinGreen = 0
		Set tMaxGreen = 255
		Set tMinBlue = 0
		Set tMaxBlue = 255
		Set tRedScale = 0
		Set tBlueScale = 0
		Set tGreenScale = 0
		If (..colorScale = "red-to-black") {
			Set tRedScale = 1
		}
		ElseIf (..colorScale = "green-to-black") {
			Set tGreenScale = 1
		}
		ElseIf (..colorScale = "blue-to-black") {
			Set tBlueScale = 1
		}
		ElseIf (..colorScale = "salmon-to-black") {
			Set tRedScale = 1
			Set tGreenScale = 0.65
			Set tBlueScale = 0.45
		}
		ElseIf (..colorScale = "purple-to-black") {
			Set tBlueScale = 1
			Set tRedScale = 1
		}
		ElseIf (..colorScale = "gray-to-black") {
			Set tRedScale = 0.75
			Set tBlueScale = 0.75
			Set tGreenScale = 0.75
		}
		ElseIf ($P(..colorScale,":",1) = "custom") {
			// JMD1063: custom:r1,g1,b1:r2,g2,b2
			Set tRGB1 = $P(..colorScale,":",2)
			Set tRGB2 = $P(..colorScale,":",3)
			Set r1 = +$P(tRGB1,",",1)
			Set g1 = +$P(tRGB1,",",2)
			Set b1 = +$P(tRGB1,",",3)
			Set r2 = +$P(tRGB2,",",1)
			Set g2 = +$P(tRGB2,",",2)
			Set b2 = +$P(tRGB2,",",3)
			Set r1=$S(r1<0:0,r1>255:255,1:r1)
			Set g1=$S(g1<0:0,g1>255:255,1:g1)
			Set b1=$S(b1<0:0,b1>255:255,1:b1)
			Set r2=$S(r2<0:0,r2>255:255,1:r2)
			Set g2=$S(g2<0:0,g2>255:255,1:g2)
			Set b2=$S(b2<0:0,b2>255:255,1:b2)
			Set tMinRed = r1,tMaxRed=r2,tRedScale = (r2-r1)/255
			Set tMinGreen = g1,tMaxGreen=g2,tGreenScale = (g2-g1)/255
			Set tMinBlue = b1,tMaxBlue=b2,tBlueScale = (b2-b1)/255
		}

		#; if we support drag & drop we need additional mouse event handling
		Set dnd = %page.dragAndDrop
		Set tZenPage = %page

		// use a dataController to drive the KPI
		New %datacontroller
		New %page		// prevent temp components from being added to page!

		Set tController = ##class(%ZEN.Auxiliary.dataController).%New()
		Set %datacontroller = tController
		Set ..%KPIController = tController
		Set tController.modelClass = ..kpi
		Set tController.modelId = ..dataSourceName

		Set tController.criteria = ##class(%ZEN.proxyObject).%New()
		Set tCriteria = tController.criteria

		// apply filter values
		For n = 1:1:..filters.Count() {
			Set tFilter = ..filters.GetAt(n)
			Set tFilterName = tFilter.spec
			If ((tFilterName'="")&&(tFilter.enabled'=0)) {
				Set tValue = tFilter.value
				Set $zobjproperty(tCriteria,tFilterName) = tValue
				Set:tValue'="" tFilterValues(tFilterName) = tValue
			}
		}

		&html<<div class="dsPivotTableWrapper">>

		#; scroll bars (initially hidden)
		&html<<div class="dsptVtScroll" style="display:none;" id="#(..%MakeId("vtScroll"))#" onscroll="zenPage.getComponent(#(..index)#).cellScrollVt();"><div class="dsptVtScrollInner" id="#(..%MakeId("vtScrollInner"))#">&nbsp;</div></div>>
		&html<<div class="dsptHzScroll" style="display:none;" id="#(..%MakeId("hzScroll"))#" onscroll="zenPage.getComponent(#(..index)#).cellScrollHz();"><div class="dsptHzScrollInner" id="#(..%MakeId("hzScrollInner"))#">&nbsp;</div></div>>

		If (..isDrillThrough) {
			// check for listing
			Set tListingName = ""
			Kill tSelection
			Set tSelection("rowValues") = ..selectedRowValues
			Set tSelection("selectedRange") = ..selectedRange
			Set tSelection("sortColumn") = ..listingSortColumn
			Set tSelection("sortDir") = ..listingSortDir
			
			Set tSC = $zobjclassmethod(..kpi,"%GetListingResultSet",.tFilterValues,.tSelection,tListingName,.tSQLRS)
			If $$$ISERR(tSC) Quit

			If $IsObject(tSQLRS) {
				// JMD1331
				Set tSC = ..%MaterializeListing("",tSQLRS)
				If $$$ISERR(tSC) Quit
				
				//Set tSC = ..%DrawListing("",tSQLRS)
				Set tSC = ..%DrawListing()
				If $$$ISERR(tSC) Quit
				Quit
			}
			// pass through for now
		}

		// aquire data from KPI
		Set tSC = tController.%AcquireData()
		// WAL252 -- if we get an error, don't worry about Merge tables since we don't have a table to deal with

		If $$$ISERR(tSC) {
			//Set tMsg = $$$TextHTML("KPI is abstract or has invalid data model","%DeepSee")
			Set tErr = $ZCVT($System.Status.GetErrorText(tSC),"O","HTML")
			&html<<div style="padding:5px;">#(msgKPIError)#</div>>
			&html<<div style="padding:5px;color:darkred;">#(tErr)#</div>>
			Set tSC = $$$OK
			Quit
		}

		If (tController.modelError'="") {
			&html<<div style="padding:5px;">#(msgKPIError)#</div>>
			&html<<div style="padding:5px;color:darkred;">#($ZCVT(tController.modelError,"O","HTML"))#</div>>
			Quit
		}

		Set tModel = tController.%model
		If ('$IsObject(tModel)) {
			Set tMsg = $$$TextHTML("KPI has no data model","%DeepSee")
			&html<<div style="padding:5px;">#(msgKPIError)#</div>>
			&html<<div style="padding:5px;color:darkred;">#(tMsg)#</div>>
			Quit
		}

		// JMD900-test for async KPI
		If (tModel.%IsCacheable()) {
			// take a peek at the cache
			Set ..queryStatus = 100
			Set ..queryComplete = 100
			Set tClass = $$$UPPER(tModel.%ClassName(1))
			Set tCacheKey = tModel.%cacheKey
			If ((tClass'="")&&(tCacheKey'="")) {
				Set tKPISC = $G($$$DeepSeeKPIGLVN(tClass,tCacheKey,"error"),$$$OK)
				If $$$ISERR(tKPISC) {
					Set tKPIError = $System.Status.GetErrorText(tKPISC)
					&html<<div style="padding:5px;">#(msgKPIError)#</div>>
					&html<<div style="padding:5px;color:darkred;">#($ZCVT(tKPIError,"O","HTML"))#</div>>
					Quit
				}
				Set tPctComplete = $G($$$DeepSeeKPIGLVN(tClass,tCacheKey,"pctComplete"),100)
				If (tPctComplete<=100) {
					Set ..queryStatus = tPctComplete
					Set ..queryComplete = tPctComplete
					Set ..queryKey = tCacheKey
				}
			}
		}

		Set tCellWidth = ..cellWidth
		Set tCellHeight = ..cellHeight
		Set tRowTotals = 0
		Set tStyle = ""
		Set tRowCount = 0

		If (..%message '= "") {
			// 1 cell, displaying message
			Set tRowCount = 1
			Set tColCount = 1
			Set tCellWidth = 500 // make sure there is room
		}
		Else {
			#; compute size/shape of columns & rows
			Set tRowCount = tController.dataBag.seriesCount
			Set tColCount = 0

			Set tSC = ..%GetKPIColumns(tController,.tColCount,.tColProps,..columnList)
			If $$$ISERR(tSC) Quit

			Set tRowCount = $S(tRowCount>=0:tRowCount,1:1)
			Set tColCount = $S(tColCount>0:tColCount,1:1)
			Set ..rowCount = tRowCount
		}

		#; message box
		&html<<div id="#(..%MakeId("message"))#" class="dsPivotMessage" style="display: none;">&nbsp;</div>>

		#; Use divs to layout 4 tables
		#; (plus status area on the bottom)
		&html<<div class="dsptOuterDiv" id="#(..%MakeId("outerDiv"))#">>
		
		Set tUnselectHelp = $$$TextHTML("Click here to unselect cells")

		// force load of images used by message box
		&html<
			<div style="display:none;">
			<img src="deepsee/cancel_24.png"/>
			<img src="deepsee/insert_table_64.png"/>
			<img src="deepsee/insert_table_fav_64.png"/>
			<img src="deepsee/insert_table_clock_64.png"/>
			</div>
		>

		Set tTLStyle = ..columnHeaderStyle
		// JMD1377
		// turn off border if there is a header style
		// (with ie hacks!)
		If ((tTLStyle'="")&&(..showZebra)) {
			If ($$$ZENISIE) {
				Set tTLStyle = tTLStyle _ "border: none; border-bottom: none;border-right: none;"
			}
			Else {
				Set tTLStyle = tTLStyle _ "border-bottom: 1px solid transparent;border-right: 1px solid transparent;"
			}
		}
		// WAL252n -- topLeftDiv
		If tShowCB {	// DTB101
			//&html<<div class="dsptTopLeftDiv#($S(..showZebra:"Zebra",1:""))#" style="#(tTLStyle)#text-align:left;" id="#(..%MakeId("topLeftDiv"))#" title="#($ZCVT(tUnselectHelp,"O","HTML"))#">>
		}
		Else {
			//&html<<div class="dsptTopLeftDiv#($S(..showZebra:"Zebra",1:""))#" style="#(tTLStyle)#text-align:left;" id="#(..%MakeId("topLeftDiv"))#" title="#($ZCVT(tUnselectHelp,"O","HTML"))#" onclick="zenPage.getComponent(#(..index)#).cellClickHandler(event,'','');">>
		}
		
		// WAL
		Set tTitle = tUnselectHelp

		#; nub
		If (..pivotSelect = "multi") {
			Set hlpAll = $$$Text("Select or unselect all items","%DeepSee")
			Set tTitle = hlpAll // WAL
			//&html<<input style="margin-left:6px;" type="checkbox" id="#(..%MakeId("cb_all"))#" title="#(hlpAll)#" onclick="zenPage.getComponent(#(..index)#).allClickPivot(event);"/>>
			// WAL252
			Set tNubTableHTML("content",1,"input") = "<input style=""margin-left:6px;"" type=""checkbox"" id="""_..%MakeId("cb_all")_""" title="""_hlpAll_""" onclick=""zenPage.getComponent("_..index_").allClickPivot(event);""/>"
			
			// WAL -- grab content
			Set tNubTableAttributes("contents") = "<input style=""margin-left:6px;"" type=""checkbox"" id="""_..%MakeId("cb_all")_""" title="""_hlpAll_""" onclick=""zenPage.getComponent("_..index_").allClickPivot(event);""/>"
		}
		//&html<</div>>
		
		
		// WAL252 -- nub table
		Set tNubTableHTML("content",1,"style")=""
		Set tNubTableHTML("metadata","style")=""
		Set tNubTableHTML("metadata","unselect")="Click here to unselect cells"
		Set tNubTableHTML("metadata","zebra")=$S(..showZebra:1,1:0)
		
		// WAL -- KPI nub (has no captions)
		Set tNubTableAttributes("onclick") = "zenPage.getComponent("_..index_").allClickPivot(event);"
		Set tNubTableAttributes("class") = $S(..showZebra:"dsNubZebra",1:"dsNub")
		Set tNubTableAttributes("style") = tTLStyle
		Set tNubTableAttributes("title") = tTitle
	
		#; top table: column headers
		
		#; column headers
		Set tColSpan = 0

		For c = 1:1:tColCount {
			Set tStyle = ..columnHeaderStyle
			Set tDivStyle = ""

			// JMD921
			If ($G(tColProps(c,"headerStyle"))'="") {
				Set tStyle = tStyle _ tColProps(c,"headerStyle")
			}

			Set tDStyle = tStyle // WAL
			Set:tStyle'="" tStyle = "style="_$$$quote(tStyle)
			Set tDIStyle = tDivStyle // WAL
			Set:tDivStyle'="" tDivStyle = "style="_$$$quote(tDivStyle)

			Set tName = $S($D(tColProps(c,"caption")):tColProps(c,"caption"),1:$G(tColProps(c)))
			// JMD1377
			If (..showZebra) {
				Set tCls = $S((..sortColumn=c):"dsPivotColumnSortZebra",1:"dsPivotColumnZebra")
			}
			Else {
				Set tCls = $S((..sortColumn=c):"dsPivotColumnSort",1:"dsPivotColumn")
			}
			Set tSortChar = $S(..sortColumn=c:$S(..sortDir="DESC":"&#x25BC;",1:"&#x25B2;"),1:"")

			Set id = ..%MakeId("col_1:"_c)
			If tShowCB {	// DTB101
				Set tTopTableHTML(1,c) = "<th nowrap=""1"" id="""_id_""" class="""_tCls_""" "_tStyle_" title="""_$ZCVT(tName,"O","HTML")_"""><div class=""dsPivotColumnOuter""><div class=""dsPivotColumnDiv"" ondblclick=""zenPage.getComponent("_..index_").columnDblClickHandler(event,"_c_");"" "_tDivStyle_">"_$ZCVT(tName,"O","HTML")_" "_tSortChar_"</div></div></th>" // WAL252t
				//Set tContents = ""
				
				Set tTopTableAttributes(1,c,"contents","class") = "dsPivotColumnDiv"
				Set tTopTableAttributes(1,c,"contents","contents") = $ZCVT(tName,"O","HTML")_" "_tSortChar
				Set tTopTableAttributes(1,c,"contents","ondblclick") = "zenPage.getComponent("_..index_").columnDblClickHandler(event,"_c_");"
				Set tTopTableAttributes(1,c,"contents","style") = tDIStyle
			}
			Else {
				Set tTopTableHTML(1,c) = "<th nowrap=""1"" id="""_id_""" class="""_tCls_""" "_tStyle_" title="""_$ZCVT(tName,"O","HTML")_"""><div class=""dsPivotColumnOuter""><div class=""dsPivotColumnDiv"" onclick=""zenPage.getComponent("_..index_").columnClickHandler(event,"_c_");"" ondblclick=""zenPage.getComponent("_..index_").columnDblClickHandler(event,"_c_");"" "_tDivStyle_">"_$ZCVT(tName,"O","HTML")_" "_tSortChar_"</div></div></th>" // WAL252t
			
				Set tTopTableAttributes(1,c,"contents","class") = "dsPivotColumnDiv"
				Set tTopTableAttributes(1,c,"contents","contents") = $ZCVT(tName,"O","HTML")_" "_tSortChar
				Set tTopTableAttributes(1,c,"contents","onclick") = "zenPage.getComponent("_..index_").columnClickHandler(event,"_c_");"
				Set tTopTableAttributes(1,c,"contents","ondblclick") = "zenPage.getComponent("_..index_").columnDblClickHandler(event,"_c_");"
				Set tTopTableAttributes(1,c,"contents","style") = tDIStyle
			}
			
			// WAL -- KPI top table
			Set tTopTableAttributes(1,c,"id") = id
			Set tTopTableAttributes(1,c,"class") = tCls
			Set tTopTableAttributes(1,c,"style") = tDStyle
			Set tTopTableAttributes(1,c,"title") = $ZCVT(tName,"O","HTML")
		}

		#; if sorting is enabled, build sort index here
		Set tUseSort = 0
		If ((tRowCount > 1)&&(..sortColumn>0)) {
			Kill ^||ds.sort
			Kill ^||ds.rowsort
			For r=1:1:tRowCount {
				Set tProp = $G(tColProps(..sortColumn))
				If (tProp'="") {
					Set tValue = tController.dataBag.%GetValue(tProp,r)
					Set:tValue=$$$ZENMISSING tValue = 1E-14
					Set:tValue="" tValue=1E-14
					Set ^||ds.sort(tValue,r) = ""
				}
			}

			Set tDir = $S(..sortDir="DESC":-1,1:1)
			Set n = 0
			Set k = $O(^||ds.sort(""),tDir)
			While (k'="") {
				Set r = $O(^||ds.sort(k,""),tDir)
				While (r'="") {
					Set ^||ds.rowsort($I(n)) = r
					Set r = $O(^||ds.sort(k,r),tDir)
				}
				Set k = $O(^||ds.sort(k),tDir)
			}
			Set tUseSort = 1
		}

		#; side table: row labels
		//&html<<<div class="dsptBottomLeftDiv" id="#(..%MakeId("bottomLeftDiv"))#">>
		//&html<<<table id="#(..%MakeId("leftTable"))#" class="dsPivotTable" cellspacing="0"  >>

		#; row headers
		For tRowIndex = 1:1:tRowCount {
			If (tUseSort) {
				Set tRow = $G(^||ds.rowsort(tRowIndex))
			}
			Else {
				Set tRow = tRowIndex
			}
			// JMD1377
			Set tRowClass = $S(..showZebra:$S((tRowIndex#2):"dsPivotRowOdd",1:"dsPivotRowEven"),1:"dsPivotRow")
			Set tStyle = ..rowHeaderStyle
			If (..showZebra && (..rowHeaderStyle'="")) {
				Set tStyle = tStyle _ $S((tRowIndex#2):"background:white;",1:"")
			}

			Set tDStyle = tStyle // WAL
			Set:tStyle'="" tStyle = "style="_$$$quote(tStyle)

			Set tName = $G(tModel.%seriesNames(tRow))

			// +DTB450 - Look for a valueColumn when setting the rowValue
			Set tRowValue = ""
			If (..valueColumn'="") {
				Set tRowValue = tController.dataBag.%GetValue(..valueColumn,tRow)
			}
			Else {
				// use first column
				Set tProp = $G(tColProps(1))
				Set tRowValue = tController.dataBag.%GetValue(tProp,tRow)
			}
			Set:tRowValue=$$$ZENMISSING tRowValue = ""
			// -DTB450

			// JMD1468 use row index
			Set trID = ..%MakeId("tr_"_tRowIndex)
			Set tSideTableHTML(tRowIndex) = "<tr id="""_trID_""" value="""_$ZCVT(tRowValue,"O","HTML")_""">" // WAL252	// DTB450 - Add value to the row
			
			Set id = ..%MakeId("row_"_1_":"_tRowIndex)
			Set tSideTableHTMLString = ""
			If tShowCB {	// DTB101
				Set tSideTableHTMLString = tSideTableHTMLString_"<th id="""_id_""" class="""_tRowClass_""" "_tStyle_" rowspan=""1"" colspan=""1""><div class=""dsPivotRowDiv"">" // WAL252
				Set tSideTableHTMLString = tSideTableHTMLString_"<input type=""checkbox"" id="""_..%MakeId("cb_"_tRowIndex)_""" onclick=""zenPage.getComponent("_..index_").cbClickPivot(event,this);""/>" // WAL252s
		
				// WAL
				Set tSideTableAttributes(tRowIndex,1,"id") = id
				Set tSideTableAttributes(tRowIndex,1,"class") = tRowClass
				Set tSideTableAttributes(tRowIndex,1,"style") = tDStyle
				Set tSideTableAttributes(tRowIndex,1,"contents","class") = "dsPivotRowDiv"
				Set tSideTableAttributes(tRowIndex,1,"contents","contents") = "<input type=""checkbox"" id="""_..%MakeId("cb_"_tRowIndex)_""" onclick=""zenPage.getComponent("_..index_").cbClickPivot(event,this);""/>&nbsp;"_tName
			}
			Else {
				Set tSideTableHTMLString = tSideTableHTMLString_"<th id="""_id_""" class="""_tRowClass_""" nowrap=""1"" "_tStyle_" rowspan=""1"" colSpan=""1"" title="""_$ZCVT(tName,"O","HTML")_"""><div class=""dsPivotRowDiv"" onclick=""zenPage.getComponent("_..index_").rowClickHandler(event,"_tRowIndex_");"">" // WAL252s
			
				// WAL
				Set tSideTableAttributes(tRowIndex,1,"id") = id
				Set tSideTableAttributes(tRowIndex,1,"class") = tRowClass
				Set tSideTableAttributes(tRowIndex,1,"style") = tDStyle
				Set tSideTableAttributes(tRowIndex,1,"title") = $ZCVT(tName,"O","HTML")
				Set tSideTableAttributes(tRowIndex,1,"contents","class") = "dsPivotRowDiv"
				Set tSideTableAttributes(tRowIndex,1,"contents","onclick") = "zenPage.getComponent("_..index_").rowClickHandler(event,"_tRowIndex_");"
				Set tSideTableAttributes(tRowIndex,1,"contents","contents") = "&nbsp;"_tName
			}
			Set tSideTableHTML(tRowIndex,1) = tSideTableHTMLString_"&nbsp;"_tName_"</div></th>" // WAL252s
		}
		
		// total
		If (tRowTotals) {
			Set msgTotal = $$$Text("Total","%DeepSee")
			Set tRowClass = $S(..showZebra:"dsPivotRowOdd",1:"dsPivotRow")
			
			// WAL -- is this ok?
			Set tRowLevels = 1
			
			// WAL252 -- totals
			Set tSideTableHTML(10000000,1) = "<th colspan="""_tRowLevels_""" class="""_tRowClass_""">&nbsp;"_msgTotal_"</th>" // WAL252s
			
			Set tSideTableAttributes(tRowCount+1,1,"style") = tRowClass 
			Set tSideTableAttributes(tRowCount+1,1,"contents","contents") = msgTotal 
			Set tSideTableAttributes(tRowCount+1,1,"contents","class") = "dsPivotRowDiv"
		}
		
		// WAL -- KPI row totals

		#; cell table
		Set tCellRowCount = tRowCount

		For tRowIndex = 1:1:tRowCount {
			If (tUseSort) {
				Set tRow = $G(^||ds.rowsort(tRowIndex))
			}
			Else {
				Set tRow = tRowIndex
			}
			Set tRowFormat = ""
			Set tRange = 0
			Set tMinValue = 0

			// JMD1377 apply zebra stripes
			If (..showZebra) {
				Set tZebraClass = $S('(tRowIndex#2):"dsptRowEven",1:"dsptRowOdd")
				If (..cellStyle'="") {
					Set tZebraStyle = $S('(tRowIndex#2):..evenRowStyle,1:"background:white;")
				}
				Else {
					Set tZebraStyle = $S('(tRowIndex#2):..evenRowStyle,1:"background:none;")
				}
			}
			Else {
				Set tZebraClass = ""
				Set tZebraStyle = ""
			}

			// JMD1468 use rowIndex
			//Set tDataTableHTML($i(tDataTableHTML)) = "<tr id="""_..%MakeId("dtr_"_tRowIndex)_""" class="""_tZebraClass_""" value="""_$ZCVT(tRowValue,"O","HTML")_""">" 
			// data cells
			For c=1:1:tColCount {
				Set tProp = $G(tColProps(c))
				If (tProp'="") {
					Set tIcon = ""
					Set tIconCount = 1
					Set tStyle = ..cellStyle
					Set tValue = tController.dataBag.%GetValue(tProp,tRow)
					Set:tValue=$$$ZENMISSING tValue = ""

					// JMD1377
					Set tStyle = tStyle _ tZebraStyle

					Set tCls = "dsPivotNum"
					If (tCellWidth'="") {
						//JMD1465 Set tStyle = tStyle _ "width:"_(tCellWidth)_"px;"
						// WAL261 -- undo JMD1465 and uncomment this line so width can be manipulated
						Set tStyle = tStyle _ "width:"_(tCellWidth)_"px;"
					}
					If (tCellHeight'="") {
						Set tStyle = tStyle _ "height:"_(tCellHeight)_"px;"
					}

					// JMD921
					If ($G(tColProps(c,"style"))'="") {
						Set tStyle = tStyle _ tColProps(c,"style")
					}
					If ($G(tColProps(c,"format"))'="") {
						Set tFormat = tColProps(c,"format")
					}
					ElseIf (tRowFormat'="") {
						Set tFormat = tRowFormat
					}
					Else {
						Set tFormat = ""
					}

					// format cell
					Set tDisplay = ##class(%DeepSee.ResultSet).%FormatNumber(tValue,tFormat,.tType,.tFormatStyle)
					Set tCls = $Case(tType,"integer":"dsPivotNum",
											"date":"dsPivotDate",
											"number":"dsPivotNum",
											:"dsPivotString")
						
					// + WAL260 -- account for zebra styling
					If (..showZebra) {
						Set tZebraClass = $S('(tRowIndex#2):"dsptRowEven",1:"dsptRowOdd")
						If (..cellStyle'="") {
							Set tZebraStyle = $S('(tRowIndex#2):..evenRowStyle,1:"background:white;")
						}
						Else {
							Set tZebraStyle = $S('(tRowIndex#2):..evenRowStyle,1:"background:white;")
						}
					}
					Else {
						Set tZebraClass = ""
						Set tZebraStyle = ""
					}				
					If (tZebraClass'="") {
						//Set tCls = tZebraClass	
						If (tZebraClass [ "Odd") { Set tCls = tCls_" dsPivotRowOdd" }
						Else { Set tCls = tCls_" dsPivotRowEven" }
					}
					Set tStyle = tStyle _ tZebraStyle
					// - WAL260
											
					// 3rd piece of format is cell style (undocumented)
					If ($P(tFormat,"^",3)'="") {
						Set tStyle = tStyle_$P(tFormat,"^",3)
					}
					// color scaling
					If ($IsValidNum(tValue)&&(tRange>0)&&(..colorScale'="")) {
						// special case for pct values
						If (tFormat["%") {
							Set tPct = $S(tValue<0:0,tValue>1:1,1:tValue)
						}
						Else {
							Set tPct = (tValue-tMinValue/tRange)
						}
						Set cvr = $S(tMinRed<tMaxRed:(tMinRed + (tRedScale * tPct * tMaxRed)\1),1:(tMaxRed + (-tRedScale * (1-tPct) * tMinRed)\1))
						Set cvg = $S(tMinGreen<tMaxGreen:(tMinGreen + (tGreenScale * tPct * tMaxGreen)\1),1:(tMaxGreen + (-tGreenScale * (1-tPct) * tMinGreen)\1))
						Set cvb = $S(tMinBlue<tMaxBlue:(tMinBlue + (tBlueScale * tPct * tMaxBlue)\1),1:(tMaxBlue + (-tBlueScale * (1-tPct) * tMinBlue)\1))
						Set tBright = (cvr*cvr*0.241)+(cvg*cvg*0.691)+(cvb*cvb*0.068)
						Set tFG = $S(tBright>16900:"black",1:"white")
						Set tStyle = tStyle_"background:rgb("_cvr_","_cvg_","_cvb_");color:"_tFG_";"
					}

					// conditional format
					For n = 1:1:tFormatRuleCount {
						Set tCondition = ..formatRules.GetAt(n)
						If (tCondition.%EvaluateCondition(tRow,c,tValue)) {
							Set tStyle = tStyle _ tCondition.style
							Set:tCondition.text'="" tDisplay = tCondition.text
							Set:tCondition.icon'="" tIcon = tCondition.icon
							Set:tCondition.iconCount'="" tIconCount = tCondition.iconCount
							If (($E(tIcon)="@")&&(tIcon'="@")) {
								// user icon: resolve
								Set ik = $E(tIcon,2,$L(tIcon))
								If $D(tLocalIconList(ik)) {
									Set tIcon = tLocalIconList(ik)
								}
								Else {
									Set tIcon = ##class(%DeepSee.UserPortal.Utils).%GetUserIcon(ik)
									Set tLocalIconList(ik) = tIcon
								}
							}
						}
					}
					If (tFormatStyle'="") {
						Set tStyle = tStyle _ "color:"_tFormatStyle_";"
					}

					If (tIcon'="") {
						Set tDisplay = ""
						For ic = 1:1:tIconCount {
							Set tDisplay = tDisplay _ "<image alt=""*"" style=""padding-right:2px;"" height="""_(tCellHeight-4)_""" src="""_tIcon_"""/>"
						}
						Set tCls = "dsPivotIcon"
					}
					ElseIf ($E(tDisplay,*)'=")") { // align negative numbers
						Set tDisplay = tDisplay _ "&nbsp;"
					}

					// apply align to inner div
					Set tDivStyle = ""
					Set tTestStyle = $TR(tStyle," ","")
					If ((tCls'="dsPivotNum")||(tTestStyle["text-align:left;")) {
						Set tDivStyle = "text-align:left;"
					}
					If (tTestStyle["text-align:center;") {
						Set tDivStyle = "text-align:center;"
					}
					ElseIf (tTestStyle["text-align:right;") {
						Set tDivStyle = "text-align:right;"
					}

					Set tDStyle = tStyle // WAL
					Set:tStyle'="" tStyle = "style="_$$$quote(tStyle)
					Set tIStyle = ""
					Set tDIStyle = tDivStyle // WAL
					Set:tDivStyle'="" tIStyle = "style="_$$$quote(tDivStyle)
					Set id = ..%MakeId("cell_"_tRowIndex_"_"_c)
					If tShowCB {	// DTB101 - do not allow cell selection if check boxes are being used
						// WAL252d
						Set tDataTableHTML(tRowIndex,c) = "<td class="""_tCls_""" "_tStyle_" id="""_id_"""><div class=""dsptCellDiv"" "_tIStyle_">&nbsp;"_tDisplay_"</div></td>"
						
						//WAL
						Set tDataTableAttributes(tRowIndex,c,"id") = id
						Set tDataTableAttributes(tRowIndex,c,"class") = tCls 
						Set tDataTableAttributes(tRowIndex,c,"style") = tDStyle
						Set tDataTableAttributes(tRowIndex,c,"contents","class") = "dsptCellDiv"
						Set tDataTableAttributes(tRowIndex,c,"contents","style") = tDIStyle
						Set tDataTableAttributes(tRowIndex,c,"contents","contents") = "&nbsp;"_tDisplay
					}
					Else {
						// WAL252d
						Set tDataTableHTML(tRowIndex,c) = "<td class="""_tCls_""" "_tStyle_" id="""_id_""" onmousedown=""return zenPage.getComponent("_..index_").cellMouseDownHandler(event);"" onclick=""zenPage.getComponent("_..index_").cellClickHandler(event,"_tRowIndex_","_c_");"" ondblclick=""zenPage.getComponent("_..index_").cellDblClickHandler(event,"_tRowIndex_","_c_");"" zenValue="""_tValue_""" title="""_$ZCVT(tValue,"O","HTML")_"""><div class=""dsptCellDiv"" "_tIStyle_">&nbsp;"_tDisplay_"</div></td>"
					
						// WAL
						Set tDataTableAttributes(tRowIndex,c,"id") = id
						Set tDataTableAttributes(tRowIndex,c,"class") = tCls 
						Set tDataTableAttributes(tRowIndex,c,"style") = tDStyle
						Set tDataTableAttributes(tRowIndex,c,"onmousedown") = "return zenPage.getComponent("_..index_").cellMouseDownHandler(event);"
						Set tDataTableAttributes(tRowIndex,c,"onclick") =  "zenPage.getComponent("_..index_").cellClickHandler(event,"_tRowIndex_","_c_");"
						Set tDataTableAttributes(tRowIndex,c,"ondblclick")="zenPage.getComponent("_..index_").cellDblClickHandler(event,"_tRowIndex_","_c_");"
						Set tDataTableAttributes(tRowIndex,c,"zenValue") = tValue
						Set tDataTableAttributes(tRowIndex,c,"title") = $ZCVT(tValue,"O","HTML")
						Set tDataTableAttributes(tRowIndex,c,"contents","class") = "dsptCellDiv"
						Set tDataTableAttributes(tRowIndex,c,"contents","style") = tDIStyle
						Set tDataTableAttributes(tRowIndex,c,"contents","contents") = "&nbsp;"_tDisplay
					}
				}
				Set tProp = $O(tInfo(tProp))
			}
		}
		If $$$ISERR(tSC) Quit

		// WAL252 -- merge
		Set tSC = ..%MergeTables(.tNubTableHTML,.tTopTableHTML,.tSideTableHTML,.tDataTableHTML, .tNubTableAttributes, .tTopTableAttributes, .tSideTableAttributes, .tDataTableAttributes)
		If $$$ISERR(tSC) Quit

		// JMD1462
		If (tZenPage.cssLevel>=3) {
			Set tBackgroundOpacity = ..backgroundOpacity
			Set tBackgroundImage = ..backgroundImage
			If (+..analyzerMode) {
				Set tBackgroundOpacity = 0.12
				Set tBackgroundImage = "deepsee/pivottable.jpg"
			}
			If ((tBackgroundOpacity>0)&&(tBackgroundImage'="")) {
				&html<<div class="dsPivotTableImage" style="background-image:url(#(tBackgroundImage)#);opacity:#(+tBackgroundOpacity)#;"></div>>
			}
		}

		&html<</div>> // outer

		Set ..columnCount = tColCount
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetKPIColumns">
<Description><![CDATA[
Return information on the set of columns to display for the current KPI.
Returns:<br/>
pColInfo(n) = property<br/>
pColInfo(n,"caption") = caption (if different)<br/>
This is a class method that is also called from Excel and PDF export.<br/>
If <var>pColumnList</var> is provided, it is a csv-list that specifies the columns 
and column order from the KPI to display. Otherwise all columns are displayed in the order
defined by the KPI.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pController:%ZEN.Auxiliary.dataController,*pColCount:%Integer,*pColInfo,pColumnList:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pColCount = 0
		Set tModel = pController.%model

		// +DTB457 - Check for a single hidden column
		Set tHideColumn = ""
		If ($E(pColumnList)="!") {
			Set tHideColumn = $E(pColumnList,2,*)
			Set pColumnList = ""
		}
		// -DTB457

		If (pColumnList'="") {
			// get captions from KPI
			If ($IsObject(tModel) && (tModel.%IsA("%DeepSee.KPI"))) {
				// KPIs have more information
				Set tSC = tModel.%GetKPIPropertyInfo(.tInfo)
				If $$$ISERR(tSC) Quit

				Set n = $O(tInfo(""))
				While (n'="") {
					Set tSeqNo = $G(tInfo(n,"columnNo"),99999)
					Set tName = $G(tInfo(n))
					Set tCaption = $G(tInfo(n,"caption"))
					Set tIndex(tName) = tCaption
					Set tFormats(tName) = $G(tInfo(n,"format"))
					Set tStyles(tName) = $G(tInfo(n,"style"))
					Set tHeaderStyles(tName) = $G(tInfo(n,"headerStyle"))
					Set n = $O(tInfo(n))
				}
			}

			// pull columns out of list
			// handle escaped characters
			Set tColList = pColumnList
			Set tColList = $Replace(tColList,"\,",$C(1))
			Set tColList = $Replace(tColList,"\:",$C(2))

			For p=1:1:$L(tColList,",") {
				Set pColCount = pColCount + 1
				Set tItem = $ZSTRIP($P(tColList,",",p),"<>W")
				Set tName = $$UNESC($P(tItem,":",1))
				If (tName'="") {
					Set tCaption = $$UNESC($P(tItem,":",2))
					Set tFormat = $$UNESC($P(tItem,":",3))
					Set:tFormat="" tFormat = $G(tFormats(tName))
					Set tStyle = $G(tStyles(tName))
					Set tHeaderStyle = $G(tHeaderStyles(tName))

					Set pColInfo(pColCount) = tName
					If ($G(tIndex(tName))'="") {
						Set pColInfo(pColCount,"caption") = tIndex(tName)
					}
					If ((tCaption'="")&&(tCaption'="$auto")) {
						// local override
						Set pColInfo(pColCount,"caption") = tCaption
					}
					If (tFormat'="") {
						// local override
						Set pColInfo(pColCount,"format") = tFormat
					}
					If (tStyle'="") {
						Set pColInfo(pColCount,"style") = tStyle
					}
					If (tHeaderStyle'="") {
						Set pColInfo(pColCount,"headerStyle") = tHeaderStyle
					}
				}
			}
			Quit
		}

		// get info from controller
		If ($IsObject(tModel) && (tModel.%IsA("%DeepSee.KPI"))) {
			// KPIs have more information
			Set tSC = tModel.%GetKPIPropertyInfo(.tInfo)
			If $$$ISERR(tSC) Quit

			Set n = $O(tInfo(""))
			While (n'="") {
				Set tSeqNo = $G(tInfo(n,"columnNo"),99999)
				Set tCaption = $G(tInfo(n,"caption"))
				// JMD921
				Set tFormat = $G(tInfo(n,"format"))
				Set tStyle = $G(tInfo(n,"style"))
				Set tHeaderStyle = $G(tInfo(n,"headerStyle"))
				Set tList(tSeqNo,n) = $LB(tInfo(n),tCaption,tFormat,tStyle,tHeaderStyle)
				Set n = $O(tInfo(n))
			}

			// now put items into the output list
			Set pColCount = 0
			Set k = $O(tList(""))
			While (k'="") {
				Set n = $O(tList(k,""))
				While (n'="") {
					If $LG(tList(k,n),1)'=tHideColumn {
						// DTB457 - There might be a single column removal
						Set pColCount = pColCount + 1
						Set pColInfo(pColCount) = $LG(tList(k,n),1)
						Set:($LG(tList(k,n),2)'="") pColInfo(pColCount,"caption") = $LG(tList(k,n),2)
						Set:($LG(tList(k,n),3)'="") pColInfo(pColCount,"format") = $LG(tList(k,n),3)
						Set:($LG(tList(k,n),4)'="") pColInfo(pColCount,"style") = $LG(tList(k,n),4)
						Set:($LG(tList(k,n),5)'="") pColInfo(pColCount,"headerStyle") = $LG(tList(k,n),5)
					}
					Set n = $O(tList(k,n))
				}
				Set k = $O(tList(k))
			}
		}
		Else {
			// use generic information
			Set tSC = pController.%GetModelPropertyInfo(.tInfo)
			If $$$ISERR(tSC) Quit

			// first get non % props from controller in sequence order
			Set tProp = $O(tInfo(""))
			While (tProp'="") {
				If (tProp '[ "%") {
					Set tList(tInfo(tProp)) = tProp
				}
				Set tProp = $O(tInfo(tProp))
			}

			// now put them in the output list
			Set pColCount = 0
			Set k = $O(tList(""))
			While (k'="") {
				If tList(k)'=tHideColumn {
					// DTB457 - There might be a single column removal
					Set pColCount = pColCount + 1
					Set pColInfo(pColCount) = tList(k)
				}
				Set k = $O(tList(k))
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
UNESC(x)
	Set x = $Replace(x,$C(1),",")
	Set x = $Replace(x,$C(2),":")
	Quit x
]]></Implementation>
</Method>

<Method name="%DrawStatusArea">
<Description><![CDATA[
Draw the contents of the status area.
<var>pMode</var> indicates whether this is a pivot status or a listing status.]]></Description>
<Internal>1</Internal>
<FormalSpec>pPageCount:%Integer,pMode:%String="pivot",pTruncated:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	&html<<table><tr>>

	If (pMode="listing") {
		Set tMsgRows = $$$Text("Records:","%DeepSee")

		Set tCurrPage = ..currListingPage
		Set tListingCount = $S(..listingRowCount="":"",1:$FN(..listingRowCount,","))
		
		// PFS104 - Add info message to inform users that more rows may exist
		Set tListingMax = ""
		If (..listingRowCount=..#MAXLISTINGROWS ) {
			Set tListingMax = $$$Text("Maximum listing rows reached. Additional rows may exist.")
		}

		&html<<td valign="middle" nowrap="1">>
		&html<<span class="dsptStatusLabel">#(tMsgRows)#</span><span id="#(..%MakeId("listingCount"))#" class="dsptStatusValue">#(tListingCount)#</span>&nbsp;<span id="#(..%MakeId("listingMax"))#" class="dsptStatusValue">#(tListingMax)#</span>&nbsp;>
		&html<</td>>
	}
	Else {
		// pivot
		Set tValue = $S(..totalValue="":$$$Text("working...","%DeepSee"),..totalValue="ERROR":$$$Text("ERROR","%DeepSee"),..totalValue'=(..totalValue\1):$FN(..totalValue,",",2),1:$FN(..totalValue,","))
		Set tCellCount = $S(..cellCount="":"",1:$FN(..cellCount,","))

		Set tMsgTotal = $$$Text("Total:","%DeepSee")
		Set tMsgCells = $$$Text("Cells:","%DeepSee")
		Set tCurrPage = ..currPage

		If (..showPivotStats) {
			&html<<td valign="middle" nowrap="1">>
			&html<<span class="dsptStatusLabel">#(tMsgCells)#</span><span id="#(..%MakeId("cellCount"))#" class="dsptStatusValue">#(tCellCount)#</span>&nbsp;>
			&html<<span class="dsptStatusLabel">#(tMsgTotal)#</span><span id="#(..%MakeId("total"))#" class="dsptStatusValue">#(tValue)#</span>&nbsp;>
			If (..columnsTruncated) {
				Set msgTooMany = $$$FormatText($$$Text("Too many columns: Only the first %1 are displayed","%DeepSee"),..#MAXCOLUMNS)
				&html<<span class="dsptStatusLabel" style="color:#802020;padding:1px;">&nbsp;#(msgTooMany)#&nbsp;</span>&nbsp;>
			}
			&html<</td>>
		}
		// JMD900 - pending results indicator
		Set msgComputing = $$$Text("Computing...","%DeepSee")
		Set tStyle = $S(..queryPending:"",1:"display:none;")
		&html<<td>&nbsp;&nbsp;&nbsp;</td><td valign="middle" nowrap="1" id="#(..%MakeId("pending"))#" style="#(tStyle)#"><span class="dsptStatusLabel">#(msgComputing)#</span></td>>
	}

	// JMD1129
	If (pTruncated)&&(..headFunctionAdded) {		// DTB201
		Set hlpShow = $$$Text("Click here to load all results")
		Set msgShow = $$$Text("Show All")
		&html<<td class="dsptShowMore" valign="middle" nowrap="1" onclick="zenPage.getComponent(#(..index)#).showAllRows();" title="#(hlpShow)#">#(msgShow)#</td>>
		Set ..rowsTruncated = pTruncated		// DTB712
	}

	#; navigation buttons
	&html<<td nowrap="1" align="right" valign="middle" width="90%">>
	If (pPageCount>1) {
		// JMD1304 indicate truncated results
		Set tPageCountMsg = pPageCount _ $S(pTruncated:"+",1:"")
		Set msgPage = $$$FormatText($$$Text("Page %1 of %2","%DeepSee"),tCurrPage,tPageCountMsg)
		Set hlpFirst = $$$Text("View first page of results","%DeepSee")
		Set hlpPrev = $$$Text("View previous page of results","%DeepSee")
		Set hlpNext = $$$Text("View next page of results","%DeepSee")
		Set hlpLast = $$$Text("View last page of results","%DeepSee")

		&html<<span class="dsptStatusLabel">#(msgPage)#&nbsp;</span>>
		&html<</td>>
		&html<<td nowrap="1" align="right" valign="middle" width="5%">>
		&html<<div class="dsptIconBar" style="font-size:0.8em;vertical-align:top;">>
			
			If (tCurrPage > 1) {
				&html<<img class="dsptIcon" title="#(hlpFirst)#" style="height:18px;width:18px;padding:2px;" src="deepsee/ds2_skip_backward.png" onclick="zenPage.getComponent(#(..index)#).firstPage();" />>
				&html<<img class="dsptIcon" title="#(hlpPrev)#" style="height:18px;width:18px;padding:2px;" src="deepsee/ds2_rewind.png" onclick="zenPage.getComponent(#(..index)#).previousPage();"/>>
			}
			Else {
				&html<<img class="dsptIconDisabled" style="height:18px;width:18px;padding:2px;" src="deepsee/ds2_skip_backward.png"/>>
				&html<<img class="dsptIconDisabled" style="height:18px;width:18px;padding:2px;" src="deepsee/ds2_rewind.png"/>>
			}
			If (tCurrPage < pPageCount) {
				&html<<img class="dsptIcon" style="height:18px;width:18px;padding:2px;" title="#(hlpNext)#" src="deepsee/ds2_fast_forward.png" onclick="zenPage.getComponent(#(..index)#).nextPage();" />>
				&html<<img class="dsptIcon" title="#(hlpLast)#" style="height:18px;width:18px;padding:2px;" src="deepsee/ds2_skip_forward.png" onclick="zenPage.getComponent(#(..index)#).lastPage();"/>>
			}
			Else {
				&html<<img class="dsptIconDisabled" style="height:18px;width:18px;padding:2px;" src="deepsee/ds2_fast_forward.png" />>
				&html<<img class="dsptIconDisabled" style="height:18px;width:18px;padding:2px;" src="deepsee/ds2_skip_forward.png"/>>
			}		
		&html<</div>>
	}
	&html<</td>>
	&html<</tr></table>>
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%DrawDataTable">
<Description><![CDATA[
Draw the table containing the data cells.<br/>
<var>pColRoot</var> is node number for top node along the column axis.<br/>
<var>pRowRoot</var> is node number for top node along the row axis.<br/>
<var>pStartRow</var> is the ordinal number of the first row to display.<br/>
<var>pEndRow</var> is the ordinal number of the last row to display.<br/>]]></Description>
<FormalSpec><![CDATA[pAxisCount:%Integer,pColRoot:%Integer,pRowRoot:%Integer,pStartRow:%Integer,pEndRow:%Integer,pColumnTotals:%Boolean=0,pRowTotals:%Boolean=0,pUseSort:%Boolean=0,pMaxCols:%Boolean=1000,&pHTML:%String,&pHTMLAttributes:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tTotal = ""
		Set tCellCount = 0
		Set tCellWidth = ..cellWidth
		Set tMaxCols = pMaxCols

		Set tCellHeight = ..cellHeight
		Set tCubeIndex = ..cubeKey
		Set tKey = ..queryKey
		
		// WAL106
		Set tDataTableOffset = pStartRow-1

		// pull range apart
		Set tRangeRow1 = $P(..selectedRange,",",1)
		Set tRangeCol1 = $P(..selectedRange,",",2)
		Set tRangeRow2 = $P(..selectedRange,",",3)
		Set tRangeCol2 = $P(..selectedRange,",",4)

		#; set up format conditions
		Set tFormatRuleCount = ..formatRules.Count()

		#; set up color scaling
		Set tMinRed = 0
		Set tMaxRed = 255
		Set tMinGreen = 0
		Set tMaxGreen = 255
		Set tMinBlue = 0
		Set tMaxBlue = 255
		Set tRedScale = 0
		Set tBlueScale = 0
		Set tGreenScale = 0
		If (..colorScale = "red-to-black") {
			Set tRedScale = 1
		}
		ElseIf (..colorScale = "green-to-black") {
			Set tGreenScale = 1
		}
		ElseIf (..colorScale = "blue-to-black") {
			Set tBlueScale = 1
		}
		ElseIf (..colorScale = "salmon-to-black") {
			Set tRedScale = 1
			Set tGreenScale = 0.65
			Set tBlueScale = 0.45
		}
		ElseIf (..colorScale = "purple-to-black") {
			Set tBlueScale = 1
			Set tRedScale = 1
		}
		ElseIf (..colorScale = "gray-to-black") {
			Set tRedScale = 0.75
			Set tBlueScale = 0.75
			Set tGreenScale = 0.75
		}
		ElseIf ($P(..colorScale,":",1) = "custom") {
			// JMD1063: custom:r1,g1,b1:r2,g2,b2
			Set tRGB1 = $P(..colorScale,":",2)
			Set tRGB2 = $P(..colorScale,":",3)
			Set r1 = +$P(tRGB1,",",1)
			Set g1 = +$P(tRGB1,",",2)
			Set b1 = +$P(tRGB1,",",3)
			Set r2 = +$P(tRGB2,",",1)
			Set g2 = +$P(tRGB2,",",2)
			Set b2 = +$P(tRGB2,",",3)
			Set r1=$S(r1<0:0,r1>255:255,1:r1)
			Set g1=$S(g1<0:0,g1>255:255,1:g1)
			Set b1=$S(b1<0:0,b1>255:255,1:b1)
			Set r2=$S(r2<0:0,r2>255:255,1:r2)
			Set g2=$S(g2<0:0,g2>255:255,1:g2)
			Set b2=$S(b2<0:0,b2>255:255,1:b2)
			Set tMinRed = r1,tMaxRed=r2,tRedScale = (r2-r1)/255
			Set tMinGreen = g1,tMaxGreen=g2,tGreenScale = (g2-g1)/255
			Set tMinBlue = b1,tMaxBlue=b2,tBlueScale = (b2-b1)/255
		}

		Set tRowRoot = pRowRoot
		Set tColRoot = pColRoot
		Set tColAxisNo = 1
		Set tRowAxisNo = 2
		Set tPageAxisNo = 3
		Set tPageNodeNo = ""		// can only be one value

		Set tMessage = $ZCVT(..%message,"O","HTML")

		// WAL -- draw empty table
		If ((tCubeIndex="")||(tKey="")) {
			If (..dataSource="automatic") {
				Do ..%DrawEmptyTable($$$Text("No cube"),.tDataTableHTML,.tDataTableHTMLAttributes)
				Merge pHTML = tDataTableHTML
				Merge pHTMLAttributes = tDataTableHTMLAttributes // WAL
			}
			Else {
				Do ..%DrawEmptyTable($$$Text("No results"),.tDataTableHTML,.tDataTableHTMLAttributes)
				Merge pHTML = tDataTableHTML
				Merge pHTMLAttributes = tDataTableHTMLAttributes // WAL
			}
			Quit
		}

		// get keys used to find axis info
		Set tColAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"axis",tColAxisNo))
		Set tRowAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"axis",tRowAxisNo))
		Set tPageAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"axis",tPageAxisNo))
		
		Set ..queryStatus = ..%ResultSet.%GetStatus()		// DTB868 - Refresh status now

		If (pAxisCount>3) {
			Do ..%DrawEmptyTable($$$Text("Pivot table cannot show more than 3 dimensional results"),.tDataTableHTML,.tDataTableHTMLAttributes)
			Merge pHTML = tDataTableHTML
			Merge pHTMLAttributes = tDataTableHTMLAttributes // WAL
			Quit
		}

		Set tMinValue = +$G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"stats","min"))
		Set tMaxValue = +$G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"stats","max"))
		Set tRange = tMaxValue - tMinValue

		// count number of columns; build local index
		Set tColCount = 0
		If (tMessage '= "") {
			Set tCellWidth = 500 + 3 // extra space for message
			Set tColCount = 1
			Set tColIndex(1) = ""
		}
		ElseIf (tColRoot="") {
			Set tColCount = 1
			Set tColIndex(1) = ""
		}
		Else {
			Set c = $O($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"leaf",tColAxisNo,""),1,data)
			While (c'="") {
				If (tColCount >= tMaxCols) {
					Set ..columnsTruncated = 1
				}
				Else {
					Set tColCount = tColCount + 1
					Set tColIndex(tColCount) = data
					Set tFmt = ""
					Set tCSO = 0
					Set tCStyle = ""
					Set tTestNodeNo = data
					While ((tTestNodeNo'="")) {
						Set tSNodeType = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tTestNodeNo)),1)
						Set tCF = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tTestNodeNo)),12)
						Set:(tCF'="")&&(tFmt="") tFmt = tCF
						Set tCS = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tTestNodeNo)),18)
						Set:(tCS'="")&&(tCStyle="") tCStyle = tCS
						Set tSO = +$LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tTestNodeNo)),15)
						Set:tSO>0 tCSO = tSO
						Set tTestNodeNo = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tColAxisKey,"axes",tTestNodeNo)),4)
					}

					Set tCAgg = ""
					Set:tCStyle["summary:" tCStyle = ..%GetSummaryFromCSS(tCStyle,.tCAgg)

					Set:tFmt'="" tColFormat(tColCount) = tFmt
					Set:tCStyle'="" tColStyle(tColCount) = tCStyle
					Set:tCAgg'="" tColAgg(tColCount) = tCAgg
					Set:tCSO>0 tColSolveOrder(tColCount) = tCSO
				}
				Set c = $O($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"leaf",tColAxisNo,c),1,data)
			}
		}

		If (tPageAxisKey'="") {
			Set p = $O($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"leaf",tPageAxisNo,""),1,data)
			If (p'="") { 
				Set tPageIndex = data
				// JMD1406
				Set tPageFormat = $LG($$$DeepSeeAxisGLVN(tCubeIndex,tPageAxisKey,"axes",data),12)
			}
		}

		#; cell table
		Set tNotCalculated = "?"
		Set tNull = $S(..queryStatus>=100:"",1:tNotCalculated)
		Set tTableStarted = 0

		// JMD988
		Set tHasCmbr = $D($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"cmbrMap"))

		#; rows
		Set tRowCount = 0
		Set tRow = 0
		If (tRowRoot="") {
			Set r = 1
		}
		Else {
			Set r = $O($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tRowRoot,"all",""))
		}

		#; display rows
		For tRowIndex = pStartRow:1:pEndRow {
			If (pUseSort) {
				Set tRow = $$$DeepSeeResultsGLVN(tCubeIndex,tKey,"sort",..sortColumn,..sortDir,tRowIndex)
			}
			Else {
				Set tRow = tRowIndex
			}
			Set tRowCount = tRowCount + 1
			If ('tTableStarted) {
				Set tTableStarted = 1
			}

			#; determine default format
			Set tDefaultFormat = $G(tPageFormat)
			Set tDefaultStyle = ""
			Set tSlicer = $G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"slicer"))
			If (tSlicer'="") {
				Set tSlicerKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"axis",0))
				If (tSlicerKey'="") {
					Set s = $O($$$DeepSeeAxisGLVN(tCubeIndex,tSlicerKey,"axes",1,"all",""))
					If (s'="") {
						Set tSNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tSlicerKey,"axes",s))
						Set tSNodeType = $LG(tSNode,1)
						If ((tSNodeType="msr")||(tSNodeType="exp")||(tSNodeType="cmbr")) {
							Set tDefaultFormat = $LG(tSNode,12)
						}
						Else {
							// look at parent node
							Set sp = $LG(tSNode,4)
							While (sp'="") {
								Set tSNode = $G($$$DeepSeeAxisGLVN(tCubeIndex,tSlicerKey,"axes",sp))
								Set tSNodeType = $LG(tSNode,1)
								If ((tSNodeType="msr")||(tSNodeType="exp")||(tSNodeType="cmbr")) {
									Set tDefaultFormat = $LG(tSNode,12)
									Quit
								}
								Set sp = $LG(tSNode,4)
							}
						}
					}
				}
			}

			If (..showZebra) {
				Set tZebraClass = $S('(tRowCount#2):"dsptRowEven",1:"dsptRowOdd")
				If (..cellStyle'="") {
					Set tZebraStyle = $S('(tRowCount#2):..evenRowStyle,1:"background:white;")
				}
				Else {
					// WAL106
					//Set tZebraStyle = $S('(tRowCount#2):..evenRowStyle,1:"background:none;")
					Set tZebraStyle = $S('(tRowCount#2):..evenRowStyle,1:"background:white;")
				}
			}
			Else {
				Set tZebraClass = ""
				Set tZebraStyle = ""
			}

			#; get value for cells
			#; use -1 to avoid subscript error
			Set tRowNode = $G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"leaf",tRowAxisNo,tRow))
			Set:tRowNode="" tRowNode = -1
			Set tRowFormat = ""
			Set tRowCStyle = ""
			Set tRowSolveOrder = 0

			If (tRowAxisKey'="") {
				Set tTestNodeNo = tRowNode
				While ((tTestNodeNo'="")) {
					Set tSNodeType = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tTestNodeNo)),1)
					Set tRF = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tTestNodeNo)),12)
					Set:(tRF'="")&&(tRowFormat="") tRowFormat = tRF
					Set tRCS = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tTestNodeNo)),18)
					Set:(tRCS'="")&&(tRowCStyle="") tRowCStyle = tRCS
					Set tSO = +$LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tTestNodeNo)),15)
					Set:tSO>0 tRowSolveOrder = tSO
					Set tTestNodeNo = $LG($G($$$DeepSeeAxisGLVN(tCubeIndex,tRowAxisKey,"axes",tTestNodeNo)),4)
				}
			}

			Set tRowAgg = ""
			Set:tRowCStyle["summary:" tRowCStyle = ..%GetSummaryFromCSS(tRowCStyle,.tRowAgg)
			
			For c = 1:1:tColCount {
				Set tIcon = ""
				Set tIconCount = 1
				Set tColNode = tColIndex(c)
				Set tCmbrFormat = ""

				// put node #s in canonic order
				If (pAxisCount<2) {
					Set tNodeIdx(1) = tColNode
					Set tNodeIdx(2) = ""
					Set:$G(tPageIndex)'="" tNodeIdx(3) = tPageIndex
				}
				Else {
					Set tNodeIdx(1) = tColNode
					Set tNodeIdx(2) = tRowNode
					Set:$G(tPageIndex)'="" tNodeIdx(3) = tPageIndex
				}
				If (tMessage'="") {
					Set tValue = tMessage
					Set tTotal = 0
				}
				Else {
					Set tValue = $$GETVAL(pAxisCount,.tNodeIdx)
					Set:$IsValidNum(tValue) tTotal = tTotal + tValue		// DTB363

					// JMD988 Test for cmbr override of format
					If (tHasCmbr&&($G(tNodeIdx(1))'="")&&($G(tNodeIdx(2))'="")) {
						Set tCmbrFormat = $LG($G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"cmbrMap",tNodeIdx(1),tNodeIdx(2),0)),12)
					}
				}

				Set tCls = "dsPivotNum"
				Set tStyle = ..cellStyle
				If (tCellWidth'="") {
					// JMD1465 Set tStyle = tStyle _ "width:"_(tCellWidth-3)_"px;"
				}
				If (tCellHeight'="") {
					Set tStyle = tStyle _ "height:"_(tCellHeight)_"px;"
				}
				Set tStyle = tStyle _ tZebraStyle

				If (+$G(tColSolveOrder(c))>=tRowSolveOrder) {
					If ($G(tColFormat(c))'="") {
						Set tFormat = tColFormat(c)
					}
					ElseIf (tRowFormat'="") {
						Set tFormat = tRowFormat
					}
					Else {
						Set tFormat = tDefaultFormat
					}
					If ($G(tColStyle(c))'="") {
						Set tCStyle = tRowCStyle_tColStyle(c)
					}
					ElseIf (tRowCStyle'="") {
						Set tCStyle = $G(tColStyle(c))_tRowCStyle
					}
					Else {
						Set tCStyle = tDefaultStyle
					}
				}
				Else {
					If (tRowFormat'="") {
						Set tFormat = tRowFormat
					}
					ElseIf ($G(tColFormat(c))'="") {
						Set tFormat = tColFormat(c)
					}
					Else {
						Set tFormat = tDefaultFormat
					}
					If (tRowCStyle'="") {
						Set tCStyle = $G(tColStyle(c))_tRowCStyle
					}
					ElseIf ($G(tColStyle(c))'="") {
						Set tCStyle = tRowCStyle_tColStyle(c)
					}
					Else {
						Set tCStyle = tDefaultStyle
					}
				}
				Set:tCmbrFormat'="" tFormat = tCmbrFormat

				// format cell
				Set tDisplay = ##class(%DeepSee.ResultSet).%FormatNumber(tValue,tFormat,.tType,.tFormatStyle)
				Set tCls = $Case(tType,"integer":"dsPivotNum",
										"date":"dsPivotDate",
										"number":"dsPivotNum",
										:"dsPivotString")

				// 3rd piece of format is cell style
				If ($P(tFormat,"^",3)'="") {
					Set tStyle = tStyle_$P(tFormat,"^",3)
				}

				// color scaling
				If (..queryStatus < 100) {
					// partial results
					Set tStyle = tStyle_"color:blue;"
				}
				ElseIf ($P(tValue," ") = "@Computing") {
					// JMD900: pending results: pct is 0 to 100
					Set tPct = +$P(tValue," ",2)
					Set tStyle = tStyle_"background:rgb(180,180,"_(200+(tPct\2))_");color:#404040;white-space:nowrap;font-size:0.8em;"
					Set tDisplay = $$$Text("Computing","%DeepSee")_": " _ $FN(tPct,"",2) _ "%"
				}
				ElseIf ($IsValidNum(tValue)&&(tRange>0)&&(..colorScale'="")) {
					// special case for pct values
					If (tFormat["%") {
						Set tPct = $S(tValue<0:0,tValue>1:1,1:tValue)
					}
					Else {
						Set tPct = (tValue-tMinValue/tRange)
					}
					Set cvr = $S(tMinRed<tMaxRed:(tMinRed + (tRedScale * tPct * tMaxRed)\1),1:(tMaxRed + (-tRedScale * (1-tPct) * tMinRed)\1))
					Set cvg = $S(tMinGreen<tMaxGreen:(tMinGreen + (tGreenScale * tPct * tMaxGreen)\1),1:(tMaxGreen + (-tGreenScale * (1-tPct) * tMinGreen)\1))
					Set cvb = $S(tMinBlue<tMaxBlue:(tMinBlue + (tBlueScale * tPct * tMaxBlue)\1),1:(tMaxBlue + (-tBlueScale * (1-tPct) * tMinBlue)\1))
					Set tBright = (cvr*cvr*0.241)+(cvg*cvg*0.691)+(cvb*cvb*0.068)
					Set tFG = $S(tBright>16900:"black",1:"white")
					Set tStyle = tStyle_"background:rgb("_cvr_","_cvg_","_cvb_");color:"_tFG_";"
				}

				// conditional format
				For n = 1:1:tFormatRuleCount {
					Set tCondition = ..formatRules.GetAt(n)
					If (tCondition.%EvaluateCondition(tRow,c,tValue)) {
						Set tStyle = tStyle _ tCondition.style
						Set:tCondition.text'="" tDisplay = tCondition.text
						Set:tCondition.icon'="" tIcon = tCondition.icon
						Set:tCondition.iconCount'="" tIconCount = tCondition.iconCount
						If (($E(tIcon)="@")&&(tIcon'="@")) {
							// user icon: resolve
							Set ik = $E(tIcon,2,$L(tIcon))
							If $D(tLocalIconList(ik)) {
								Set tIcon = tLocalIconList(ik)
							}
							Else {
								Set tIcon = ##class(%DeepSee.UserPortal.Utils).%GetUserIcon(ik)
								Set tLocalIconList(ik) = tIcon
							}
						}
					}
				}
				Set tCellCount = tCellCount + 1
				If (tCStyle'="") {
					Set tStyle = tStyle _ tCStyle
				}
				If (tFormatStyle'="") {
					Set tStyle = tStyle _ "color:"_tFormatStyle_";"
				}

				If (tIcon'="") {
					Set tDisplay = ""
					For ic = 1:1:tIconCount {
						Set tDisplay = tDisplay _ "<image alt=""*"" style=""padding-right:2px;"" height="""_(tCellHeight-4)_""" src="""_tIcon_"""/>"
					}
					Set tCls = "dsPivotIcon"
				}
				ElseIf ($E(tDisplay,*)'=")") { // align negative numbers
					Set tDisplay = tDisplay _ "&nbsp;&nbsp;"
				}

				// apply align to inner div
				Set tDivStyle = ""
				Set tTestStyle = $TR(tStyle," ","")
				If ((tCls'="dsPivotNum")||(tTestStyle["text-align:left;")) {
					Set tDivStyle = "text-align:left;"
				}
				If (tTestStyle["text-align:center;") {
					Set tDivStyle = "text-align:center;"
				}
				ElseIf (tTestStyle["text-align:right;") {
					Set tDivStyle = "text-align:right;"
				}

				
				Set tDStyle = tStyle // WAL -- leave style adjustable
				Set tDIStyle = tDivStyle // WAL -- stick with the same format
				Set:tStyle'="" tStyle = "style="_$$$quote(tStyle)
				Set tIStyle = ""
				Set:tDivStyle'="" tIStyle = "style="_$$$quote(tDivStyle)
				
				// WAL106
				Set tDCls = tCls
				If (tZebraClass'="") {
					//Set tCls = tZebraClass	
					If (tZebraClass [ "Odd") { 
						Set tCls = tCls_" dsPivotRowOdd" 
						Set tDCls = "dsPivotRowOdd" // WAL	
					}
					Else {
						Set tCls = tCls_" dsPivotRowEven" 
						Set tDCls = "dsPivotRowEven" // WAL
					}
				}

				Set id = ..%MakeId("cell_"_tRowCount_"_"_c)
				// DTB828 [PFS010] - Use offset to assign absolute ID value
				Set tDataTableHTML((tRowCount+tDataTableOffset),c) = "<td nowrap=""1"" class="""_tCls_""" "_tStyle_" id="""_..%MakeId("cell_"_(tRowCount+tDataTableOffset)_"_"_c)_""" onmousedown=""return zenPage.getComponent("_..index_").cellMouseDownHandler(event);"" onclick=""zenPage.getComponent("_..index_").cellClickHandler(event,"_(tRowCount+tDataTableOffset)_","_c_");"" ondblclick=""zenPage.getComponent("_..index_").cellDblClickHandler(event,"_(tRowCount+tDataTableOffset)_","_c_");"" zenValue="""_tValue_""" title="""_$ZCVT(tValue,"O","HTML")_"""><div class=""dsptCellDiv"" "_tIStyle_">&nbsp;"_tDisplay_"</div></td>"
				
				// when I convert these to strings, all the values need to be quoted
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),c,"id")=id
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),c,"class")=tDCls
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),c,"style")=tDStyle
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),c,"onmousedown")="return zenPage.getComponent("_..index_").cellMouseDownHandler(event);"
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),c,"onclick")="zenPage.getComponent("_..index_").cellClickHandler(event,"_tRowCount+tDataTableOffset_","_c_");"			// DTB828
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),c,"ondblclick")="zenPage.getComponent("_..index_").cellDblClickHandler(event,"_tRowCount+tDataTableOffset_","_c_");"		// DTB828
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),c,"zenValue")=tValue
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),c,"title")=$ZCVT(tValue,"O","HTML")
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),c,"contents","class")="dsptCellDiv"
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),c,"contents","style")=tDIStyle
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),c,"contents","contents")="&nbsp;"_tDisplay			
			}

			If (pColumnTotals) {
				// holder for totals
				Set tStyle = ""
				If ('..showZebra) {
					Set tStyle = tStyle _ "background:#F8F8F8;"
				}
				Set tStyle = tStyle _ ..cellStyle
				Set tStyle = tStyle _ tRowCStyle
				Set tAgg = tRowAgg
				Set tDivStyle = ""
				If (tCellWidth'="") {
					//JMD1465 Set tDivStyle = tDivStyle_"width:"_(tCellWidth-3)_"px;"
				}
				Set tDivStyle = tDivStyle _ "height:auto;"
				If (tCellHeight'="") {
					// JMD1462 don't set height
					// Set tDivStyle = tDivStyle _ "height:"_(tCellHeight)_"px;"
				}
				Set tStyle = tStyle _ "font-weight:bold;"_tZebraStyle
				
				Set tFormat = $G(tRowFormat)
				Set:tFormat="" tFormat = tDefaultFormat
				Set tIStyle = ""
				Set tDIStyle = tDivStyle // WAL
				Set:tDivStyle'="" tIStyle = "style="_$$$quote(tDivStyle)
				
				Set tCls = "dsPivotNum"
				If (tZebraClass'="") {
					//Set tCls = tZebraClass	
					If (tZebraClass [ "Odd") { Set tCls = "dsPivotRowOdd" }
					Else { Set tCls = "dsPivotRowEven" }
				}

				// WAL106 -- this is the end cell in each row -- zebra seems to look good now; will need to review whether or not
				//           icon, num, etc. things still work
				
				Set id = ..%MakeId("ctot_"_tRowCount)
				Set divId = ..%MakeId("ctotd_"_tRowCount)
				// WAL
				Set tDataTableHTML("ctot",(tRowCount+tDataTableOffset)) = "<td style="""_tStyle_""" agg="""_tAgg_""" format="""_$G(tFormat)_""" id="""_id_""" row="""_tRow_""" nowrap=""1"" class="""_tCls_"""><div class=""dsptCellDiv"" id="""_divId_""" "_tIStyle_">&nbsp;</div></td>"
			
				// WAL
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),(tColCount+1),"id")=id
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),(tColCount+1),"class")=tCls
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),(tColCount+1),"row")=tRow
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),(tColCount+1),"format")=$G(tFormat)
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),(tColCount+1),"agg")=tAgg
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),(tColCount+1),"style")=tStyle
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),(tColCount+1),"contents","class")="dsptCellDiv"
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),(tColCount+1),"contents","id") = divId
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),(tColCount+1),"contents","style") = tDIStyle
				Set tDataTableHTMLAttributes((tRowCount+tDataTableOffset),(tColCount+1),"contents","contents") = "&nbsp;"
			}
		}

		Set ..queryStatus = ..%ResultSet.%GetStatus()		// DTB868 - Refresh 
		If ('tTableStarted || (tCellCount=0)) {
			If (..queryStatus < 100) {
				Do ..%DrawEmptyTable($$$Text("Working..."),.tDataTableHTML,.tDataTableHTMLAttributes)
				Merge pHTML = tDataTableHTML
				Merge pHTMLAttributes = tDataTableHTMLAttributes // WAL
			}
			Else {
				Do ..%DrawEmptyTable($$$Text("No results"),.tDataTableHTML,.tDataTableHTMLAttributes)
				Merge pHTML = tDataTableHTML
				Merge pHTMLAttributes = tDataTableHTMLAttributes // WAL
			}
			Quit
		}
		Else {
			If (pRowTotals) {
				Set tRowCount = tRowCount + 1
				If (..showZebra) {
					Set tZebraClass = $S('(tRowCount#2):"dsptRowEven",1:"dsptRowOdd")
					If (..cellStyle'="") {
						Set tZebraStyle = $S('(tRowCount#2):..evenRowStyle,1:"background:white;")
					}
					Else {
						Set tEvenRowStyle=""
						If (..evenRowStyle = "") {
							Set tEvenRowStyle="background:#F0F0F4;"
						}
						Set tZebraStyle = $S('(tRowCount#2):tEvenRowStyle,1:"background:white;")
					}
				}
				Else {
					Set tZebraClass = ""
					Set tZebraStyle = ""
				}
				
				// WAL106
				Set tCls = "dsPivotNum"
				If (tZebraClass'="") {	
					If (tZebraClass [ "Odd") { Set tCls = "dsPivotRowOdd" }
					Else { Set tCls = "dsPivotRowEven" }
				}
				
				For c = 1:1:tColCount {
					Set tAgg = $G(tColAgg(c))
					Set tFormat = $G(tColFormat(c))
					Set:tFormat="" tFormat = tDefaultFormat
					Set tStyle = ..cellStyle _ $G(tColStyle(c))
					Set tDivStyle = ""
					If (tCellWidth'="") {
						// JMD1462 don't set width for totals
						//Set tDivStyle = tDivStyle_"width:"_(tCellWidth-3)_"px;"
					}
					Set tStyle = tStyle _ tZebraStyle
					Set tIStyle = ""
					Set tDIStyle = tDivStyle // WAL
					Set:tDivStyle'="" tIStyle = "style="_$$$quote(tDivStyle)
					// WAL106 -- add tCls
					
					Set id = ..%MakeId("rtot_"_c)
					Set divId = ..%MakeId("rtotd_"_c)
					// WAL
					Set tDataTableHTML("rtot",c) = "<td style=""font-weight:bold;background:#F8F8F8;"_tStyle_""" agg="""_$G(tAgg)_""" format="""_tFormat_""" id="""_id_""" nowrap=""1"" class="""_tCls_"""><div class=""dsptCellDiv"" id="""_divId_""" "_tIStyle_">&nbsp;</div></td>"
				
					// WAL 
					Set tDataTableHTMLAttributes(tRowCount,c,"id") = id
					Set tDataTableHTMLAttributes(tRowCount,c,"style") = "font-weight:bold;background:#F8F8F8;"_tStyle
					Set tDataTableHTMLAttributes(tRowCount,c,"agg") = $G(tAgg)
					Set tDataTableHTMLAttributes(tRowCount,c,"format") = tFormat
					Set tDataTableHTMLAttributes(tRowCount,c,"class") = tCls
					Set tDataTableHTMLAttributes(tRowCount,c,"contents","class") = "dsptCellDiv"
					Set tDataTableHTMLAttributes(tRowCount,c,"contents","id") = divId
					Set tDataTableHTMLAttributes(tRowCount,c,"contents","style") = tDIStyle
					Set tDataTableHTMLAttributes(tRowCount,c,"contents","contents") = "&nbsp;"
				}
				If (pColumnTotals) {
					Set tStyle = ..cellStyle
					Set tDivStyle = ""
					If (tCellWidth'="") {
						// JMD1462 don't set width for totals
						//Set tDivStyle = tDivStyle_"width:"_(tCellWidth-3)_"px;"
					}
					Set tStyle = tStyle _ tZebraStyle
					Set tFormat = $G(tColFormat(tColCount))
					Set:$G(tFormat)="" tFormat = tDefaultFormat
					Set tIStyle = ""
					Set tDIStyle = tDivStyle // WAL
					Set:tDivStyle'="" tIStyle = "style="_$$$quote(tDivStyle)
					
					Set id = ..%MakeId("gtot")
					Set divId = ..%MakeId("gtotd")
					// WAL
					Set tDataTableHTML("gtot") = "<td style=""font-weight:bold;background:#F8F8F8;"_tStyle_""" format="""_tFormat_""" id="""_id_""" nowrap=""1"" class=""dsPivotNum""><div class=""dsptCellDiv"" id="""_divId_""" "_tIStyle_">&nbsp;</div></td>"
				
					// WAL -- grand total node
					Set tDataTableHTMLAttributes(tRowCount,(tColCount+1),"style") = "font-weight:bold;background:#F8F8F8;"_tStyle
					Set tDataTableHTMLAttributes(tRowCount,(tColCount+1),"format") = tFormat
					Set tDataTableHTMLAttributes(tRowCount,(tColCount+1),"id") = id
					Set tDataTableHTMLAttributes(tRowCount,(tColCount+1),"class") = "dsPivotNum"
					Set tDataTableHTMLAttributes(tRowCount,(tColCount+1),"contents","class") = "dsptcellDiv"
					Set tDataTableHTMLAttributes(tRowCount,(tColCount+1),"contents","id") = divId
					Set tDataTableHTMLAttributes(tRowCount,(tColCount+1),"contents","style") = tDIStyle
					Set tDataTableHTMLAttributes(tRowCount,(tColCount+1),"contents","contents") = "&nbsp;"
				}
			}
		}
		
		Merge pHTML = tDataTableHTML
		Merge pHTMLAttributes = tDataTableHTMLAttributes
		
		Set ..totalValue = tTotal
		Set ..cellCount = tCellCount
		Set ..columnCount = tColCount
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC

	// lookup value in result cache; tNodeNo is array of subscripts in axis order
	Set tAxisCount = ""
GETVAL(tAxisCount,tNodeNo)
	Quit $Case(tAxisCount,
		0:$G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"data",0)),
		1:$G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"data",0,tNodeNo(1))),
		2:$G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"data",0,tNodeNo(1),tNodeNo(2))),
		3:$G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"data",0,tNodeNo(1),tNodeNo(2),tNodeNo(3))),
		4:$G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"data",0,tNodeNo(1),tNodeNo(2),tNodeNo(3),tNodeNo(4))),
		5:$G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"data",0,tNodeNo(1),tNodeNo(2),tNodeNo(3),tNodeNo(4),tNodeNo(5))),
		6:$G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"data",0,tNodeNo(1),tNodeNo(2),tNodeNo(3),tNodeNo(4),tNodeNo(5),tNodeNo(6))),
		7:$G($$$DeepSeeResultsGLVN(tCubeIndex,tKey,"data",0,tNodeNo(1),tNodeNo(2),tNodeNo(3),tNodeNo(4),tNodeNo(5),tNodeNo(6),tNodeNo(7))),
		:"")
]]></Implementation>
</Method>

<Method name="%DrawEmptyTable">
<Description>
Draw a one-cell data table with the given message.</Description>
<FormalSpec><![CDATA[pMessage:%String,&pHTML:%String,&pHTMLAttributes]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tRow = 1
	Set c = 1
	Set tRowCls = $S(..showZebra:"dsPivotRowOdd",1:"")
	Set tCls = ""
	Set tStyle = ""
	Set tCellWidth = ..cellWidth
	Set id = ..%MakeId("cell_"_tRow_"_"_c)

	// + WAL106 -- instead of drawing the empty table, return the HTML for the one data table cell
	//  		   let the caller know we create the empty table so it won't write out the nub
	Set pHTML(1,1) = "<td nowrap=""1"" class="""_tCls_""" """_tStyle_""" id="""_id_""" zenValue="""" title="""_$ZCVT(pMessage,"O","HTML")_"""><div class=""dsptCellDiv"" style=""width:"_tCellWidth_"px;"">&nbsp;"_$ZCVT(pMessage,"O","HTML")_"</div></td>"
	Set pHTML("empty") = 1
	// - WAL106
	
	// WAL
	Set pHTMLAttributes(1,1,"class") = tCls
	Set pHTMLAttributes(1,1,"style") = tStyle
	Set pHTMLAttributes(1,1,"id") = id
	Set pHTMLAttributes(1,1,"zenValue") = ""
	Set pHTMLAttributes(1,1,"title") = $ZCVT(pMessage,"O","HTML")
	Set pHTMLAttributes(1,1,"contents","class") = "dsptCellDiv"
	Set pHTMLAttributes(1,1,"contents","style") = "width:"_tCellWidth_"px;"
	Set pHTMLAttributes(1,1,"contents","contents") = "&nbsp;"_$ZCVT(pMessage,"O","HTML")

	Set ..totalValue = 0
	Set ..cellCount = 1
	Set ..columnCount = 1
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetAxisSize">
<Description><![CDATA[
Find the number of displayed leaf nodes in the given axis.<br/>
<var>pAxisNo</var> is the axis number.<br/>]]></Description>
<Internal>1</Internal>
<FormalSpec>pAxisNo:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tSize = 0
	Try {
		If $IsObject(..%ResultSet) {
			// DTB868 - Use the current resultset if available
			Set tSize = ..%ResultSet.%GetAxisSize(pAxisNo)
		}
		Else {
			Set tCubeIndex = ..cubeKey
			Set tQueryKey = ..queryKey

			#; walk down leaf nodes and count
			Set tItemNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",pAxisNo,""))
			While (tItemNo '= "") {
				Set tSize = tSize + 1
				Set tItemNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"leaf",pAxisNo,tItemNo))
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
		Set tSize = 0
	}
	Quit tSize
]]></Implementation>
</Method>

<Method name="%GetAxisSpecs">
<Description><![CDATA[
Compute information needed to draw the labels and cells of this table for the
given axis.<br/>
<var>pAxisNo</var> is the axis number.<br/>
<var>pSpan</var> indicates whether we should span parent labels.<br/>
<var>pStart</var> is the (ordinal) number of the first cell to show.<br/>
<var>pEnd</var> is the (ordinal) number of the end cell to show.<br/>
<var>pLevels</var> returns the number of levels within the axis.<br/>
<var>pItems</var> returns an array of items to plot.
This takes the form:<br/>
pItems(level,index) = $LB(nodeNo,colSpan,rowSpan,hasChildren,[itemNo(presorted #)])
(along the column axis, otherwise flip the row and col spans).<br/>]]></Description>
<Internal>1</Internal>
<FormalSpec>pAxisNo:%Integer,pSpan:%Boolean,pStart:%Integer,pEnd:%Integer,*pLevels:%Integer,*pItems,pUseSort:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// +DTB254 - Introduce index for testing whether this node is a candidate for display
	Set tVisibleNodeTypes("mbr") = ""
	Set tVisibleNodeTypes("msr") = ""
	Set tVisibleNodeTypes("lit") = ""
	Set tVisibleNodeTypes("agg") = ""
	Set tVisibleNodeTypes("exp") = ""  // WAL186 -- add "exp" so non-"agg" calculated members display properly
	Set tVisibleNodeTypes("cmbr") = "" // WAL198 -- add "cmbr" so properties and current members
	Set tVisibleNodeTypes("cell") = ""	// DTB680
	// -DTB254
	
	Set tSC = $$$OK
	Try {
		Set tCubeIndex = ..cubeKey
		Set tQueryKey = ..queryKey
		Set tSpanParents = pSpan

		Set tAxisKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",pAxisNo))

		Kill pItems
		Set pLevels = 0

		// walk down leaf nodes to find number of levels
		// and remember depth of each node
		Kill tDepth
		For tItemIndex = pStart:1:pEnd {
			// + WAL230 -- use tItemIndex to iterate and tItemNo to identify the item, as below
			//             this ensures that we build tAllNodes correctly even in the case of sorting
			If (pUseSort) {
				Set tItemNo = $$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"sort",..sortColumn,..sortDir,tItemIndex)
			}
			Else {
				Set tItemNo = tItemIndex
			}
			// - WAL230
			
			// +DTB248
			Set tSC = ..%ResultSet.%GetOrdinalLabelNodes(pAxisNo,tItemNo,.tNodes)		//Use common resultset API
			If $$$ISERR(tSC) $$$ThrowStatus(tSC)
			
			Merge tAllNodes(tItemNo) = tNodes		// Store these locally for the second pass where the label graph is actually built
			If '$D(tNodes) {
				Quit
			}
				
			// Each path up the label chain may skip some axis nodes that should not end up in the label.
			// Use $O through the local array rather than going back to the global with parent $LG(node,4)
			Set tNodeNo = $O(tNodes(""),-1,tNode)
			Set tLevel=0
			// -DTB248
			
			// DTB175 - Remember which nodes have measures, and whether display of measures will 
			// have an effect for this node.
			Set tNodeType = $LG(tNode,1)
			Set tHasMeasure(tItemNo) = ((tNodeType = "msr")||(tNodeType = "lit")||(tNodeType="agg"))
			Set tHasMeasure = $G(tHasMeasure,0) || tHasMeasure(tItemNo)

			While (tNodeNo'="") {
				Set tNodeType = $LG(tNode,1)
				If $D(tVisibleNodeTypes(tNodeType)) {		// DTB254
					// JMD1097 If no label, skip
					If (($LG(tNode,5)'="")||(tNodeType="lit")) { // WAL251 -- protect spaces, which are literal values with label ""
						Set tLevel = tLevel + 1
					}
				}
				Set tNodeNo = $O(tNodes(tNodeNo),-1,tNode)		// DTB248 - Use new loop condition
			}
			Set tDepth(tItemNo) = tLevel
			Set pLevels = $S(tLevel>pLevels:tLevel,1:pLevels)
		}
		
		Set tMeasuresThisAxis = ((..measureLocation="columns")&&(pAxisNo=1)) || ((..measureLocation="rows")&&(pAxisNo=2))		// DTB666
		
		If (pLevels = 0) Quit

		// now walk down leaf nodes again to get details
		For tItemIndex = pStart:1:pEnd {
			If (pUseSort) {
				Set tItemNo = $$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"sort",..sortColumn,..sortDir,tItemIndex)
			}
			Else {
				Set tItemNo = tItemIndex
			}
			Kill tNodes
			Merge tNodes = tAllNodes(tItemNo)	// DTB248 - pull from stored values
			If '$D(tNodes) {
				Quit
			}
			
			Set tNodeNo = $O(tNodes(""),-1,tNode)

			// + WAL207 -- use tItemNo not tItemIndex, since tDepth is based on itemNo and is created
			//             before we think about sorting.
			//      JMD -- start level # depends on depth of this item
			Set tLevel = pLevels - tDepth(tItemNo) + 1
			// - WAL207
			Set tBottomSpan = tLevel
			
			// +DTB175 - Separate level from span
			Set tItemLevel = tLevel
			Set tNodeType = $LG(tNode,1)
			If (tHasMeasure&&'tHasMeasure(tItemNo)&&(..%HideMeasures())&&tMeasuresThisAxis) {		// DTB666 - Only do this if the measures are on *this* axis!
				// If the axis has measures that are being turned off, but *this* node does not have measures, reduce its span
				Set tBottomSpan = $S((tBottomSpan-1)>=1:tBottomSpan-1,1:1)
			}
			// -DTB175
			
			// DTB248 - We are now walking up a reduced, ordered chain
			Set tParent = $O(tNodes(tNodeNo),-1,tNode)

			While (tParent '= "") {
				Set tNodeType = $LG(tNode,1)
				If $D(tVisibleNodeTypes(tNodeType)) {		// DTB254
					// JMD1097 If no label, skip
					If ($LG(tNode,5)'="") {
						Set tLevel = tLevel + 1
						If ('tSpanParents) {
							Set pItems(tLevel,tItemIndex) = $LB(+tParent,1,1,1)
						}
						Else {
							If ($G(tLastParent(tLevel))=tParent) {
								#; increase span
								Set $List(pItems(tLevel,tLastItem(tLevel)),2) = $List(pItems(tLevel,tLastItem(tLevel)),2)+1
							}
							Else {
								#; add parent node
								#; check if this item is alone at the top
								Set tTestParent = $O(tNodes(tParent),-1,tParentNode)
								Set tParentNodeType = $LG(tParentNode,1)
								
								If $D(tVisibleNodeTypes(tParentNodeType)) {		// DTB254
									Set pItems(tLevel,tItemIndex) = $LB(+tParent,1,1,1)
								}
								Else {
									Set pItems(pLevels,tItemIndex) = $LB(+tParent,1,1,1)
								}
								Set tLastParent(tLevel) = tParent
								Set tLastItem(tLevel) = tItemNo
							}
						}
					}
				}
				Set tParent = $O(tNodes(tParent),-1,tNode)		// DTB248 - Use new loop condition
			}
			Set pItems(tItemLevel,tItemIndex) = $LB(+tNodeNo,1,tBottomSpan,0,tItemNo)		// DTB175 - Use tItemLevel
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetFilterInfo">
<Description><![CDATA[
Get information for filters.<br/>
<var>pInfo</var> returns the list of filters in the first subscript:<br/>
pInfo(i) = $LB(idx,spec,value,text,isMsr,isMember)<br/>
If the <var>pReturnMembers</var> flag is set, the list of members for the filter will
be returned in:<br>
pInfo(i,j) = $LB(value,name,memberId,memberKey) for the j-th member of the i-th filter.<br/>
There may be advanced filters:<br/>
pAdvancedFilters(i) = $LB(idx,spec,text)<br/>]]></Description>
<Internal>1</Internal>
<FormalSpec>*pInfo,*pAdvancedFilters,pReturnMembers=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK

	Try {
		Kill pAdvancedFilters
		Set tCubeName = $$$ZENVAL(..cubeName)
		If (tCubeName = "") {
			Set tSC = $$$ERROR($$$GeneralError,"Cube name missing")
			Quit
		}

		Set tContext = ""

		// get local calc members
		For n = 1:1:..calculatedMembers.Count() {
			Set tCalcMbr = ..calculatedMembers.GetAt(n)
			If ($IsObject(tCalcMbr)&&(tCalcMbr.dimension'="")&&(tCalcMbr.memberName'="")) {
				Set tCalcMbrs($$$UPPER(tCalcMbr.dimension),$$$UPPER(tCalcMbr.memberName)) = $LB(tCalcMbr.dimension,tCalcMbr.memberName)
			}
		}

		// first, organize filters by dimension
		// group filters from same dimension together,
		// organized by level
		// separate advanced items

		For n = 1:1:..filters.Count() {
			Set tFilter = ..filters.GetAt(n)
			If ('$IsObject(tFilter) || (tFilter.enabled=0)) {
				Continue	
			}
			If (tFilter.advanced) {
				// for advanced filters, the spec includes the key value
				// for named filters, the spec is "%FILTER"
				Set pAdvancedFilters($I(pAdvancedFilters)) = $LB(n,tFilter.spec,tFilter.text)
				Continue
			}
			ElseIf ($$$LOWER($E(tFilter.value,1,10))="$variable.") {
				// JMD1276: treat pivot variable as advanced filter (if context is expression)
				Set tVarName = $E(tFilter.value,11,*)
				// only use if context is expression
				Kill tVInfo
				Do ##class(%DeepSee.Utils).%GetPivotVariableInfo(..cubeName,tVarName,.tVInfo)
				If ($G(tVInfo("context"))="expression") {
					Set pAdvancedFilters($I(pAdvancedFilters)) = $LB(n,tFilter.value,tFilter.text)
				}
				Continue
			}
			
			// DTB268 - Check for shared items. Strip any %SHAREDx token if present
			Set tFilterSpec = tFilter.spec
			If $E(tFilterSpec,1,7)="%SHARED" {
				Set tFilterSpec = $P(tFilterSpec,".",2,*)
			}
			
			Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(tCubeName,tFilterSpec,.tDimNo,.tHierNo,.tLevelNo,.tRelationName,.tRelationSpec,.tSpecInfo,.tCalcMbrs)
			If $$$ISERR(tSC) Quit

			If (tDimNo<0) {
				// calc member or named set: make up hier no
				Set tHierNo = $ZCRC(tFilter.spec,6)
			}

			Set tMemberSpec = ""
			// we assume that all filter specs are fully qualified
			// [dim].[hier].[level].Members|AllMembers for a list OR
			// [dim].[hier].[level].&[key] for a specific member
			// !!!
			// OR {a,b,c} for a specific set!
			// there *could* be relationship names at the start of the spec
			// also: the key can be a range

			// JMD1407 process list and check for range
			// first find number of items within the "key"
			Set tCount = 0
			Set tKeyCount = 1
			Set k = $O(tSpecInfo(""))
			While (k'="") {
				Set tCount = tCount + 1
				Set tToken = tSpecInfo(k)
				If (tToken=":") {
					Set tKeyCount = 3
				}
				Set k = $O(tSpecInfo(k))
			}

			For t=1:1:tCount-tKeyCount {
				Set tMemberSpec = tMemberSpec _ $S(tMemberSpec="":"",1:".") _ "["_tSpecInfo(t)_"]"
			}

			Set tMemberKey = ""
			If (tKeyCount = 1) {
				// single key
				Set tMemberKey = tSpecInfo(tCount)
			}
			ElseIf (tKeyCount=3) {
				// range
				Set tMemberKey = "&["_tSpecInfo(tCount-2)_"]:&["_tSpecInfo(tCount)_"]"
			}

			// named set
			If (tDimNo=-2) {
				Set tMemberSpec = "["_$G(tSpecInfo(1))_"]"
				Set tMemberKey = ""
			}

			If (($$$UPPER(tMemberKey)'="MEMBERS")&&($$$UPPER(tMemberKey)'="ALLMEMBERS")) {
				// reference to a specific member (i.e., not a set of members)
				// figure out levelSpec,key,and levelName
				// spec,key,level name,text
				If (tRelationName'="") {
					Set tSpecificMember(n,0) = $LB(tMemberSpec,tMemberKey,tSpecInfo(3),tFilter.text)
				}
				Else {
					// use dhl numbers as a unique key
					Set k = tDimNo_":"_tHierNo_":"_tLevelNo
					Set k2 = $I(tSpecificMember(k))
					Set tSpecificMember(k,k2) = $LB(tMemberSpec,tMemberKey,tSpecInfo(3),tFilter.text)
				}
			}
			Else {
				If (tRelationName'="") {
					Set tFilterList(n,0) = n
					Merge tFilterList(n,0,"info") = tSpecInfo
				}
				Else {
					// skip relations here
					// remove duplicates
					// JMD951 allow duplicates
					//If ('$D(tLevel(tDimNo,tHierNo,tLevelNo))) {
						Set tLevel(tDimNo,tHierNo,tLevelNo) = ""
						// sort within hierarchy, preserve original order otherwise
						//If '$D(tHier(tDimNo,tHierNo)) {
							Set tHier(tDimNo,tHierNo) = $S(tDimNo=0:0,1:n) // measures first
						//}
						Set tIndex = tHier(tDimNo,tHierNo)
						Set tFilter.filterDim = tDimNo
						Set tFilter.filterHier = tHierNo
						Set tFilterList(tIndex,tLevelNo) = n
						Merge tFilterList(tIndex,tLevelNo,"info") = tSpecInfo
					//}
				}
			}
		}
		If $$$ISERR(tSC) Quit

		// process specific member references
		Set n = 0
		Set k = $O(tSpecificMember(""))
		While (k'="") {
			Set tKeyList = ""
			Set tText = ""
			Set tLevelSpec = ""
			Set k2 = $O(tSpecificMember(k,""))
			While (k2'="") {
				Set n = n + 1
				Set tLevelSpec = $LG(tSpecificMember(k,k2),1)
				Set tKey = $LG(tSpecificMember(k,k2),2)
				Set tLevelName = $LG(tSpecificMember(k,k2),3)

				// use ~~ as delim for multiple keys, if present
				Set tKeyList = tKeyList _ $S(tKeyList="":"",1:"~~") _ tKey

				Set tText = tText _ $S(tText="":"",1:",") _ $S(tLevelName'="":tLevelName_"=",1:"")_$LG(tSpecificMember(k,k2),4)

				Set tFilter.position = n
				Set k2 = $O(tSpecificMember(k,k2))
			}

			// JMD1095 Get real value of tDimNo
			Set tDimNo = $P(k,":",1)
			If (tLevelSpec'="") {
				If (tDimNo = -2) {
					// named set
					Set pAdvancedFilters($I(pAdvancedFilters)) = $LB(n,tLevelSpec,tText)
				}
				Else {
					// Set isMember flag to prevent drop down from listing
					Set pInfo(n) = $LB(n,tLevelSpec,tKeyList,tText,0,1)
				}
			}
			Set k = $O(tSpecificMember(k))
		}

		// loop over other filters defined for pTable, get information
		Set i = $O(tFilterList(""))
		While (i'="") {
			Set j = $O(tFilterList(i,""))
			While (j'="") {
				Set tFilter = ..filters.GetAt(tFilterList(i,j))
				Kill tSpecInfo
				Merge tSpecInfo = tFilterList(i,j,"info")
				Kill tMembers
				// check for measures
				Set t = $G(tSpecInfo(1))
				If ($$$UPPER(t) = "MEASURES") {
					Set n = n + 1
					Set tFilter.position = n
					Set pInfo(n) = $LB(tFilterList(i,j),tFilter.spec,tFilter.key,tFilter.text,1,0)
				}
				Else {
					// convert current key value(s) to name value(s)
					Set tFilterValue = ""
					Set tNumKeys = $L(tFilter.key,"~~")
					Set tAbbr = $S(tNumKeys>5:3,tNumKeys>1:11,1:20)
					For t = 1:1:tNumKeys {
						Set tFKey = $P(tFilter.key,"~~",t)
						If (tFKey="") {
							Set tName = ""
						}
						Else {
							Set tSC = ##class(%DeepSee.Utils).%GetLevelNameForKey(tCubeName,tFilter.spec,tFKey,.tName)
							If $$$ISERR(tSC) Quit
						}
						Set tFilterValue = tFilterValue _ $S(tFilterValue="":"",1:"+") _ $E(tName,1,tAbbr)
					}
					If $$$ISERR(tSC) Quit

					Set n = n + 1
					If pReturnMembers {
						// DTB894 - only return the actual members by request
					  	Set tSC = ##class(%DeepSee.Utils).%GetDimensionMembers(tCubeName,tFilter.spec,"",.tMembers)		// DTB599 - explicitly pass null context parameter
					  	If $$$ISERR(tSC) Quit
						Merge pInfo(n) = tMembers
					}
					Set tFilter.position = n
					Set pInfo(n) = $LB(tFilterList(i,j),tFilter.spec,tFilter.key,tFilter.text,,,tFilterValue)

					#; Set context for next filter
					#; assume that filters are grouped and displayed in level order
					If (tFilter.key '= "") {
						// !!! no longer used?
						Set tContext = $LB(tFilter.spec,tFilter.key)
					}
				}
				Set j = $O(tFilterList(i,j))
			}
			If $$$ISERR(tSC) Quit
			Set i = $O(tFilterList(i))
		}
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%CreateResultSet">
<Description><![CDATA[
Create the DeepSee ResultSet needed to get data for this table.<br/>
Does not execute the query.<br/>
<var>pSC</var> is a status code.<br/>
<var>pParms</var> is an array of input parameter values.<br/>
<var>pFilterInfo</var> is an array of filter details.<br/>
<var>pAdvancedFilters</var> is an array of advanced filter details.<br/>
<var>pAxes</var> is an array of top nodes for each axis.<br/>
<var>pDataReady</var> is true if the query results are in the cache.<br/>
<var>pQueryText</var> is the text of the query.<br/>
<var>pComplexQuery</var> is true if this is a "complex" query that should have its axes executed first.<br/>]]></Description>
<FormalSpec><![CDATA[*pSC:%Status,&pParms,&pFilterInfo,&pAdvancedFilters,*pQueryText:%String,*pAxes,*pDataReady:%Boolean,*pComplexQuery:%Boolean,pExecuteBaseQuery:%Boolean=0]]></FormalSpec>
<ReturnType>%DeepSee.ResultSet</ReturnType>
<Implementation><![CDATA[
	Set pSC = $$$OK
	Set tRS = ""

	Try {
		Set pComplexQuery = 0
		Set pQueryText = ""
		Set tMeasureCount = 0
		Set tSingleSimpleMeasure = 0

		// invoke callback
		Set tRS = ""
		Set pSC = ..%OnCreateResultSet(.tRS, .pParms)
		If $$$ISERR(pSC) Quit
		Set tCubeName = $$$ZENVAL(..cubeName)

		If (tRS = "") {
			// DTB595 - Create a resultset object and find the current MDX text
			Set tMDX = ..SynthesizeMDX(.pSC, .tRS, .pParms, .pFilterInfo, .pAdvancedFilters, .pQueryText, .pAxes, .pDataReady, .pComplexQuery, pExecuteBaseQuery)
			If $$$ISERR(pSC) Quit
		} 

		If (tMDX '= "") {
			// Use query
			Set pQueryText = tMDX
			Set ^DeepSee.LastQuery = tMDX
			Set tSC = tRS.%SetListing(..listing)
			If $$$ISERR(pSC) Quit

			// + WAL075
			Set tSC = ..SetCurrentQueryText("current",tMDX)
			If $$$ISERR(tSC) Quit
			Set tSC = ..SetCurrentQueryText("resolved",tMDX)
			If $$$ISERR(tSC) Quit
			// - WAL075

			// JMD1276: assemble list of pivot variables
			// test for overrides
			Kill tVariables
			If (..cubeName'="") {
				// DTB572 - Always assemble the list of available variables
				Set pSC = ##class(%DeepSee.Utils).%GetPivotVariables(..cubeName,.tVariableList)
				If $$$ISERR(pSC) Quit
				Set vk = $O(tVariableList(""))
				While (vk'="") {
					Set tVName = $$$LOWER($LG(tVariableList(vk),1))
					Set tVDefValue = $LG(tVariableList(vk),3)
					Set tVariables(tVName) = tVDefValue
					Set tVRuntime = ..pivotVariables.GetAt(tVName)
					Set:tVRuntime'="" tVariables(tVName) = tVRuntime
					Set vk = $O(tVariableList(vk))
				}
			}
			Set pSC = tRS.%PrepareMDX(tMDX,.tVariables,.tResolvedMDX)
			If $$$ISERR(pSC) Quit
			
			// + WAL075
			Set tSC = ..SetCurrentQueryText("resolved",tResolvedMDX)		// DTB411 - Set resolved text
			If $$$ISERR(tSC) Quit
			// - WAL075

			Set ..cubeName = tRS.%GetCubeName()
			Set ..cubeKey = $$$DeepSeeIndex(..cubeName)
		}
	}
	Catch(ex) {
		Set pSC = ex.AsStatus()
	}
	
	Set:$$$ISERR(pSC) tRS = ""
	Quit tRS
]]></Implementation>
</Method>

<Method name="%OnCreateResultSet">
<Description><![CDATA[
This callback is invoked when the pivot table is about to
create a result set.<br/>
If the callback creates a <class>%DeepSee.ResultSet</class> object and returns it
via <var>pRS</var>, then the pivot table will use this result set to display results.]]></Description>
<FormalSpec><![CDATA[*pRS:%DeepSee.ResultSet,&pParms]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%CountMeasures">
<Description>
Return the total number of measures and how many are computed measures.</Description>
<Internal>1</Internal>
<FormalSpec>*pMeasures:%Integer,*pComputedMeasures:%Integer</FormalSpec>
<Implementation><![CDATA[
	Set pComputedMeasures = 0
	Set pMeasures = ..measures.Count()
	If (..cubeName="") Quit
	Set tCube = $$$UPPER(..cubeName)

	For n=1:1:pMeasures {
		// see if this is a computed measure
		Set tMeasure = ..measures.GetAt(n)
		
		Set tSpec = $$$UPPER(tMeasure.spec)
		If ($P(tSpec,"[MEASURES].",1)="") {
			Set tName = $P(tSpec,"[MEASURES].",2,999)
			// unescape
			If ($E(tName,1)="[") {
				Set tName = $E(tName,2,$L(tName)-1)
			}
			If (tName'="") {
				If ($D($$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs","MEASURES",tName))) {
					Set pComputedMeasures = pComputedMeasures + 1
				} ElseIf (..calculatedMembers.Count()) {
					// DTB064: This is not defined in the cube--check for any calculated members stored with the table
					For k=1:1:..calculatedMembers.Count() {
						Set tCalcMemberName = $$$UPPER(..calculatedMembers.GetAt(k).memberName)
						Set:(tName=tCalcMemberName) pComputedMeasures = pComputedMeasures + 1	
		 			}	
				}
			}
		} ElseIf ($P($$$UPPER(tSpec),"[%QUALITYMEASURE].",1)="") {
			// DTB064: All quality measures are assumed to be computed
			Set pComputedMeasures = pComputedMeasures + 1
		}
	}
]]></Implementation>
</Method>

<Method name="%CollectMeasures">
<FormalSpec>pQueryKey:%String,*pCollectedMeasures:%String,pListingFilters:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// + WAL190 -- collect measures
	Set r1 = +$P(..selectedRange,",",1)
	Set c1 = +$P(..selectedRange,",",2)
	Set r2 = +$P(..selectedRange,",",3)
	Set c2 = +$P(..selectedRange,",",4)
	
	For i=r1:1:r2 {
		Set tTempObj = ##class(%ZEN.proxyObject).%New()
		// this.GetItemSpec(itemInfo,this.cubeName,this.queryKey,this.sortDir,this.sortColumn,tgtType,itemno,1);
		Set tSC = ..GetItemSpec(.tTempObj,..cubeName,pQueryKey,..sortDir,..sortColumn,"row",i,1)
		Set:tTempObj.measureLogical'="" pCollectedMeasures(tTempObj.measureLogical)=""
	}
	For i=c1:1:c2 {
		Set tTempObj = ##class(%ZEN.proxyObject).%New()
		// this.GetItemSpec(itemInfo,this.cubeName,this.queryKey,this.sortDir,this.sortColumn,tgtType,itemno,1);
		Set tSC = ..GetItemSpec(.tTempObj,..cubeName,pQueryKey,..sortDir,..sortColumn,"col",i,1)
		Set:tTempObj.measureLogical'="" pCollectedMeasures(tTempObj.measureLogical)=""
	}

	// Prune the list if we only want measures with listing filters	
	If (pListingFilters) {
		Set tMeasureName = $O(pCollectedMeasures(""))
		While (tMeasureName'="") {
			Set tCalcName = $G($$$DeepSeeMetaGLVN("cubes",..cubeName,"calcMbrs","MEASURES",$$$UPPER(tMeasureName)))
			If (tCalcName'="") {
				Set tListingFilter = $LG($$$DeepSeeMetaGLVN("cubes",..cubeName,"calcMbrs","MEASURES",$$$UPPER(tMeasureName)),6)
				If (tListingFilter'="") {
					Set pCollectedMeasures(tMeasureName,"calcListingFilter") = tListingFilter
				}
				Else {
					Kill pCollectedMeasures(tMeasureName)
				}
			}
			Else {
				// WAL232 -- use more granular metadata location to distinguish between measures that have the same
				//           source property
				Set tMsrInfo = $G($$$DeepSeeMetaGLVN("cubes",..cubeName,"mbrs","MEASURES",$$$UPPER(tMeasureName))) // WAL234
				If (tMsrInfo'="") {
				Set tMsrNumber = $LG(tMsrInfo,2)
					If (tMsrNumber'="") {
						Set tMsrInfo = $$$DeepSeeMetaGLVN("cubes",..cubeName,"mbr#",0,tMsrNumber,0)
						// PFS019 - Use nodes 15 and 16
						Set tListingFilterOperator = $LG(tMsrInfo,15)
						Set tListingFilter = $LG(tMsrInfo,16)
						// WAL232 -- fix typo
						If ((tListingFilter = "")&&((tListingFilterOperator'="MAX")&&(tListingFilterOperator'="MIN"))) { // WAL190 (2)
							Kill pCollectedMeasures(tMeasureName)	
						}
						Else {
							Set pCollectedMeasures(tMeasureName,"listingFilter")=tListingFilter
							Set pCollectedMeasures(tMeasureName,"listingFilterOperator")=tListingFilterOperator
						}	
					}
					Else {
						Kill pCollectedMeasures(tMeasureName)
					}
				}
			}
			Set tMeasureName = $O(pCollectedMeasures(tMeasureName))
		}	
	}
	// - WAL190
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%HideMeasures">
<Description>
Return true if the Measures setting stipulates the measures should be hidden from view.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB175 - Reusable implementation of WAL114 logic
	Set tHideMeasures=0
	Try {
		If (..hideMeasures) {
			// Hide only when 1 measure
			If (..hideMeasures = 1) {
				Do ..%CountMeasures(.tMeasureCount)
				If (tMeasureCount=1) {
					Set tHideMeasures = 1
				}
			}
			// Hide always
			ElseIf (..hideMeasures = 2) {
				Set tHideMeasures = 1
			}
		}
	}
	Catch {
	}

	Quit tHideMeasures
]]></Implementation>
</Method>

<Method name="%GetWhereClause">
<Description>
Construct the MDX WHERE clause for the pivot table.</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[&pFilterInfo]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tClause = ""

	// use new %NOT function
	Set tUseNOT = 1

	// use new %OR function
	Set tUseOR = 1

	// assemble slicer from filters & measure
	Set tParenCount = 0

	// count items in slicer
	Set tTermCount = 0

	// JMD866: Do not add measures to WHERE clause;
	// They will either be in %FILTER or in the COLUMNS axis

	Set n = $O(pFilterInfo(""))
	While (n '= "") {
		Set tValue = $LG(pFilterInfo(n),3)
		Set tIsMsr = +$LG(pFilterInfo(n),5)
		If ((tValue '= "")||(tIsMsr)) {
			Set tTermCount = tTermCount + 1
		}
		Set n = $O(pFilterInfo(n))
	}

	If (tTermCount > 0) {
		Set tCount = 0

		// now loop over filter terms
		Set n = $O(pFilterInfo(""))
		While (n '= "") {
			Set tSpec = $LG(pFilterInfo(n),2)
			Set tValue = $LG(pFilterInfo(n),3)
			Set tIsMsr = +$LG(pFilterInfo(n),5)

			// strip function off end of spec, if present
			If ($P($$$UPPER(tSpec),".",$L(tSpec,"."))="MEMBERS") {
				Set tSpec = $P($$$UPPER(tSpec),".",1,$L(tSpec,".")-1)
			}
			ElseIf ($P($$$UPPER(tSpec),".",$L(tSpec,"."))="ALLMEMBERS") {
				Set tSpec = $P($$$UPPER(tSpec),".",1,$L(tSpec,".")-1)
			}

			// test for NO RELATION member!
			Set tNullRef = ""
			Set tDim = $P($$$UPPER(tSpec),".",1)
			Set:$E(tDim)="[" tDim = $E(tDim,2,*-1)
			If (..cubeName'="") {
				Set tNullRef = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(..cubeName),"relations",$$$UPPER(tDim),"nullReplacement"))
				If (tNullRef'="") {
					Set tNullRef = "&["_$$$UPPER(tNullRef) _ "]"
					Set tDim = "["_tDim_"]"
				}
			}

			If ((tValue '= "")||(tIsMsr)) {
				Set tCount = tCount + 1
				If (tCount > 1) {
					Set tClause = tClause _ ","
				}

				If (tTermCount > tCount) {
					Set tClause = tClause _ "NONEMPTYCROSSJOIN("
					Set tParenCount = tParenCount + 1
				}

				If ('tIsMsr) {
					Set tIsNot = 0
					If ($E(tValue,1,5)="%NOT ") {
						Set tValue = $E(tValue,6,$L(tValue))
						Set tIsNot = 1
					}

					If ($E(tValue,1,2)="&[") {
						If ('tIsNot) {
							If ($$$UPPER(tValue)=tNullRef) {
								Set tClause = tClause _ tDim_"."_tNullRef
							}
							Else {
								If (tUseOR && (tValue["]:&[")) {
									Set tClause = tClause _ "%OR("_tSpec_"."_tValue_")"
								}
								Else {
									Set tClause = tClause _ tSpec_"."_tValue
								}
							}
						}
						Else {
							If (tUseNOT) {
								If ($$$UPPER(tValue)=tNullRef) {
									Set tClause = tClause _ tDim_"."_tNullRef_".%NOT"
								}
								Else {
									Set tClause = tClause _ tSpec_"."_tValue_".%NOT"
								}
							}
							Else {
								If ($$$UPPER(tValue)=tNullRef) {
									Set tClause = tClause _ "EXCEPT("_tSpec_".Members,"_tDim_"."_tNullRef_")"
								}
								Else {
									Set tClause = tClause _ "EXCEPT("_tSpec_".Members,"_tSpec_"."_tValue_")"
								}
							}

						}
					}
					ElseIf ($E(tValue,1)="{") {
						// split value
						Set tValue = $E(tValue,2,$L(tValue)-1)

						Set tKeySet = ""
						Set tLength=$L(tValue,"],&[") ; JSL4424
						For x = 1:1:tLength {
							// v is not quite the original key because the $P strips off &[ unless first key and ] unless last key
							Set v = $P(tValue,"],&[",x)
							;Set:($E(v)="&")&&($L(tValue,"],&[")'=x) v = v_"]" // JSL4424, tenative solution
							Set:$E(v)'="&" v = "&["_v ; the code in the $PIECE strips off "&[" of the next element and here we add it back on - JSL
							;Set:$E(v,$L(v))'="]" v = v_"]" comment out this line of Joe's code JSL4424
							Set:tLength'=x v=v_"]" ; $PIECE stripped it off, this puts it back on JSL4424
							If ($$$UPPER(v)=tNullRef) {
								Set tKeySet = tKeySet _ $S(tKeySet="":"",1:",") _ tDim_"."_tNullRef
							}
							Else {
								Set tKeySet = tKeySet _ $S(tKeySet="":"",1:",") _ tSpec_"."_v
							}
						}
						Set tKeySet = "{"_tKeySet_"}"
						If ('tIsNot) {
							If (tUseOR) {
								Set tClause = tClause _ "%OR("_tKeySet_")"
							}
							Else {
								Set tClause = tClause _ tKeySet
							}
						}
						Else {
							// + WAL034
							Set tNotSet = $E(tKeySet,2,*-1)
							For i=1:1:$L(tNotSet,",") {
								Set tClause = tClause _ $s(i=1:"(",1:",") _ $p(tNotSet,",",i) _ ".%NOT"
							}
							Set tClause = tClause _ ")"
							// - WAL034
						}
					}
					Else {
						// tValue is one or more KEY values for the current level
						// JMD951 -- these should be ANDed not ORed
						Set p = $L(tValue,"~~")
						If (p = 1) {
							Set tClause = tClause _ tSpec_".&["_$$$dsEscapeIdent(tValue)_"]"
						}
						Else {
							Set tClause = tClause _ "("
							For vp = 1:1:p {
								Set t = $P(tValue,"~~",vp)
								Set tClause = tClause _ $S(vp>1:",",1:"") _ tSpec_".&["_$$$dsEscapeIdent(t)_"]"
							}
							Set tClause = tClause _ ")"
						}
					}
				}
				Else {
					Set tClause = tClause _ tSpec_$S(tIsMsr:"",1:".["_tValue_"]")
				}
			}
			Set n = $O(pFilterInfo(n))
		}
	}

	If (tParenCount > 0) {
		// close parens
		Set tClause = tClause _ $TR($J(")",tParenCount)," ",")")
	}
	Quit tClause
]]></Implementation>
</Method>

<Method name="%GetAxisClauseFromLevels">
<Description>
Convert an array of pivot levels into an MDX axis clause
that will serve as part of the query executed for the pivot.</Description>
<Internal>1</Internal>
<FormalSpec>pLevels:%AbstractList,pShowEmpty:%Boolean=0,*pComplexQuery:%Boolean,pDrillLevel:%Integer="",pMaxItems:%Integer="",pShowAll:%Boolean=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tClause = ""
	Set tItemCount = pLevels.Count()
	Set tHasJOIN = 0
	Set pComplexQuery = 0

	Set tCount = 0
	For n = 1:1:tItemCount {
		Set tLevel = pLevels.GetAt(n)
		If ((pDrillLevel'="")&&(tLevel.drillLevel'=pDrillLevel)) {
			Continue
		}
		Set tCount = tCount + 1

		If (tLevel.levelType = "space") {
			Set tSpec = "%SPACE()"
		}
		ElseIf (tLevel.levelType = "value") {
			Set tSpec = tLevel.value
		}
		ElseIf (tLevel.levelType = "mdx") {
			// JMD1276: check for pivot variable
			If ($$$LOWER($E(tLevel.value,1,10))="$variable.") {
				Set tVarName = $E(tLevel.value,11,*)
				// only use if context is expression
				Kill tVInfo
				Do ##class(%DeepSee.Utils).%GetPivotVariableInfo(..cubeName,tVarName,.tVInfo)
				If ($G(tVInfo("context"))="expression") {
					Set tSpec = tLevel.value
				}
				Else {
					Set tSpec = ""
				}
			}
			Else {
				Set tSpec = tLevel.value
			}
		}
		Else {
			// value, text, spec
			Set tSpec = tLevel.spec

			// apply SET functions, if any
			If (tLevel.filterEnabled) {
				Set tSpec = "FILTER(" _ tSpec
				Set tExpr = tLevel.filterExpression
				Set:tExpr="" tExpr = "1"

				Set tSpec = tSpec _ "," _ tExpr
				Set tSpec = tSpec _ ")"
			}

			If (tLevel.orderEnabled) {
				Set tSpec = "ORDER(" _ tSpec
				Set tExpr = tLevel.orderExpression
				Set tCountName = ##class(%DeepSee.Utils).%GetCountName(..cubeName,.tSC)
				Set:tExpr="" tExpr = "MEASURES.["_$S(tCountName="":"%COUNT",1:tCountName)_"]"

				Set tDirection = tLevel.orderDirection
				Set:tDirection="" tDirection = "BDESC"

				Set tSpec = tSpec _ "," _ tExpr
				Set tSpec = tSpec _ "," _ tDirection
				Set tSpec = tSpec _ ")"
			}
			If (tLevel.headEnabled) {
				Set tSpec = "HEAD(" _ tSpec
				Set:((+tLevel.headCount)>1) tSpec = tSpec _ "," _ tLevel.headCount
				Set tSpec = tSpec _ ")"
			}
			If (($P($$$UPPER(tLevel.spec),".",1)="[MEASURES]")&&(tLevel.aggFunction'="")) {
				// apply aggregate to measure
				Set tSpec = tSpec _ "." _ tLevel.aggFunction
			}
			
			// DTB268 - Check for shared items. Strip any %SHAREDx token if present
			If $$$UPPER(tLevel.spec["%SHARED") {
				// DTB715 - Snip the %SHARED token from the spec
				Set tSpecAsList = $ListFromString(tLevel.spec,".")
				For n = 1:1:$LL(tSpecAsList) {
					If $$$UPPER($LG(tSpecAsList,n)["%SHARED") {
						Set tSpecAsList = $LI(tSpecAsList,1,n-1)_$LI(tSpecAsList,n+1,*)
					}
				}
				Set tSpec = $ListToString(tSpecAsList,".")
			}
		}

		If (tLevel.childLevels.Count() > 0) {
			Set tSubClause = ..%GetAxisClauseFromLevels(tLevel.childLevels,pShowEmpty,.tComplexQuery,,,pShowAll)		// DTB835
			If (pShowEmpty) {
				Set tSpec = "CROSSJOIN("_tSpec_","_tSubClause_")"
			}
			Else {
				Set tSpec = "NONEMPTYCROSSJOIN("_tSpec_","_tSubClause_")"
			}
			Set pComplexQuery = 1
			Set tHasJOIN = 1
		}

		// JMD861 Apply aggregate *after* processing child levels
		If (tLevel.aggEnabled && (tLevel.aggFunction'="") && ($P($$$UPPER(tLevel.spec),".",1)'="[MEASURES]")) {
			If (($$$UPPER(tLevel.aggFunction)="PERCENTILE") && (tLevel.aggFunctionParm'="")) {
				// make sure 2nd argument is present!
				Set tSpec = tLevel.aggFunction _ "(" _ tSpec _ ",,"_tLevel.aggFunctionParm_")"
			}
			ElseIf (($$$UPPER(tLevel.aggFunction)="COUNT NONEMPTY")) {
				Set tSpec = "COUNT(" _ tSpec _ ",EXCLUDEEMPTY)"
			}
			Else {
				Set tSpec = tLevel.aggFunction _ "(" _ tSpec _ ")"
			}
		}

		// JMD861: tack on label after all else
		If ((tLevel.levelCaption'="")||(tLevel.levelFormat'="")||(tLevel.levelStyle'="")||(tLevel.levelHeaderStyle'="")||(tLevel.levelSummary'="")) {
			Set tSpec = "%LABEL(" _ tSpec _ ","_ $$$quote(tLevel.levelCaption) _ ","_ $$$quote(tLevel.levelFormat)
			// JMD: tack summary onto style
			Set tLevelStyle = tLevel.levelStyle
			Set:(tLevel.levelSummary'="") tLevelStyle = tLevelStyle_"summary:"_tLevel.levelSummary_";"
			Set:(tLevelStyle'="") tSpec = tSpec _ ",,"_ $$$quote(tLevelStyle)
			Set:(tLevel.levelHeaderStyle'="") tSpec = tSpec _ $S((tLevel.levelStyle=""):",,,",1:",")_ $$$quote(tLevel.levelHeaderStyle)
			Set tSpec = tSpec _ ")"
		}


		Set tClause = tClause _ $S(tCount>1:",",1:"") _ tSpec
	}

	If (tCount>1) {
		Set tClause = "{" _ tClause _ "}"
	}
	
	// JMD1129
	// DTB701 - Consider previewMode setting
	// DTB835 - Add override to include all results in exports
	If 'pShowAll && ((tHasJOIN && +pMaxItems)||..previewMode) {
		Set ..headFunctionAdded = 1		// DTB201 - Track the addition of the HEAD function
		Set tClause = "HEAD("_tClause_","_$S(..previewMode:..previewRowCount,1:pMaxItems)_",SAMPLE)"		// DTB326 - Use flag for fast results		// DTB - Change to 25
	}
	Else {
		Set ..headFunctionAdded = 0
	}

	Quit tClause
]]></Implementation>
</Method>

<Method name="ProcessLevels">
<Description><![CDATA[
Convert array of levels (from <var>pStart</var>) into a parse tree
that can be handed to a query.]]></Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[pList:%AbstractList,pStart:%Integer,&pTree,pParent:%Integer]]></FormalSpec>
<Implementation><![CDATA[
	#; either make a set of the first item
	#; or make it a set and join it with the next item
	If (pStart = pList.Count()) {
		#; last item: set
		Set tName = pList.GetAt(pStart).spec
		Set pTree(pTree) = $LB("set")
		Set pTree(pParent,"ch",pTree) = ""
		Set pTree(pTree,"ch",$I(pTree)) = ""
		Set pTree(pTree) = $LB("dim",tName)
	}
	Else {
		#; join
		Set pTree(pTree) = $LB("join")
		Set pTree(pParent,"ch",pTree) = ""
		Set tJoinParent = pTree
		Set x = $I(pTree)

		#; make set for this item
		Set tName = pList.GetAt(pStart).spec
		Set pTree(pTree) = $LB("set")
		Set pTree(tJoinParent,"ch",pTree) = ""
		Set pTree(pTree,"ch",$I(pTree)) = ""
		Set pTree(pTree) = $LB("dim",tName)
		Set x = $I(pTree)

		#; join in rest of list
		Do ..ProcessLevels(pList,pStart+1,.pTree, tJoinParent)
	}
]]></Implementation>
</Method>

<Method name="cellMouseDownHandler">
<Description>
Mouse down within a cell.
Try to prevent text select when selecting multiple cells.</Description>
<FormalSpec>evt</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	if (evt.shiftKey && evt.preventDefault) {
		evt.preventDefault();
	}
	return true;
]]></Implementation>
</Method>

<Method name="cellClickHandler">
<Description><![CDATA[
Notification that a cell is clicked.<br/>
<var>row</var> and <var>col</var> give the ordinal (logical) position of the cell.]]></Description>
<FormalSpec>evt,row,col</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	if (evt.shiftKey && '' != this.selectedRange) {
		// expand range
		var p = this.selectedRange.split(',');
		p[0] = (row < p[0]) ? row : p[0];
		p[1] = (col < p[1]) ? col : p[1];
		p[2] = (row > p[2]) ? row : p[2];
		p[3] = (col > p[3]) ? col : p[3];
		this.selectCellRange(p[0],p[1],p[2],p[3],false,false);
	}
	else {
		this.selectCellRange(row,col,row,col,false,false);
	}
	this.updateToolbar();
	zenInvokeCallbackMethod(this.oncellClick,this,'oncellClick','pivot',this);
	return true;
]]></Implementation>
</Method>

<Method name="cellDblClickHandler">
<Description><![CDATA[
Notification that a cell is double-clicked.<br/>
<var>row</var> and <var>col</var> give the ordinal position of the cell.]]></Description>
<FormalSpec>evt,row,col</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	zenInvokeCallbackMethod(this.oncellDblClick,this,'oncellDblClick','pivot',this);
	return true;
]]></Implementation>
</Method>

<Method name="columnClickHandler">
<Description><![CDATA[
Notification that a column header is clicked.<br/>]]></Description>
<FormalSpec>evt,col</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	if (evt.shiftKey && '' != this.selectedRange) {
		return this.cellClickHandler(evt,1,col);
	}
	this.selectCellRange(1,col,this.rowCount,col,true,false);
	zenInvokeCallbackMethod(this.oncellClick,this,'oncellClick','pivot',this);
	this.updateToolbar();
	return true;
]]></Implementation>
</Method>

<Method name="columnDblClickHandler">
<Description><![CDATA[
Notification that a column header is double-clicked.<br/>]]></Description>
<FormalSpec>evt,col</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	// sort by column
	if (col != this.sortColumn) {
		this.sortColumn = col;
		this.sortDir = 'ASC';
	}
	else if ('ASC'==this.sortDir) {
		this.sortDir = 'DESC';
	}
	else {
		this.sortColumn = 0;
		this.sortDir = 'ASC';
	}
	this.selectedRange = '';

	// JMD1462
	this.showMessage($$$Text('sorting...'),'',true);
	this.deferredExecuteQuery(true);
	return true;
]]></Implementation>
</Method>

<Method name="listingHeaderDblClickHandler">
<Description><![CDATA[
Notification that a listing header is double-clicked.<br/>]]></Description>
<FormalSpec>evt,col</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	// sort by column
	if (col != this.listingSortColumn) {
		this.listingSortColumn = col;
		this.listingSortDir = 'ASC';
	}
	else if ('ASC'==this.listingSortDir) {
		this.listingSortDir = 'DESC';
	}
	else {
		this.listingSortColumn = 0;
		this.listingSortDir = 'ASC';
	}
	// JMD1331 reset paging
	this.currListingPage = -1;
	this.showMessage($$$Text('sorting...'),'',true);
	this.deferredExecuteQuery(true);
	return true;
]]></Implementation>
</Method>

<Method name="rowClickHandler">
<Description><![CDATA[
Notification that a row header is clicked.<br/>]]></Description>
<FormalSpec>evt,row</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	if (evt.shiftKey && '' != this.selectedRange) {
		return this.cellClickHandler(evt,row,1);
	}
	this.selectCellRange(row,1,row,this.columnCount,false,true);
	zenInvokeCallbackMethod(this.oncellClick,this,'oncellClick','pivot',this);
	this.updateToolbar();
	return true;
]]></Implementation>
</Method>

<Method name="rowDblClickHandler">
<Description><![CDATA[
Notification that a row header is double clicked.<br/>]]></Description>
<FormalSpec>evt,level,row</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	if (level == 1 && this.canDrillDown) {
		// only worry about lowest level

		// get spec for this item
		var itemInfo = new zenProxy();
		var ok = this.GetItemSpec(itemInfo,this.cubeName,this.queryKey,this.sortDir,this.sortColumn,'row',row,1); // WAL088 - note that itemno is already sorted
		if (!ok) {
			if (itemInfo.error) {
				alert(itemInfo.error);
			}
			return;
		}

		// JMD1311: see if there is a drilldownSpec for this item
		var drilldownSpec = itemInfo.childSpec;
		var dspec = this.rowAxisOptions.drilldownSpec;
		if (dspec) {
			if (dspec == 'none') {
				// no drill down
				return;
			}
			else {
				var t = dspec.toString().split('^');
				drilldownSpec = t[this.getDrillLevel()];
				drilldownSpec = drilldownSpec ? drilldownSpec : '';
			}
		}

		if (drilldownSpec == '' || drilldownSpec == 'none') {
			return;
		}

		this.pushState();

		// JMD1445: clear override for drill down
		// DTB745 - Keep the override in place. It will only be applied to the base level.
		//this.overrideRowSpec = '';
		//this.overrideRowText = '';

		// add a drill level
		if (itemInfo.spec != '') {
			var drill = zenPage.createComponentNS('http://www.intersystems.com/deepsee','pivotLevel');
			drill.spec = itemInfo.spec;
			drill.text = itemInfo.text;
			this.drillLevels[this.drillLevels.length] = drill;
			
			// WAL224 -- remember which row should be selected after returning from drill down
			this.drillRowNumbers[this.drillRowNumbers.length] = row;
		}

		// add a new row level
		var parm = zenPage.createComponentNS('http://www.intersystems.com/deepsee','pivotLevel');
		parm.spec = drilldownSpec;
		parm.text = itemInfo.text;
		parm.drillLevel = this.getDrillLevel();
		this.rowLevels[this.rowLevels.length] = parm;

		this.sortColumn = 0;
		this.sortDir = 'ASC';
		this.selectedRange = '';
		var ret = zenInvokeCallbackMethod(this.ondrill,this,'ondrill','pivot',this);
		if (!ret) {
			this.executeQuery(this.autoExecute);
		}
	}
	return true;
]]></Implementation>
</Method>

<Method name="selectCellRange">
<Description><![CDATA[
Set the selected cell range. Addresses are 1-based.<br/>]]></Description>
<FormalSpec>startRow,startCol,endRow,endCol,allRows,allCols,selectOnly</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	allRows = 'undefined' == typeof allRows ? false : allRows;
	allCols = 'undefined' == typeof allCols ? false : allCols;
	selectOnly = 'undefined' == typeof selectOnly ? false : selectOnly;

	// unselect current range
	if (!selectOnly && ('' != this.selectedRange)) {
		var p = this.selectedRange.split(',');
		for (var r = parseInt(p[0]); r <= parseInt(p[2]); r++) {
			for (var c = parseInt(p[1]); c <= parseInt(p[3]); c++) {
				var cell = this.findElement('cell_'+r+'_'+c);
				if (cell) {
					var color = cell._oldColor ? cell._oldColor : '';
					cell.style.color = color;
					cell._oldcolor = null;		// PFS018
					var bg = cell._oldBackground ? cell._oldBackground : '';
					cell.style.background = bg;
					cell._oldBackground = null;		// PFS018
				}
			}
		}
	}

	var total = 0;
	var cellCount = 0;

	if ('' == startRow) {
		this.selectedRange = '';
	}
	else {
		this.selectedRange = startRow + ',' + startCol + ',' + endRow + ',' + endCol + ',' + (allRows?1:0) + ',' + (allCols?1:0);
		var p = this.selectedRange.split(',');
		for (var r = parseInt(p[0]); r <= parseInt(p[2]); r++) {
			for (var c = parseInt(p[1]); c <= parseInt(p[3]); c++) {
				var cell = this.findElement('cell_'+r+'_'+c);
				if (cell) {
					cellCount++;
					if (cell.getAttribute && cell.getAttribute('zenValue')) {
						total += parseFloat(cell.getAttribute('zenValue'));
					}
					// PFS018 - Store old values if they are null, which means this cell is not currently selected
					if (cell._oldColor == null) {
						cell._oldColor = cell.style.color ? cell.style.color : '';
					}
					if (cell._oldBackground == null) {
						cell._oldBackground = cell.style.background ? cell.style.background : '';
					}
					cell.style.color = this.selectedCellColor;
					cell.style.background = this.selectedCellBackground;
				}
			}
		}
	}

	// update status area
	var format = ('number'!=typeof total) ? '' : (total == parseInt(total,10)) ?  '#,#' : '#,#.##';
	if (isNaN(parseInt(total,10))) {
		this.totalValue = '';
	}
	else {
		this.totalValue = zenFormatNumber(total,format);
	}
	this.cellCount = zenFormatNumber(cellCount,'#,#');
	var span = this.findElement('total');
	if (span) {
		span.innerHTML = this.totalValue;
	}
	var span = this.findElement('cellCount');
	if (span) {
		span.innerHTML = this.cellCount;
	}
]]></Implementation>
</Method>

<Method name="getPageCount">
<Description>
For multi-page display, calculate the number of pages.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var rc = parseInt(this.rowCount,10);
	if (!isNaN(rc) && rc > 0 && this.pageSize > 0) {
		return Math.floor(rc / this.pageSize) + ((rc % this.pageSize) ? 1 : 0);
	}
	return 1;
]]></Implementation>
</Method>

<Method name="getListingPageCount">
<Description>
For multi-page listing display, calculate the number of pages.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var rc = parseInt(this.listingRowCount,10);
	if (!isNaN(rc) && rc > 0 && this.listingPageSize > 0) {
		return Math.floor(rc / this.listingPageSize) + ((rc % this.listingPageSize) ? 1 : 0);
	}
	return 1;
]]></Implementation>
</Method>

<Method name="previousPage">
<Description>
For multi-page display, go to previous page, if possible.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this.isDrillThrough) {
		if (this.currListingPage > 1) {
			this.currListingPage--;
			this.isPaging = true;
			this.showMessage($$$Text('working...'),'',true);
			this.deferredExecuteQuery();
		}
	}
	else {
		if (this.currPage > 1) {
			this.currPage--;
			this.isPaging = true;
			this.executeQuery();
		}
	}
]]></Implementation>
</Method>

<Method name="nextPage">
<Description>
For multi-page display, go to next page, if possible.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this.isDrillThrough) {
		if (this.currListingPage < this.getListingPageCount()) {
			this.currListingPage++;
			this.isPaging = true;
			this.showMessage($$$Text('working...'),'',true);
			this.deferredExecuteQuery();
		}
	}
	else {
		if (this.currPage < this.getPageCount()) {
			this.currPage++;
			this.isPaging = true;
			this.executeQuery();
		}
	}
]]></Implementation>
</Method>

<Method name="firstPage">
<Description>
For multi-page display, go to the first page.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this.isDrillThrough) {
		if (1 != this.currListingPage) {
			this.currListingPage = 1;
			this.isPaging = true;
			this.showMessage($$$Text('working...'),'',true);
			this.deferredExecuteQuery();
		}
	}
	else {
		if (1 != this.currPage) {
			this.currPage = 1;
			this.isPaging = true;
			this.executeQuery();
		}
	}
]]></Implementation>
</Method>

<Method name="lastPage">
<Description>
For multi-page display, go to the last page.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this.isDrillThrough) {
		if (this.getListingPageCount() != this.currListingPage) {
			this.currListingPage = this.getListingPageCount();
			this.isPaging = true;
			this.showMessage($$$Text('working...'),'',true);
			this.deferredExecuteQuery();
		}
	}
	else {
		if (this.getPageCount() != this.currPage) {
			this.currPage = this.getPageCount();
			this.isPaging = true;
			this.executeQuery();
		}
	}
]]></Implementation>
</Method>

<Method name="gotoPage">
<Description>
For multi-page display, go to specified page (1 is first page), if possible.</Description>
<FormalSpec>page</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	page = parseInt(page);
	if (page >= 1 && page != this.currPage && page <= this.getPageCount()) {
		this.currPage = page;
		this.isPaging = true;
		this.executeQuery();
	}
]]></Implementation>
</Method>

<Method name="setProperty">
<Description><![CDATA[
Set the value of a named property.<br>]]></Description>
<FormalSpec>property,value,value2</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	switch(property) {
	case 'showStatus':
	case 'pivot':
	case 'rowTotals':
	case 'columnTotals':
	case 'showEmptyRows':
	case 'showEmptyColumns':
	case 'rowLabelSpan':
	case 'columnLabelSpan':
		value = value ? true : false;
		if (this[property] != value) {
			this[property] = value;
			this.executeQuery();
		}
		break;

	case 'currPage':
		// alternate API for going to a page (within this table)
		this.gotoPage(value);
		break;

	case 'pageSize':
		if (value != this.pageSize) {
			this.currPage = 1; // go back to start
			this.selectedRange = '';
			this.pageSize = value;
			this.executeQuery();
		}
		break;

	case 'colorScale':
		if (value != this.colorScale) {
			this.selectedRange = '';
			this.colorScale = value;
			this.executeQuery();
		}
		break;

	case 'rowTotalSource':
	case 'showZebra':
	case 'showRowCaption':
	case 'evenRowStyle':
	case 'cellStyle':
	case 'columnHeaderStyle':
	case 'rowHeaderStyle':
	case 'rowTotalAgg':
	case 'columnTotalAgg':
	case 'cellWidth':
	case 'cellHeight':
	case 'backgroundImage':
	case 'backgroundOpacity':
		if (this[property] != value) {
			this[property] = value;
			this.executeQuery();
		}
		break;

	case 'text':
	case 'value':
		// readonly
		break;

	default:
		// dispatch
		return this.invokeSuper('setProperty',arguments);
	}
	return true;
]]></Implementation>
</Method>

<Method name="dragStartHandler">
<Description>
Built-in drag handler for pivot table component.
Let the user drag the selected node.</Description>
<FormalSpec>dragData</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var ok = false;

	// drag item is type:#
	var dragItem = this._dragSource;

	if (null != dragItem) {
		dragData.sourceItem = dragItem;
		delete this._dragSource;

		var t = dragItem.split(':');
		var n = t[1] - 1;
		var tgtType = t[0];

		switch(tgtType) {
		case 'rowLevel':
			if (this.rowLevels[n]) {
				ok = true;
				dragData.value = this.rowLevels[n].spec;
				dragData.text = this.rowLevels[n].text;
			}
			break;
		case 'colLevel':
			if (this.columnLevels[n]) {
				ok = true;
				dragData.value = this.columnLevels[n].spec;
				dragData.text = this.columnLevels[n].text;
			}
			break;
		case 'row':
		case 'col':
			break;
		case 'filter':
			if (this.filters[n]) {
				ok = true;
				dragData.value = this.filters[n].spec;
				dragData.text = this.filters[n].text;
			}
			break;	
		case 'measure':
			if (this.measures[0]) {
				ok = true;
				dragData.value = this.measures[0].spec;
				dragData.text = this.measures[0].text;
			}
			break;	
		}

		if (ok) {
			ZLM.setDragCaption(dragData.text);
		}
	}

	return ok;
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// + WAL102

]]></Content>
</UDLText>

<Method name="callGetItemSpec">
<Description>
Used to provide label related info when required.</Description>
<FormalSpec>labelInfo,rowItem,columnItem</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// get spec for this item
	var itemInfoRow = new zenProxy();
	var ok = this.GetItemSpec(itemInfoRow,this.cubeName,this.queryKey,this.sortDir,this.sortColumn,'row',rowItem,0);
	
	var itemInfoCol = new zenProxy();
	var ok = this.GetItemSpec(itemInfoCol,this.cubeName,this.queryKey,this.sortDir,this.sortColumn,'col',columnItem,0);
	
	// Replace %Search -- should only appear on rows
	labelInfo.rowCaption = itemInfoRow.tooltipText=='%Search' ? $$$Text('Series') : itemInfoRow.tooltipText;
	labelInfo.colCaption = itemInfoCol.tooltipText=='%Search' ? $$$Text('Series') : itemInfoCol.tooltipText;

	if (itemInfoRow.measure != '') {
		labelInfo.measure = itemInfoRow.measure;
	}
	else if (itemInfoCol.measure != '') {
		labelInfo.measure = itemInfoCol.measure;
	}
	else {
		labelInfo.measure = $$$Text("Value");	
	}
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// - WAL102

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// + WAL122

]]></Content>
</UDLText>

<Method name="callFormatValue">
<Description>
Used to provide label related info when required.</Description>
<FormalSpec>value,formattedValue,rowItem,columnItem</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	var ok = this.FormatValue(this.cubeName, this.queryKey, value, formattedValue, rowItem, columnItem);
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// - WAL122

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// + WAL118

]]></Content>
</UDLText>

<Method name="removeMeasureLabels">
<FormalSpec>values,measureCaption</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (values && measureCaption) {
		for (i=1; i < values.length; ++i) {
			var valueText = values[i].split('/');
			for (var j = 0; j < valueText.length; ++j) {
				if (this.hiddenMeasureText.length>=1) {
					for (var k = 0; k < this.hiddenMeasureText.length; ++k) {
						if (valueText[j] == this.hiddenMeasureText[k]) {
							valueText.splice(j,1);	
							break;
						}
					}
				}
				else if (valueText[j] == measureCaption) {
					valueText.splice(j,1);	
					break;	
				}
			}
			values[i] = valueText.join('/');	
		}
	}
	return values;
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// - WAL118

]]></Content>
</UDLText>

<Method name="dropStartHandler">
<Description>
Drop handler. This is called when an item is dropped onto the table.</Description>
<FormalSpec>dragData</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var value = dragData.value;
	var text = dragData.text;

	var tgtId = ZLM.getDragInnerDestination().id;
	if ('' == tgtId) {
		tgtId = ZLM.getDragInnerDestination().parentNode.id;
	}
	var tgtIndex = -1;
	var tgtType = '';
	var grpIndex = -1;

	if (tgtId) {
		if (tgtId.indexOf('rowdim_')!=-1) {
			tgtType = 'rowLevel';
			grpIndex = tgtId.split('_')[1];
			tgtIndex = tgtId.split('_')[2];
		}
		else if (tgtId.indexOf('coldim_')!=-1) {
			tgtType = 'colLevel';
			grpIndex = tgtId.split('_')[1];
			tgtIndex = tgtId.split('_')[2];
		}
		else if (tgtId.indexOf('row')!=-1) {
			tgtType = 'row';
			grpIndex = tgtId.split('_')[1];
			tgtIndex = tgtId.split('_')[2];
		}
		else if (tgtId.indexOf('col')!=-1) {
			tgtType = 'col';
			grpIndex = tgtId.split('_')[1];
			tgtIndex = tgtId.split('_')[2];
		}
		else if (tgtId.indexOf('filters')!=-1) {
			tgtType = 'filter';
		}
		else if (tgtId.indexOf('measure')!=-1) {
			tgtType = 'measure';
		}
		else if (tgtId.indexOf('filter_')!=-1) {
			tgtType = 'filter';
			tgtIndex = tgtId.split('_')[1];
		}
	}
	else if ('' == tgtId) {
		tgtType = 'rowLevel'; // we don't get an id for the nub!!!
	}
	dragData.targetItem = tgtIndex;

	// find dimension name
	var s = value.toString().split('.');
	var dimName = s[0] ? s[0].toUpperCase() : '';

	var changed = false;
	switch(tgtType) {
	case 'row':
		// drill into this item
		var t = grpIndex.toString().split(':');
		var levelno = t[0];
		var itemno = t[1];

		if (levelno > 1) {
			// drill down only works on lowest level
			break;
		}

		// WAL -- keep in mind that this is looking for a th, but we might need
		//           a different kind of element
		//           THEN AGAIN this might just seamlessly work since th is just a name
		// get unsorted item number
		var th = ZLM.getDragInnerDestination().parentNode;
		if (th && th.getAttribute('rowNo')) {
			itemno = th.getAttribute('rowNo');
		}

		// get spec for this item
		var itemInfo = new zenProxy();
		var ok = this.GetItemSpec(itemInfo,this.cubeName,this.queryKey,this.sortDir,this.sortColumn,tgtType,itemno,1);  // WAL088 - note that itemno is already sorted

		if (!ok) {
			if (itemInfo.error) {
				alert(itemInfo.error);
			}
			return;
		}

		this.pushState();

		// add a drill level
		if (itemInfo.spec != '') {
			var drill = zenPage.createComponentNS('http://www.intersystems.com/deepsee','pivotLevel');
			drill.spec = itemInfo.spec;
			drill.text = itemInfo.text;
			this.drillLevels[this.drillLevels.length] = drill;
			
			// WAL224 -- remember which row should be selected after returning from drill down
			this.drillRowNumbers[this.drillRowNumbers.length] = itemno;
		}

		// add a new row level
		var parm = zenPage.createComponentNS('http://www.intersystems.com/deepsee','pivotLevel');
		parm.spec = value;
		parm.text = text;
		parm.drillLevel = this.getDrillLevel();
		this.rowLevels[this.rowLevels.length] = parm;
		var ret = zenInvokeCallbackMethod(this.ondrill,this,'ondrill','pivot',this);
		if (!ret) {
			changed = true;
		}
		else {
			changed = false;
		}
		break;
	case 'col':
		break;
	case 'measure':
		if ((dimName == '[MEASURES]')||(dimName == 'MEASURES')) {
			this.pushState();
			if (this.measures[0]) {
				this.measures[0].spec = value;
				this.measures[0].text = text;
			}
			else {
				// create
				var msr = zenPage.createComponentNS('http://www.intersystems.com/deepsee','pivotLevel');
				msr.spec = value;
				msr.text = text;
				this.measures[0] = msr;
			}
			changed = true;
		}
		break;
	case 'rowLevel':
		this.pushState();
		if (tgtIndex > 0 && this.rowLevels[tgtIndex-1]) {
			this.rowLevels[tgtIndex-1].spec = value;
			this.rowLevels[tgtIndex-1].text = text;
		}
		else {
			// append
			var parm = zenPage.createComponentNS('http://www.intersystems.com/deepsee','pivotLevel');
			parm.spec = value;
			parm.text = text;
			this.rowLevels[this.rowLevels.length] = parm;
		}
		changed = true;
		break;
	case 'colLevel':
		this.pushState();
		if (tgtIndex > 0 && this.columnLevels[tgtIndex-1]) {
			this.columnLevels[tgtIndex-1].spec = value;
			this.columnLevels[tgtIndex-1].text = text;
		}
		else {
			// append
			var parm = zenPage.createComponentNS('http://www.intersystems.com/deepsee','pivotLevel');
			parm.spec = value;
			parm.text = text;
			this.columnLevels[this.columnLevels.length] = parm;
		}
		changed = true;
		break;
	case 'filter':
		if ((dimName != '[MEASURES]')&&(dimName != 'MEASURES')) {
			this.pushState();
			if (tgtIndex > 0 && this.filters[tgtIndex-1]) {
				this.filters[tgtIndex-1].spec = value;
				this.filters[tgtIndex-1].text = text;
				this.filters[tgtIndex-1].value = '';
				this.filters[tgtIndex-1].key = '';
			}
			else {
				// append
				var parm = zenPage.createComponentNS('http://www.intersystems.com/deepsee','pivotLevel');
				parm.spec = value;
				parm.text = text;
				this.filters[this.filters.length] = parm;
			}
			changed = true;
		}
		break;

	default:
		break;
	}

	if (changed) {
		this.sortColumn = 0;
		this.sortDir = 'ASC';
		this.selectedRange = '';
		this.executeQuery(this.autoExecute);
	}
	return true;
]]></Implementation>
</Method>

<Method name="dragFinishHandler">
<Description><![CDATA[
This is called when a drag operation started within this component is completed.<br/>]]></Description>
<FormalSpec>dragData</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// remove the dragged item
	// find what was dragged
	var srcId = ZLM.getDragInnerSource().id;
	var srcIndex = -1;
	var srcType = '';
	if (srcId) {
		if (srcId.indexOf('rowdim_')!=-1) {
			srcType = 'rowLevel';
			srcIndex = srcId.split('_')[2];
		}
		else if (srcId.indexOf('coldim_')!=-1) {
			srcType = 'colLevel';
			srcIndex = srcId.split('_')[2];
		}
		else if (srcId.indexOf('row')!=-1) {
			srcType = 'row';
		}
		else if (srcId.indexOf('col')!=-1) {
			srcType = 'col';
		}
		else if (srcId.indexOf('filters')!=-1) {
			srcType = 'filter';
		}
		else if (srcId.indexOf('measure')!=-1) {
			srcType = 'measure';
		}
		else if (srcId.indexOf('filter_')!=-1) {
			srcType = 'filter';
			srcIndex = srcId.split('_')[1];
		}
	}
	else if ('' == srcId) {
		srcType = 'rowLevel'; // !!! we don't get an id for the nub!!!
	}

	var changed = false;
	switch(srcType) {
	case 'rowLevel':
		if (srcIndex > 0 && this.rowLevels[srcIndex-1]) {
			this.pushState();
			changed = true;
			this.rowLevels.splice(srcIndex-1,1);
		}
		break;
	case 'colLevel':
		if (srcIndex > 0 && this.columnLevels[srcIndex-1]) {
			this.pushState();
			changed = true;
			this.columnLevels.splice(srcIndex-1,1);
		}
		break;
	case 'filter':
		if (srcIndex > 0 && this.filters[srcIndex-1]) {
			this.pushState();
			changed = true;
			this.filters.splice(srcIndex-1,1);
		}
		break;
	case 'measure':
		if (this.measures) {
			this.pushState();
			changed = true;
			this.measures = new Array();
		}
		break;
	default:
		break;
	}
	if (changed) {
		this.executeQuery(this.autoExecute);
	}
]]></Implementation>
</Method>

<Method name="hideMessage">
<Description>
Hide the message box.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// JMD1462
	self.document.body.style.cursor = 'auto';
	if (!this.isDrillThrough && this.controller && this.controller.hideMessage) {
		// dispatch
		this.controller.hideMessage();
		return;
	}

	var div = this.findElement('message');
	if (div) {
		// PFS092 - Remove innerHTML so printing to PDF does not pick this up
		div.innerHTML = '';
		div.style.display = 'none';
	}
]]></Implementation>
</Method>

<Method name="showPendingMsg">
<Description>
Show (or hide) the "computing..." message.</Description>
<FormalSpec>flag,msg</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var div = this.findElement('pending');
	if (div) {
		if (flag) {
			div.style.display = 'block';
		}
		else {
			div.style.display = 'none';
		}
	}
]]></Implementation>
</Method>

<Method name="showMessage">
<Description>
Display the message box.
(or display message within pivot controller, if present).</Description>
<FormalSpec>msg,pct,listing</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// JMD1462
	self.document.body.style.cursor = 'wait';

	var units = '%';
	if (this.queryStatus < 30) {
		units = $$$Text(' items');
	}
	if (!this.isDrillThrough && this.controller && this.controller.showMessage) {
		// dispatch
		this.controller.showMessage(this,msg,pct,listing,units);
		return;
	}

	var div = this.findElement('message');
	if (div) {
		var html = '';
		var icon = "deepsee/insert_table_clock_64.png";

		html += '<table><tr><td width="80" valign="middle" align="center">';
		html += '<img src="'+icon+'"/><br/><br/>';
		html += '</td><td width="200" valign="top">';
		
		if (listing) {
			// listing message
			html += '<div><i>' + msg + '</i></div>';
		}
		else {
			pct = parseFloat(pct);
			pct = isNaN(pct) ? '0' : (Math.round(pct*100)/100);

			if (!isNaN(this.queryStatus) && this.queryStatus >= 50 && this.queryStatus < 100) {
				icon = "deepsee/insert_table_fav_64.png";
			}
			else if (!isNaN(this.queryStatus) && this.queryStatus < 35) {
				icon = "deepsee/insert_table_64.png";
			}

			html += '<div><i>' + msg + '</i></div>';
			html += '<div class="dsptPct">' + pct + '<span style="font-size:0.8em;">'+units+'</span></div>';
			html += '<div style="font-size:0.8em; color: darkblue;"><i>' + $$$Text('Cells Calculated') + '</i></div>';
			var pos = (this.queryCalls % 10) * 10;
			html += '<div style="width:100px;border-top:1px solid darkblue;"><div style="border:1px solid black; background: darkblue; color:darkblue; font-size: 8pt; width:10px; left:'+pos+'px;position:relative;">X</div></div>';
		}
		html += '</td>';
		html += '</tr></table>';

		div.innerHTML = html;
		div.style.display = 'block';
	}
]]></Implementation>
</Method>

<Method name="itemMouseDown">
<Description>
Mouse down handler for nodes.</Description>
<Internal>1</Internal>
<FormalSpec>evt,idx</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this.dragEnabled) {
		evt = evt ? evt : window.event;
		if (evt.preventDefault) {
			evt.preventDefault();
		}
		this._dragSource = idx;
	}
]]></Implementation>
</Method>

<Method name="itemMouseUp">
<Description>
Mouse up handler for nodes.</Description>
<Internal>1</Internal>
<FormalSpec>evt</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this.dragEnabled) {
		evt = evt ? evt : window.event;
		if (evt.preventDefault) {
			evt.preventDefault();
		}
		delete this._dragSource;
	}
]]></Implementation>
</Method>

<Method name="absoluteAdjustLayout">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Added by WAL
	try {
		// divs
		var enc = this.getEnclosingDiv();
		var outer = this.findElement('outerDiv');
		var singleTable = this.findElement('dsPivotCompleteTable');
		var singleTableDiv = this.findElement('dsPivotCompleteTableDiv');
		
		var vtScroll = this.findElement('vtScroll');
		var hzScroll = this.findElement('hzScroll');
		var vtScrollInner = this.findElement('vtScrollInner');
		var hzScrollInner = this.findElement('hzScrollInner');
		var errorDiv = this.findElement('errorDiv');
		var	status = this.findElement('statusDiv');
		
		var dataTable = this.findElement('dataTable'); 
		var dataTableDiv = this.findElement('dataTableDiv');
		var sideTable = this.findElement('sideTable');
		var topTable = this.findElement('topTable');
		var nubTable = this.findElement('nubTable');

		var adjustArray=[];
		
		// Loop through top table, use old table to assign sizes
		var topHeights=[];
		var topWidths=[];
		var topOffsets = undefined;		// DTB842 - Offsets will be initialized on the first pass of the loop
		var multipleRows=0;
		var maxRow=0;
		var childOffsetWidth="";
		var childOffsetHeight="";
		var parentOffsetWidth="";
		var parentOffsetHeight="";
		if (topTable) {		// DTB867 - Test for existence of the topTable
			for (var cell=0;cell<topTable.children.length;cell++) {
				var tempNew = topTable.children[cell];
				var tempOld = document.getElementById(tempNew.id.substring(3,tempNew.id.length));
				if ((tempNew) && (tempOld)) {
					if ((childOffsetHeight=="") && (childOffsetWidth=="")) {
						// PFS111 - Added outer div, so we need to go down 2 child levels
						var childOffsetStyle=window.getComputedStyle(tempOld.children[0].children[0]);
						childOffsetHeight=parseInt(childOffsetStyle.paddingTop)+parseInt(childOffsetStyle.paddingBottom);
						childOffsetWidth=parseInt(childOffsetStyle.paddingRight)+parseInt(childOffsetStyle.paddingLeft);
					}
					if ((parentOffsetHeight=="") && (parentOffsetWidth=="")) {
						var parentOffsetStyle=window.getComputedStyle(tempOld);
						parentOffsetHeight=parseInt(parentOffsetStyle.borderTopWidth)+parseInt(parentOffsetStyle.borderBottomWidth);
						parentOffsetWidth=parseInt(parentOffsetStyle.borderRightWidth)+parseInt(parentOffsetStyle.borderLeftWidth);
					}
					var idArray=tempOld.id.split("_");
					if (idArray[0]=="coltotal") {
						var colNum=101;
						var rowNum=maxRow;
						for (r=rowNum;r>=1;r--) {
							// DTB861 - Set for all rows of the offset table
							topOffsets[r][colNum] = topOffsets[r][topOffsets[r].length-1];		// DTB850 - Set the column total offset to be the final offset previously logged
						}
					} else {
						var colNum=parseInt(idArray[1].split(":")[1]);
						var rowNum=parseInt(idArray[1].split(":")[0]);
					}
					
					if (!(topOffsets)) {
						// DTB842 - Initialize the offset array. This replaces topWidths for setting
						// left position of each cell
						topOffsets = [];
						for (r=rowNum;r>=1;r--) {
							topOffsets[r] = [];
							topOffsets[r][colNum] = 0;
						}
					}
					
					var rect=tempOld.getBoundingClientRect()
					tempWidth=rect.width;
					tempHeight=rect.height;
					var tempAdjust={};
					tempAdjust.id=tempNew.id;
					tempAdjust.height=tempHeight-parentOffsetHeight;
					tempAdjust.width=tempWidth-parentOffsetWidth;
					tempAdjust.left=topOffsets[rowNum][colNum];		// DTB842 - Directly look up the offset for this cell
					tempAdjust.offsetHeight=childOffsetHeight;
					tempAdjust.offsetWidth=childOffsetWidth;
					adjustArray.push(tempAdjust);
					
					colSpan=tempOld.colSpan ? parseInt(tempOld.colSpan) : 1;
					rowSpan=tempOld.rowSpan ? parseInt(tempOld.rowSpan) : 1;
					multipleRows = rowNum>1 ? 1 : multipleRows;
					maxRow = rowNum>maxRow ? rowNum: maxRow;
					
					for (var r=rowNum;r>=1;r--) {
						// DTB842 - Fill in the current spanned offset for the next cell, for all rows below this one
						topOffsets[r][colNum+colSpan] = topOffsets[r][colNum] + tempWidth
					}
					
					// DTB842 - Leave topWidths and topHeights exactly as they were in case they get used later
					for (var r=rowNum;r>(rowNum-rowSpan);r--) {
						if (topWidths[r]) {
							topWidths[r]+=tempWidth;
						} else {
							topWidths[r]=tempWidth;
						}
					}
					
					for (var c=colNum;c<(colNum+colSpan);c++) {
						if (!topHeights[c]) {
							topHeights[c]=[];
						}
						topHeights[c][rowNum]=tempHeight;
					}
				}
			}
		}
		
		// Reverse for crossjoins 
		if (multipleRows) {
			var childrenLength=topTable.children.length;
			for (var cell=childrenLength-1;cell>=0;cell--) {
				var tempNew = topTable.children[cell];
				var tempOld = document.getElementById(tempNew.id.substring(3,tempNew.id.length));
				if ((tempNew) && (tempOld)) {
					var idArray=tempOld.id.split("_");
					if (idArray[0]=="coltotal") {
						var colNum=101;
						var rowNum=maxRow;
					} else {
						var colNum=parseInt(idArray[1].split(":")[1]);
						var rowNum=parseInt(idArray[1].split(":")[0]);
					}
					var tempHeight=0;
					for (var r=rowNum+1;r<topHeights[colNum].length;r++) {
						tempHeight+=topHeights[colNum][r];
					}
					
					adjustArray[adjustArray.length-(adjustArray.length-cell)].top=tempHeight;
				}
			}
		}
		
		// Loop through nub table, use old table to assign sizes
		// Nub table can ignore height calculations, top table will certainly be taller
		var totalLeft=0;
		if (nubTable) {		// DTB783 - Test for existence of the nubTable
			for (var cell=0;cell<nubTable.children[0].children.length;cell++) {
				var tempNew = nubTable.children[0].children[cell];
				var tempOld = document.getElementById(tempNew.id.substring(3,tempNew.id.length));
				if ((tempNew) && (tempOld)) {
					var offsetStyle=window.getComputedStyle(tempNew);
					offsetHeight=parseInt(offsetStyle.borderTopWidth)+parseInt(offsetStyle.borderBottomWidth)+parseInt(offsetStyle.paddingTop)+parseInt(offsetStyle.paddingBottom);
					offsetWidth=parseInt(offsetStyle.borderRightWidth)+parseInt(offsetStyle.borderLeftWidth)+parseInt(offsetStyle.paddingRight)+parseInt(offsetStyle.paddingLeft);
					var rect=tempOld.getBoundingClientRect()
					tempWidth=rect.width;
					tempHeight=rect.height;
					var tempAdjust={};
					tempAdjust.id=tempNew.id;
					tempAdjust.height=tempHeight;
					tempAdjust.width=tempWidth;
					tempAdjust.left=totalLeft;
					tempAdjust.offsetHeight=offsetHeight;
					tempAdjust.offsetWidth=offsetWidth;
					adjustArray.push(tempAdjust);
					totalLeft+=tempWidth;
				}
			}
		}
		
		// Loop through side table, use old table to assign sizes
		var sideHeights=[];
		var sideWidths=[];
		var multipleCols=0;
		var maxCol=0;
		var childOffsetWidth="";
		var childOffsetHeight="";
		var parentOffsetWidth="";
		var parentOffsetHeight="";
		if (sideTable) {		// DTB783 - Test for existence of the sideTable
			for (var cell=0;cell<sideTable.children.length;cell++) {
				var tempNew = sideTable.children[cell];
				var tempOld = document.getElementById(tempNew.id.substring(3,tempNew.id.length));
				if ((tempNew) && (tempOld)) {
					if ((childOffsetHeight=="") && (childOffsetWidth=="")) {
						var childOffsetStyle=window.getComputedStyle(tempOld.children[0]);
						childOffsetHeight=parseInt(childOffsetStyle.paddingTop)+parseInt(childOffsetStyle.paddingBottom);
						childOffsetWidth=parseInt(childOffsetStyle.paddingRight)+parseInt(childOffsetStyle.paddingLeft);
					}
					if ((parentOffsetHeight=="") && (parentOffsetWidth=="")) {
						var parentOffsetStyle=window.getComputedStyle(tempOld);
						parentOffsetHeight=parseInt(parentOffsetStyle.borderTopWidth)+parseInt(parentOffsetStyle.borderBottomWidth);
						parentOffsetWidth=parseInt(parentOffsetStyle.borderRightWidth)+parseInt(parentOffsetStyle.borderLeftWidth);
					}
					var idArray=tempOld.id.split("_");
					if (idArray[0]=="rowtotal") {
						var colNum=maxCol;
						var rowNum = (this.currPage*100)+1;		// DTB861 - Assign a row total just after the final row ID for the current page
					} else {
						var colNum=parseInt(idArray[1].split(":")[0]);
						var rowNum=parseInt(idArray[1].split(":")[1]);
					}
					var rect=tempOld.getBoundingClientRect()
					tempWidth=rect.width;
					tempHeight=rect.height;
					var tempAdjust={};
					tempAdjust.id=tempNew.id;
					tempAdjust.height=tempHeight-parentOffsetHeight;
					tempAdjust.width=tempWidth-parentOffsetWidth;
					tempAdjust.top=sideHeights[colNum];
					tempAdjust.offsetHeight=childOffsetHeight;
					tempAdjust.offsetWidth=childOffsetWidth;
					adjustArray.push(tempAdjust);
					
					colSpan=tempOld.colSpan ? parseInt(tempOld.colSpan) : 1;
					rowSpan=tempOld.rowSpan ? parseInt(tempOld.rowSpan) : 1;
					multipleCols = colNum>1 ? 1 : multipleCols;
					maxCol = colNum>maxCol ? colNum : maxCol;
					
					for (var c=colNum;c>(colNum-colSpan);c--) {
						if (sideHeights[c]) {
							sideHeights[c]+=tempHeight;
						} else {
							sideHeights[c]=tempHeight;
						}
					}
					
					for (var r=rowNum;r<(rowNum+rowSpan);r++) {
						if (!sideWidths[r]) {
							sideWidths[r]=[];
						}
						sideWidths[r][colNum]=tempWidth;
					}
				}
			}
		}
		
		// Use totalWidths array to reposition sideTable
		if (multipleCols) {
			var childrenLength=sideTable.children.length;
			for (var cell=0;cell<sideTable.children.length;cell++) {
				var tempNew = sideTable.children[cell];
				var tempOld = document.getElementById(tempNew.id.substring(3,tempNew.id.length));
				if ((tempNew) && (tempOld)) {
					var idArray=tempOld.id.split("_");
					if (idArray[0]=="rowtotal") {
						var colNum=maxCol;
						var rowNum = (this.currPage*100)+1;		// DTB861 - Assign a row total just after the final row ID for the current page
					} else {
						var colNum=parseInt(idArray[1].split(":")[0]);
						var rowNum=parseInt(idArray[1].split(":")[1]);
					}
					var tempLeft=0;
					for (var c=colNum+1;c<sideWidths[rowNum].length;c++) {
						tempLeft+=sideWidths[rowNum][c];
					}
					adjustArray[adjustArray.length-(childrenLength-cell)].left=tempLeft;
				}
			}
		}
		
		for (var pos in adjustArray) {
			var tempAdjust=adjustArray[pos];
			this.adjustCellSize(tempAdjust.id,tempAdjust.height,tempAdjust.width,tempAdjust.top,tempAdjust.left,tempAdjust.offsetHeight,tempAdjust.offsetWidth);
		}
	
	
		// Apply height and width to table divs
		// Loop through top height array to get max height - this is faster than looking at the table element
		var totalTop=0;
		for (var colNum in topHeights) {
			var tempTop=0;
			for (var rowNum in topHeights[colNum]) {
				tempTop+=topHeights[colNum][rowNum]
			}
			totalTop = tempTop>totalTop ? tempTop : totalTop;
		}
		
		// Loop through side width array to get max width - this is faster than looking at the table element
		var totalSide=0;
		for (var rowNum in sideWidths) {
			var tempSide=0;
			for (var colNum in sideWidths[rowNum]) {
				tempSide+=sideWidths[rowNum][colNum]
			}
			totalSide = tempSide>totalSide ? tempSide : totalSide;
		}
		
		if (sideTable) {		// DTB783 - Protect against missing sideTable
			sideTable.style.top=totalTop+'px';
			sideTable.style.height=(dataTableDiv ? (parseInt(dataTableDiv.style.height)-totalTop) : 0)+'px';
			sideTable.style.width=totalSide+'px';
		}
		
		if (topTable) {		// DTB783 - Protect against missing topTable
			topTable.style.height=totalTop+'px';
			topTable.style.left=totalSide+'px';
			topTable.style.width=(dataTableDiv ? (parseInt(dataTableDiv.style.width)-totalSide) : 0)+'px'
		}
		
		//Apply height and width to the nub table
		if (nubTable) {		// DTB783 - Protect against missing nubTable
			nubTable.style.height=totalTop+'px';
			nubTable.style.width=totalSide+'px';
			nubTable.children[0].style.height=totalTop+'px';
			nubTable.children[0].style.width=totalSide+'px';
		}
	}
	catch(ex) {
		alert('Error in absoluteAdjustLayout: ' + ex.message);
	}
]]></Implementation>
</Method>

<Method name="adjustCellSize">
<FormalSpec>cellid,height,width,top,left,offsetHeight,offsetWidth</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var celldiv=document.getElementById(cellid);
	var child=celldiv.children[0];
	var tempStyle=celldiv.style;
	if (child) {
		child=child.style;
		child.height=((height-offsetHeight)!=undefined ? (height-offsetHeight) : child.height)+'px';
		child.width=((width-offsetWidth)!=undefined ? (width-offsetWidth) : child.width)+'px';
		tempStyle.height=(height!=undefined ? height: tempStyle.height)+'px';
		tempStyle.width=(width!=undefined ? width: tempStyle.width)+'px';
	} else {
		tempStyle.height=((height-offsetHeight)!=undefined ? (height-offsetHeight) : tempStyle.height)+'px';
		tempStyle.width=((width-offsetWidth)!=undefined ? (width-offsetWidth) : tempStyle.width)+'px';
	}
	tempStyle.top=(top!=undefined ? top : tempStyle.top)+'px';
	tempStyle.left=(left!=undefined ? left : tempStyle.left)+'px';
]]></Implementation>
</Method>

<Method name="singleTableAdjustLayout">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	try {
		// divs
		var enc = this.getEnclosingDiv();
		var outer = this.findElement('outerDiv');
		var singleTable = this.findElement('dsPivotCompleteTable');
		var singleTableDiv = this.findElement('dsPivotCompleteTableDiv');
		var dataTable = this.findElement('dataTable');
		var dataTableDiv = this.findElement('dataTableDiv');
		
		var vtScroll = this.findElement('vtScroll');
		var hzScroll = this.findElement('hzScroll');
		var vtScrollInner = this.findElement('vtScrollInner');
		var hzScrollInner = this.findElement('hzScrollInner');
		var errorDiv = this.findElement('errorDiv');
		var	status = this.findElement('statusDiv');

		// show scroll bar divs (but make visible only if needed)
		if (vtScroll) {
			vtScroll.style.display = 'block';
		}
		if (hzScroll) {
			hzScroll.style.display = 'block';
			if (zenIsIE) {
				// JMD1023 another #^$%& workaround
				hzScroll.style.height = '30px';
			}
		}
		
		if (singleTable) {
			singleTable.style.visibility='visible';
		}
		if (dataTable) {
			dataTable.style.visibility='visible';
		}
		
		// DTB701 - hide scrollbars if previewMode is on
		// DTB712 - check interactivity
		if (this.previewMode&&!this.allowPreviewInteraction) {
			vtScroll.style.display = 'none';
			hzScroll.style.display = 'none';
		}

		vtScrollWid = vtScroll ? vtScroll.offsetWidth : 0;
		hzScrollHgt = hzScroll ? hzScroll.offsetHeight : 0;

		if (!singleTable) {
			if (vtScroll) {
				vtScroll.style.display = 'none';
			}
			if (hzScroll) {
				hzScroll.style.display = 'none';
			}
		}
		
		// WAL -- steal some old dt sizing logic for scroll bar

		var errHgt = errorDiv ? errorDiv.offsetHeight : 0;
		var dtHgt = dataTable ? dataTable.offsetHeight : singleTable ? singleTable.offsetHeight : 0;
		var dtWid = dataTable ? dataTable.offsetWidth : singleTable ? singleTable.offsetWidth : 0;

		if (vtScrollInner) {
			vtScrollInner.style.height = dtHgt + 'px';
		}
		if (hzScrollInner) {
			hzScrollInner.style.width = dtWid + 'px';
		}

		// outer div
		if (outer && enc) {
			outer.style.height = enc.offsetHeight + 'px';
			outer.style.width = enc.offsetWidth + 'px';
		}

		var st_h = 0;
		var st_w = 0
		if (status && enc) {
			st_h = status.offsetHeight;
			st_w = status.offsetWidth;
			status.style.top = (enc.offsetHeight - st_h) + 'px';
			status.style.left = '0px';
			status.style.right = '0px';
			
			/*
			// DTB171 - Completely hide pivot status if it is empty
			if (status.children.length) {
				status.style.display = 'block';
			}
			else {
				status.style.display = 'none';
			}
			*/
		}

		if (errorDiv) {
			errorDiv.style.bottom = st_h + 'px';
			errorDiv.style.left = '0px';
			errorDiv.style.right = '0px';
		}
		
		if (dataTableDiv && outer && hzScroll && vtScroll) {
			dataTableDiv.style.width = outer.offsetWidth - hzScroll.offsetHeight + 'px';
			if (this.kpi==='' && status) {
				dataTableDiv.style.height = outer.offsetHeight - status.offsetHeight - vtScroll.offsetWidth + 'px';
			}
			else {
				dataTableDiv.style.height = outer.offsetHeight - vtScroll.offsetWidth + 'px';
			}
		}
		if (singleTableDiv && outer && hzScroll && vtScroll) {
			singleTableDiv.style.width = outer.offsetWidth - hzScroll.offsetHeight + 'px';
			if (this.kpi==='' && status) {
				singleTableDiv.style.height = outer.offsetHeight - status.offsetHeight - vtScroll.offsetWidth + 'px';
			}
			else {
				singleTableDiv.style.height = outer.offsetHeight - vtScroll.offsetWidth + 'px';
			}
		}

		var singleTableWidth = singleTable ? singleTable.offsetWidth : 0;
		var singleTableHeight = singleTable ? singleTable.offsetHeight : 0;
		
		// + WAL258 -- take vertical scroll into account
		// DTB171 - Completely hide pivot status if it is empty
		if (status) {
			if (status.children.length || (singleTableDiv.clientHeight < singleTableDiv.scrollHeight)) {
				status.style.display = 'block';
			}
			else {
				status.style.display = 'none';
			}
		}
		// - WAL258

		if (vtScroll && outer) {
			vtScroll.style.right = '0px';
			if (this.kpi==='' && status) {
				vtScroll.style.height = outer.offsetHeight - status.offsetHeight - hzScroll.offsetHeight + 'px';
			}
			else {
				vtScroll.style.height = outer.offsetHeight - hzScroll.offsetHeight + 'px';
			}
		}
		// + WAL258 (2) -- make sure we don't use the status width when
		//                 the status area is hidden
		if (hzScroll && outer) {
			if ( (this.kpi==='') && status  && (st_w!=0) ) {
				hzScroll.style.bottom = status.offsetHeight + 'px';
				hzScroll.style.width = st_w - vtScroll.offsetWidth + 'px';
			}
			else {
				hzScroll.style.bottom = '0px';
				hzScroll.style.width = (enc.offsetWidth - vtScroll.offsetWidth) + 'px';	
			}
		}
		// - WAL258
		if (outer) {
			outer.style.visibility = 'visible';
		}
		if (singleTableDiv) {
			singleTableDiv.style.visibility = 'visible';	
		}
		
		// WAL106 -- hide scrollbars if we don't need to scroll in that direction
		if (vtScroll && dataTableDiv && (dataTableDiv.clientHeight >= dataTableDiv.scrollHeight)) {
			vtScroll.style.display = 'none';
		}
		if (hzScroll && dataTableDiv && (dataTableDiv.clientWidth >= dataTableDiv.scrollWidth)) {
			hzScroll.style.display = 'none';
		}

		// WAL106 -- wheel handling for single table
		// JMD814 add wheel handling
		if (singleTable) {
			var handler = new Function('evt','zenPage.getComponent('+this.index+').wheelHandler(evt);');

			if (singleTable.addEventListener) {
				singleTable.addEventListener('DOMMouseScroll', handler, false);  
				singleTable.addEventListener('mousewheel', handler, false);
			}
			else if(singleTable.attachEvent) {
				singleTable.attachEvent('onmousewheel', handler);
			}
		}
		
		if (singleTable) {
			singleTable.style.height=singleTableDiv.style.height;
			singleTable.style.width=singleTableDiv.style.width;
		}
		if (dataTableDiv) {
			dataTableDiv.style.height=singleTableDiv.style.height;
			dataTableDiv.style.width=singleTableDiv.style.width;
			dataTableDiv.style.visibility='visible';
		}
		if (!errorDiv) {
			if (this.absolutePositioning==1) {
				this.absoluteAdjustLayout();
			}
			
			if (singleTableDiv) {		// DTB783 - Do not add the pivot coverPane if there is no table div
				this.addPivotCoverPane(singleTableDiv);		// DTB701
				this.setPivotDisabled((this.previewMode||this.headFunctionAdded)&&this.rowsTruncated);		// DTB714 - Adjust coverPane test conditions
			}
		}
	}
	catch(ex) {
		alert('Error in singleTableAdjustLayout: ' + ex.message);
	}
]]></Implementation>
</Method>

<Method name="adjustTableLayout">
<Description>
Adjust size and position of the layout divs that contain the table
as well as the cells and headers in the table.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	try {
		// + WAL106 -- different handler for single table case
		if (this.singleTable) {
			this.singleTableAdjustLayout();
			return;	
		}
		// - WAL106
		
		// there is a cell height difference with webkit
		// use this as a work-around
		var who=navigator.userAgent;
		var isWebKit = who.indexOf("WebKit")>=0;

		// JMD1055: chrome fudge factors
		var fudgeW = isWebKit ? 0 : 0;
		var fudgeH = isWebKit ? 0 : 0;

		var colLevels = 1;

		// JMD1465 use cellWidth as min-width
		var minCellWidth = this.cellWidth!=='' ? parseInt(this.cellWidth,10) : 0;

		// JMD1023: skip for CSS=2
		var oldIE = false;
		if (zenPage.cssLevel<3) {
			fudgeH = 0;
			oldIE = zenIsIE;
		}

		// divs
		var enc = this.getEnclosingDiv();
		var outer = this.findElement('outerDiv');
		var topLeft = this.findElement('topLeftDiv');
		var topRight = this.findElement('topRightDiv');
		var bottomLeft = this.findElement('bottomLeftDiv');
		var bottomRight = this.findElement('bottomRightDiv');
		var vtScroll = this.findElement('vtScroll');
		var hzScroll = this.findElement('hzScroll');
		var vtScrollInner = this.findElement('vtScrollInner');
		var hzScrollInner = this.findElement('hzScrollInner');
		var errorDiv = this.findElement('errorDiv');
		var nubDiv = this.findElement('nubDiv');
		var	status = this.findElement('statusDiv');


		// show scroll bar divs (but make visible only if needed)
		if (vtScroll) {
			vtScroll.style.display = 'block';
		}
		if (hzScroll) {
			hzScroll.style.display = 'block';
			if (zenIsIE) {
				// JMD1023 another #^$%& workaround
				hzScroll.style.height = '30px';
			}
		}

		vtScrollWid = vtScroll ? vtScroll.offsetWidth : 0;
		hzScrollHgt = hzScroll ? hzScroll.offsetHeight : 0;

		// tables within divs
		var topTable = this.findElement('topTable');
		var leftTable = this.findElement('leftTable');
		var dataTable = this.findElement('dataTable');

		if (!dataTable) {
			if (vtScroll) {
				vtScroll.style.display = 'none';
			}
			if (hzScroll) {
				hzScroll.style.display = 'none';
			}
		}
		


		var errHgt = errorDiv ? errorDiv.offsetHeight : 0;
		var dtHgt = dataTable ? dataTable.offsetHeight : 0;
		var dtWid = dataTable ? dataTable.offsetWidth : 0;
		if (vtScrollInner) {
			vtScrollInner.style.height = dtHgt + 'px';
		}
		if (hzScrollInner) {
			hzScrollInner.style.width = dtWid + 'px';
		}

		// outer div
		if (outer) {
			outer.style.height = enc.offsetHeight + 'px';
			outer.style.width = enc.offsetWidth + 'px';
		}

		var st_h = 0;
		if (status) {
			st_h = status.offsetHeight;
			status.style.top = (enc.offsetHeight - st_h) + 'px';
			status.style.left = '0px';
			status.style.right = '0px';
		}

		if (errorDiv) {
			errorDiv.style.bottom = st_h + 'px';
			errorDiv.style.left = '0px';
			errorDiv.style.right = '0px';
		}

		// WAL106 -- there is only one box now
		// find top,left,wid,hgt for each of the four boxes
		var tl_t,tl_l,tl_w,tl_h;
		var tr_t,tr_l,tr_w,tr_h;
		var bl_t,bl_l,bl_w,bl_h;
		var br_t,br_l,br_w,br_h;

		// tl
		tl_t = 0;
		tl_l = 0;
		tl_w = leftTable ? leftTable.offsetWidth : 0;
		tl_h = topTable ? topTable.offsetHeight : 0;

		// adjust left side to show row header
		// JMD-add magic number to prevent slow increase in label width!
		if (nubDiv && nubDiv.offsetWidth > (tl_w + 5)) {
			tl_w = nubDiv.offsetWidth;
			leftTable.style.width = tl_w + 'px';
		}

		var w = (parseInt(enc.offsetWidth) - tl_w - 3 - vtScrollWid);
		w = (w > 0) ? w : 0;

		// tr
		tr_t = 0;
		tr_l = tl_w;
		tr_w = w;
		tr_h = tl_h;

		var h = (parseInt(enc.offsetHeight) - tr_h - 3 - st_h - 0 - hzScrollHgt - errHgt);
		h = (h > 0) ? h : 0;

		// bl
		bl_t = tl_h + 0;
		bl_l = 0;
		bl_w = tl_w
		bl_h = h;

		// br
		br_t = bl_t;
		br_l = bl_w;
		br_w = w;
		br_h = h;
		
		var nubadj = zenIsIE ? -1 : 0;

		// apply changes
		if (topLeft) {
			topLeft.style.top = tl_t + 'px';
			topLeft.style.left = tl_l + 'px';
			topLeft.style.width = ((tl_w>0)?(tl_w - 1 - nubadj):0) + 'px';
			topLeft.style.height = ((tl_h>0)?(tl_h-1):0) + 'px';
		}
		if (topRight) {
			topRight.style.top = tr_t + 'px';
			topRight.style.left = tr_l + 'px';
			topRight.style.width = tr_w + 'px';
			topRight.style.height = tr_h + 'px';
		}
		if (bottomLeft) {
			bottomLeft.style.top = bl_t + 'px';
			bottomLeft.style.left = bl_l + 'px';
			bottomLeft.style.width = bl_w + 'px';
			bottomLeft.style.height = bl_h + 'px';
		}
		if (bottomRight) {
			bottomRight.style.top = br_t + 'px';
			bottomRight.style.left = br_l + 'px';
			bottomRight.style.width = br_w + 'px';
			bottomRight.style.height = br_h + 'px';
		}

		if (vtScroll) {
			vtScroll.style.top = br_t + 'px';
			vtScroll.style.right = '0px';
			vtScroll.style.height = br_h + 'px';
		}
		if (hzScroll) {
			hzScroll.style.bottom = (st_h + errHgt) + 'px';
			hzScroll.style.right = vtScrollWid + 'px';
			hzScroll.style.width = br_w + 'px';
		}
		if (outer) {
			outer.style.visibility = 'visible';
		}

		if (dataTable && dataTable.offsetWidth >= 0) {
			// adjust size of column headers
			if (!leftTable) {
				// listing

				var ttw = 0;
				var hasRows = false;
				for (var c = 1;;c++) {
					var r = 1;
					var cell = this.findElement('cell_1_'+c);
					var c1 = this.findElement('col_'+r+':'+c);

					if ((!cell || !c1)&&c>1) break;
					if (cell && c1) {
						hasRows = true;
						// JMD1055 look at inner div
						// JMD1465
						var cellSz = this.computeDivSize(cell.firstChild,isWebKit);
						cellw = cellSz.width;
						var hdrSz = this.computeDivSize(c1.firstChild,isWebKit);
						hw = hdrSz.width;

						// JMD1506 look at *every* row!
						if (!isWebKit) {
							for (var rx = 2;;rx++) {
								var cellx = this.findElement('cell_'+rx+'_'+c);
								if (!cellx) break;
								var cellxSz = this.computeDivSize(cellx.firstChild,isWebKit);
								cellxw = cellxSz.width;
								cellw = cellw>cellxw ? cellw : cellxw;
								if (zenIsIE && rx>20) {
									// ie is too slow!
									break;
								}
							}
						}

						cellw = (hw>cellw) ? hw : cellw;

						if (cellw>0) {
							c1.style.width = cellw+fudgeW + 'px';
							cell.style.width = cellw+fudgeW + 'px';
							ttw += cellw;
						}
					}
				}
				// JMD1506 check for header with no cell
				if (!hasRows) {
					var ttw = 0;
					for (var c = 1;;c++) {
						var r = 1;
						var c1 = this.findElement('col_'+r+':'+c);
						if (!c1) break;
						var hdrSz = this.computeDivSize(c1.firstChild,isWebKit);
						cellw = hdrSz.width;
						c1.style.width = cellw+fudgeW + 'px';
						ttw += cellw;
					}
				}

				// fudge size of table!
				if (!oldIE) {
					// JMD remove fudge
					topTable.style.width = (ttw) + 'px';
					dataTable.style.width = topTable.offsetWidth + 'px';
					if (!isWebKit && !hasRows) {
						// JMD1484: if listing has no data, make sure ie shows headers
						dataTable.style.tableLayout = 'fixed';
					}
				}
				else {
					topTable.style.width = (ttw) + 'px';
					dataTable.style.width = topTable.offsetWidth + 'px';
					// JMD1274 we need to give ie a kick in the pants to do the right thing
					self.setTimeout("zenPage.getComponent("+this.index+").ieLayout()",10);
				}
			}
			else {
				// first make the tables really big!
				// JMD1091 - skip for old IE
				if (!oldIE) {
					topTable.style.width = 'auto';
					dataTable.style.width = topTable.offsetWidth + 'px';
				}
				else {
					// JMD1338
					dataTable.style.width = topTable.offsetWidth + 'px';
				}

				// set widths for pivot data columns
				var ttw = 0;
				for (var c = 1;;c++) {
					var r = 1;
					var cr = 1; // JMD1462 + (this.pageSize * (this.currPage-1));
					var cell = this.findElement('cell_'+cr+'_'+c);
					var c1 = this.findElement('col_'+r+':'+c);
					if (cell && !c1) {
						// check higher row
						for (r=2;r<10;r++) {
							var c1 = this.findElement('col_'+r+':'+c);
							if (c1) break;
						}
					}

					if (!cell || !c1) break;
					// JMD1055 look at inner div
					// JMD1465 use function, not offsetWidth
					// (this will *not* find a wide cell if it is not in the first row)
					var cellSz = this.computeDivSize(cell.firstChild,isWebKit);
					cellw = cellSz.width;
					var hdrSz = this.computeDivSize(c1.firstChild,isWebKit);
					hw = hdrSz.width;

					// JMD1506 look at *every* row!
					if (!isWebKit) {
						for (var rx = 2;;rx++) {
							var cellx = this.findElement('cell_'+rx+'_'+c);
							if (!cellx) break;
							var cellxSz = this.computeDivSize(cellx.firstChild,isWebKit);
							cellxw = cellxSz.width;
							cellw = cellw>cellxw ? cellw : cellxw;
						}
					}
					
					// +DTB093 - check the cell containing the column total
					var rtot = this.findElement('rtot_'+c);
					if (rtot) {
						var rtotSz = this.computeDivSize(rtot.firstChild,isWebKit);
						var rtotw = rtotSz.width;
						cellw = cellw>rtotw ? cellw : rtotw;
					}
					// -DTB093

					cellw = (hw>cellw) ? hw : cellw;
					// JMD1465
					cellw = (cellw<minCellWidth) ? minCellWidth : cellw;

					if (cellw>0) {
						c1.style.width = cellw+fudgeW + 'px';
						cell.style.width = cellw+fudgeW + 'px';
						
						if (zenIsIE) {
							// JMD1506 this appears to help!
							c1.firstChild.innerHTML = c1.firstChild.innerHTML;
							cell.firstChild.innerHTML = cell.firstChild.innerHTML;
						}
						ttw += cellw;
					}

					// look for headers in higher rows
					r++;
					for (;;r++) {
						var cn = this.findElement('col_'+r+':'+c);
						if (!cn) break;

						colLevels++;
						var span = parseInt(cn.colSpan);
						if (cellw>0) {
							cn.style.width = ((cellw+fudgeW)*span)-1+'px';
						}

						// inner div
						var adj = zenIsIE ? 0 : 4;
						// JMD846: compensate for colspan
						var span = parseInt(cn.colSpan);
						var divw = cellw * span;
						cn.firstChild.style.width = ((divw>adj)?(divw-adj):0) + 'px';
					}
				}
			
				// calculate width of the row totals column
				
				// +DTB093 - check for a grand total, it is likely the largest 
				var gtotal = this.findElement('gtot');
				if (gtotal) {
					var gtSz = this.computeDivSize(gtotal.firstChild,isWebKit);
					var gtxw = gtSz.width;
					hw = hw>gtxw ? hw : gtxw;
				}
				
				// WAL184 -- handle rare case where hw is undefined
				if (hw) {
					hw = (hw>minCellWidth) ? hw : minCellWidth;  // enforce min cell width
				}
				else {
					var hw = minCellWidth;	
				}
				// - WAL184
				
				var c1 = this.findElement('coltotal');
				if (c1) {	
					// Check all rows in totals column for width and keep the largest
					var hdrSz = this.computeDivSize(c1.firstChild,isWebKit);
					var hxw = hdrSz.width;
					hw = hw>hxw ? hw : hxw;
				
					for (var rt = 1;;rt++) {
						var cell = this.findElement('ctot_'+rt);
						if (!cell) break;
						var cellSz = this.computeDivSize(cell.firstChild,isWebKit);
						cellxw = cellSz.width;
						cellw = cellw>cellxw ? cellw : cellxw;
						cellw = (hw>cellw) ? hw : cellw;
						if (cellw>0) {
							cell.style.width = cellw+fudgeW + 'px';
						}
					}

					if (cellw>0) {
						c1.style.width = cellw+fudgeW + 'px';
						ttw += cellw;
					}
				}
				// -DTB093

				// fudge size of table!
				if (!oldIE) {
					// JMD1462 if fudge is 10 then columns do not always line up
					// if fudge is too big, then simple cases will fail
					// will columns *creep* in size with 20?
					var fdg = Math.round(ttw*0.05);
					fdg = fdg<10 ?10 : fdg;
					if (colLevels>1) {
						fdg = 100;
					}
					topTable.style.width = (ttw+fdg) + 'px';
				}
				else {
					// JMD1338
					// cannot use fudge factor for ie8 or else we get column "creep"
					topTable.style.width = (ttw) + 'px';
				}
				dataTable.style.width = topTable.offsetWidth + 'px';
				// JMD1465
				topTable.style.width = dataTable.offsetWidth + 'px';

				// adjust height of row headers
				// JMD1055
				for (var r = 1;;r++) {
					var r1 = this.findElement('row_1:'+r);
					var c1 = this.findElement('ctot_'+r);
					if (!c1) {
						var c1 = this.findElement('cell_'+r+'_1');
					}
					if (!c1||!r1) break;

					var rh = r1.firstChild.offsetHeight;
					var cellh = c1.firstChild.offsetHeight;

					if (cellh > rh) {
						r1.style.height = cellh+1 + 'px';
						c1.style.height = cellh+1 + 'px';
					}
					else if (cellh < rh) {
						c1.style.height = rh+1 + 'px';
						r1.style.height = rh+1 + 'px';
					}
					r1.parentNode.style.height = c1.offsetHeight + 'px';
					c1.parentNode.style.height = c1.offsetHeight + 'px';

					// JMD1506 do every cell across!
					if (oldIE) {
						var ieHeight = Math.max(0,c1.offsetHeight-4);
						for (var c = 2;;c++) {
							var cx = this.findElement('cell_'+r+'_'+c);
							if (!cx) break;
							cx.firstChild.style.height = ieHeight + 'px';
						}
					}
				}

				// total row
				var c1 = this.findElement('rtot_'+1);
				var r1 = this.findElement('rowtotal');
				if (c1 && r1) {
					var rh = r1.firstChild.offsetHeight;
					var cellh = c1.firstChild.offsetHeight;
					if (cellh > rh) {
						r1.style.height = cellh+1 + 'px';
						c1.style.height = cellh+1 + 'px';
					}
					else if (cellh < rh) {
						c1.style.height = rh+1 + 'px';
						r1.style.height = rh+1 + 'px';
					}
					r1.parentNode.style.height = c1.offsetHeight + 'px';
					c1.parentNode.style.height = c1.offsetHeight + 'px';
				}
			}
		}

		// re-adjust sizes
		tl_w = leftTable ? leftTable.offsetWidth : 0;
		tl_h = topTable ? topTable.offsetHeight : 0;
		var h = (parseInt(enc.offsetHeight) - tr_h - 3 - st_h - 0 - hzScrollHgt - errHgt);
		h = (h > 0) ? h : 0;

		// bl
		bl_t = tl_h + 0;
		bl_l = 0;
		bl_w = tl_w
		bl_h = h;

		// br
		br_t = bl_t;
		br_l = bl_w;
		br_w = w;
		br_h = h;
		if (topLeft) {
			topLeft.style.height = ((tl_h>0)?(tl_h-1):0) + 'px';
		}
		if (topRight) {
			// JMD1023
			topRight.style.height = ((tl_h>0)?(tl_h):0) + 'px';
		}
		if (bottomLeft) {
			bottomLeft.style.top = bl_t + 'px';
			bottomLeft.style.height = bl_h + 'px';
		}
		if (bottomRight) {
			bottomRight.style.top = br_t + 'px';
			bottomRight.style.height = br_h + 'px';
		}

		if (vtScroll) {
			vtScroll.style.top = br_t + 'px';
			vtScroll.style.height = br_h + 'px';
		}

		var dtHgt = dataTable ? dataTable.offsetHeight : 0;
		var dtWid = dataTable ? dataTable.offsetWidth : 0;
		if (vtScrollInner) {
			vtScrollInner.style.height = dtHgt + 'px';
			vtScroll.style.visibility = (dtHgt<br_h) ? 'hidden' : 'visible';
		}
		if (hzScrollInner) {
			hzScrollInner.style.width = dtWid + 'px';
			// JMD1055: use br_w not br_h
			hzScroll.style.visibility = (dtWid<br_w) ? 'hidden' : 'visible';
		}

		// adjust row captions
		var rcTable = this.findElement('rcTable');
		if (rcTable) {
			for (var r = 1;;r++) {
				var r1 = this.findElement('row_'+r+':1');
				if (!r1) break;
				var rcap = this.findElement('rcap_' + r);
				if (rcap) {
					rcap.style.width = (r1.offsetWidth>2?r1.offsetWidth-2:0) + 'px';
				}
			}
		}

		// JMD814 add wheel handling
		if (dataTable) {
			var handler = new Function('evt','zenPage.getComponent('+this.index+').wheelHandler(evt);');

			if (dataTable.addEventListener) {
				dataTable.addEventListener('DOMMouseScroll', handler, false);  
				dataTable.addEventListener('mousewheel', handler, false);
			}
			else if(dataTable.attachEvent) {
				dataTable.attachEvent('onmousewheel', handler);
			}
		}
	}
	catch(ex) {
		alert('Error in adjustTableLayout: ' + ex.message);
	}
]]></Implementation>
</Method>

<Method name="computeDivSize">
<Description>
Compute and return the size of the given html.</Description>
<Internal>1</Internal>
<FormalSpec>theDiv,isWebKit</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var size = {width:0, height:0};

	if (isWebKit) {
		size.width = theDiv.offsetWidth;
		size.height = theDiv.offsetHeight;
		return size;
	}

	var div = this.getEnclosingDiv();
	var element = document.createElement('div');
	element.className = theDiv.className;
	element.style.position = 'absolute';
	element.style.top = '0px';

	if (window.getComputedStyle) {
		var cStyle = window.getComputedStyle(theDiv,null);
		var fSize = cStyle.getPropertyValue('font-size');
		element.style.fontSize = fSize;
		var fWeight = cStyle.getPropertyValue('font-weight');
		element.style.fontWeight = fWeight;
		var fFamily = cStyle.getPropertyValue('font-family');
		element.style.fontFamily = fFamily;
	}
	else if (theDiv.currentStyle) {
		// ie8
		// JMD1506 add test for missing currentStyles
		element.style.fontSize = theDiv.currentStyle['font-size'] ? theDiv.currentStyle['font-size'] : '';
		element.style.fontWeight = theDiv.currentStyle['font-weight'] ? theDiv.currentStyle['font-weight'] : '';
		element.style.fontFamily = theDiv.currentStyle['font-family'] ? theDiv.currentStyle['font-family'] : '';
	}

	element.innerHTML = theDiv.innerHTML;
	div.appendChild(element);

	size.width = element.offsetWidth;
	size.height = element.offsetHeight;
	div.removeChild(element);
	return size;
]]></Implementation>
</Method>

<Method name="ieLayout">
<Description>
Work-around for ie8!</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// JMD1274
	var dataTable = this.findElement('dataTable');
	dataTable.style.tableLayout = 'fixed';
]]></Implementation>
</Method>

<Method name="wheelHandler">
<Description>
Mouse wheel handler.</Description>
<FormalSpec>evt</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	var wheelDelta = evt.detail ? evt.detail * -1 : evt.wheelDelta;
	var vtScroll = this.findElement('vtScroll');
	if (vtScroll) {
		var c1 = this.findElement('cell_1_1');
		var d = c1 ? c1.offsetHeight : 40;
		vtScroll.scrollTop = vtScroll.scrollTop + ((wheelDelta>0) ? -d : d);
		this.cellScrollVt();
	}
]]></Implementation>
</Method>

<Method name="cellScrollVt">
<Description>
Vertical Scroll handler.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var vtScroll = this.findElement('vtScroll');
	
	// WAL
	// PFS037 - Do not handle listings here
	if ((this.absolutePositioning==1)&&(!this.isDrillThrough)) {
		this.findElement('sideTable').scrollTop = vtScroll.scrollTop;
		this.findElement('dataTableDiv').scrollTop = vtScroll.scrollTop;
		return	
	}
	
	// + WAL106
	if (this.singleTable) {
		var singleTableDiv = this.findElement('dataTableDiv');
		singleTableDiv.scrollTop = vtScroll.scrollTop;
		return;
	}
	// - WAL106
	
	var bottomLeft = this.findElement('bottomLeftDiv');
	var bottomRight = this.findElement('bottomRightDiv');
	if (bottomLeft && vtScroll) {
		bottomLeft.scrollTop = vtScroll.scrollTop;
	}
	if (bottomRight && vtScroll) {
		bottomRight.scrollTop = vtScroll.scrollTop;
	}
]]></Implementation>
</Method>

<Method name="cellScrollHz">
<Description>
Horizontal Scroll handler..</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var hzScroll = this.findElement('hzScroll');
	
	// WAL
	// PFS037 - Do not handle listings here
	if ((this.absolutePositioning==1)&&(!this.isDrillThrough)) {
		this.findElement('topTable').scrollLeft = hzScroll.scrollLeft;
		this.findElement('dataTableDiv').scrollLeft = hzScroll.scrollLeft;
		return	
	}
	
	// + WAL106
	if (this.singleTable) {	
		// need a div that just wraps the table
		var singleTableDiv = this.findElement('dataTableDiv');
		singleTableDiv.scrollLeft = hzScroll.scrollLeft;
		return;
	}
	// - WAL106
	
	
	var topRight = this.findElement('topRightDiv');
	var bottomRight = this.findElement('bottomRightDiv');
	if (topRight && hzScroll) {
		topRight.scrollLeft = hzScroll.scrollLeft;
	}
	if (bottomRight && hzScroll) {
		bottomRight.scrollLeft = hzScroll.scrollLeft;
	}
]]></Implementation>
</Method>

<Method name="onloadHandler">
<Description>
This client event, if present, is fired when the page is loaded.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this._registeredCounter = 0; // + WAL259
	
	this.adjustTableLayout();

	if (('' != this.queryKey) && (!this.queryStatus || this.queryStatus < 100 || this.queryKey.toString().indexOf('SLAVE:')>=0)) {
		this.showMessage($$$Text('Working...'),'');
		this.sendEventToViews('beginWait');
		this.startQueryTimer();
	}
	else if (this.queryPending) {
		this.sendEventToViews('beginWait');
		this.showPendingMsg(true);
		this.startQueryTimer();
	}
	else {
		this.computeTotals();
	}
]]></Implementation>
</Method>

<Method name="onupdateHandler">
<Description>
This client method, if present, is fired when the object is updated from the server.
This is called *after* changes have been synched.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this._runningQuery = false;
	// JMD1128 test hidden
	if (!zenPage._noUpdate && !this.hidden) {
		// JMD1023: prevent size change during save
		this.adjustTableLayout();
	}

	// JMD1269
	var ready = true;
	if (('' != this.queryKey) && (!this.queryStatus || this.queryStatus < 100)) {
		this.showMessage($$$Text('Working...'),'');
		this.sendEventToViews('beginWait');
		this.showPendingMsg(false);
		this.startQueryTimer();
		ready = false;
	}
	else {
		this.hideMessage();
		if (this.queryPending) {
			this.sendEventToViews('beginWait');
			this.showPendingMsg(true,'update');
			this.startQueryTimer();
		}
		else {
			// JMD1462
			this.showPendingMsg(false);
		}
	}
	if (!zenPage._noUpdate && ready) {
		this.raiseDataChange();

		// JMD1063
		// JMD1128 test hidden
		if (zenPage.adjustSizes && !this.hidden) {
			zenPage.adjustSizes();
		}
	}
	// JMD1063: apply selected color
	if ('' != this.selectedRange && !this.isDrillThrough) {
		var p = this.selectedRange.split(',');
		this.selectCellRange(p[0],p[1],p[2],p[3],false,false,true);
	}
]]></Implementation>
</Method>

<Method name="startQueryTimer">
<Description>
Start the timer used to update during query calculation.</Description>
<FormalSpec>needsRefresh</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.stopQueryTimer();
	var interval = 200;

	// JMD1462
	if (zenGet(needsRefresh,false)) {
		this.sendEventToViews('beginWait');
		this.showPendingMsg(true);
		this._needsRefresh = true;
		var interval = 50;
	}

	this.queryCalls++;

	if (this.queryCalls > 5) {
		interval = 800;
	}
	this._queryTimerId = self.setTimeout("zenPage.getComponent("+this.index+").queryTimerHandler()",interval);
]]></Implementation>
</Method>

<Method name="stopQueryTimer">
<Description>
Stop the query timer.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this._queryTimerId) {
		this.showPendingMsg(false);
		self.clearTimeout(this._queryTimerId);
		this._queryTimerId = null;
	}
]]></Implementation>
</Method>

<Method name="queryTimerHandler">
<Description><![CDATA[
Internal method.<br>
Timer event handler used by the query timer bar.]]></Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this._queryTimerId = null;
	if (this._inCancel) {
		return;
	}
	
	// JMD1462
	if (this._needsRefresh) {
		delete this._needsRefresh;
		this.executeQuery();
		this.sendEventToViews('beginWait');
		this.startQueryTimer();
		return;
	}

	var proxy = new zenProxy();
	// pass id to server as a diagnostic
	proxy.id = this.id;
	var oldStatus = this.queryStatus;

	var ok = this.GetQueryStatus(proxy,this.cubeKey,this.queryKey,this.kpi);
	if (ok) {
		this.queryStatus = parseInt(proxy.queryStatus,10);
		this.queryComplete = parseInt(proxy.queryComplete,10);
		this.queryComplete = isNaN(this.queryComplete) ? 0 : this.queryComplete;
		this.queryPending = (proxy.queryPending==1)?true:false;

		// query failed due to exception
		if (proxy.error) {
			this.sendEventToViews('endWait');
			this.hideMessage();
			// DTB716 - Suppress this alert. This will now be displayed in the table content.
			//alert($$$FormatText($$$Text("There has been an error in processing this query:\n%1","%DeepSee"),proxy.error));
			//return;
		}

		var doRefresh = 0;		// DTB823 - Signal flag to decide behavior after all tests
		if (this.queryStatus >= 100) {
			if (this.queryPending) {
				// try again
				this.showPendingMsg(true,'timer');
				doRefresh = 1;		// DTB823
			}
			else {
				this.showPendingMsg(false);
				this.sendEventToViews('endWait');
				doRefresh = 1;		// DTB823
			}
		}
		else if (this.queryStatus < 0) {
			this.sendEventToViews('endWait');
			this.hideMessage();
			alert($$$Text('Error on server!'));
			return;
		}
		else if (this.kpi != '') {
			// JMD1144
			if (this.queryComplete>=0) {
				this.showMessage($$$Text('Calculating...'),this.queryComplete);
			}
			else if ((this.queryStatus!=oldStatus)) {
				doRefresh = 1;		// DTB823
			}
			// JMD1339: make sure charts get wait event
			this.sendEventToViews('beginWait');
		}
		else {
			if (this.queryStatus<100) {
				// DTB868 - Signal a refresh under all remaining conditions that are not complete
				doRefresh = 1;
			}
			
			// DTB868 - Determine the appropriate message based on current status
			if (this.queryStatus >= 50) {
				this.showMessage($$$Text('Preparing final result...'),100);
			}
			if (this.queryStatus < 30) {
				this.showMessage($$$Text('Computing axes...'),this.queryComplete);
			}
			else {
				this.showMessage($$$Text('Calculating...'),this.queryComplete);
			}
			// JMD1339: make sure charts get wait event
			this.sendEventToViews('beginWait');
		}
		
		// DTB823 - Either refresh contents or initiate a timer to refresh later as needed
		if (doRefresh) {
			this.refreshContents();
		}
		else {
			this.startQueryTimer();
		}
	}
	else {
		this.sendEventToViews('endWait');
		if (!zenPage.limitPopups) {
			// DTB789 - Check the page setting before throwing an alert window
			alert('Error from server.');
		}
	}
]]></Implementation>
</Method>

<Method name="GetItemCaption">
<Description>
Return the caption associate with given cube element.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pSpec:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	If ($$$LOWER($P(pSpec,".",*))="variable") {
		// DTB489 - Add support for pivot variable captions
		Set tSC = ##class(%DeepSee.Utils).%GetPivotVariableInfo(pCubeName,$P(pSpec,".",1,*-1),.tPivotVariableInfo)
		If $$$ISERR(tSC) Quit pSpec
		
		Set tCaption = $G(tPivotVariableInfo("displayName"))
		If (tCaption="") {
			Set tCaption = $G(tPivotVariableInfo("name"),pSpec)
		}
	}
	Else {
		Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(pCubeName,pSpec,.tDimNo,.tHierNo,.tLevelNo,.tRelationName,.tRelationSpec)
		If $$$ISERR(tSC) Quit pSpec
		
		If (tRelationName'="") {
			Set tRelCube = ##class(%DeepSee.Utils).%GetRelatedCube(pCubeName,tRelationName)
			Quit ..GetItemCaption(tRelCube,tRelationSpec)
		}

		Set tSC = ##class(%DeepSee.Utils).%GetDimensionCaption(pCubeName,tDimNo,tHierNo,tLevelNo,.tCaption)
		If $$$ISERR(tSC) Quit pSpec
	}

	Quit tCaption
]]></Implementation>
</Method>

<Method name="FormatValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pQueryKey:%String,pValue:%String,pFormattedValue:%ZEN.proxyObject,pRowNo:%Integer,pColNo:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	// Method added by WAL122
	// re-open existing query
	Set tRS = ##class(%DeepSee.ResultSet).%New()
	Set tSC = tRS.%PrepareKey(pCubeName,pQueryKey)
	// If there's an error just return the original value
	If $$$ISERR(tSC) {
		Set pFormattedValue.formatted = 0
		Set pFormattedValue.value = pValue		
		Quit $$$OK
	}
	Set tSC = tRS.%GetOrdinalLabel(.tLabel,1,pColNo,.tFormat)
	Set tSC = tRS.%GetOrdinalLabel(.tLabel,2,pRowNo,.tFormat)
	Set pFormattedValue.formatted = $S($G(tFormat)'="":1,1:0)
	Set pFormattedValue.value = $S($G(tFormat)'="":tRS.%FormatNumber(pValue,tFormat),1:pValue)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetItemSpec">
<Description><![CDATA[
Get the tuple spec for the given item within the query result and place it into the proxy object.
<var>pAxisName</var> is "row" or "col".<br/>
Return true, if ok.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSpec:%ZEN.proxyObject,pCubeName:%String,pQueryKey:%String,pSortDir:%String,pSortColumn:%String,pAxisName:%String,pItemNo:%Integer,pItemNoSorted:%Boolean=0</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	Set tHasChildren = 0
	Set tIsRelation = 0
	Set tAxisNo = $Case(pAxisName,"row":2,"col":1,:-1)
	If (tAxisNo < 0) {
		Set pSpec.error = "Invalid axis name"
		Quit 0
	}

	// WAL088 -- when GetItemSpec is called in rowDblClickHandler and dropStartHandler the item number is already sorted
	//           so we don't need this lookup ('pItemNoSorted)
	if (pSortColumn>0 && (tAxisNo=2) && ('pItemNoSorted)) { // JSL4418
		Set pItemNo = $G($$$DeepSeeResultsGLVN($$$UPPER(pCubeName),pQueryKey,"sort",pSortColumn,pSortDir,pItemNo),pItemNo) // JSL4418
	}

	Set tChildSpec = ""

	// re-open existing query
	Set tRS = ##class(%DeepSee.ResultSet).%New()
	Set tSC = tRS.%PrepareKey(pCubeName,pQueryKey)
	If $$$ISERR(tSC) {
		Set pSpec.error = $System.Status.GetOneErrorText(tSC)
		Quit 0
	}

	Set tSC = tRS.%GetAxisMembers(tAxisNo,.tKey,pItemNo)
	If $$$ISERR(tSC) {
		Set pSpec.error = $System.Status.GetOneErrorText(tSC)
		Quit 0
	}

	// JMD1456 loop over items and pull out measures
	// WAL102 -- maybe we can grab measure info here
	Set pSpec.measure = ""
	Set k = $O(^||DeepSee.AxisMembers(tKey,tAxisNo,pItemNo,""),1,tInfo)
	While ((k'="") && ($G(tInfo)'="")) { // WAL236
		Set tDimNo = $LG(tInfo,7)		
		// + WAL227 -- check for calculated first, before concluding this isn't a measure
		//             calculated measures don't *always* belong to dimension 0
		// WAL229 -- avoid <SUBSCRIPT> error by checking ($LG(tInfo,2)'="")
		If (($LG(tInfo,2)'="") &&
			($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"calcMbrs","MEASURES",$$$UPPER($LG(tInfo,2))))'="")) {
			Set pSpec.measure = $LG(tInfo,2)
			Set pSpec.measureLogical = $LG(tInfo,2)
		}
		// - WAL227
		ElseIf (tDimNo'=0) {
			Set tItemList($I(tItemList)) = tInfo
		}
		Else {
			// + WAL102 -- Maintain list of measures for tooltip
			// Item 2 from the %GetAxisMembers list is the text
			Set pSpec.measure = $LG(tInfo,2)
			Set pSpec.measureLogical = $LG(tInfo,4) // WAL190
			Set:pSpec.measureLogical="" pSpec.measureLogical = pSpec.measure
			// - WAL102
		}
		Set k = $O(^||DeepSee.AxisMembers(tKey,tAxisNo,pItemNo,k),1,tInfo)
	}

	Set tSpec = ""
	Set tText = ""
	Set tTooltipText = "" // WAL102
	Set c = 0

	Set k = $O(tItemList(""),1,tInfo)
	While (k'="") {
		Set c = c + 1
		Set tIsAgg = 0
		Set tDimName = $LG(tInfo,3)
		Set tRelSpec = $LG(tInfo,10)
		Set tIsLastItem = ($O(tItemList(k))="")

		// JMD1361 Check for %OR
		If (tRelSpec'="") {
			Set tUseChildren = ($$$UPPER(tRelSpec)[".CHILDREN")		// DTB486 - Note the presence of CHILDREN on the axis
 			
			If ($E(tRelSpec,1,4)'="%OR(") {
				// strip off children and key
				Set tRelSpec = $P(tRelSpec,".children",1)
				Set tRelSpec = $P(tRelSpec,".&[",1)
			}
		}
		If (tRelSpec'="") {
			// JMD1289 try to find names for relationship
			Set tRCubeCaption = tDimName
			Set tRelCube = $$$UPPER(##class(%DeepSee.Utils).%GetRelatedCube(pCubeName,tDimName))

			// JMD1361
			If ($E(tRelSpec,1,4)="%OR(") {
				// strip off %OR, decorate each item, and reapply %OR
				// assume no commas in spec!
				Set t = $E(tRelSpec,6,*-2)
				If (tRelCube'="") {
					// use first OR term to get caption
					Set tRCubeCaption = ##class(%DeepSee.Utils).%GetCubeCaption(tRelCube)
					Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(tRelCube,$P(t,",",1),.tRelDimNo)
					If $$$ISERR(tSC) Quit
				}
				Set ts = ""
				For tp = 1:1:$L(t,",") {
					Set ts = ts _ $S(ts="":"",1:",") _ "["_tDimName_"]"_"."_$P(t,",",tp)
				}
				Set tItemSpec = "%OR({"_ts_"})"

				Set:tItemSpec'="" tSpec = tSpec _ $S(tSpec="":"",1:",") _ tItemSpec
				If (tIsLastItem) {
					If (c>1) {
						Set tSpec = "("_tSpec_")"
					}
				}
				// + WAL102
				If (tAxisNo=1) {
					Set tTooltipText = tRCubeCaption _ $S(tText="":"",1:"/") _ tTooltipText
				}
				Else {
					Set tTooltipText = tTooltipText _ $S(tText="":"",1:"/") _ tRCubeCaption
				}
				// - WAL102
				Set tThisText = tRCubeCaption_":"_$LG(tInfo,2)
				Set tText = tText _ $S(tText="":"",1:" / ") _ tThisText
				Set:tIsLastItem tIsRelation = 1
			}
			ElseIf ($$$UPPER(tRelSpec) '[ ".%TOPMEMBERS") {
				If (tRelCube'="") {
					Set tRCubeCaption = ##class(%DeepSee.Utils).%GetCubeCaption(tRelCube)
					Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(tRelCube,tRelSpec,.tRelDimNo,.tRelHierNo,.tRelLevelNo)		// DTB486 - Return all 3 numeric level coordinates
					If $$$ISERR(tSC) Quit
					
					Set tTempRelCube = tRelCube
					Set tLastRelCube = tRelCube
					Set tTempRelSpec = tRelSpec
					While (tRelDimNo="") {
						// DTB626 - The remaining spec might still have relatinships in it. Test them to work down to the real spec and collect labels as we go.
						Kill tSpecInfo
						Set tSC = ##class(%DeepSee.Query.Parser).%ParseMemberSpec(tTempRelSpec,.tNewSpecInfo)
						Set tTempRelDim = tNewSpecInfo(1)
						Set tTempRelCube = $$$UPPER(##class(%DeepSee.Utils).%GetRelatedCube(tLastRelCube,tTempRelDim))
						
						Set tRCubeCaption = tRCubeCaption _ ":" _ ##class(%DeepSee.Utils).%GetCubeCaption(tTempRelCube)
						
						Set tTempRelSpecList = ""
						Set tSpecNo = $O(tNewSpecInfo(1),1,tSpecItem)
						While (tSpecNo'="") {
							Set tTempRelSpecList = tTempRelSpecList _ $LB(tSpecItem)
							Set tSpecNo = $O(tNewSpecInfo(tSpecNo),1,tSpecItem)
						}
						
						Set tTempRelSpec = ##class(%DeepSee.Query.Parser).%BuildEscapedSpec(tTempRelSpecList)

						Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(tTempRelCube,tTempRelSpec,.tRelDimNo,.tRelHierNo,.tRelLevelNo)
						If $$$ISERR(tSC) Quit
						
						Set tLastRelCube = tTempRelCube
					}
					
					Set tSC = ##class(%DeepSee.Utils).%GetDimensionCaption(tTempRelCube,tRelDimNo,tRelHierNo,tRelLevelNo,.tCaption)
					If $$$ISERR(tSC) Quit
					Set tRCubeCaption = tCaption		// DTB626 - Use only the final level caption to match what is returned by filters.
					
					// DTB486 - If the original level was defined using CHILDREN, try to find the next level down
					If tUseChildren {
						Set tRelLevelNo = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tRelCube),"mbr#",tRelDimNo,tRelHierNo,tRelLevelNo))
						
						If tRelLevelNo'="" {
							Set tSC = ##class(%DeepSee.Utils).%GetDimensionSpec(tRelCube,.tRelSpec,tRelDimNo,tRelHierNo,tRelLevelNo)
							If $$$ISERR(tSC) Quit
						}
						Else {
							Quit
						}
					}
				}
				Set tItemSpec = "[" _ tDimName _ "]." _ tRelSpec

				// JMD862: Test for and use "All level"
				// we should test if there are children of this related level!
				If ($LG(tInfo,6)'="") {
					Set tItemSpec = tItemSpec _ ".&[" _ $$$dsEscapeIdent($LG(tInfo,6))_"]"
					If (tIsLastItem) {
						Set tChildSpec = tItemSpec_".children"
					}
					Else {
						Set tChildSpec = tItemSpec
					}
				}
				Else {
					If (tRelCube'="") {
						Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(tRelCube,tRelSpec,.tRelDimNo)
						If $$$ISERR(tSC) Quit
						If (tRelDimNo'="") {
							// is there an All level?
							Set tAllLevel = $LG($G($$$DeepSeeMetaGLVN("cubes",tRelCube,"mbr#",tRelDimNo,0,0)),4)
							If (tAllLevel'="") {
								If (tIsLastItem) {
									Set tChildSpec = tItemSpec_".["_tAllLevel_"].children"
								}
								Else {
									Set tChildSpec = tItemSpec_".["_tAllLevel_"]"
								}
							}
						}
					}
				}
				
				Set:tItemSpec'="" tSpec = tSpec _ $S(tSpec="":"",1:",") _ tItemSpec
				If (tIsLastItem) {
					If (c>1) {
						Set tSpec = "("_tSpec_")"
					}
				}

				// + WAL102
				If (tAxisNo=1) {
					Set tTooltipText = tRCubeCaption _ $S(tText="":"",1:"/") _ tTooltipText
				}
				Else {
					Set tTooltipText = tTooltipText _ $S(tText="":"",1:"/") _ tRCubeCaption
				}
				// - WAL102
				Set tThisText = tRCubeCaption_":"_$LG(tInfo,2)
				Set tText = tText _ $S(tText="":"",1:" / ") _ tThisText
				Set:tIsLastItem tIsRelation = 1
			}
			Quit:tIsLastItem
		}
		ElseIf (tDimName="") {
			// assume an aggregate; loop over children, build set
			Set tIsAgg = 1
			Set tSetSpec = ""
			// JMD1366: try to be smarter about text for computed dimension
			// with %OR in it!
			Set tText = $LG(tInfo,2)
			Set tAgg = $LG(tInfo,4)
			Set tNeedText = 1
			If (tText=tAgg) {
				Set tText = ""
			}
			Else {
				Set tNeedText = 0
			}

			Set k2 = $O(^||DeepSee.AxisMembers(tKey,tAxisNo,pItemNo,k,""),1,tInfo2)
			While (k2'="") {
				// !!! change to recursive function!
				Set tDimNo = $LG(tInfo2,7)
				Set tHierNo = $LG(tInfo2,8)
				Set tLevelNo = $LG(tInfo2,9)
				Set tSC = ##class(%DeepSee.Utils).%GetDimensionCaption(pCubeName,tDimNo,tHierNo,tLevelNo,.tCaption)
				If $$$ISERR(tSC) Quit

				If (tNeedText) {
					// WAL102
					If (tAxisNo=1) {
						Set tTooltipText = tCaption _ $S(tText="":"",1:"/") _ tTooltipText
					}
					Else {
						Set tTooltipText = tTooltipText _ $S(tText="":"",1:"/") _ tCaption
					}
					// - WAL102
					Set tText = tText _ $S(tText="":"",1:" / ") _ tCaption_":"_$LG(tInfo2,2)
				}
				Set tItemSpec = "["_$LG(tInfo2,3) _ "]"
				Set:$LG(tInfo2,4)'="" tItemSpec = tItemSpec _ ".[" _ $LG(tInfo2,4) _ "]"
				Set:$LG(tInfo2,5)'="" tItemSpec = tItemSpec _ ".[" _ $LG(tInfo2,5) _ "]"
				Set:$LG(tInfo2,6)'="" tItemSpec = tItemSpec _ ".&[" _ $$$dsEscapeIdent($LG(tInfo2,6))_"]"
				Set tSetSpec = tSetSpec _ $S(tSetSpec="":"",1:",") _ tItemSpec
				Set k2 = $O(^||DeepSee.AxisMembers(tKey,tAxisNo,pItemNo,k,k2),1,tInfo2)
			}
			Set tSetSpec = "{"_tSetSpec_"}"
			Set tSpec = tSpec _ $S(tSpec="":"",1:",") _ tSetSpec
		}
		Else {
			Set tDimNo = $LG(tInfo,7)
			Set tHierNo = $LG(tInfo,8)
			Set tLevelNo = $LG(tInfo,9)
			Set tSC = ##class(%DeepSee.Utils).%GetDimensionCaption(pCubeName,tDimNo,tHierNo,tLevelNo,.tCaption)
			If $$$ISERR(tSC) Quit

			// WAL102
			If (tAxisNo=1) {
				Set tTooltipText = tCaption _ $S(tText="":"",1:"/") _ tTooltipText
			}
			Else {
				Set tTooltipText = tTooltipText _ $S(tText="":"",1:"/") _ tCaption
			}
			// - WAL102
			Set tText = tText _ $S(tText="":"",1:" / ") _ tCaption_":"_$LG(tInfo,2)
			
			// WAL032 -- handle %OR members
			Set tORSpec=$LG(tInfo,11)
			// WAL032

			// JMD976: test for null relationship
			If (($LG(tInfo,3)'="")&&($LG(tInfo,4)="")&&##class(%DeepSee.Utils).%IsRelationship(pCubeName,$LG(tInfo,3))) {
				Set tItemSpec = "["_$LG(tInfo,3) _ "].&[<null>]"
			}
			ElseIf (tORSpec'="") {
				// WAL032
				Set tBaseItemSpec = "["_$LG(tInfo,3) _ "]"
				Set:$LG(tInfo,4)'="" tBaseItemSpec = tBaseItemSpec _ ".[" _ $LG(tInfo,4) _ "]"
				Set:$LG(tInfo,5)'="" tBaseItemSpec = tBaseItemSpec _ ".[" _ $LG(tInfo,5) _ "]"
				
				Set tSC = ##class(%DeepSee.Utils).%MemberHasChildren(pCubeName,tDimNo,tHierNo,tLevelNo,.tHasChildren)
				If $$$ISERR(tSC) Quit
				
				Set tIsLastItem = ($O(^||DeepSee.AxisMembers(tKey,tAxisNo,pItemNo,k))="")	
				
				// Use next level in hierarchy for final child spec
				If (tIsLastItem && tHasChildren) {
					Set tSC = ##class(%DeepSee.Utils).%GetDimensionSpec(pCubeName,.tChildLevelSpec,tDimNo,tHierNo,tLevelNo+1)
					If $$$ISERR(tSC) Quit
					Set tItemSpecForChild=tChildLevelSpec_".MEMBERS"
				}
				Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
				Set tDimensionInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo))
				Set tMemberClass = $lg(tDimensionInfo,6)
				// Loop through the OR members specs
				Set tOrTermCount = 0
				For i=1:1:$length(tORSpec,"|") {
					Set tORMember = $p(tORSpec,"|",i)
					Set tORMemberKey = $classmethod(tMemberClass,"%GetMemberSpec",tORMember,"Patients",tDimNo,tHierNo,tLevelNo)
	
					If ($G(tORMemberKey)'="")&&(tORMember'="NO MEMBER") {
						// DTB598 - Only add real executable members to this set
						Set tItemSpec = tBaseItemSpec _ "." _ $G(tORMemberKey)
						Set tCompleteItemSpec = $G(tCompleteItemSpec) _ $S($G(tCompleteItemSpec)="":"",1:",") _ tItemSpec
						Set x = $I(tOrTermCount)
					}
				}
				// Add %OR to tItemSpec
				Set:(($G(tCompleteItemSpec)'="")&&(tOrTermCount>1)) tCompleteItemSpec="%OR({"_tCompleteItemSpec_"})"
				Set tSpec = tSpec _ $S(tSpec="":"",1:",") _ tCompleteItemSpec
				Set tItemSpec = tCompleteItemSpec
				If (c > 1) {
					Set tChildSpec = "CROSSJOIN("_tChildSpec_","_$S($G(tItemSpecForChild)'="":tItemSpecForChild,1:tItemSpec)
				}
				Else {
					Set tChildSpec = $S($G(tItemSpecForChild)'="":tItemSpecForChild,1:tItemSpec)
				}
			}
			Else {
				Set tItemSpec = "["_$LG(tInfo,3) _ "]"
				Set:$LG(tInfo,4)'="" tItemSpec = tItemSpec _ ".[" _ $LG(tInfo,4) _ "]"
				Set:$LG(tInfo,5)'="" tItemSpec = tItemSpec _ ".[" _ $LG(tInfo,5) _ "]"
				Set:$LG(tInfo,6)'="" tItemSpec = tItemSpec _ ".&[" _ $$$dsEscapeIdent($LG(tInfo,6))_"]"
				Set tSpec = tSpec _ $S(tSpec="":"",1:",") _ tItemSpec
				If (c > 1) {
					Set tChildSpec = "CROSSJOIN("_tChildSpec_","_tItemSpec
				}
				Else {
					Set tChildSpec = tItemSpec
				}
			}
			// WAL032
		}

		// next item
		Set k = $O(tItemList(k),1,tInfo)
		If ('tIsAgg&&(k="")) {
			// last item, test for children
			Set tSC = ##class(%DeepSee.Utils).%MemberHasChildren(pCubeName,tDimNo,tHierNo,tLevelNo,.tHasChildren)
			If $$$ISERR(tSC) Quit

			// WAL032 -- don't add ".children" if we are dealing with a %OR spec
			If (tHasChildren&&($LG(tInfo,11)="")) {
				Set tChildSpec = tChildSpec _ ".children"
			}
			// WAL032
		}
		If ('tIsAgg&&(c > 1)) {
			Set tChildSpec = tChildSpec_")"
		}
	}
	If $$$ISERR(tSC) {
		Set pSpec.error = $System.Status.GetOneErrorText(tSC)
		Quit 0
	}

	// make a tuple
	If ('tIsRelation) {
		If (c > 1) {
			Set tSpec = "("_tSpec_")"
		}
		If ('tHasChildren) {
			Set tChildSpec = ""
		}
	}
	Set pSpec.spec = tSpec
	Set pSpec.text = tText
	Set pSpec.childSpec = tChildSpec
	Set pSpec.tooltipText = tTooltipText // WAL102
	Quit 1
]]></Implementation>
</Method>

<Method name="getFilterForCells">
<Description>
Return the filter spec for the given cell range.</Description>
<FormalSpec>r1,c1,r2,c2,allRows,allCols</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// JMD1468

	allRows = ('undefined' == typeof allRows) ? false : (parseInt(allRows,10)==1);
	allCols = ('undefined' == typeof allCols) ? false : (parseInt(allCols,10)==1);

	var filter = '';
	if (''!=this.kpi) return filter;
	
	if (''==this.cubeKey || ''==this.queryKey) return filter;
	
	// DTB397 - Test typeof for 'undefined'
	c2 = ('undefined' == typeof c2) ? c1 : c2;
	r2 = ('undefined' == typeof r2) ? r1 : r2;
	
	// DTB828 [PFS010] - Cells now indexed by absolute value, do not apply any offset
	r1 = parseInt(r1)
	r2 = parseInt(r2)

	var proxy = new zenProxy();
	var ok = this.GetSlicerSpecForCells(proxy,this.cubeKey,this.queryKey,r1,c1,r2,c2,allRows,allCols,this.sortColumn,this.sortDir);
	// JMD1394 if query has been deleted; re-execute.
	if (proxy.nokey) {
		this.executeQuery(true);
		return '';
	}

	if (!ok) {
		alert(proxy.error);
	}
	else {
		filter = proxy.filter;
	}
	
	return filter;
]]></Implementation>
</Method>

<Method name="GetSlicerSpecForCells">
<Description>
Get the slicer spec for the given cell within the query result and place it into the proxy object.
Return true, if ok.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSpec:%ZEN.proxyObject,pCubeName:%String,pQueryKey:%String,pStartRow:%Integer,pStartCol:%Integer,pEndRow:%Integer="",pEndCol:%Integer="",pAllRows:%Boolean=0,pAllCols:%Boolean=0,pSortCol:%Integer=0,pSortDir:%String="ASC"</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	Set:pEndCol="" pEndCol = pStartCol
	Set:pEndRow="" pEndRow = pStartRow
	Set pSortCol = +pSortCol

	// re-open existing query
	Set tRS = ##class(%DeepSee.ResultSet).%New()
	Set tSC = tRS.%PrepareKey(pCubeName,pQueryKey)
	If $$$ISERR(tSC) {
		// JMD1394 tell the client that the query has been deleted
		Set pSpec.nokey = 1
		Set pSpec.error = $System.Status.GetOneErrorText(tSC)
		Quit 0
	}

 	// JMD1347 use %GetFiltersForCellRange
	Set tSC = tRS.%GetFiltersForCellRange(.tFilters,pStartRow,pStartCol,pEndRow,pEndCol,.tMsr,+pAllRows,+pAllCols,pSortCol,pSortDir)
	If $$$ISERR(tSC) {
		Set pSpec.error = $System.Status.GetOneErrorText(tSC)
		Quit 0
	}

	Set tSlicer = ""
	Set k = $O(tFilters(""))
	While (k'="") {
		Set tSlicer = tSlicer _ "%FILTER " _ tFilters(k) _ " "
		Set k = $O(tFilters(k))
	}
	Set pSpec.filter = tSlicer
	Quit 1
]]></Implementation>
</Method>

<Method name="GetQueryStatus">
<Description>
Check on the status of the given query.
Return true, if ok.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pObject:%ZEN.proxyObject,pCubeName:%String,pQueryKey:%String,pKPI:%String=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	Set tOK = 1
	Set pObject.queryPending = 0
	// JMD1339 report error
	Set pObject.error = ""

	If (pKPI'="") {
		// JMD900 Get status from KPI (pKPI is the KPI class name)
		Set pObject.queryStatus = 100
		Set pObject.queryComplete = 100

		// take a peek at the cache
		Set tClass = $$$UPPER(pKPI)
		If ((tClass'="")&&(pQueryKey'="")) {
			Set tPctComplete = $G($$$DeepSeeKPIGLVN(tClass,pQueryKey,"pctComplete"),100)
			If (tPctComplete<100) {
				Set pObject.queryStatus = tPctComplete
				Set pObject.queryComplete = tPctComplete
			}
		}
	}
	Else {
		Set tStatus = ##class(%DeepSee.ResultSet).%GetQueryStatus(pCubeName, pQueryKey, .tComplete,.tSC,.tPending)
		Set pObject.queryStatus = tStatus
		Set pObject.queryComplete = tComplete
		Set pObject.queryPending = tPending
		If $$$ISERR(tSC) {
			Set pObject.error = $System.Status.GetErrorText(tSC)
		}
	}
	Quit tOK
]]></Implementation>
</Method>

<Method name="GetQueryText">
<Description>
Get the MDX text for the current query.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pQueryKey:%String,pEncrypt:%Boolean=0</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	Set tMDX = ""
	// re-open existing query
	Set tRS = ##class(%DeepSee.ResultSet).%New()
	Set tSC = tRS.%PrepareKey(pCubeName,pQueryKey)
	If $$$ISERR(tSC) {
		Set tMDX = $System.Status.GetOneErrorText(tSC)
	}
	Else {
		Set tMDX = tRS.%GetQueryText()
		If (pEncrypt) {
			// DTB611 - Do not run encryption
			// Set tMDX = $ZCVT(tMDX,"O","UTF8")
			// Set tMDX = ##class(%CSP.Page).Encrypt(tMDX)
			Set tSC = $$$ERROR($$$NotImplemented)
			Set tMDX = $System.Status.GetOneErrorText(tSC)
		}
	}
	Quit tMDX
]]></Implementation>
</Method>

<Method name="SetCurrentQueryText">
<FormalSpec>pWhich:%String="current",pMDX:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	// + WAL075 -- method added
	Set tSC = $$$OK
	Try {
		// + WAL075 (2)
		If (pWhich="resolved") {
			Set tSC = ..resolvedQueryText.Clear()
		}
		ElseIf (pWhich="current") {
			Set tSC = ..currentQueryText.Clear()
		}
		// - WAL075 (2)
		Set tNumChunks = $system.SQL.CEILING($L(pMDX)/100)
		For i=1:1:tNumChunks {
			Set tCurrentChunkStart = (i-1)*100+1
			Set tCurrentChunkEnd = tCurrentChunkStart + 99
			Set tCurrentChunk = $E(pMDX,tCurrentChunkStart,tCurrentChunkEnd)
			Set tChunk = ##class(%DeepSee.Component.queryChunk).%New()
			Set tChunk.chunkText = tCurrentChunk
			If (pWhich="resolved") {
				Set tSC = ..resolvedQueryText.SetAt(tChunk,i)
				// Need to add each chunk to the page or we have problems
				Do:$IsObject($G(%page)) %page.%AddComponent(tChunk)
			}
			ElseIf (pWhich="current") {
				Set tSC = ..currentQueryText.SetAt(tChunk,i)
				// Need to add each chunk to the page or we have problems
				Do:$IsObject($G(%page)) %page.%AddComponent(tChunk)	
			}
		}
	}
	Catch (ex) {
		Set tSC = ex.AsStatus()	
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetCurrentQueryText">
<FormalSpec>pWhich:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	
	Try {
		// + WAL075
		Set:($G(pWhich)="") pWhich = "current"
		Set tMDX=""
		Set tText = ""
	
		If (pWhich="resolved") {
			Set tText = ..resolvedQueryText
		}
		ElseIf (pWhich="current") {
			Set tText = ..currentQueryText
		}
		ElseIf (pWhich="export") {
			// DTB835 - The export mode pulls directly from the current pivotTable object without truncations, and resolves the text
			Set tRawMDX = ..SynthesizeMDX(.tSC,,,,,,,,,,1)
			If $$$ISERR(tSC) Quit
			
			// Resolve pivot variables
			Kill tVariables
			If (..cubeName'="") {
				// DTB572 - Always assemble the list of available variables
				Set tSC = ##class(%DeepSee.Utils).%GetPivotVariables(..cubeName,.tVariableList)
				If $$$ISERR(tSC) Quit
				Set vk = $O(tVariableList(""))
				While (vk'="") {
					Set tVName = $$$LOWER($LG(tVariableList(vk),1))
					Set tVDefValue = $LG(tVariableList(vk),3)
					Set tVariables(tVName) = tVDefValue
					Set tVRuntime = ..pivotVariables.GetAt(tVName)
					Set:tVRuntime'="" tVariables(tVName) = tVRuntime
					Set vk = $O(tVariableList(vk))
				}
			}
			Set tRS = ##class(%DeepSee.ResultSet).%New()
			Set tSC = tRS.%PrepareMDX(tRawMDX,.tVariables,.tMDX)
			If $$$ISERR(tSC) Quit
		}

		If (tText'="") {
			For i=1:1:tText.Count() {
				Set tMDX = $G(tMDX)_tText.GetAt(i).chunkText
			}
		}
		// - WAL075
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	If $$$ISERR(tSC) {
		// DTB835 - Return text of errors in the return string
		Set tMDX = $system.Status.GetErrorText(tSC)
	}
	
	Quit tMDX
]]></Implementation>
</Method>

<Method name="KillQuery">
<Description><![CDATA[
Cancel the query specified by <var>pCubeName</var> and  <var>pQueryKey</var>.
Return true, if ok.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pQueryKey:%String,pNonce:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	Set tOK = 1
	If (pQueryKey="") {
		// query is still setting up; set cancel global
		If (pNonce'="") {
			Set ^DeepSee.Cancel(pNonce) = ""
		}
	}
	Else {
		// query is already running
		Set tSC = ##class(%DeepSee.ResultSet).%CancelQuery(pCubeName, pQueryKey)
		If $$$ISERR(tSC) {
			Set tOK = 0
		}
	}
	Quit tOK
]]></Implementation>
</Method>

<Method name="showIKnowMeasureValue">
<FormalSpec>cubeName,measure,objId</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var parms = {
			CUBE:cubeName,
			MEASURE:measure,
			OBJIDS:objId
			};
			
	zenLaunchPopupWindow('_iKnow.DeepSee.UI.MeasureValue.zen',measure,'status,scrollbars,resizable=yes,width=800,height=600',parms);
]]></Implementation>
</Method>

<Method name="%MaterializeListing">
<Description><![CDATA[
Execute the listing for a drillthrough query and save it to a cache global.<br/>
If <var>pSQLRS</var> is provided, use it.]]></Description>
<Internal>1</Internal>
<FormalSpec>pRS:%DeepSee.ResultSet,pSQLRS:%SQL.StatementResult=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// JMD1331
	Set tSC = $$$OK
	Try {
		If (..listingType = "map") {
			Quit
		}

		Set tDayNo = +$H
		If (..listingKey="") {
			Set ..listingKey = $I($$$DeepSeeListingResultsGLVN(tDayNo))
		}
		Set tPivotNo = ..listingKey

		// if we are on a different "page" of existing results, we can use the cached values
		If ($D($$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo))&&(..currListingPage>0)) {
			Quit
		}

		If (..currListingPage<1) {
			Set ..currListingPage = 1
		}

		Kill $$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo)

		// listing is written to $$$DeepSeeListingResultsGLVN(DAY,PIVOT#)
		// ...("rows",row#) = $LB(row)
		// ...("cols",col#) = $LB(colName,ODBCtype,style)

		Set tStart = $ZH
		Set $$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"lastExec") = $ZDT($H,3)
		Set:$IsObject(pRS) $$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"sql") = pRS.%GetListingSQL()

		If $IsObject(pSQLRS) {
			// use sql result set provided by caller
			Set tRS = pSQLRS
			Set tListingFields = ""
		}
		Else {
			// make sure listing is executed
			// these sizes are ignored for page=1;
			// which is the only case we should ever see!
			Set pRS.listingPage = ..currListingPage
			Set pRS.listingPageSize = ..listingPageSize

			Set tSC = pRS.%ExecuteListing()
			If $$$ISERR(tSC) Quit

			// use SQL result set to get answers
			Set tSC = pRS.%GetListingResultSet(.tRS,.tListingFields)
			If $$$ISERR(tSC) Quit
		}

		// JMD987: get information from result set after exec
		Set ..listingRowCount = +..%ResultSet.listingRows
		Set tFormatList = $S($IsObject(pRS):pRS.listingFormatList,1:"")

		Set tColumnMeta = tRS.%GetMetaData().columns
		If (tListingFields = "") {
			Set tColCount = tColumnMeta.Count()
		}
		Else {
			Set tColCount = $LL(tListingFields)
		}

		Merge tColIndex=tRS.%GetMetaData().columnIndex
		// headers
		kill tIKLinkCols
		For c = 1:1:tColCount {
			If (tListingFields = "") {
				Set tColInfo = tColumnMeta.GetAt(c)
				Set tColName = tColInfo.colName
			} Else {
				set tColName = $LG(tListingFields,c)
				Set tColInfo = tColumnMeta.GetAt($LG(tColIndex($$$UPPER(tColName)),1))
			}
			Set tColStyle = $P(tFormatList,"^",c)
			
			Set $$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"cols",c) = $LB(tColName,tColInfo.ODBCType,tColStyle)
		}

		// get results
		Set tRow = 0
		While (tRS.%Next(.tSC)) {
			If $$$ISERR(tSC) Quit
			Set tRow = tRow + 1
			Set tRowData = ""
			For c = 1:1:tColCount {
				If (tListingFields = "") {
					Set tValue = tRS.%GetData(c)
				}
				Else {
					Set tValue = tRS.%Get($LG(tListingFields,c))
				}
				Set $List(tRowData,c) = tValue
			}
			Set $$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"rows",tRow) = tRowData
		}
		If $$$ISERR(tSC) Quit

		Set $$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"xecTime") = $ZH - tStart

		Set ..listingRowCount = +..%ResultSet.listingRows

		#; JMD1318 recompute actual listingSize
		If (tRow <..listingRowCount) {
			Set ..listingRowCount = tRow
		}
		// + WAL138 -- needed for KPIs since they don't set ..listingRowCount
		//             anywhere else. If it remains 0 paging doesn't work
		// WAL257 && SK -- if condition more permissive to handle custom SQL listings as well
		If ((..listingRowCount<tRow) && (tRow <= ..listingRows)) { // WAL257 (2) -- respect max
			Set ..listingRowCount = tRow	
		}
		ElseIf (tRow > ..listingRows ) { // WAL257 (2) -- report correct number of records if truncating
			Set ..listingRowCount = ..listingRows
			// + WAL309 -- this case means that the user has not configured a max listing row number for this pivot 
			If (..listingRows="") {
				If (tRow>=..#MAXLISTINGROWS) {
					Set ..listingRowCount = ..#MAXLISTINGROWS 
				}
				Else {
					Set ..listingRowCount = tRow		
				}
			}
			// - WAL309
		}
		// - WAL138
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%DrawListing">
<Description><![CDATA[
Draw the listing table for a drillthrough query.<br/>
Assume the listing has been materialized to a listing global.]]></Description>
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set hlpAll = $$$Text("Select or unselect all items","%DeepSee")
		
		Set ..singleTable = 0 // WAL106

		#; message box
		&html<<div id="#(..%MakeId("message"))#" class="dsPivotMessage" style="display: none;">&nbsp;</div>>

		#; Use divs to layout 2 tables
		#; (plus status area on the bottom)
		&html<<div class="dsptOuterDiv" id="#(..%MakeId("outerDiv"))#">>

		If (..listingType = "map") {
			// do not show table
			// show a neutral message in case this is visible
			Write "<div style=""padding:10px; color: #808080;"">",$$$Text("Formatting results..."),"</div>"
			Write "</div>"
			Quit
		}

		// get column meta data from cache
		Set tDayNo = +$H
		Set tPivotNo = ..listingKey

		If ((tPivotNo="")||'$D($$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo))) {
			Write "<div style=""padding:10px;padding-top:50px;color:#804040;"">",$$$Text("Unable to find listing results..."),"</div>"
			Write "</div>"
		}

		Set tColCount = 0
		Set c = $O($$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"cols",""),1,tInfo)
		While (c'="") {
			Set tColCount = tColCount + 1
			Set tColName(c) = $LG(tInfo,1)
			Set tColStyle(c) = $LG(tInfo,3)

			#; type--> 2:float,4:integer,12:string,8:double ???
			Set tColClass(c) = $Case($LG(tInfo,2),2:"number",4:"number",8:"number",:"")

			Set c = $O($$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"cols",c),1,tInfo)
		}

		If (..showQuery) {
			&html<<textarea rows="3" style="width:100%;margin-top:40px;">>
			Write $ZCVT($G($$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"sql")),"O","HTML")
			&html<</textarea>>
		}

		// + WAL299 -- check for no data, adjust styling to show column headers in this case
		Set tOffset = (..currListingPage-1)*(..listingPageSize)
		Set r = $O($$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"rows",""))
		Set n = 0
		Set tNoData=1
		For tRowNo = (tOffset+1):1:(tOffset+..listingPageSize) {
			Set tRowData = $G($$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"rows",tRowNo))
			If (tRowData="") Quit
			Set n = n+1
		}
		Set:n>0 tNoData=0
		// - WAL299

		// show checkboxes?
		Set tShowCB = (..listingSelect'="")
		Set tHdrStyle = ""
		If (..columnHeaderStyle'="") {
			Set tHdrStyle = tHdrStyle_..columnHeaderStyle
		}
		Else {
			Set:tNoData tHdrStyle = "width:20px;"  // WAL299
		}
		Set tNumStyle = "style="_$$$quote("text-align:center;"_tHdrStyle)
		Set:tNoData tHdrStyle = tHdrStyle_"width:100px;"  // WAL299

		#; top table: column headers
		&html<<div class="dsptTopRightDiv" id="#(..%MakeId("topRightDiv"))#">>

		&html<<table id="#(..%MakeId("topTable"))#" border="0" cellpadding="0" cellspacing="0" class="dsListingTable">>
		&html<<tr>>
		If (..listingSelect = "multi") {
			&html<<th width="1" class="dsListingColumn" id="#(..%MakeId("col_"_1_":"_1))#" style="#(tHdrStyle)#"><div class="dsptListCellDiv"><input type="checkbox" id="#(..%MakeId("cb_all"))#" title="#(hlpAll)#" onclick="zenPage.getComponent(#(..index)#).allClick(event);"/></div></th>>
		}
		ElseIf (tShowCB) {
			&html<<th width="1" class="dsListingColumn" id="#(..%MakeId("col_"_1_":"_1))#" style="#(tHdrStyle)#"><div class="dsptListCellDiv">&nbsp;</div></th>>
		}
		&html<<th class="dsListingColumn" id="#(..%MakeId("col_"_1_":"_2))#" #(tNumStyle)#><div class="dsptListCellDiv">#</div></th>>

		// headers
		kill tIKLinkCols
		For c = 1:1:tColCount {

			Set tCls = $S(..listingSortColumn=c:"dsListingColumnSort",1:"dsListingColumn")
			Set tSortChar = $S(..listingSortColumn=c:$S(..listingSortDir="DESC":"&#x25BC;",1:"&#x25B2;"),1:"")
			Set tXStyle = $S($G(tColStyle(c))["display:none;":"display:none;",1:"")

			// BDB296: check if this is an $$$IKLINK column (prefixed with ___IKLINK)
			set tColName = tColName(c)
			set:$p(tColName," ",1)="___IKLINK" tColName = $p(tColName," ",2,999), tIKLinkCols(c) = tColName

			// apply align to inner div
			Set tDivStyle = ""
			Set tTestStyle = $TR(tHdrStyle," ","")
			If ((tTestStyle["text-align:left;")) {
				Set tDivStyle = "text-align:left;"
			}
			If (tTestStyle["text-align:center;") {
				Set tDivStyle = "text-align:center;"
			}
			Set tIStyle = ""
			Set:tDivStyle'="" tIStyle = "style="_$$$quote(tDivStyle)

			&html<<th class="#(tCls)#" style="#(tHdrStyle_tXStyle)#" id="#(..%MakeId("col_"_1_":"_(c+2)))#" ondblclick="zenPage.getComponent(#(..index)#).listingHeaderDblClickHandler(event,#(c)#);"><div class="dsptListCellDiv" #(tIStyle)#>#($ZCVT(tColName,"O","HTML"))# #(tSortChar)#</div></th>>
		}
		&html<</tr>>
		&html<</table>>

		&html<</div>>

		// show results (for current page)
		&html<<div class="dsptBottomRightDiv" id="#(..%MakeId("bottomRightDiv"))#">>
		&html<<table id="#(..%MakeId("dataTable"))#" border="0" cellpadding="0" cellspacing="0" class="dsListingTable">>

		Set tOffset = (..currListingPage-1)*(..listingPageSize)
		Set r = $O($$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"rows",""))
		Set n = 0
		For tRowNo = (tOffset+1):1:(tOffset+..listingPageSize) {
			Set n = n + 1
			Set tRowData = $G($$$DeepSeeListingResultsGLVN(tDayNo,tPivotNo,"rows",tRowNo))
			If (tRowData="") Quit
			Set tRowValue = $LG(tRowData)	// use first column

			&html<<tr id="#(..%MakeId("tr_"_n))#" rowno="#(n)#" value="#($ZCVT(tRowValue,"O","HTML"))#" class="#($S(n#2:"oddRow",1:"evenRow"))#">>
			If (tShowCB) {
				&html<<td id="#(..%MakeId("cell_"_n_"_"_1))#"><div class="dsptListCellDiv"><input type="checkbox" id="#(..%MakeId("cb_"_n))#" onclick="zenPage.getComponent(#(..index)#).cbClick(event,this);"/></div></td>>
			}
			&html<<td style="text-align:right;width:2.0em;" id="#(..%MakeId("cell_"_n_"_"_2))#"><div class="dsptListCellDiv">#(n+tOffset)#&nbsp;</div></td>>
			For c = 1:1:tColCount {
				Set tValue = $LG(tRowData,c)
				Set tCls = $S(tColClass(c)="":"",1:"class="""_tColClass(c)_"""")

				// BDB296: if this is an iKnow measure column, show the link
				if ($d(tIKLinkCols(c), tColName)) {
					set tValue = "<a href=""#"" onclick=""zenPage.getComponent("_..index_").showIKnowMeasureValue("_tValue_");""><img style=""height:16px;"" src=""deepsee/ds2_magnify_44.png"" title="""_tColName_""" /></a>"
				} else {
					set tValue = $ZCVT(tValue,"O","HTML")
				}
				// JMD1023
				Set:tValue="" tValue="&nbsp;"

				// apply align to inner div
				Set tDivStyle = ""
				Set tTestStyle = $TR($G(tColStyle(c))," ","")
				//+ MES001 Changed if to elseif
				If ((tTestStyle["text-align:left;")) {
					Set tDivStyle = "text-align:left;"
				}
				ElseIf (tTestStyle["text-align:center;") {
					Set tDivStyle = "text-align:center;"
				}
				ElseIf ((tCls["number") || (tTestStyle["text-align:right;")) {
					Set tDivStyle = "text-align:right;"
				}
				//- MES001
				Set tIStyle = ""
				Set:tDivStyle'="" tIStyle = "style="_$$$quote(tDivStyle)
				&html<<td #(tCls)# style="#($G(tColStyle(c)))#" id="#(..%MakeId("cell_"_n_"_"_(c+2)))#" nowrap="1"><div class="dsptListCellDiv" #(tIStyle)#>#(tValue)#</div></td>>
			}
			&html<</tr>>
		}
		If $$$ISERR(tSC) Quit

		&html<</table>>
		&html<</div>>

		#; status area
		#; JMD1313: show buttons if we need to
		Set tPageCount = (..listingRowCount \ ..listingPageSize) + $S(..listingRowCount#..listingPageSize:1,1:0)
		If (..showStatus || (tPageCount>1)) {
			&html<<div class="dsptStatusDiv" id="#(..%MakeId("statusDiv"))#">>
			Set tSC = ..%DrawStatusArea(tPageCount,"listing")
			&html<</div>> // outer
		}

		// outer div
		&html<</div>>
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ShowPlan">
<Description>
Show execution plan for the query</Description>
<FormalSpec>pRS:%DeepSee.ResultSet</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// make sure listing is executed
		Set tSC = pRS.%GetPlan(.tPlan)
		If $$$ISERR(tSC) Quit

		&html<<div style="overflow:auto; height:100%; width:100%;">>
		Set tKey = $O(tPlan(""))
		Do ..%ShowPlanItem(.tPlan, tKey)
		&html<<br/></div>>
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ShowPlanItem">
<Description>
Show one item in a query plan.</Description>
<FormalSpec><![CDATA[&pPlan,pNodeNo:%Integer,pLevel:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tType = $LG(pPlan(pNodeNo),1)
		Set tParm = $LG(pPlan(pNodeNo),2)
		Set tParm2 = $LG(pPlan(pNodeNo),3)
		Set tText = ""
		Set tBgColor = "white"
		If (tType="query") {
			Set tText = "<b>Query execution plan:</b><hr/><span style=""color:#404040;"">"_$ZCVT(tParm,"O","HTML")_"</span>"
		}
		ElseIf (tType="subquery") {
			Set tText = "<b>Execute subquery:</b><hr/><span style=""color:#404040;"">"_$ZCVT(tParm,"O","HTML")_"</span>"
		}
		ElseIf (tType="consolidate") {
			Set tText = "<b>Consolidate answers</b>"
			Set tBgColor = "#E0E0F0"
		}
		ElseIf (tType="execA") {
			Set tText = "<b>Compute cell values in parallel</b><hr/>"_(tParm*tParm2)_"&nbsp;("_tParm_" x "_tParm2_")&nbsp;"_"Tasks"
		}
		ElseIf (tType="exec") {
			Set tText = "<b>Compute cell values</b><hr/>"
		}
		ElseIf (tType="listing") {
			Set tText = "<b>Execute listing query:</b><hr/><span style=""color:#404040;"">"_$ZCVT(tParm,"O","HTML")_"</span>"
		}
		ElseIf (tType="dim") {
			Set tText = "<b>Execute dimension query: ("_tParm2_")</b><hr/><span style=""color:#404040;"">"_$ZCVT(tParm,"O","HTML")_"</span>"
		}
		Else {
			Set tText = tType
		}

		&html<<div class="dsptPlanItem" style="background:#(tBgColor)#; width:#(800-((pLevel+2)*20))#px; margin-top:10px; margin-left:#((pLevel+2)*20)#px;">#(tText)#</div>>

		Set tChild = $O(pPlan(pNodeNo,"ch",""))
		While (tChild'="") {
			Do ..%ShowPlanItem(.pPlan, tChild, pLevel + 1)
			Set tChild = $O(pPlan(pNodeNo,"ch",tChild))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="filterLabelClick">
<Description>
Click on an item label within the filter dropdown.</Description>
<FormalSpec>evt,filterValue</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var ctrl = this._cbIndex[(''==filterValue)?' ':filterValue];
	ctrl.checked = !ctrl.checked;
	this.filterItemClick(evt,filterValue);
]]></Implementation>
</Method>

<Method name="pushState">
<Description>
Push the current state of the pivot onto the "history" stack.</Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (null == this._history) {
		this._history = new Array();
		this._historyStack = 0;
	}

	var state = new Object();
	state.rowAxisOptions = this.rowAxisOptions.clone();
	state.columnAxisOptions = this.columnAxisOptions.clone();

	// override spec
	state.overrideRowSpec = this.overrideRowSpec;
	state.overrideRowText = this.overrideRowText;
	state.overrideColumnSpec = this.overrideColumnSpec;
	state.overrideColumnText = this.overrideColumnText;

	state.rowLevels = new Array();
	for (n = 0; n < this.rowLevels.length; n++) {
		state.rowLevels[n] = this.rowLevels[n].clone();
	} 
	state.columnLevels = new Array();
	for (n = 0; n < this.columnLevels.length; n++) {
		state.columnLevels[n] = this.columnLevels[n].clone();
	} 
	state.filters = new Array();
	for (n = 0; n < this.filters.length; n++) {
		state.filters[n] = this.filters[n].clone();
	} 
	state.measures = new Array();
	for (n = 0; n < this.measures.length; n++) {
		state.measures[n] = this.measures[n].clone();
	} 
	state.drillLevels = new Array();
	state.drillRowNumbers = new Array(); // WAL224
	for (n = 0; n < this.drillLevels.length; n++) {
		state.drillLevels[n] = this.drillLevels[n].clone();
		state.drillRowNumbers[n] = this.drillRowNumbers[n]; // WAL224
	} 
	state.listingFilters = new Array();
	for (n = 0; n < this.listingFilters.length; n++) {
		state.listingFilters[n] = this.listingFilters[n].clone();
	} 

	state.isDrillThrough = this.isDrillThrough;
	state.selectedRange = this.selectedRange;
	this._history[this._historyStack] = state;
	this._historyStack++;
]]></Implementation>
</Method>

<Method name="popState">
<Description>
Pop the current state of the pivot from the "history" stack.</Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (null == this._history || this._historyStack == 0) {
		return;
	}
	this._historyStack--;
	var state = this._history[this._historyStack];

	this.rowAxisOptions = state.rowAxisOptions.clone(true);
	this.columnAxisOptions = state.columnAxisOptions.clone(true);

	// override spec
	this.overrideRowSpec = state.overrideRowSpec;
	this.overrideRowText = state.overrideRowText;
	this.overrideColumnSpec = state.overrideColumnSpec;
	this.overrideColumnText = state.overrideColumnText;

	this.rowLevels = new Array();
	for (n = 0; n < state.rowLevels.length; n++) {
		this.rowLevels[this.rowLevels.length] = state.rowLevels[n].clone(true);
	} 

	this.columnLevels = new Array();
	for (n = 0; n < state.columnLevels.length; n++) {
		this.columnLevels[this.columnLevels.length] = state.columnLevels[n].clone(true);
	} 

	this.filters = new Array();
	for (n = 0; n < state.filters.length; n++) {
		this.filters[this.filters.length] = state.filters[n].clone(true);
	}

	this.measures = new Array();
	for (n = 0; n < state.measures.length; n++) {
		this.measures[this.measures.length] = state.measures[n].clone(true);
	}

	this.drillLevels = new Array();
	this.drillRowNumbers = new Array(); // WAL224
	for (n = 0; n < state.drillLevels.length; n++) {
		this.drillLevels[this.drillLevels.length] = state.drillLevels[n].clone(true);
		// WAL224 -- remember which row should be selected after returning from drill down
		this.drillRowNumbers[this.drillRowNumbers.length] = state.drillRowNumbers[n];
	}
	this.listingFilters = new Array();
	for (n = 0; n < state.listingFilters.length; n++) {
		this.listingFilters[this.listingFilters.length] = state.listingFilters[n].clone(true);
	}

	if (state.isDrillThrough) {
		this.selectedRange = state.selectedRange;
		this.isDrillThrough = true;
		this.executeListing();
	}
	else {
		if (this.isDrillThrough) {
			this.mdx = '';
			this.isDrillThrough = false;
		}
		this.executeQuery(true);
	}

	// JMD1362
	this.updateController();

	if (zenPage.UpdateFilterControls) {
		var msg = zenPage.UpdateFilterControls(this.cubeName,zen('filterGroup'),this);
		if (''!==msg) {
			alert(msg);
		}
	}
]]></Implementation>
</Method>

<Method name="copyState">
<Description>
Copy the (most of the) current state of another pivot into this one.
Used by linked pivots.</Description>
<Internal>1</Internal>
<FormalSpec>master</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.rowLevels = new Array();
	for (n = 0; n < master.rowLevels.length; n++) {
		this.rowLevels[this.rowLevels.length] = master.rowLevels[n].clone(true);
	} 

	this.columnLevels = new Array();
	for (n = 0; n < master.columnLevels.length; n++) {
		this.columnLevels[this.columnLevels.length] = master.columnLevels[n].clone(true);
	} 

	/*
	this.filters = new Array();
	for (n = 0; n < master.filters.length; n++) {
		this.filters[this.filters.length] = master.filters[n].clone(true);
	}
	*/

	this.measures = new Array();
	for (n = 0; n < master.measures.length; n++) {
		this.measures[this.measures.length] = master.measures[n].clone(true);
	}

	this.drillLevels = new Array();
	this.drillRowNumbers = new Array();
	for (n = 0; n < master.drillLevels.length; n++) {
		this.drillLevels[this.drillLevels.length] = master.drillLevels[n].clone(true);
		// WAL224 -- remember which row should be selected after returning from drill down
		this.drillRowNumbers[this.drillRowNumbers.length] = master.drillRowNumbers[n];
	}
]]></Implementation>
</Method>

<Method name="hasFormatRules">
<Description>
Indicate if there are any formatting rules in play.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return (this.colorScale || (this.formatRules && this.formatRules.length > 0)) ? true : false;
]]></Implementation>
</Method>

<Method name="canGoBack">
<Description>
Indicate if we can go back to a prior state.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return this._historyStack ? true : false;
]]></Implementation>
</Method>

<Method name="goBack">
<Description>
Go back to the previous state.</Description>
<FormalSpec>notify</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.pushState();
	this._historyStack--;
	this.popState();
	if (notify) {
		zenInvokeCallbackMethod(this.ondrill,this,'ondrill','pivot',this);
	}
]]></Implementation>
</Method>

<Method name="canGoForward">
<Description>
Indicate if we can go forward to a visited state.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (null == this._history || null == this._history[this._historyStack+1]) {
		return false;
	}
	return true;
]]></Implementation>
</Method>

<Method name="goForward">
<Description>
Go forward to the next state (if there is one).</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (null == this._history || null == this._history[this._historyStack+1]) {
		return;
	}
	this._historyStack += 2;
	this.popState();
]]></Implementation>
</Method>

<Method name="%ClearDataModified">
<Description>
Clear the (shadow) modified bit for the data property.</Description>
<Internal>1</Internal>
<CodeMode>objectgenerator</CodeMode>
<Implementation><![CDATA[
#if ($p($p($p($ZV,") ",2)," ",1),".",1))>=2011
	Do %code.WriteLine(" Set s%data = 0")
#else
	Set tModBit = $P($$$comMemberKeyGet(%compiledclass.Name,$$$cCLASSinstancevar,"data",$$$cIVARslot),",")
	Do %code.WriteLine(" Set $zobjmod(,/*data*/"_tModBit_")=0")
#endif
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%SetDataModified">
<Description>
Set the (shadow) modified bit for the data property.</Description>
<Internal>1</Internal>
<CodeMode>objectgenerator</CodeMode>
<Implementation><![CDATA[
#if ($p($p($p($ZV,") ",2)," ",1),".",1))>=2011
	Do %code.WriteLine(" Set s%data = 1")
#else
	Set tModBit = $P($$$comMemberKeyGet(%compiledclass.Name,$$$cCLASSinstancevar,"data",$$$cIVARslot),",")
	Do %code.WriteLine(" Set $zobjmod(,/*data*/"_tModBit_")=1")
#endif
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnDrawObjectProperties">
<Description>
Render the JSON content of the target object
along with the other properties of the provider.</Description>
<Internal>1</Internal>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Write "// JSON: OnDrawObjectProperties",!
		Write "o.data = "
		Set tSC = ..%DrawJSON()
		Write ";",!

		// clear modbit so that we don't later update content
		Do ..%ClearDataModified()
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	If $$$ISERR(tSC) {
		Do ##class(%ZEN.Utils).%DisplayErrorJS(##this,tSC)
	}
]]></Implementation>
</Method>

<Method name="%OnObjectSynch">
<Description>
Render the JSON content of the target object
along with the other properties of the provider.</Description>
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	// if user has set or modified the target object
	// then update the client content

	// DEBUG OUTPUT
	If (0) {
		Set io = $io
		Set tFile = "c:/temp/json.txt"
		Open tFile:"WNS":0 Else  Quit $$$ERROR($$$FileCanNotOpen,tFile)
		Use tFile
		Set tSC = ..%DrawJSON()
		Use io
		Close tFile
	}

	Write "// JSON: %OnObjectSynch",!
	Write "o.data = "
	Set tSC = ..%DrawJSON()
	Write ";",!
	
	// raise notification that new data is present
	Write "zenPage.getComponent("_..index_").newDataHandler();",!

	// clear modbit so that we don't later update content
	Do ..%ClearDataModified()
	Quit tSC
]]></Implementation>
</Method>

<Method name="%DrawJSON">
<Description>
Draw JSON output for the current query results.</Description>
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (..kpi'="") {
			Set tSC = ..%OutputJSONForKPI()
			Quit
		}

		// JMD: if there is no result set then it could be that there is a request
		// to refresh this component without rendering its HTML
		// Try to recreate the result set in that case

		If '$IsObject(..%ResultSet) {
			If (..queryKey '= "") {
				// re-open existing query
				Set tRS = ##class(%DeepSee.ResultSet).%New()
				Set tRS.%Recompute = 0
				Set ..%ResultSet = tRS
				Set tSC = tRS.%PrepareKey(..cubeName,..queryKey)
				Set ..%ResultSet = tRS
			}
		}

		If '$IsObject(..%ResultSet) {
			Write "null"
		}
		ElseIf (..%ResultSet.%IsDrillThrough()) {
			If (..listingType="map") {
				// write out JSON data for geolisting
				Set tSC = ..%OutputJSONForGeoListing(..%ResultSet)
			}
			Else {
				If (..showPivot) {
					Write "null"
				}
				Else {
					// write out JSON data for listing
					Set tSC = ..%OutputJSONForGeoListing(..%ResultSet)
				}
			}
		}
		Else {
			Set tDrillCount = ..drillLevels.Count()
			Set nr = 0
			Set tLevel = ..rowLevels.GetAt(1)
			While $IsObject(tLevel) {
				If (tLevel.drillLevel = tDrillCount) {
					Set tRowCaptions($I(nr)) = tLevel.caption
				}
				Set tLevel = tLevel.childLevels.GetAt(1)
			}
			Set tSC = ..%ResultSet.%OutputJSON(..pageSize,..currPage,.tRowCaptions,..jsonRows)
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
		Set tText = $System.Status.GetOneErrorText(tSC)
		Write "'",$ZCVT(tText,"O","JS"),"'"
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OutputJSONForGeoListing">
<Description>
Draw JSON output for a geolisting.</Description>
<Internal>1</Internal>
<FormalSpec>pRS:%DeepSee.ResultSet,pSQLRS:%SQL.StatementResult=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// n.b. zu(144) does not handle quotes correctly for JS!
#define JS(%x) $S($IsValidNum(%x):+%x,1:""""_$ZCVT(%x,"O","JS")_"""")

	Set tSC = $$$OK
	Try {
		If $IsObject(pSQLRS) {
			// use sql result set provided by caller
			Set tRS = pSQLRS
			Set tListingFields = ""
		}
		Else {
			// make sure listing is executed
			Set tSC = pRS.%ExecuteListing()
			If $$$ISERR(tSC) Quit

			// use SQL result set to get answers
			Set tSC = pRS.%GetListingResultSet(.tRS,.tListingFields)
			If $$$ISERR(tSC) Quit
		}

		Set tColumnMeta = tRS.%GetMetaData().columns
		If (tListingFields = "") {
			Set tColCount = tColumnMeta.Count()
			For c = 1:1:tColCount {
				Set tColInfo = tColumnMeta.GetAt(c)
				Set tPropName(c) = tColInfo.colName
			}
		}
		Else {
			Set tColCount = $LL(tListingFields)
			For c = 1:1:tColCount {
				Set tColInfo = tColumnMeta.GetAt(c)
				Set tPropName(c) = $LG(tListingFields,c)
			}
		}
		
		// !!! compute range of map !!!

		Write "{"
		Write "_isListing:true,"
		Write "axes:[],"
		Write "rows:[],"

		Write "listingRows:[",!

		// loop over results
		Set n = 0
		While (tRS.%Next(.tSC)) {
			If $$$ISERR(tSC) Quit
			Write:n>0 ","
			Write "{"
			Set n = n + 1
			For c = 1:1:tColCount {
				If (tListingFields = "") {
					Set tValue = tRS.%GetData(c)
				}
				Else {
					Set tValue = tRS.%Get($LG(tListingFields,c))
				}

				Write:c>1 ","

				// check for valid prop names
				Set tProp = tPropName(c)
				Set tProp = $Translate(tProp," %'+-*/""$#@^&","_")

				Write tProp,":",$$$JS(tValue),!
			}
			Write "}",!
		}

		Write "]",!
		Write "}",!

	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
		Set tText = $System.Status.GetOneErrorText(tSC)
		Write "'",$ZCVT(tText,"O","JS"),"'"
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OutputJSONForKPI">
<Description>
Draw JSON output for the current KPI class.</Description>
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define JS(%x) $S($IsValidNum(%x):+%x,1:""""_$ZCVT(%x,"O","JS")_"""")

	Set tSC = $$$OK
	Try {
		If '$IsObject(..%KPIController) {
			Write "null"
			Quit
		}
		Set tController = ..%KPIController
		If ('$IsObject(tController)) {
			Write "null"
			Quit
		}

		Set tRowCount = tController.dataBag.seriesCount
		Set tModel = tController.%model

		If ('$IsObject(tModel)) {
			Write "null"
			Quit
		}

		Set tSC = ..%GetKPIColumns(tController,.tColCount,.tColProps,..columnList)
		If $$$ISERR(tSC) Quit

		Write "{"
		Write "cubeName:",$$$JS(..kpi),",",!
		Write "cubeClass:",$$$JS(..kpi),",",!
		Write "axes:[",!

		// column axis
		Write "{",! // axis object
		//Write "key:",$$$JS(tAxisKey),",",!
		Write "tuples:[",!
		Set n = 0

		For c=1:1:tColCount {
			Set tCaption = $S($D(tColProps(c,"caption")):tColProps(c,"caption"),1:$G(tColProps(c)))
			Write:c>1 ","
			Write "{" // tuple object
			Write "caption:",$$$JS(tCaption)
			Write "}",! // tuple object
		}

		Write "]",! // tuples

		Write "}",! // axis object

		// row axis
		Write ",{",! // axis object
		//Write "key:",$$$JS(tAxisKey),",",!

		Write "tuples:[",!
		For tRow = 1:1:tRowCount {
			Write:tRow>1 ","
			Write "{" // tuple object
			Write "caption:",$$$JS($G(tModel.%seriesNames(tRow)))
			Write "}",! // tuple object
		}

		Write "]",! // tuples

		Write "}",! // axis object


		Write "],",! // axes

		// data

		// JMD1227: simplify JSON for data
		// fastest way is to not use pure JSON!
		// instead, define an array of known-size and explicitly insert values into it.
		// data is written out as [R1C1,R1C2,R1C3,R2C1,R2C2,R2C3]
		// write out size of data;
		// this allows us to use 1 array for all data values

		Write $$$ZENJSPAIR("rowCount",tRowCount),",",!
		Write $$$ZENJSPAIR("columnCount",tColCount),",",!

		Write """cells"":[],",!

		Write "status:",$$$JS(100),! // last property
		Write "}"

		// JMD1227: violate JSON rules for speed's sake:
		Write ";",!

		// cells
		Write "var a = new Array(",tRowCount*tColCount,");",!
		Write "o.data.cells = a;",!
		Set tCellCount = 0
		For tRow=1:1:tRowCount {
			For c=1:1:tColCount {
				Set tProp = tColProps(c)
				Set tValue = tController.dataBag.%GetValue(tProp,tRow)
				Set:tValue=$$$ZENMISSING tValue = ""
				Write "a["_tCellCount_"]="_$$$ZENJSVALUE(tValue)_";",!
				Set tCellCount = tCellCount + 1
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
		Write "/*"
		Do $System.OBJ.DisplayError(tSC)
		Write "*/"
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="getContent">
<Final>1</Final>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return this.data;
]]></Implementation>
</Method>

<Method name="sendEventToViews">
<Description><![CDATA[
Send an event to all listeners (dataViews) connected to this dataController.
<var>reason</var> is the name of the event.<br>
<var>source</var>, if not null, if the dataView that raised the event.<br>
<var>data1</var>,<var>data2</var>, and <var>data3</var> contain event-specific data passed along with the event.<br>]]></Description>
<FormalSpec>reason,source,data1,data2,data3</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this._listeners) {
		for (var n = 0; n < this._listeners.length; n++) {
			if (this._listeners[n] && (this._listeners[n]!=source)) {
				this._listeners[n].notifyView(reason,data1,data2,data3);
			}
		}
	}
]]></Implementation>
</Method>

<Method name="register">
<Description><![CDATA[
Internal method.<br>
Establish a connection between this pivotTable and a chart component]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>component</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// + WAL259
	if(null == this._registeredCounter) {
		this._registeredCounter = 1;
	}
	else {
		this._registeredCounter += 1;
	}
	// - WAL259
	if (null == this._listeners) {
		this._listeners = new Array();
	}
	this._listeners[this._listeners.length] = component;
]]></Implementation>
</Method>

<Method name="unregister">
<Description><![CDATA[
Internal method.<br>
Break the a connection between this pivotTable and a chart component]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>component</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this._listeners) {
		for (var n = 0; n < this._listeners.length; n++) {
			// + WAL083 (5) -- check *this* item not the last one
			if (this._listeners[n] == component) { 
			//if (this._listeners[this._listeners.length] == component) {
			// - WAL083 (5)
				this._listeners.splice(n,1);
				break;
			}
		}
	}
]]></Implementation>
</Method>

<Method name="raiseDataChange">
<Description><![CDATA[
Send notification to listeners that the data associated with this pivotTable has changed.<br/>]]></Description>
<Final>1</Final>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this._listeners) {
		for (var n = 0; n < this._listeners.length; n++) {
			if (this._listeners[n]) {
				this._listeners[n].notifyView('dataChange',null);
			}
		}
	}
]]></Implementation>
</Method>

<Method name="getDimensions">
<Description>
Return number of dimensions in this pivot.</Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return 2;
]]></Implementation>
</Method>

<Method name="getDimSize">
<Description><![CDATA[
Return the number of items in the specified dimension
(<var>dim</var> is 1,2, or 3).]]></Description>
<Final>1</Final>
<FormalSpec>dim</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var size = 0;
	var data = this.getContent();
	switch (dim) {
	case 1:
		size = data ? data.rowCount : 0;
		// JMD1462 limit chart size
		var maxChartSize = this.maxChartSize;		// DTB384 - Use the pivot setting
		if (maxChartSize>0) {
			size = size>maxChartSize ? maxChartSize : size;
		}
		break;
	case 2:
		size = data ? data.columnCount : 0;
		break;
	}
	return size;
]]></Implementation>
</Method>

<Method name="getDimGrouping">
<Description>
Special method: return if the given dimension has hierarchical groupings
(to indicate that a chart should display them).</Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>dim</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var ret = false;
	var data = this.getContent();
	if (!data) return false;

	switch (dim) {
	case 1:
		var axis = data.axes[1];
		break;
	case 2:
		var axis = data.axes[0];
		break;
	}
	if (axis) {
		ret = axis.hasGroups ? true : false;
	}
	return ret;
]]></Implementation>
</Method>

<Method name="getDataAsArrays">
<Description><![CDATA[
This is a specialized variant of <method>getData</method> that
return the data in this controller as an array of arrays (used by charts).]]></Description>
<Final>1</Final>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var array = null;
	var data = this.getContent();
	if (data) {
		var items = data.rowCount;
		var series = data.columnCount;

		if (series) {
			array = new Array(series);
			for (var s = 0; s < series; s++) {
				array[s] = new Array(items);
				for (var i = 0; i < items; i++) {
					var idx = (i*series) + s;
					array[s][i] = data.cells[idx];
				}
			}
		}
	}
	return array;
]]></Implementation>
</Method>

<Method name="getLabel">
<Description>
Get the label at position n (0-based) in the given
dimension (1,2, or 3).</Description>
<Final>1</Final>
<FormalSpec>n,dim,noformat</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	try {
		var label = '';
		var data = this.getContent();
		if (!data) {
			return '';
		}
		noformat = zenGet(noformat,false);

		switch (dim) {
		case 1:
			// item name from rows axis
			var axis = data.axes[1];
			if (axis) {
				var tuple = axis.tuples[n];
				label = tuple ? this.computeCaption(tuple,noformat) : 'N/A';		// DTB387 - Add noformat
				if (tuple && tuple.g && axis.groups) {
					// JMD1148 use g
					var group = axis.groups[parseInt(tuple.g,10)];
					while (group) {
						var caption = this.computeCaption(group,noformat);
						if (caption!=='') {
							label = caption + '/' + label;
						}
						if (group.g) {
							group = axis.groups[parseInt(group.g,10)];
						}
						else {
							group = null;
						}
					}
				}
			}
			break;
		case 2:
			// series names from columns axis
			var axis = data.axes[0];
			if (axis) {
				var tuple = axis.tuples[n];
				label = tuple ? this.computeCaption(tuple,noformat) : '';
				// JMD1011
				// JMD1148 use g
				if (tuple && tuple.g && axis.groups) {
					var group = axis.groups[parseInt(tuple.g,10)];
					while (group) {
						var caption = this.computeCaption(group,noformat);
						if (caption!=='') {
							label = caption + '/' + label;
						}
						if (group.g) {
							group = axis.groups[parseInt(group.g,10)];
						}
						else {
							group = null;
						}
					}
				}
				if (label==='') {
					label = data.defaultCaption;
				}
			}
			break;
		}
	}
	catch(ex) {
		alert('Error in pivot.getLabel: ' + ex.message);
	}
	return label;
]]></Implementation>
</Method>

<Method name="computeCaption">
<Description>
Resolve the caption for a given axis item.
(This is used to get logical values for time axis members).</Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>item,noformat</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	noformat = zenGet(noformat,false);

	var caption = (item.caption!=='') ? item.caption : '';
	if (item.type && item.key) {
		switch(item.type) {
		case 'month':
			var year = item.key.toString().substr(0,4);
			var month = item.key.toString().substr(4,2);
			// JMD1263.2
			if (noformat) {
				caption = year + '-' + month;
			}
			else {
				caption = item.caption ? item.caption : year + '-' + month;
			}
			break;
		case 'quarter':
			var year = item.key.toString().substr(0,4);
			var quarter = item.key.toString().substr(4,1);
			var month = (quarter-1) * 3;
			month = (month < 10) ? ('0'+month) : month;
			// JMD1263.2
			if (noformat) {
				caption = year + '-' + month;
			}
			else {
				caption = item.caption ? item.caption : year + '-' + month;
			}
			break;
		case 'day':
			// JMD1263
			if (noformat) {
				caption = this.dateFromHorolog(item.key);
			}
			else { 
				caption = item.caption ? item.caption : this.dateFromHorolog(item.key);
			}
			break;
		}
	}
	return caption;
]]></Implementation>
</Method>

<Method name="dateFromHorolog">
<Description>
Convert a $H to yyyy-mm-dd date.</Description>
<FormalSpec>val</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (''!==val && !isNaN(val) && 'NOW' != val) {
		var text = val;
		var days1970 = parseInt(val) - 47117;
		var date = new Date((days1970 * 24 * 3600 * 1000));

		var mon = date.getUTCMonth();
		mon = (mon<9?'0':'') + (mon+1);
		var day = date.getUTCDate();
		day = (day<10?'0':'') + (day);
		var yr = date.getUTCFullYear();
		val = yr+'-'+mon+'-'+day;
	}
	return val;
]]></Implementation>
</Method>

<Method name="getDimName">
<Description>
Return a name for the given dimension (1,2, or 3).
This provides the axis label for a chart.</Description>
<Final>1</Final>
<FormalSpec>dim</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var name = '';
	var drillLevel = this.drillLevels.length;
	switch(dim) {
	case 0:
		if (this.overrideRowSpec) {
			name = this.overrideRowText;
		}
		else if (this.rowLevels) {
			// multiple top-level items for rows
			// JMD1148 only show 3 top items at most and nested items
			// JMD1300 test drillLevel
			var nc = 0;
			for (var n = 0; n < this.rowLevels.length; n++) {
				var level = this.rowLevels[n];
				if (level.drillLevel == drillLevel) {
					if (nc++ >= 3) {
						name += '...';
						break;
					}
					var text = level.caption ? level.caption : level.text;
					var childLevel = level.childLevels ? level.childLevels[0] : null;
					while (childLevel) {
						if (childLevel.caption) {
							text = text + ((text=='')?'':'/') + childLevel.caption;
						}
						else if (childLevel.text) {
							text = text + ((text=='')?'':'/') + childLevel.text;
						}
						childLevel = childLevel.childLevels ? childLevel.childLevels[0] : null;
					}
					if (text) {
						name = name + ((name=='')?'':' & ') + text;
					}
				}
			}
		}
		break;
	case 1:
		if (this.overrideColumnSpec) {
			name = this.overrideColumnText;
		}
		else if (this.columnLevels && (this.columnLevels.length == 1)) {
			name = this.columnLevels[0].text;
		}
		break;
	}
	return name;
]]></Implementation>
</Method>

<Method name="getPropertyName">
<Description>
Given a 0-based index, return the corresponding property name.</Description>
<FormalSpec>n</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return this.getLabel(n,2);
]]></Implementation>
</Method>

<Method name="getValueName">
<Description>
Return a label for the values returned by the data source.
This provides the axis label for a chart.</Description>
<Final>1</Final>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this.overrideColumnSpec) {
		return this.overrideColumnText;
	}
	else if (this.measures.length==1 && '' != this.measures[0].text) {
		return this.measures[0].text;
	}
	else if (this.columnLevels && (this.columnLevels.length > 0)) {
		// JMD1148
		// return this.columnLevels[0].text;
		// JMD1300
		return $$$Text('Value');
	}
	//return $$$Text('Value');
	// JMD1300
	return this.getLabel(0,2);
]]></Implementation>
</Method>

<Method name="getDataSourceCaption">
<Description>
Return a title to display for this data source.
This provides the title for a chart.</Description>
<Final>1</Final>
<FormalSpec>which,title</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var caption = '';
	// test for special title values:
	switch (title) {
	case '$caption':
		caption = this.caption!==''?this.caption:null;
		break;
	/*	
	case '$date':
		// !!!format
		var d = new Date();
		caption = zenDateToString(d,'yyyy-mm-dd');
		break;
	*/

	case '':		
		switch (which) {
		case 'title':
			caption = this.caption;
			break;
		case 'subtitle':
			break;
		}
		break;
	}
	return caption;
]]></Implementation>
</Method>

<Method name="getDataByName">
<FormalSpec>property,series</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var value = '';
	var data = this.getContent();
	if (!data) {
		return '';
	}

	series = ('undefined'==typeof series) ? 0 : parseInt(series,10);
	
	// JMD1432 if property is a numeric literal return it as the value
	if (!isNaN(parseFloat(property))) {
		return parseFloat(property);
	}

	// JMD1432 if property is enclosed within =[xxx], remove
	if ((property.toString().substr(0,2)=='=[')&&(property.toString().substr(property.length-1,1)==']')) {
		property = property.substr(2,property.length-3);
	}

	// find column whose caption matches property name
	var colNo = -1;
	var axis = data.axes[0];
	if (axis && axis.tuples) {
		// special case for queries with no columns
		if (axis.tuples.length==1 && axis.tuples[0].caption=='' && property==data.defaultCaption) {
			// get value from first row,column
			colNo = 0;
		}
		else {
			for (var n = 0; n < axis.tuples.length; n++) {
				if (this.getLabel(n,2) == property) {		// DTB559 - Add support for retrieving nested labels and try to match that
					colNo = n;
					break;
				}
			}
		}
	}

	switch (property) {
	case '%rangeUpper':
		// get range from totals (which column !!!)
		if (data.rowTotals && data.rowTotals[0]) {
			value = data.rowTotals[0].max;
			if (value) {
				// round up
				value = Math.pow(10,Math.ceil(Math.log(value)/Math.log(10)));
			}
		}
		break;
	case '%rangeLower':
	case '%thresholdUpper':
	case '%thresholdLower':
		break;

	default:
		// JMD1432
		if (colNo<0) {
			value = property;
		}
		else {
			// get value from cells
			// JMD1219: single array
			var colCount = data.columnCount;
			if (colNo>=0 && colCount) {
				value = data.cells[(series*colCount) + colNo];
			}
		}
		break;
	}

	return value;
]]></Implementation>
</Method>

<Method name="getData">
<Description>
dataSet API
Return the data contained in the specified location.
Location is 0-based;</Description>
<FormalSpec>d1,d2,d3</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var value = '';
	var data = this.getContent();
	if (!data || !data.cells) {
		return '';
	}

	var row = d1;
	var col = (null===d2) ? 0 : d2;
	value = data.cells[(row*data.columnCount) + col];
	return value;
]]></Implementation>
</Method>

<Method name="getFilterInfo">
<Description><![CDATA[
Return information on current filters.<br/>
<var>fnames</var> is an array in which the filter names will be placed.<br/>
<var>fvalues</var> is an array in which the filter values will be placed.<br/>
<var>flabels</var> is an array in which the filter labels will be placed.<br/>]]></Description>
<Final>1</Final>
<FormalSpec>fnames,fvalues,flabels</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	for (var n = 0; n < this.filters.length; n++) {
		var filter = this.filters[n];
		if (('' != filter.key)&&(filter.enabled)) {		// DTB634
			if ('' === filter.caption) {
				// find caption for filter if the caption is missing
				if ('' != filter.baseSpec) {
					// use the baseSpec to look up the caption
					filter.caption = this.GetItemCaption(this.cubeName,filter.baseSpec);
				}
				else if ('' != filter.spec) {
					// DTB858 - If the baseSpec is also missing, attempt to pull the baseSpec from the complete spec
					// and use that to find the caption
					var baseSpec = '';
					var baseSpecArray = filter.spec.split('.').slice(0,-1);
					baseSpec = baseSpecArray.join('.');
					
					filter.caption = this.GetItemCaption(this.cubeName,baseSpec);
				}
			}

			// JMD: for some saved filters, we may not have baseSpec
			// in this case, do not use %OR etc as caption
			if (filter.caption && filter.caption.toString().indexOf('%OR(')<0) {
				fnames[fnames.length] = filter.caption;
				var text = filter.text.toString();
				
				// apply some unescapes to the text!
				var t = text.split('&#160;');
				text = t.join(' ');
				fvalues[fvalues.length] = text;
				
				// DTB551 - Add labels here if requested
				if (flabels) {
					flabels[flabels.length] = ((filter._label) ? filter._label : filter.caption);
				}
			}
		}
	}
	
	if (this.contextFilterSpec) {
		// DTB648 - Parse the context into a collection of cell addresses which can be displayed
		var contextArray = this.ParseMDXExpression(this.contextFilterSpec,this.cubeKey).split('\n');
		
		var counter = 0;
		for (n in contextArray) {
			counter++
			fnames[fnames.length] = $$$Text('Other Filter ') + counter.toString();
			fvalues[fvalues.length] = contextArray[n];
			if (flabels) {
				flabels[flabels.length] = '';
			}
		}
	}
		
	// +DTB115	 
	// If applicable, add information about drill-down filters
	if (this.getDrillLevel()>0) {
		for (var d=0 ; d < this.getDrillLevel() ; d++) {
			// DTB115 - Indicate this came from a drilldown
			fnames[fnames.length] = $$$Text('Drilldown Level','%DeepSee') + ' ' + (d+1);		//DTB309 - Localize label
			fvalues[fvalues.length] = this.drillLevels[d].text;
			if (flabels) {		// DTB648
				flabels[flabels.length] = '';
			}
		}
	}

	// If applicable, add information about cell selection context in a detail listing			
	if ((this.isDrillThrough)&&(this.listingFilters.length)) {		// DTB157 - add condition to test for existence of any listingFilters
		fnames[fnames.length] = '- ' + $$$Text('Selected Cell Context','%DeepSee') + ' -';
		fvalues[fvalues.length] = ' ';
		if (flabels) {		// DTB648
			flabels[flabels.length] = '';
		}
		for (var f=0 ; f < this.listingFilters.length ; f++) {
			fnames[fnames.length] = 'Cell Context ' + f;			// N.B. This is not displayed, and so is not localized
			fvalues[fvalues.length] = this.listingFilters[f].spec;
			if (flabels) {		// DTB648
				flabels[flabels.length] = '';
			}
		}
	}
	// -DTB115
]]></Implementation>
</Method>

<Method name="ParseMDXExpression">
<Description>
Parse an MDX clause representing a collection of cell addresses into a $C(10)-delimited list that can be pssed back to the client. This is designed to parse contextual filters.  </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pExpression,pCubeName</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	// Method added by DTB648
	Set tMessage = ""
	
	Try {
		Set tSC = ##class(%DeepSee.UserPortal.Utils).%ParseCellSelectionContext(pExpression,pCubeName,.tContextFilters)
		If $$$ISERR(tSC) Quit		// DTB662 - Quit on error
		
		Set tName="" 
		Set tValue=""
		For f=1:1:tContextFilters {
			Set tName = tName _ $S($L(tName):" / ",1:"") _ $LG(tContextFilters(f),1) _ ":" _ $LG(tContextFilters(f),2)
			If '$D(tContextFilters(f,"ch")) {
				// This node contains the end of a chain, add it to the filters as a group
				Set tMessage = tMessage _ $S($L(tMessage):$C(10),1:"") _ tName
				Set tName = ""
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	If $$$ISERR(tSC) {		
		// DTB662 - Different error reporting
		Set tMessage = $system.Status.GetOneErrorText(tSC)
	}

	Quit tMessage
]]></Implementation>
</Method>

<Method name="getPivotVariableInfo">
<Description><![CDATA[
Return information on current pivot variables.<br/>
<var>pnames</var> is an array in which the variable names will be placed.<br/>
<var>pvalues</var> is an array in which the variable values will be placed.<br/>]]></Description>
<Final>1</Final>
<FormalSpec>pnames,pvalues</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB489
	for (variableName in this.pivotVariables) {
		var pdata = new zenProxy;
		
		// DTB515 - Get the full pivot information on each pivot variable
		pdata = this.GetPivotVariableData(this.cubeName,variableName+'.variable',this.pivotVariables[variableName]);
		
		if (pdata.text) {
			// DTB568 - Only add to the pivot variable array if the value is defined
			pnames[pnames.length] = pdata.caption;
			pvalues[pvalues.length] = pdata.text;
		}
		
		if (pdata.error) {
			// Report a data error if present
			alert(pdata.error)
		}

	}
]]></Implementation>
</Method>

<Method name="addController">
<Description>
Associate a controller component with this pivotTable.
This is called by the controller component.</Description>
<Internal>1</Internal>
<FormalSpec>ctrl</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	this.controller = ctrl;
]]></Implementation>
</Method>

<Method name="removeController">
<Description>
Remove the controller component associated with this pivotTable.
This is called by the controller component.</Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	this.controller = null;
]]></Implementation>
</Method>

<Method name="updateController">
<Description>
Update the controller component associated with this pivotTable, if any.
This is called internally when the state of the pivot table changes.</Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this.controller && this.controller.updateState) {
		this.controller.updateState();
	}
]]></Implementation>
</Method>

<Method name="updateToolbar">
<Description>
Update the toolbar on the controller component associated with this pivotTable, if any.
This is called internally when the state of the pivot table changes.</Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this.controller && this.controller.updateToolbar) {
		this.controller.updateToolbar();
	}
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec>initvalue:%RawString</FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..rowAxisOptions = ##class(%DeepSee.Component.pivotLevel).%New()
	Set ..rowAxisOptions.filterEnabled = 0
	Do:$IsObject($G(%page)) %page.%AddComponent(..rowAxisOptions)

	Set ..columnAxisOptions = ##class(%DeepSee.Component.pivotLevel).%New()
	Set ..columnAxisOptions.filterEnabled = 0
	Do:$IsObject($G(%page)) %page.%AddComponent(..columnAxisOptions)

	Quit ##super($G(initvalue))
]]></Implementation>
</Method>

<Method name="getDrillLevel">
<Description>
Return current drill level for this pivot.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return this.drillLevels.length;
]]></Implementation>
</Method>

<Method name="gotoDrillLevel">
<Description>
Go to the given drill level.</Description>
<FormalSpec>idx</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	idx = parseInt(idx);
	if (this.drillLevels.length == idx + 1) return;
	this.pushState();
	this.drillLevels.length = idx + 1;

	// remove extra row levels
	for (var n = this.rowLevels.length - 1; n >=0; n--) {
		if (this.rowLevels[n].drillLevel > (idx+1)) {
			this.rowLevels.splice(n,1);
		}
	}

	this.isDrillThrough = false;
	this.selectedRange = '';
	this.sortColumn = 0;
	this.sortDir = 'ASC';
	this.mdx = '';
	var ret = zenInvokeCallbackMethod(this.ondrill,this,'ondrill','pivot',this);
	if (!ret) {
		this.executeQuery(true);
	}
]]></Implementation>
</Method>

<Method name="removeDrillLevel">
<Description><![CDATA[
Remove a drill level. The input parameter <var>idx</var> is the 0-based index of the level to remove.]]></Description>
<FormalSpec>idx,evt</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var prevCanDrillDown = this.canDrillDown;
	idx = parseInt(idx);
	this.pushState();
	var drillRowNumber = this.drillRowNumbers.splice(idx,1);
	this.drillLevels.splice(idx,1);
	
	// + WAL224 -- prevent this event from being handled by 
	//             rowClickHandler as well
	//             Some browsers use stopPropagation(), some use
	//             cancelBubble
	// + WAL237 -- check if evt is undefined -- order of args switched
	if (evt !== undefined) {
	    if (typeof evt.stopPropagation != "undefined") {
	        evt.stopPropagation();
	    } else {
	        evt.cancelBubble = true;
	    }
	}
    // - WAL224

	// remove row levels
	for (var n = this.rowLevels.length - 1; n >=0; n--) {
		if (this.rowLevels[n].drillLevel == (idx+1)) {
			this.rowLevels.splice(n,1);
		}
		else if (this.rowLevels[n].drillLevel > (idx+1)) {
			this.rowLevels[n].drillLevel--;
		}
	}
	this.isDrillThrough = false;
	// + WAL224 -- onUpdateHandler will use the range set here
	this.selectedRange = drillRowNumber + ',1,' + drillRowNumber + ',' + this.columnCount + ',0,0';
	//this.selectedRange = '';
	// - WAL224

	this.sortColumn = 0;
	this.sortDir = 'ASC';
	this.mdx = '';
	var ret = zenInvokeCallbackMethod(this.ondrill,this,'ondrill','pivot',this);
	if (!ret) {
		this.executeQuery(true);
	}
	this.canDrillDown = prevCanDrillDown;
]]></Implementation>
</Method>

<Method name="removeAllDrillLevels">
<Description>
Clear all current drill levels and reset the table back to its resting state.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB745
	if ( (this.drillLevels) && (this.drillLevels.length>0) ) {
		// Work backward through the drillLevels and remove each in turn.
		for (var level = (this.drillLevels.length-1) ; level>=0 ; level--) {
			this.removeDrillLevel(level)
		}
	}
]]></Implementation>
</Method>

<Method name="setListing">
<Description>
Set the name of the listing (and listing type) to show for this pivot.</Description>
<FormalSpec>listing,type</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (listing) {
		// DTB732 - Only set the pivot's listing if there is something to set!
		this.listing = listing;
	}
	else {
		this.listing = this.defaultListing;		// DTB732 (2) - Reset to default listing if nothing is selected
	}

	if (type=='map' || type == 'table') {
		this.listingType = type;
	}
]]></Implementation>
</Method>

<Method name="allClick">
<Description>
Click on all check box (in detail listing).</Description>
<FormalSpec>evt</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	if (evt) {
		if (evt.stopPropagation) {
			evt.stopPropagation();
		}
		else {
			evt.cancelBubble = true;
		}
	}
	var cbAll = this.findElement('cb_all');

	for (var r = 1;;r++) {
		var cb = this.findElement('cb_'+r);
		if (cb) {
			cb.checked = cbAll.checked;
			var tr = this.findElement('tr_'+r);
			if (tr) {
				if (cb.checked) {
					tr.className = 'selectedRow';
				}
				else {
					var rowno = tr.getAttribute('rowno');
					tr.className = rowno%2 ? 'evenRow' : 'oddRow';
				}
			}
		}
		else {
			break;
		}
	}
	zenInvokeCallbackMethod(this.onlistingSelect,this,'onlistingSelect','pivot',this);
]]></Implementation>
</Method>

<Method name="cbClick">
<Description>
Click on checkbox.</Description>
<FormalSpec>evt,currCb</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	if (evt) {
		if (evt.stopPropagation) {
			evt.stopPropagation();
		}
		else {
			evt.cancelBubble = true;
		}
	}

	var cbAll = this.findElement('cb_all');
	if (cbAll) {
		cbAll.checked = false;
	}

	for (var r = 1;;r++) {
		var cb = this.findElement('cb_'+r);
		var tr = this.findElement('tr_'+r);
		if (cb && tr) {
			if ('single' == this.listingSelect && cb !== currCb) {
				cb.checked = false;
			}

			if (cb.checked) {
				tr.className = 'selectedRow';
			}
			else {
				var rowno = tr.getAttribute('rowno');
				tr.className = rowno%2 ? 'evenRow' : 'oddRow';
			}
		}
		else {
			break;
		}
	}
	zenInvokeCallbackMethod(this.onlistingSelect,this,'onlistingSelect','pivot',this);
]]></Implementation>
</Method>

<Method name="allClickPivot">
<Description>
Click on all check box (in pivot).</Description>
<FormalSpec>evt</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	if (evt) {
		if (evt.stopPropagation) {
			evt.stopPropagation();
		}
		else {
			evt.cancelBubble = true;
		}
	}
	var cbAll = this.findElement('cb_all');

	for (var r = 1;;r++) {
		var cb = this.findElement('cb_'+r);
		if (cb) {
			cb.checked = cbAll.checked;
			var th = this.findElement('row_1:'+r);
			if (th) {
				if (cb.checked) {
					th.style.background = '#B0B0F0';
					this.selectCellRange(r,1,r,this.columnCount,false,true,true);	// DTB101
				}
				else {
					th.style.background = '';
					// DTB101 - unselect this row
					for (var c = 1; c <= this.columnCount; c++) {
						var cell = this.findElement('cell_'+r+'_'+c);
						if (cell) {
							var color = cell._oldColor ? cell._oldColor : '';
							cell.style.color = color;
							var bg = cell._oldBackground ? cell._oldBackground : '';
							cell.style.background = bg;
						}
					}	
				}
			}
		}
		else {
			break;
		}
	}
]]></Implementation>
</Method>

<Method name="cbClickPivot">
<Description>
Click on checkbox in pivot.</Description>
<FormalSpec>evt,currCb</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	evt = evt ? evt : window.event;
	if (evt) {
		if (evt.stopPropagation) {
			evt.stopPropagation();
		}
		else {
			evt.cancelBubble = true;
		}
	}
	var cbAll = this.findElement('cb_all');
	if (cbAll) {
		cbAll.checked = false;
	}
	for (var r = 1;;r++) {
		var cb = this.findElement('cb_'+r);
		var tr = this.findElement('tr_'+r);
		if (cb && tr) {
			if ('single' == this.pivotSelect && cb !== currCb) {
				cb.checked = false;
			}
			
			var th = this.findElement('row_1:'+r);
			if (cb.checked) {
				th.style.background = '#B0B0F0';
				this.selectCellRange(r,1,r,this.columnCount,false,true,true);	// DTB101
			}
			else {
				th.style.background = '';
				
				// DTB101 - unselect this row
				for (var c = 1; c <= this.columnCount; c++) {
					var cell = this.findElement('cell_'+r+'_'+c);
					if (cell) {
						var color = cell._oldColor ? cell._oldColor : '';
						cell.style.color = color;
						var bg = cell._oldBackground ? cell._oldBackground : '';
						cell.style.background = bg;
					}
				}						
			}
		}
		else {
			break;
		}
	}
]]></Implementation>
</Method>

<Method name="getSelectedItems">
<Description>
Return an array of the values of the selected items in the pivot table.
For listing mode, this is the set of ids for the selected rows.
For pivot mode, this is the values of the value column for each selected row.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var cellSelection = this.selectedRange.split(',');
	
	// DTB898 - If the pivot is in drillthrough mode, the 'tr'/'dtr' elements will have paged IDs 1-100. If the pivot is displaying
	// the MDX resultset, these elements have absolute-position IDs which will be captured in the selectedRange.
	var firstRow = this.isDrillThrough ? 1 : cellSelection[0];
	
	var array = new Array();
	for (var r = firstRow;;r++) {		// DTB898 - Use the start point which works in both MDX and drillthrough mode
		// NB: Since this traverses the currently visible DOM, this loop should never execute more than 100 times (pivotTable pageSize)
		var cb = this.findElement('cb_'+r);
		var tr = this.findElement('tr_'+r);
		var dtr = this.findElement('dtr_'+r);
		
		// +DTB101 - For each row of the table, determine if it is a "selected item"
		// This could be defined by: 
		//  - cell selection in a pivot
		//  - check box selection in a pivot (overrides cell selection)
		//  - check box selection in a listing
		if (tr||dtr) {	 
			if (cb) {	
				// Use check boxes if they are present, ignore the selection
				if (cb.checked) {
					if ((''!=this.valueColumn) || (this.isDrillThrough)) {
						// In a listing valueColumn has no meaning
						var value = dtr ? dtr.getAttribute('value') : tr.getAttribute('value');
					}
					else {
						// There is no column defined as the valueColumn, use the seriesName
						var div = tr.getElementsByTagName('div');
						var value = div[0].innerText;	// tr should contain only one div
					}
					array[array.length] = value;
					if ('single' == this.listingSelect) {
						break;
					}
				}
			}
			else if (!this.isDrillThrough) {	// pivot mode
				// Use cell selection to obtain row values for execution of a KPI listing. 
				if ('' != this.selectedRange) { 
					var inSelectedRange = ((r >= cellSelection[0]) && (r <= cellSelection[2]));
				}
				else {
					var inSelectedRange = false;
				}

				if (inSelectedRange) {
					if (''!=this.valueColumn) {
						var value = dtr ? dtr.getAttribute('value') : tr.getAttribute('value');
					}
					else {
						// there is no column defined as the valueColumn, use the seriesName
						var div = tr.getElementsByTagName('div');
						// DTB202 - Use cross-browser read statement
						var value = div[0].innerText || div[0].textContent;	// tr should contain only one div
						if ('\n'==value[0]) {
							// DTB202 - Remove newLine prepended by FireFox!
							value = value.slice(1,value.length);
						}
						value = value.trim();
					}
					array[array.length] = value;
				}
			}
		}
		else {
			// no more rows to process in the current table
			break;
		}
		// -DTB101
	}
	return array;
]]></Implementation>
</Method>

<Method name="newDataHandler">
<Description>
Notification that new data is available.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	delete this._rowDescriptors;
	delete this._columnDescriptors;
	this.computeTotals();
]]></Implementation>
</Method>

<Method name="computeTotals">
<Description>
Compute row and columns totals, as needed.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var data = this.getContent();
	if (!data) return;

	if (!this.rowTotals && !this.columnTotals) return;
	this.rowTotalAgg = this.rowTotalAgg=='' ? 'sum' : this.rowTotalAgg;
	this.columnTotalAgg = this.columnTotalAgg=='' ? 'sum' : this.columnTotalAgg;

	var gtotal = null;
	var grandTotal = data.grandTotal ? data.grandTotal : 0;

	// JMD1148: compute "page" totals locally; get grand totals from JSON
	if (this.rowTotals && this.rowTotalSource!='all') {
		var colTotals = [];
		var startRow = (parseInt(this.currPage,10)-1) * parseInt(this.pageSize,10);
		var endRow = startRow + parseInt(this.pageSize,10) - 1;
		endRow = endRow>(data.rowCount-1)?(data.rowCount-1):endRow;
		for (var r = startRow; r<=endRow; r++) {
			for (var c = 0; c<data.columnCount; c++) {
				var idx = (r*data.columnCount)+c;
				var val = (null==data.cells[idx]) ? null : parseFloat(data.cells[idx]);
				val = isNaN(val) ? null : val;
				if (null != val) {
					if (null == colTotals[c]) {
						colTotals[c] = {};
					}
					colTotals[c].count = (colTotals[c].count?colTotals[c].count:0) + 1;
					colTotals[c].sum = (colTotals[c].sum?colTotals[c].sum:0) + val;
					colTotals[c].min = (colTotals[c].min&&colTotals[c].min<val?colTotals[c].min:val);
					colTotals[c].max = (colTotals[c].max&&colTotals[c].max>val?colTotals[c].max:val);
				}
			}
		}

		// avg and pct
		for (var c = 0; c<data.columnCount; c++) {
			if (null != colTotals[c]) {
				colTotals[c].avg =(colTotals[c].count?colTotals[c].sum/colTotals[c].count:'');
				colTotals[c].pct =(grandTotal?colTotals[c].sum/grandTotal:'');
			}
		}
	}

	// JMD1148: revise
	if (this.rowTotals) {
		for (var c = 0; c<data.columnCount; c++) {
			var rowTotalAgg = this.rowTotalAgg;
			var td = this.findElement('rtot_'+(c+1));
			var tddiv = this.findElement('rtotd_'+(c+1));
			if (td&&tddiv) {
				// override of agg?
				var agg = td.getAttribute('agg');
				if (agg && agg!=='') {
					rowTotalAgg = agg;
				}
				var fmt = td.getAttribute('format');
				fmt = fmt ? fmt : '#,#';
				if (rowTotalAgg=='pct') {
					fmt = '#,#.##%';
				}
				else if (rowTotalAgg=='count') {
					fmt = '#,#';
				}
				styleObj = { color: '' };
				if (rowTotalAgg=='none') {
					var val = '';
				}
				else if (this.rowTotalSource=='all') {
					var val = (data&&data.columnTotals&&data.columnTotals[c])?data.columnTotals[c][rowTotalAgg] : null;
				}
				else {
					var val = colTotals&&colTotals[c]?colTotals[c][rowTotalAgg]:null;
				}
				
				var disp = ((null!=val)?zenFormatNumber(val,fmt,styleObj):'');
				if (disp.toString().indexOf(')')==-1) {
					disp += '&nbsp;';
				}
				// JMD1462 match data cells
				tddiv.innerHTML = '&nbsp;'+disp+'&nbsp;';
				tddiv.title = val;
				if (styleObj.color && styleObj.color!='') {
					tddiv.style.color = styleObj.color;
				}
			}
		}
	}
	if (this.columnTotals) {
		for (var r = 0; r<data.rowCount; r++) {
			var td = this.findElement('ctot_'+(r+1));
			var tddiv = this.findElement('ctotd_'+(r+1));
			if (td&&tddiv) {
				var columnTotalAgg = this.columnTotalAgg;
				// override of agg?
				var agg = td.getAttribute('agg');
				if (agg && agg!=='') {
					columnTotalAgg = agg;
				}
				var fmt = td.getAttribute('format');
				fmt = fmt ? fmt : '#,#';
				if (columnTotalAgg=='pct') {
					fmt = '#,#.##%';
				}
				else if (columnTotalAgg=='count') {
					fmt = '#,#';
				}
				styleObj = { color: '' };
				//var var = colTotals[r];
				var rIndex = td.getAttribute('row')-1;
				if (columnTotalAgg=='none') {
					var val = '';
				}
				else {
					var val = (data&&data.rowTotals&&data.rowTotals[rIndex])?data.rowTotals[rIndex][columnTotalAgg] : null;
				}
				if (null != val) {
					gtotal = (gtotal?gtotal:0) + val;
				}
				var disp = ((null!=val)?zenFormatNumber(val,fmt,styleObj):'');
				if (disp.toString().indexOf(')')==-1) {
					disp += '&nbsp;';
				}
				// JMD1462 match data cells
				tddiv.innerHTML = '&nbsp;'+disp+'&nbsp;';
				if (styleObj.color && styleObj.color!='') {
					tddiv.style.color = styleObj.color;
				}
			}
		}
	}

	var td = this.findElement('gtot');
	var tddiv = this.findElement('gtotd');
	if (td&&tddiv) {
		var fmt = td.getAttribute('format');
		fmt = fmt ? fmt : '#,#';
		if (this.columnTotalAgg=='pct') {
			fmt = '#,#.##%';
		}
		styleObj = { color: '' };
		
		// + WAL117 -- if we have both row and column totals
		//             and the row totals are for all rows and not just this page,
		//             use the provided grand total number from the JSON data
		if (this.columnTotals&&this.rowTotals&&grandTotal&&(this.rowTotalSource=='all')) {
			gtotal = grandTotal;
		}
		// - WAL117
		
		var disp = ((null!=gtotal)?zenFormatNumber(gtotal,fmt,styleObj):'');
		if (disp.toString().indexOf(')')==-1) {
			disp += '&nbsp;';
		}
		// JMD1462 match data cells
		tddiv.innerHTML = '&nbsp;'+disp+'&nbsp;';
		if (styleObj.color && styleObj.color!='') {
			tddiv.style.color = styleObj.color;
		}
	}
]]></Implementation>
</Method>

<Method name="%GetSummaryFromCSS">
<Description>
Parse a CSS style directive and remove any "summary:val" directives within it.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pStyle:%String,*pAgg:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pAgg=""
	Set tCSS = ""
	For n=1:1:$L(pStyle,";") {
		Set t = $P(pStyle,";",n)
		If (t'="") {
			If ($P(t,":",1)="summary") {
				Set pAgg = $P(t,":",2)
			}
			Else {
				Set tCSS = tCSS _ t_";"
			}
		}
	}
	Quit tCSS
]]></Implementation>
</Method>

<Method name="getColumnDescriptors">
<Description>
Return an array of column descriptors for use by a dataGrid connected to this pivot.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var data = this.getContent();
	var isListing = (data && data._isListing);

	if (this._columnDescriptors && this._isListingCol==isListing) {
		return this._columnDescriptors;
	}
	this._isListingCol = isListing;
	var list = [];

	if (isListing) {
		// ORDER, TEST FOR EXIST!!!
		for (var p in data.listingRows[0]) {
			list[list.length] = {caption:p};
		}
	}
	else {

		// build list from pivot data
		if (data && data.axes && data.axes[0]) {
			var groups = data.axes[0].groups;
			if (groups && groups.length) {
				this.processAxisColumns(list,groups,data.axes[0].tuples);
			}
			else {
				// no groups: emit tuples
				for (var t = 0; t < data.axes[0].tuples.length; t++) {
					var caption = data.axes[0].tuples[t].caption;
					list[list.length] = {caption:caption};
				}
			}
		}
	}
	this._columnDescriptors = list;
	return list;
]]></Implementation>
</Method>

<Method name="processAxisColumns">
<Description>
Convert an axis group to descriptors.</Description>
<Internal>1</Internal>
<FormalSpec>list,groups,tuples</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	for (var n = 0; n < groups.length; n++) {
		var idx = list.length;
		list[idx] = {caption:groups[n].caption};
		if (groups[n].groups) {
			var glist = [];
			list[idx].columns = glist;
			this.processAxisColumns(glist,groups[n].groups,tuples);
		}
		else if (groups[n].tuples) {
			var glist = [];
			list[idx].columns = glist;
			for (var t = 0; t < groups[n].tuples.length; t++) {
				// !!! format !!!
				var caption = tuples[groups[n].tuples[t]-1].caption;
				glist[glist.length] = { caption:caption};
			}
		}
	}
]]></Implementation>
</Method>

<Method name="getRowDescriptors">
<Description>
Return an array of row descriptors for use by a dataGrid connected to this pivot.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var data = this.getContent();
	var isListing = (data && data._isListing);

	if (this._rowDescriptors && this._isListingRow == isListing) {
		return this._rowDescriptors;
	}

	this._isListingRow = isListing;

	// build list from pivot data
	var list = [];
	if (isListing) {
		// TEST FOR EXIST!!!
		var maxRows = parseInt(this.listingPageSize);
		for (var n=0;n<maxRows && n<data.listingRows.length; n++) {
			list[list.length] = {caption:n+1};
		}
	}
	else {
		if (data && data.axes && data.axes[1]) {
			var groups = data.axes[1].groups;
			if (groups && groups.length) {
				this.processAxisRows(list,groups,data.axes[1].tuples);
			}
			else {
				// no groups: emit tuples
				for (var t = 0; t < data.axes[1].tuples.length; t++) {
					var caption = data.axes[1].tuples[t].caption;
					list[list.length] = {caption:caption};
				}
			}
		}
	}
	this._rowDescriptors = list;
	return list;
]]></Implementation>
</Method>

<Method name="processAxisRows">
<Description>
Convert an axis group to descriptors.</Description>
<Internal>1</Internal>
<FormalSpec>list,groups,tuples</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	for (var n = 0; n < groups.length; n++) {
		var idx = list.length;
		list[idx] = {caption:groups[n].caption};
		if (groups[n].groups) {
			var glist = [];
			list[idx].rows = glist;
			this.processAxisRows(glist,groups[n].groups,tuples);
		}
		else if (groups[n].tuples) {
			var glist = [];
			list[idx].rows = glist;
			for (var t = 0; t < groups[n].tuples.length; t++) {
				// !!! format !!!
				var caption = tuples[groups[n].tuples[t]-1].caption;
				glist[glist.length] = { caption:caption};
			}
		}
	}
]]></Implementation>
</Method>

<Method name="getPageSize">
<Description>
Return total number of pages to support dataGrid paging.</Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return parseInt(this.pageSize);
]]></Implementation>
</Method>

<Method name="getRecordCount">
<Description>
Return total number of records to support dataGrid paging.</Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var data = this.getContent();
	var isListing = (data && data._isListing);
	if (isListing) {
		return data.listingRows.length;
	}

	return parseInt(this.rowCount,10);
]]></Implementation>
</Method>

<Method name="getCurrPage">
<Description>
Number of the current "page" when paging (1-based).</Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return parseInt(this.currPage);
]]></Implementation>
</Method>

<Method name="setCurrPage">
<Description>
Set the current "page" when paging (1-based).</Description>
<Internal>1</Internal>
<FormalSpec>page</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	this.gotoPage(page);
]]></Implementation>
</Method>

<Method name="getRowCaptions">
<Description>
Return an array of row captions (shown above headers).</Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// + WAL241 -- if populated, use rowCaptionList
	if (this.rowCaptionList.length > 0) {
		return this.rowCaptionList;
	}
	// - WAL241
	var rowCaptions = [];
	var data = this.getContent();
	if (data && data.rowCaptions) {
		rowCaptions = data.rowCaptions;
	}
	return rowCaptions;
]]></Implementation>
</Method>

<Method name="showAllRows">
<Description><![CDATA[
Notification that a listing header is double-clicked.<br/>]]></Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.crossJoinRowLimit = 0;
	if (this.previewMode) {
		// DTB714 - Remove calls to the zenPage. Pivot actions only effect the pivot display.
		this.previewMode = !this.previewMode;
		this.executeQuery(true);
	}
	else {
		this.executeQuery(true);
	}
]]></Implementation>
</Method>

<Method name="getPropertyDim">
<Description>
Return the ordinal number of the dimension supplying property names for this controller.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return 2;
]]></Implementation>
</Method>

<Method name="GetPivotVariableData">
<Description>
Retrieves the meta data about the pivot variable and can convert the logical value
display value.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName,pVariableName,pValue=""</FormalSpec>
<ReturnType>%ZEN.proxyObject</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	// Method added by DTB515
	Set tData = ##class(%ZEN.proxyObject).%New()
	Try {
		Set tSC = ##class(%DeepSee.Utils).%GetPivotVariableInfo(pCubeName,$P(pVariableName,".",1,*-1),.tPivotVariableInfo)
		If $$$ISERR(tSC) $$$ThrowStatus(tSC)
		
		Set tData.value = pValue		// Default to the incoming value
		Set tData.text = pValue			// DTB550 - Default Text value as well
		Set tData.type = tPivotVariableInfo("type")
		Set tData.caption = tPivotVariableInfo("displayName")
		Set tData.name = tPivotVariableInfo("name")
		
		Set tData.caption = $G(tPivotVariableInfo("displayName"))
		If (tData.caption="") {
			Set tData.caption = $G(tPivotVariableInfo("name"),pVariableName)
		}
		
		// DTB550 - Prepare the value for translation to a human-readable display value
		If ($E(pValue,1,4)="%NOT") {
			Set tIsNot = 1
			Set pValue = $E(pValue,6,*)
		}
		
		// Examine the incoming value and see if there is a display value
		Set tSC = ##class(%DeepSee.Query.Parser).%ParseMemberSpec(pValue,.tInfo)
		If $$$ISERR(tSC) $$$ThrowStatus(tSC)
		
		Set tTermCount = $O(tInfo(""),-1)
		If ((tTermCount>1)&&($G(tInfo(2))=":")) {
			// Value is a range
			If (tPivotVariableInfo("type")="day") {
				Set tValue = ##class(%DeepSee.Time.DayMonthYear).%KeyToValue(tInfo(1)) _ ":" _ 
							##class(%DeepSee.Time.DayMonthYear).%KeyToValue(tInfo(3))
				Set tData.text = $S($G(tIsNot):$$$Text("NOT","%DeepSee")_" "_tValue,1:tValue)	// DTB550 - Add NOT back in
			}
		}
		Else {
			// Single item or a set
			Set tTerm = $G(tInfo(1))		// DTB568
			If (tPivotVariableInfo("type")="day") {
				Set tValue = ##class(%DeepSee.Time.DayMonthYear).%KeyToValue(tTerm)
			}
			Else {
				Set tValue = tTerm
			}
			Set tData.text = $S($G(tIsNot):$$$Text("NOT","%DeepSee")_" "_tValue,1:tValue)		// DTB550 - Add NOT back in
		}
	}
	Catch ex {
		Set tData.error = $system.Status.GetOneErrorText(ex.AsStatus())
	}

	Quit tData
]]></Implementation>
</Method>

<Method name="SynthesizeMDX">
<Description>
Build the current MDX query text from the current contents of this component</Description>
<FormalSpec><![CDATA[*pSC:%Status,&pRS:%DeepSee.ResultSet,&pParms,&pFilterInfo,&pAdvancedFilters,*pQueryText:%String,*pAxes,*pDataReady:%Boolean,*pComplexQuery:%Boolean,pExecuteBaseQuery:%Boolean=0,pShowAll:%Boolean=0]]></FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	// Method added by DTB595
	Set tSC = $$$OK
	Set tMDX = ""
	
	Try {
		Set tSC = ..%GetFilterInfo(.pFilterInfo,.pAdvancedFilters)
		If $$$ISERR(tSC) Quit
		
		Set pComplexQuery = 0
		Set pQueryText = ""
		Set tMeasureCount = 0
		Set tSingleSimpleMeasure = 0

		Set tCubeName = $$$ZENVAL(..cubeName)
		
		Set pRS = ##class(%DeepSee.ResultSet).%New()

		// construct query
		Set tSELECT = ""
		Set tSLICER = ""
		Set tWITH = ""
		Set tShowTotals = 0

		If (..userMDX="") {
			Set tCountName = ##class(%DeepSee.Utils).%GetCountName(tCubeName,.tSC)

			// WITH clause if any
			For n = 1:1:..calculatedMembers.Count() {
				Set tCalcMbr = ..calculatedMembers.GetAt(n)
				Set tDimName = ##class(%DeepSee.Query.Parser).%UnquoteIdent(tCalcMbr.dimension)
				Set tMemberName = ##class(%DeepSee.Query.Parser).%UnquoteIdent(tCalcMbr.memberName)
				If ((tDimName'="")&&(tMemberName'="")) {
					// DTB158 - Escape identifiers before quoting 
					Set tWITH = tWITH _ " MEMBER ["_$$$dsEscapeIdent(tDimName)_"].["_$$$dsEscapeIdent(tMemberName)_"] AS '" _ tCalcMbr.valueExpression _ "'"
				}
				If (tCalcMbr.formatString'="") {
					Set tWITH = tWITH _ ",FORMAT_STRING='"_$Replace(tCalcMbr.formatString,"'","''")_"'"
				}
				If (+tCalcMbr.solveOrder>0) {
					Set tWITH = tWITH _ ",SOLVE_ORDER="_tCalcMbr.solveOrder
				}
			}

			Set:tWITH'="" tWITH = " WITH " _ tWITH _ " "
		}

		Set tWHERE = ..%GetWhereClause(.pFilterInfo)
		
		// JMD1013: use %FILTER
		// JMD1360: gather all filters into one list
		Set:tWHERE'="" tFilterClauses($I(tFilterClauses)) = tWHERE

		If (..userMDX="") {
			Do ..%CountMeasures(.tMeasureCount,.tComputedMeasures)

			// DTB208 - Removed section of code setting 
			//  tSingleSimpleMeasure
			//  tSingleCalcMeasure
			//  tMultipleMeasures
			// that is overridden by WAL114 below.				
		}
		
		// + WAL114 -- override tests so that tMultipleMeasures is always true
		//             this means that the measure will always be added to the axis
		//             specified in measure location and will never be in the slicer
		//             or on axis 2
		Set tSingleSimpleMeasure = 0
		Set tSingleCalcMeasure = 0
		Set tMultipleMeasures = 1
		// - WAL114
		
		// built filters from drill levels
		Set tDrillLevel = 0
		For n = 1:1:..drillLevels.Count() {
			Set tDrill = ..drillLevels.GetAt(n)
			If $IsObject(tDrill) {
				Set tFSpec = tDrill.spec
				If (tFSpec '= "") {
					Set tDrillLevel = tDrillLevel + 1
					Set:tFSpec'="" tFilterClauses($I(tFilterClauses)) = tFSpec
				}
			}
		}

		// add more filters for advanced filters
		Set n = $O(pAdvancedFilters(""))
		While (n'="") {
			Set tFSpec = $LG(pAdvancedFilters(n),2)
			If (tFSpec="%FILTER") {
				// lookup filter spec
				Set tFName = $LG(pAdvancedFilters(n),3)
				Set tSC = ##class(%DeepSee.Utils).%GetNamedFilterInfo(tCubeName,tFName,.tNFilterInfo)
				Set tFSpec = $G(tNFilterInfo("spec"))
			}
			ElseIf (tFSpec["$NAMEDFILTER") {
				// DTB516 - Remove the $NAMEDFILTER tag and leave the actual spec
				Set tFSpec = $Replace(tFSpec,"$NAMEDFILTER.","")
			}

			If (tFSpec'="") {
				// if this is a named filter, then its spec will be "%FILTER"
				Set:tFSpec'="" tFilterClauses($I(tFilterClauses)) = tFSpec
			}
			Set n = $O(pAdvancedFilters(n))
		}

		// JMD993
		// if drillthrough, add listing filters, create drillthrough query
		If (..isDrillThrough) {
			// Collect the current listingFilters
			Set tChunkedSpec = ""
			For n = 1:1:..listingFilters.Count() {
				Set tLFilter = ..listingFilters.GetAt(n)
				If tLFilter.%IsA("%DeepSee.Component.queryChunk") {
					// DTB783 - There might be a set of queryChunk items representing one larger statement.
					Set tChunkedSpec = tChunkedSpec _ tLFilter.chunkText
				}
				ElseIf $IsObject(tLFilter) {
					Set tFSpec = tLFilter.spec
					If (tFSpec '= "") {
						Set:tFSpec'="" tFilterClauses($I(tFilterClauses)) = tFSpec
					}
				}
			}
			
			Set:(tChunkedSpec'="") tFilterClauses($I(tFilterClauses)) = tChunkedSpec		// DTB783
			
			Set tMaxRows = ""
			If (+..listingRows>0) {
				Set tMaxRows = " MAXROWS "_..listingRows
			}

			If (..contextFilterSpec '= "") {
				If ($E(..contextFilterSpec,1,8)="%FILTER ") {
					Set tFilterClauses($I(tFilterClauses)) = $E(..contextFilterSpec,8,*)
				}
				Else {
					Set tFilterClauses($I(tFilterClauses)) = ..contextFilterSpec
				}
			}
			
			// +DTB107
			// This method is called if the queryKey is not cached when
			// called from %DrawHTML. Gather the cell selection filters in the
			// context of this base query
			If pExecuteBaseQuery {

				Set tBaseRS = ##class(%DeepSee.ResultSet).%New()
				Set tSC = tBaseRS.%PrepareMDX(..GetCurrentQueryText())
				If $$$ISERR(tSC) {
					Set:..%message="" ..%message = $System.Status.GetErrorText(tSC) _ " (1)"
					Quit
				}
				
				Set tSC = tBaseRS.%ExecuteAsynch(,.pParms)		// DTB704 - Always use %ExecuteAsynch		// DTB868 - Execute with avialable parms

				If $$$ISERR(tSC) {
					Set:..%message="" ..%message = $System.Status.GetErrorText(tSC) _ " (1)"
					Set ..error = ..%message			// DTB150
					Quit
				} 
				
				// create drill through out of current query
				Set r1 = +$P(..selectedRange,",",1)
				Set c1 = +$P(..selectedRange,",",2)
				Set r2 = +$P(..selectedRange,",",3)
				Set c2 = +$P(..selectedRange,",",4)
				Set tAllRows = +$P(..selectedRange,",",5)
				Set tAllCols = +$P(..selectedRange,",",6)
				Set:r1=0 r1=1
				Set:c1=0 c1=1
				Set:r2=0 r2=r1
				Set:c2=0 c2=c1
				
				// Use a temporary listing filter array for the cell selection
				// + WAL170
				Set tSC = tBaseRS.%GetFiltersForCellRange(.tCellSelectionFilters,r1,c1,r2,c2,,tAllRows,tAllCols,..sortColumn,..sortDir,.tPlugInInfo)
				If ($G(tPlugInInfo("NAME"))'="") Set pRS.%PlugInContextName = tPlugInInfo("NAME")
				If ($G(tPlugInInfo("PROP"))'="") Set pRS.%PlugInContextProp = tPlugInInfo("PROP")
				// - WAL170
				If $$$ISERR(tSC) {
					Set:..%message="" ..%message = $System.Status.GetErrorText(tSC) _ " (1)"
					Quit
				}
				
				// +DTB108
				// Check the slicer term in the user query.
				// If it contains $$CMBR keys, remove this term and reconstruct 
				// the executable slicer terms from the original query text
				If ($G(tCellSelectionFilters(0))["$$CMBR") {		// DTB117 - protect with $G()
					Kill tCellSelectionFilters(0)
					Set tTempRS = ##class(%DeepSee.ResultSet).%New()
					Set tSC = tTempRS.%ParseMDX(..GetCurrentQueryText(),.tTempQuery)
					For ii= 1:1:tTempQuery.filters.Count() {
						Set tFilterClauses($I(tFilterClauses)) = tTempQuery.filters.GetAt(ii).%ToString()
					}
					Kill tTempRS
				}
				// -DTB108
				
				// Transfer to the full list of filter clauses
				Set c = $O(tCellSelectionFilters(""))
				While c'="" {
					Set tFilterClauses($I(tFilterClauses)) = tCellSelectionFilters(c)
					Set c = $O(tCellSelectionFilters(c))
				}
				
				// + WAL170
				Merge pRS.%PlugInFilters = tFilterClauses
				// - WAL170
			}
			// -DTB107

			Set tSLICER = ""
			Set k = $O(tFilterClauses(""),1,tClause)
			While (k'="") {
				// DTB107 - emulate JMD1211: quick workaround for some listing issues
				// ignore any unprocessed CMBRS
				If (tClause'["$$CMBR") {
					Set tSLICER = tSLICER _ " %FILTER " _ tClause
				}
				Set k = $O(tFilterClauses(k),1,tClause)
			}
			
			Set tMDX = "DRILLTHROUGH"_tMaxRows_tWITH_" SELECT FROM [" _ $$$dsEscapeIdent(##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(tCubeName)) _ "]" _ tSLICER		// DTB130 - generated query text should never show a version number

			// check for custom field list
			Set tRETURN = "$LISTING"
			If ((..listing="$$$CUSTOM")&&(..listingFields.Count()>0)) {
				Set tRETURN = ""
				For lf=1:1:..listingFields.Count() {
					Set tSpec = ..listingFields.GetAt(lf).spec
					Set tAlias = ..listingFields.GetAt(lf).caption		// DTB509
					Set tRETURN = tRETURN _ $S(tRETURN="":"",1:",") _ tSpec
					
					Set tSpecHasAlias = ($L(tSpec," ")>1)&'($E($ZSTRIP(tSpec,"<>W"),*)=")")		// DTB508 - New test for alias
					If ((tAlias'="")&&'tSpecHasAlias) {
						Set tRETURN = tRETURN _ " """ _ tAlias _ """"
					}
				}
			}

			If (..listingSortColumn>0) {
				Set tMDX = tMDX _ " RETURN "_tRETURN_" %ORDER BY " _ ..listingSortColumn _ " " _ ..listingSortDir
			}
			ElseIf (tRETURN'="$LISTING") {
				Set tMDX = tMDX _ " RETURN "_tRETURN
			}
			
			// Save query in MDX so that SavePivot will remember the drilldown state
			Set ..mdx = tMDX
		}
		ElseIf (..userMDX'="") {
			Do ..listingFilters.Clear()

			// JMD1031
			Set tSLICER = ""
			Set k = $O(tFilterClauses(""))
			While (k'="") {
				Set tSLICER = tSLICER _ " %FILTER " _ tFilterClauses(k)
				Set k = $O(tFilterClauses(k))
			}
			Set tMDX = ..userMDX_tSLICER
		}
		Else {
			Do ..listingFilters.Clear()
			Set tMsrClause = ""

			// if more than one measure, create msrClause and add to columns or rows
			// JMD1462 if no columns, put measure into columns
			If ((tMeasureCount>0) && (tMultipleMeasures || (..columnLevels.Count()=0)||(..rowLevels.Count()=0))) {		// DTB141 - use new tMultipleMeasures test
				Set:(tMeasureCount>1) tMsrClause = "{"					// DTB117
				For n = 1:1:tMeasureCount {
					Set tMsr = ..measures.GetAt(n)
					Set tMsrSpec = tMsr.spec
					If (tMsr.aggFunction'="") {
						Set tMsrSpec = tMsrSpec _ "." _ tMsr.aggFunction
					}
					If ((tMsr.levelCaption'="")||(tMsr.levelFormat'="")||(tMsr.levelStyle'="")||(tMsr.levelHeaderStyle'="")||(tMsr.levelSummary'="")) {
						Set tMsrSpec = "%LABEL("_tMsrSpec_","_$$$quote(tMsr.levelCaption)_","_$$$quote(tMsr.levelFormat)
						// JMD: tack summary onto style
						Set tLevelStyle = tMsr.levelStyle
						Set:(tMsr.levelSummary'="") tLevelStyle = tLevelStyle_"summary:"_tMsr.levelSummary_";"
						Set:(tLevelStyle'="") tMsrSpec = tMsrSpec _ ",,"_ $$$quote(tLevelStyle)
						Set:(tMsr.levelHeaderStyle'="") tMsrSpec = tMsrSpec _ $S((tMsr.levelStyle=""):",,,",1:",") _ $$$quote(tMsr.levelHeaderStyle)
						Set tMsrSpec = tMsrSpec _ ")"
					}
					Set tMsrClause = tMsrClause _ $S(n>1:",",1:"") _ tMsrSpec
				}
				Set:(tMeasureCount>1) tMsrClause = tMsrClause _ "}"		// DTB117
			}

			// JMD1148
			If (..overrideColumnSpec'="") {
				Set:'..showEmptyColumns tSELECT = "NON EMPTY "
				Set tSELECT = tSELECT _ ..overrideColumnSpec _ " ON 0"
			}
			ElseIf (tMultipleMeasures&&(..measureLocation'="rows")&&(..columnLevels.Count()=0)&&(tMsrClause'="")) {		// DTB141 - use new tMultipleMeasures test
				Set tSELECT = tSELECT _ tMsrClause _ " ON 0"
			}
			ElseIf (..columnLevels.Count()>0) {
				Set:'..showEmptyColumns tSELECT = tSELECT _ "NON EMPTY "
				Set tClause = ..%GetAxisClauseFromLevels(..columnLevels,..showEmptyColumns,.tComplexQuery,,,pShowAll)		// DTB835
				// n.b. ignore complex query on the columns side

				If ($IsObject(..columnAxisOptions)) {
					// apply SET functions, if any
					If (..columnAxisOptions.filterEnabled) {
						Set tClause = "FILTER(" _ tClause
						Set tExpr = ..columnAxisOptions.filterExpression
						Set:tExpr="" tExpr = "1"

						Set tClause = tClause _ "," _ tExpr
						Set tClause = tClause _ ")"
					}

					If (..columnAxisOptions.orderEnabled && '..columnAxisOptions.suppress8020) {
						Set tClause = "ORDER(" _ tClause
						Set tExpr = ..columnAxisOptions.orderExpression
						Set:tExpr="" tExpr = "MEASURES.["_tCountName_"]"

						Set tDirection = ..columnAxisOptions.orderDirection
						Set:tDirection="" tDirection = "BDESC"

						Set tClause = tClause _ "," _ tExpr
						Set tClause = tClause _ "," _ tDirection
						Set tClause = tClause _ ")"
					}
					If (..columnAxisOptions.headEnabled) {
						Set tClause = "HEAD(" _ tClause
						Set:((+..columnAxisOptions.headCount)>1) tClause = tClause _ "," _ ..columnAxisOptions.headCount
						Set tClause = tClause _ ")"
					}
					If (..columnAxisOptions.aggEnabled && (..columnAxisOptions.aggFunction'="")) {
						If (($$$UPPER(..columnAxisOptions.aggFunction)="PERCENTILE") && (..columnAxisOptions.aggFunctionParm'="")) {
							// make sure 2nd argument is present!
							Set tClause = ..columnAxisOptions.aggFunction _ "(" _ tClause _ ",,"_..columnAxisOptions.aggFunctionParm_ ")"
						}
						ElseIf (($$$UPPER(..columnAxisOptions.aggFunction)="COUNT NONEMPTY")) {
							Set tClause = "COUNT(" _ tClause _ ",EXCLUDEEMPTY)"
						}
						Else {
							Set tClause = ..columnAxisOptions.aggFunction _ "(" _ tClause _ ")"
						}
					}

					// JMD916
					If (..columnAxisOptions.suppress8020) {
						// JMD1293: apply sort order
						Set tSortExpr = ""
						Set tF1 = "TOPPERCENT"
						Set tF2 = "BOTTOMPERCENT"
						If (..columnAxisOptions.orderEnabled) {
							Set tSortExpr = ..columnAxisOptions.orderExpression
							If (..columnAxisOptions.orderDirection="BASC") {
								Set tF1 = "BOTTOMPERCENT"
								Set tF2 = "TOPPERCENT"
							}
						}
						Set:tSortExpr'="" tSortExpr = ","_tSortExpr
						Set tClause = "{"_tF1_"(" _ tClause _ ",80"_tSortExpr_"),%LABEL(SUM("_tF2_"(" _ tClause _ ",20"_tSortExpr_")),"""_$$$Text("Other","%DeepSee")_""",,,,""font-style:italic;"")}"
					}

					If ((..columnAxisOptions.levelCaption'="")||(..columnAxisOptions.levelFormat'="")||(..columnAxisOptions.levelStyle'="")||(..columnAxisOptions.levelHeaderStyle'="")||(..columnAxisOptions.levelSummary'="")) {
						Set tClause = "%LABEL(" _ tClause _ ","_ $$$quote(..columnAxisOptions.levelCaption) _ ","_ $$$quote(..columnAxisOptions.levelFormat)
						// JMD: tack summary onto style
						Set tLevelStyle = ..columnAxisOptions.levelStyle
						Set:(..columnAxisOptions.levelSummary'="") tLevelStyle = tLevelStyle_"summary:"_..columnAxisOptions.levelSummary_";"
						Set:(tLevelStyle'="") tClause = tClause _ ",,"_ $$$quote(tLevelStyle)
						Set:(..columnAxisOptions.levelHeaderStyle'="") tClause = tClause _ $S((..columnAxisOptions.levelStyle=""):",,,",1:",")_ $$$quote(..columnAxisOptions.levelHeaderStyle)
						Set tClause = tClause _ ")"
					}
				}

				// if there is more than one measure, put it in the column by default
				If ((..measureLocation'="rows")&&(tMsrClause'="") && tMultipleMeasures) {		// DTB141 - use new tMultipleMeasures test
					If $E(tClause,1,6)="%LABEL" {
						// DTB208 - If the clause has a label, remove it before crossjoining, then place it around the entire crossjoin.
						// This structure provides the signal to the engine that the first term  of the crossjoin should be labeled.
						Set tClauseQuery = "SELECT " _ tClause _ " ON 0 FROM [" _ ..cubeName _"]"		// A new query to build the object form
						Set tTempRS = ##class(%DeepSee.ResultSet).%New()
						Set tSC = tTempRS.%PrepareMDX(tClauseQuery)
						If $$$ISERR(tSC) Quit
						
						Set tClauseOBJ = tTempRS.%GetQuery().axes.GetAt(1).children.GetAt(1)
						
						Set tSC = ##class(%DeepSee.Query.query).%RemoveLabel(tClauseOBJ,.tAbstractLabelOBJ,.tInnerClauseOBJ)
						If $$$ISERR(tSC) Quit
						Set tLabelArgs = $P(tAbstractLabelOBJ.%ToString(),",",2,*)
						
						Set tClause = "%LABEL(NONEMPTYCROSSJOIN("_tInnerClauseOBJ.%ToString()_","_tMsrClause_")," _ tLabelArgs			
					}
					Else {
						Set tClause = "NONEMPTYCROSSJOIN("_tClause_","_tMsrClause_")"
					}
				}

				Set tSumClause = tClause
				If (tShowTotals) {
					Set tSELECT = tSELECT _ "{"_tClause_",SUM("_tSumClause_")}"
				}
				Else {
					Set tSELECT = tSELECT_tClause
				}
				Set tSELECT = tSELECT _ " ON 0"
			}
			Else {
				// put measures along columns, if more than 1
				If ((..measureLocation'="rows")&&(tMsrClause'="") && tMultipleMeasures) {		// DTB141 - use new tMultipleMeasures test
					Set tClause = tMsrClause

					Set tSumClause = tClause
					If (tShowTotals) {
						Set tSELECT = tSELECT _ "{"_tClause_",SUM("_tSumClause_")}"
					}
					Else {
						Set tSELECT = tSELECT_tClause
					}
					Set tSELECT = tSELECT _ " ON 0"
				}
			}

			// JMD1148
			// DTB745 - Only apply the overrideRowSpec if there are no drillLevels. The override applies only to the base level of the table.
			If (..overrideRowSpec'="")&&('..drillLevels.Count()) {
				Set:tSELECT'="" tSELECT = tSELECT _ ","
				Set:'..showEmptyRows tSELECT = tSELECT _ "NON EMPTY "
				Set tSELECT = tSELECT _ ..overrideRowSpec _ " ON 1"
			}
			// WAL076 -- only if measure location is rows, simple single measures go in the slicer
			ElseIf ((..measureLocation="rows")&&(tMsrClause'="")&&tMultipleMeasures&&(..rowLevels.Count()=0)&&(..columnLevels.Count()>0)) { 	// DTB141 - use new tMultipleMeasures test
				// JMD1462
				Set:tSELECT'="" tSELECT = tSELECT _ ","
				Set tSELECT = tSELECT _ tMsrClause _ " ON 1"
			}
			ElseIf (..rowLevels.Count()>0) {
				Set tClause = ..%GetAxisClauseFromLevels(..rowLevels,..showEmptyRows,.tComplexQuery,tDrillLevel,..crossJoinRowLimit,pShowAll)		// DTB835
				Set:tComplexQuery pComplexQuery = 1
				If (tClause'="") {
					Set:tSELECT'="" tSELECT = tSELECT _ ","
					Set:'..showEmptyRows tSELECT = tSELECT _ "NON EMPTY "

					If ($IsObject(..rowAxisOptions)) {
						// apply SET functions, if any
						If (..rowAxisOptions.filterEnabled) {
							Set tClause = "FILTER(" _ tClause
							Set tExpr = ..rowAxisOptions.filterExpression
							Set:tExpr="" tExpr = "1"

							Set tClause = tClause _ "," _ tExpr
							Set tClause = tClause _ ")"
						}

						If (..rowAxisOptions.orderEnabled && '..rowAxisOptions.suppress8020) {
							Set tClause = "ORDER(" _ tClause
							Set tExpr = ..rowAxisOptions.orderExpression
							Set:tExpr="" tExpr = "MEASURES.["_tCountName_"]"

							Set tDirection = ..rowAxisOptions.orderDirection
							Set:tDirection="" tDirection = "BDESC"

							Set tClause = tClause _ "," _ tExpr
							Set tClause = tClause _ "," _ tDirection
							Set tClause = tClause _ ")"
						}
						If (..rowAxisOptions.headEnabled) {
							Set tClause = "HEAD(" _ tClause
							Set:((+..rowAxisOptions.headCount)>1) tClause = tClause _ "," _ ..rowAxisOptions.headCount
							Set tClause = tClause _ ")"
						}
						If (..rowAxisOptions.aggEnabled && (..rowAxisOptions.aggFunction'="")) {
							If (($$$UPPER(..rowAxisOptions.aggFunction)="PERCENTILE") && (..rowAxisOptions.aggFunctionParm'="")) {
								// make sure 2nd argument is present!
								Set tClause = ..rowAxisOptions.aggFunction _ "(" _ tClause _ ",,"_..rowAxisOptions.aggFunctionParm_ ")"
							}
							ElseIf (($$$UPPER(..rowAxisOptions.aggFunction)="COUNT NONEMPTY")) {
								Set tClause = "COUNT(" _ tClause _ ",EXCLUDEEMPTY)"
							}
							Else {
								Set tClause = ..rowAxisOptions.aggFunction _ "(" _ tClause _ ")"
							}
						}

						// JMD916
						If (..rowAxisOptions.suppress8020) {
							// JMD1293: apply sort order
							Set tSortExpr = ""
							Set tF1 = "TOPPERCENT"
							Set tF2 = "BOTTOMPERCENT"
							If (..rowAxisOptions.orderEnabled) {
								Set tSortExpr = ..rowAxisOptions.orderExpression
								If (..rowAxisOptions.orderDirection="BASC") {
									Set tF1 = "BOTTOMPERCENT"
									Set tF2 = "TOPPERCENT"
								}
							}
							Set:tSortExpr'="" tSortExpr = ","_tSortExpr
							Set tClause = "{"_tF1_"(" _ tClause _ ",80"_tSortExpr_"),%LABEL(SUM("_tF2_"(" _ tClause _ ",20"_tSortExpr_")),"""_$$$Text("Other","%DeepSee")_""",,,,""font-style:italic;"")}"
						}

						If ((..rowAxisOptions.levelCaption'="")||(..rowAxisOptions.levelFormat'="")||(..rowAxisOptions.levelStyle'="")||(..rowAxisOptions.levelHeaderStyle'="")||(..rowAxisOptions.levelSummary'="")) {
							Set tClause = "%LABEL(" _ tClause _ ","_ $$$quote(..rowAxisOptions.levelCaption) _ ","_ $$$quote(..rowAxisOptions.levelFormat)
							// JMD: tack summary onto style
							Set tLevelStyle = ..rowAxisOptions.levelStyle
							Set:(..rowAxisOptions.levelSummary'="") tLevelStyle = tLevelStyle_"summary:"_..rowAxisOptions.levelSummary_";"
							Set:(tLevelStyle'="") tClause = tClause _ ",,"_ $$$quote(tLevelStyle)
							Set:(..rowAxisOptions.levelHeaderStyle'="") tClause = tClause _ $S((..rowAxisOptions.levelStyle=""):",,,",1:",")_ $$$quote(..rowAxisOptions.levelHeaderStyle)
							Set tClause = tClause _ ")"
						}
					}

					// if there is more than one simple measure, put it in the rows
					If ((..measureLocation="rows")&&(tMsrClause'="") && tMultipleMeasures) {		// DTB141 - use new tMultipleMeasures test
						If $E(tClause,1,6)="%LABEL" {
							// DTB208 - If the clause has a label, remove it before crossjoining, then place it around the entire crossjoin.
							// This structure provides the signal to the engine that the first term  of the crossjoin should be labeled.
							Set tClauseQuery = "SELECT " _ tClause _ " ON 0 FROM [" _ ..cubeName _"]"		// A new query to build the object form
							Set tTempRS = ##class(%DeepSee.ResultSet).%New()
							Set tSC = tTempRS.%PrepareMDX(tClauseQuery)
							If $$$ISERR(tSC) Quit
							
							Set tClauseOBJ = tTempRS.%GetQuery().axes.GetAt(1).children.GetAt(1)
							
							Set tSC = ##class(%DeepSee.Query.query).%RemoveLabel(tClauseOBJ,.tAbstractLabelOBJ,.tInnerClauseOBJ)
							If $$$ISERR(tSC) Quit
							Set tLabelArgs = $P(tAbstractLabelOBJ.%ToString(),",",2,*)
							
							Set tClause = "%LABEL(NONEMPTYCROSSJOIN("_tInnerClauseOBJ.%ToString()_","_tMsrClause_")," _ tLabelArgs			
					}
						Else {
							Set tClause = "NONEMPTYCROSSJOIN("_tClause_","_tMsrClause_")"
						}
					}
					Set tSumClause = tClause

					If (tShowTotals) {
						Set tSELECT = tSELECT _ "{"_tClause_",SUM("_tSumClause_")}"
					}
					Else {
						Set tSELECT = tSELECT_tClause
					}
					Set tSELECT = tSELECT _ " ON 1"
				}
			}
			Else {
				// put measures along rows, if more than 1
				If ((..measureLocation="rows")&&(tMsrClause'="") && tMultipleMeasures) {		// DTB141 - use new tMultipleMeasures test
					Set tClause = tMsrClause
					Set:tSELECT'="" tSELECT = tSELECT _ ","

					Set tSumClause = tClause
					If (tShowTotals) {
						Set tSELECT = tSELECT _ "{"_tClause_",SUM("_tSumClause_")}"
					}
					Else {
						Set tSELECT = tSELECT_tClause
					}
					Set tSELECT = tSELECT _ " ON 1"
				}
			}

			// JMD1347
			If (..contextFilterSpec '= "") {
				If ($E(..contextFilterSpec,1,8)="%FILTER ") {
					Set tFilterClauses($I(tFilterClauses)) = $E(..contextFilterSpec,8,*)
				}
				Else {
					Set tFilterClauses($I(tFilterClauses)) = ..contextFilterSpec
				}
			}

			// DTB141 - A single, simple measure may be added as a filter, single computed measures
			// are moved to third axis
			If ((tSingleSimpleMeasure || tSingleCalcMeasure)&&(..userMDX="")) {	// DTB141
				Set tMsr = ..measures.GetAt(1)
				Set tMsrSpec = tMsr.spec
				If (tMsr.aggFunction'="") {
					Set tMsrSpec = tMsrSpec _ "." _ tMsr.aggFunction
				}
				// WAL076 -- remove %LABEL handling here; measures with formatting 
				//           etc. are no longer considered simple measures
				If tSingleSimpleMeasure {
					Set:tMsrSpec'="" tFilterClauses($I(tFilterClauses)) = tMsrSpec
				} ElseIf tSingleCalcMeasure {
					// DTB141 - push calculated measure to third axis
					Set tSELECT = tSELECT _ $S(tSELECT[" ON ":", ",1:"") _ tMsrSpec _ " ON 2"
				}
			}

			// construct query from current settings
			Set tSLICER = ""
			Set k = $O(tFilterClauses(""))
			While (k'="") {
				Set tSLICER = tSLICER _ " %FILTER " _ tFilterClauses(k)
				Set k = $O(tFilterClauses(k))
			}
			Set tMDX = tWITH _ "SELECT "_tSELECT_" FROM ["_##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(tCubeName)_"]"_tSLICER		// DTB130 - generated query text should never show a version number
		} // not-a-listing
		
		If (..sqlRestriction'="") {
			// DTB723 - If the sqlRestriction is defined, add it as the final filter in the current query
			Set tMDX = tMDX _ " %FILTER %SQLRESTRICT.&[" _ ..sqlRestriction _ "]"
		}
		
		Set tSC = ..SetCurrentQueryText("current",tMDX)
	}
	Catch ex {
		Set tSC = ex.AsStatus()
		Set tMDX = $system.Status.GetErrorText(tSC)
	}
	Set pSC = tSC
	
	Quit tMDX
]]></Implementation>
</Method>

<Method name="addPivotCoverPane">
<Description>
Adds a coverpane to the pivot in the DOM. This is used to disable the pivot interaction.</Description>
<Internal>1</Internal>
<FormalSpec>parentDiv</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB701
	//var pivotContent = zen('dsPivotCompleteTable');
	//var parentDiv = pivotContent.getEnclosingDiv();
	if (!parentDiv) {		// DTB783 - Protect against a call with a null prentDiv. Do nothing in this case.
		return;
	}
	var newDiv = document.createElement('div');
	var coverPaneId = this.makeId('pivotCoverPane');
	var coverPane = document.getElementById(coverPaneId);
	
	// DTB714 - Define the svgTextGroup tiled repitition limits of the coverPane text
	var tileColCount = 4;
	var tileRowCount = 3;
	
	if (!coverPane) {
		// Only add a cover pane if one does not exist already
		newDiv.setAttribute('id',coverPaneId);
		newDiv.setAttribute('class','coverPaneInactive');
		
		// Draw the word 'PREVIEW' and add it as a watermark to the pane
		var svgWatermark = document.createElementNS(SVGNS,'svg');
		svgWatermark.setAttribute('id',this.makeId('previewWatermark'));
		svgWatermark.setAttribute('height',parentDiv.offsetHeight);
		svgWatermark.setAttribute('width',parentDiv.offsetWidth);
		
		// DTB714 - Render several text tiles
		var svgTextGroup = document.createElementNS(SVGNS,'g');
		var tileWidth = parentDiv.offsetWidth/tileColCount;
		var tileHeight = parentDiv.offsetHeight/tileRowCount;
		for ( r = 0 ; r<tileRowCount ; r++ ) {
			for ( c = 0 ; c<tileColCount ; c++ ) {
				var svgText = document.createElementNS(SVGNS,'text');
				var centerX = tileWidth*c + (tileWidth/2);
				var centerY = tileHeight*r + (tileHeight/2);
				
				svgText.setAttribute('transform','rotate(-30 '+centerX+','+centerY+')');
				svgText.setAttribute('font-size',(tileHeight/(1.1*3.16))+'px');
				svgText.setAttribute('text-anchor','middle');
				svgText.setAttribute('alignment-baseline','central');
				svgText.setAttribute('x',centerX);
				svgText.setAttribute('y',centerY);
				svgText.appendChild(document.createTextNode('PREVIEW'));
				
				svgTextGroup.appendChild(svgText);
			}
		}
		svgWatermark.appendChild(svgTextGroup);
		newDiv.appendChild(svgWatermark);
		newDiv.style.zIndex=2;		// DTB710 - Add zIndex to make sure this div is on top
		if (this.allowPreviewInteraction) {
			// DTB712 - Make the coverpane transparent to events if interaction is allowed
			newDiv.style.pointerEvents='none';
		}
		
		parentDiv.style.position='relative';
		parentDiv.appendChild(newDiv);
	}
]]></Implementation>
</Method>

<Method name="setPivotDisabled">
<Description>
This prevents a user from interacting with the pivot by using the cover pane.</Description>
<FormalSpec>setDisabled</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB701
	var coverPaneId = this.makeId('pivotCoverPane');
	var coverPane = document.getElementById(coverPaneId);
	var svgWatermark = this.findElement('previewWatermark');
	
	if (coverPane) {
		// Switch the css class to hide the coverPane objects
		if (setDisabled) {
			this.selectCellRange('');
			coverPane.setAttribute('class','coverPaneActive');
			svgWatermark.setAttribute('visibility','visible');
		}
		else {
			coverPane.setAttribute('class','coverPaneInactive');
			svgWatermark.setAttribute('visibility','hidden');
		}
	}
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.CubeDefinition">
<Description><![CDATA[
Subclasses of this class are used to define
"cubes" that can be queried by the DeepSee engine.<br/>
The Cube XDATA block defines the contents of a DeepSee cube
(dimensions and measures) as an XML document.
When a subclass of this class is compiled, it generates
the indexed fact table that holds the data for this cube.<br/>
This class also provides the APIs needs to explore
a cube's metadata that are used by the DeepSee utilities.]]></Description>
<Abstract>1</Abstract>
<CompileAfter>%DeepSee.Model.cube,%DeepSee.Generator</CompileAfter>
<IncludeCode>%occUtility,%DeepSee</IncludeCode>
<IncludeGenerator>%occUtility,%DeepSee</IncludeGenerator>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeCreated>60835,71423.817858</TimeCreated>

<Parameter name="TRANSFORMXSL">
<Description>
This parameter is used to transform original cube definition.
If it is defined in subclass then the cube definition is piped
through XSLT transformation. XSL is taken from XData block named
in this parameter.</Description>
<Type>STRING</Type>
</Parameter>

<Parameter name="TRANSFORMERCLASS">
<Description>
This parameter is used to transform original cube definition.
If it is defined in a subclass then the cube definition is piped
through the transformation defined in the class named
by this parameter.</Description>
<Type>STRING</Type>
</Parameter>

<Parameter name="USECUBEVERSIONS">
<Description><![CDATA[
This parameter controls whether the compile of this class will utilize the cube versioning mechanism. If
set to 1, the current class definition will act as a generator for a distinct version of the cube. <br>
The <var>version</var> attribute of the &lt;cube&gt tag must be set if this is set to 1.]]></Description>
<Default>0</Default>
</Parameter>

<Projection name="CubeProjection">
<Description>
This projection is used to keep track of when Cubes are
compiled or deleted.</Description>
<Type>%DeepSee.CubeProjection</Type>
<Internal>1</Internal>
</Projection>

<XData name="Cube">
<Description>
This XData section provides the definition of the cube.</Description>
<XMLNamespace>http://www.intersystems.com/deepsee</XMLNamespace>
</XData>

<Method name="%GetModel">
<Description><![CDATA[
Return an instance of the <class>%DeepSee.Model.cube</class>
meta-data object that describes this cube.]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%OnProcessFact,%OnApplyOverrides</GenerateAfter>
<ReturnType>%DeepSee.Model.cube</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// See if the old cube name and timestamp are stashed
		Set tOldCubeName = $G(^||%Cls(%compiledclass.Name,"cube"))
		Set tOldDSTIME = $G(^||%Cls(%compiledclass.Name,"dstime"))
		Merge tStorage = ^||%Cls(%compiledclass.Name,"storage")		// DTB961 - Remember previous storage

		Kill ^||%Cls(%compiledclass.Name)
		
		// DTB949 - The previous cube name (if it exists) is kept in case the compile fails 
		// and information needs to be recorded
		Set:(tOldCubeName'="") ^||%Cls(%compiledclass.Name,"oldCubeName") = tOldCubeName
		
		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

	// JMD1348 prevent incremental compile
#ifdef cCLASSdisableincremental
	$$$comClassKeySet(%class.Name,$$$cCLASSdisableincremental,1)
#endif
		Set tDisplay=$$$qualifierGetValue(%qstruct,"displaylog")
		
		#; figure out if this page should provide automatic localization
		#; For library (system) classes, localization occurs for %ZEN domain
		#; For non-library classes, check for non-%DeepSee domain
		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		#; find XDATA block named Cube
		Set tIndex = %compiledclass.XDatas.FindObjectId(%class.Name_"||Cube")

		Do %code.WriteLine(" Set tCube1 = """"")

		If (tIndex '= "") {
			#; get XDATA as stream
			Set tStream = %compiledclass.XDatas.GetAt(tIndex).Data
			Do tStream.Rewind()

			#; Transform if required
			set tTransformer = %compiledclass.Parameters.FindObjectId(%class.Name_"||TRANSFORMERCLASS")
			Set tClassName = %compiledclass.Parameters.GetAt(tTransformer).Default
			if (tClassName'="") {
				if ('##class(%Dictionary.CompiledClass).%ExistsId(tClassName)) {
					Set tSC = $$$ERROR($$$GeneralError,"Transformer Class: "_tClassName_" Does not Exist")
					Quit
				}
				Set tSC = $zobjclassmethod(tClassName,"Transform",tStream,.tOut)
				If $$$ISERR(tSC) Quit
				Do tOut.Rewind()
				Set tStream = tOut
			} else {
				set tTransformer = %compiledclass.Parameters.FindObjectId(%class.Name_"||TRANSFORMXSL")
				set tXSL = %compiledclass.Parameters.GetAt(tTransformer).Default
				if (tXSL="") {
					Set tSupers = %compiledclass.Super
					for i=1:1:$l(tSupers,",") {
						Set tSuper = $p(tSupers,",",i)
						set tClass = ##class(%Dictionary.CompiledClass).%OpenId(tSuper)
						set tTransformer = tClass.Parameters.FindObjectId(tSuper_"||TRANSFORMXSL")
						Continue:tTransformer=""
						set tXSL = tClass.Parameters.GetAt(tTransformer).Default
						Quit:tXSL'=""
					}
				}
				if (tXSL'="") {
					Set tXSLId = %compiledclass.Name_"||"_tXSL
					if ('##class(%Dictionary.CompiledXData).%ExistsId(tXSLId)) {
						Set tSC = $$$ERROR($$$GeneralError,"XSL Block: "_tXSLId_" Does not Exist")
						Quit
					}
					Set tSC = ..%OnGetModel(tXSLId,tStream,.tOut)
					If $$$ISERR(tSC) Quit
					Do tOut.Rewind()
					Set tStream = tOut
				}
			}

			If (tStream.Size > 0) {

				#; render the stream into cube meta-data object (with children)
				Set tReader = ##class(%XML.Reader).%New()

				Set tSC = tReader.OpenStream(tStream)
				If $$$ISERR(tSC) Quit

				Do tReader.Correlate("cube","%DeepSee.Model.cube")

				#; there should only be one cube defined
				Do tReader.Next(.tCube,.tSC)
				If $$$ISERR(tSC) Quit
				If '$IsObject(tCube) {
					Set tSC = $$$ERROR($$$GeneralError,"No <cube> element defined in Cube block.")
					Quit
				}

				#; is this cube name already used?
				Set tCubeName = tCube.name
				If (tCubeName = "") {
					Set tSC = $$$ERROR($$$GeneralError,"Cube must be given a name")
					Quit
				}
				Set tRegClass = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName)))
				If ((tRegClass'="") && (tRegClass '= %class.Name)) {
					Set tSC = $$$ERROR($$$GeneralError,"Cube with given name already exists: " _ tCubeName)
					Quit
				}
				
				#; is cube disabled?
				// DTB294 - Move after name check and look at the override setting for disabled only
				Set tDisabledByOverride = +$G(^DeepSee.Overrides($$$UPPER(tCubeName),"DISABLED"))
				If (tCube.disabled)||(tDisabledByOverride) {
					If tDisabledByOverride {
						// DTB294 this can be hard-coded to true. An override cannot turn disabled off!
						Write:tDisplay !,$$$Text("Applying override to: ""disabled"" = ""1""","%DeepSee")
					}
					Write:tDisplay !,$$$FormatText($$$Text("Cube '%1' is disabled","%DeepSee"),tCube.name)
					Do %code.WriteLine(" Set tCube1 = """"")
					Do %code.WriteLine(" Quit tCube1")
					Quit
				}

				#; have cube generate code to recreate itself at run-time
				#; do this *before* inheritance is resolved
				Do tCube.%GenerateCode(%code,tLocalize)
				
				// +DTB130 - process cube version information
				Set tCubeVersionNo = tCube.version
				If $G(%parameter("USECUBEVERSIONS"),0) {
					If tCubeVersionNo="" {
						Set tSC = $$$ERROR($$$GeneralError,"A versioned cube definition must declare a version.")
						Quit
					}
					Else {
						// Define a new cube definition based on the version number
						Set tSC = ##class(%DeepSee.CubeVersion.Utils).%CreateCubeVersionDefinition(%compiledclass.Name,.tCube,.tNewClassName,.tCubeVersionIndex)
						If $$$ISERR(tSC) Quit
						Set tSC = $system.OBJ.Compile(tNewClassName)
						If $$$ISERR(tSC) Quit
						
						// Log this version of the cube in the versionIndex
						Set $$$DeepSeeMetaGLVN("versionIndex","versions",$$$UPPER(tCubeName),tCubeVersionNo,"class") = tNewClassName
						Set $$$DeepSeeMetaGLVN("versionIndex","versions",$$$UPPER(tCubeName),tCubeVersionNo,"cube") = tCubeVersionIndex
						
						// Cross-reference the primary definition in the version metadata
						Set $$$DeepSeeMetaGLVN("versionIndex","versionOf",tCubeVersionIndex) = $$$UPPER(tCubeName)
						
						// If this was the active version and is being recompiled, mark that the cube has  
						// no active version and that the current version is pending
						If ##class(%DeepSee.CubeVersion.Utils).%IsActiveVersion(tCubeVersionIndex) {
							Set tSC = ##class(%DeepSee.CubeVersion.Utils).%SetActiveCubeVersion(tCubeName,"")
						}
						
						// Look to see if there is a pending version already. If there is one that is not this version, deprecate it
						Set tPendingVersion = ##class(%DeepSee.CubeVersion.Utils).%GetPendingCubeVersion(tCubeName)
						If (tPendingVersion'=tCubeVersionNo) {
							Set tSC = ##class(%DeepSee.CubeVersion.Utils).%DeprecateCubeVersion(tCubeName,tPendingVersion)
						}

						// DTB130 - Cube being compiled is automatically set as the pending version
						Set tSC = ##class(%DeepSee.CubeVersion.Utils).%SetPendingCubeVersion(tCubeName,tCubeVersionNo)
						
					}
				}
				ElseIf ($G(%parameter("USECUBEVERSIONS"),0)=0) {
					// The version is ignored in this case, notify that this is the case
					If (tCubeVersionNo'="") {
						Write:tDisplay !,$$$FormatText($$$Text("Cube version is set to '%1' but USECUBEVERSIONS=0. The version attribute will be ignored.","%DeepSee"),tCubeVersionNo)
					}
					
					// Look to see if there is a pending version already. If there is one that is not this version, deprecate it
					Set tPendingVersion = ##class(%DeepSee.CubeVersion.Utils).%GetPendingCubeVersion(tCubeName)
					If tPendingVersion {
						Set tSC = ##class(%DeepSee.CubeVersion.Utils).%DeprecateCubeVersion(tCubeName,tPendingVersion)
					}
					Set tActiveVersion = ##class(%DeepSee.CubeVersion.Utils).%GetActiveCubeVersion(tCubeName)
					If tActiveVersion {
						Set tSC = ##class(%DeepSee.CubeVersion.Utils).%SetActiveCubeVersion(tCubeName,"")
						Set tSC = ##class(%DeepSee.CubeVersion.Utils).%DeprecateCubeVersion(tCubeName,tActiveVersion)
					}
					
					Kill $$$DeepSeeMetaGLVN("versionIndex","versions",$$$UPPER(tCubeName),"activeVersion")
					Kill $$$DeepSeeMetaGLVN("versionIndex","versions",$$$UPPER(tCubeName),"pendingVersion")
				}
				// -DTB130

				#; resolve inheritance (if any)
				Set tSC = tCube.%ResolveInheritance()
				If $$$ISERR(tSC) Quit

				#; resolve shared dimensions (if any)
				Set tSC = tCube.%ResolveSharedDimensions(.tSharedInfo)
				If $$$ISERR(tSC) Quit

				#; apply overrides to model (if any)
				Set tSC = tCube.%ApplyOverrides($Name(^DeepSee.Overrides))
				If $$$ISERR(tSC) Quit

				#; skip validation for abstract classes
				If ('+tCube.abstract) {
					#; test source class
					If (tCube.sourceClass="") {
						Set tSC = $$$ERROR($$$GeneralError,"Cube must define a sourceClass")
						Quit
					}

					Set tSourceType = ""

					// special case: test for worksheets and kpis
					Set tExt = $P(tCube.sourceClass,".",$L(tCube.sourceClass,"."))
					If ((tExt="kpi")||(tExt="metric")||(tExt="worksheet")) {
						If (tExt="kpi") {
							Set tName = $P(tCube.sourceClass,".",1,$L(tCube.sourceClass,".")-1)
							Set tKPIClass = ##class(%DeepSee.Utils).%GetKPIClass(tName)
							If (tKPIClass="") {
								Set tSC = $$$ERROR($$$GeneralError,"Class referred to by sourceClass is not defined: "_tCube.sourceClass)
								Quit
							}
							Set tSourceType = "kpi"
						}
						ElseIf (tExt="worksheet") {
							Set tName = tCube.sourceClass
							Set tKPIClass = "%DeepSee.KPIWorksheet"
							Set tSourceType = "worksheet"
						}
						Else {
							Set tSourceType = "metric"
							Set tName = tCube.sourceClass
							Set tKPIClass = "Ens.BusinessMetricKPI"
						}
					}
					ElseIf '$$$defClassDefined(tCube.sourceClass) {
						Set tSC = $$$ERROR($$$GeneralError,"Class referred to by sourceClass is not defined: "_tCube.sourceClass)
						Quit
					}

					#; determine type of sourceClass
					If (tSourceType = "") {
						Try {
							If ($$$getClassType(tCube.sourceClass)="view") {
								Set tSC = $$$ERROR($$$GeneralError,"View cannot be used as a data source; use a DataConnector class: "_tCube.sourceClass)
							}
							ElseIf ($$$getClassType(tCube.sourceClass)="persistent") {
								Set tSourceType = "persistent"
							}
							ElseIf $zobjclassmethod(tCube.sourceClass,"%IsA","%DeepSee.DataConnector") {
								Set tSourceType = "dataconnector"
							}
						}
						Catch (ex) {
							Set tSC = $$$ERROR($$$GeneralError,"Invalid or missing sourceClass "_tCube.sourceClass)
						}
						If $$$ISERR(tSC) Quit
					}

					If (tSourceType = "") {
						Set tSC = $$$ERROR($$$GeneralError,"Source class must be either be a persistent class or a DeepSee DataConnector class: "_tCube.sourceClass)
						Quit
					}

					Set tSC = tCube.%ProcessFunctions()
					If $$$ISERR(tSC) Quit

					#; validate cube
					Set tSC = tCube.%Validate()
					If $$$ISERR(tSC) Quit
				}

				#; get name of cube
				Set ^||%Cls(%compiledclass.Name,"cubeName") = tCubeName
				Set ^||%Cls(%compiledclass.Name,"sourceType") = $G(tSourceType)
				Set ^||%Cls(%compiledclass.Name,"sourceClass") = tCube.sourceClass
				Set ^||%Cls(%compiledclass.Name,"cubeCaption") = $S(tCube.caption'="":tCube.caption,1:tCube.displayName)
				Set ^||%Cls(%compiledclass.Name,"countName") = tCube.countMeasureName
				Set ^||%Cls(%compiledclass.Name,"countCaption") = tCube.countMeasureCaption
				Set ^||%Cls(%compiledclass.Name,"maxFacts") = tCube.maxFacts
				Set ^||%Cls(%compiledclass.Name,"abstract") = +tCube.abstract
				Set:tCube.initialBuildOrder'="" ^||%Cls(%compiledclass.Name,"initialBuildOrder") = tCube.initialBuildOrder
				Set:tCube.buildRestriction'="" ^||%Cls(%compiledclass.Name,"buildRestriction") = tCube.buildRestriction

				#; nothing more to do for abstract cubes
				If (+tCube.abstract) {
					Do %code.WriteLine(" Quit tCube1")
					Quit
				}

				Set tCubeNameU = $$$UPPER(tCubeName)

				#; JMD1472: if cube is disabled at this point then it is due to
				#; an override; mark the cube as disabled, but compile as normal
				If (tCube.disabled) {
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"disabled") = 1
				}

				#; does this cube support drill through
				#; JMD989 No longer used
				#; Set ^||%Cls(%compiledclass.Name,"drillThrough") = (tCube.listings.Count()>0)

				#; schema for generated classes
				Set tSchema = %compiledclass.Name

				// +DTB119
				// Look through the methods in %compiledclass to see if %OnProcessFact is user-defined.
				// %Dictionary.CompiledMethod does not have this entry yet!
				Set tOnProcessFact = 0
				For ii=1:1:%compiledclass.Methods.Count() {
					Set tMethod = %compiledclass.Methods.GetAt(ii)
					// The method could be inherited from a different user class that the current class inherits.
					If (tMethod.Name="%OnProcessFact")&&(tMethod.Origin'="%DeepSee.CubeDefinition") {
						Set tOnProcessFact = 1
					}
				} 
	
				If tOnProcessFact {
					// Indicate the cube actually uses this method in the metadata
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"onProcessFact") = 1
				}
				// -DTB119

				#; take out lock to prevent queries
				// +DTB130 - timeout and report locking problem
				Set tLocked = 1
				Lock +^DeepSee.Build(tCubeNameU):10 Else  Set tLocked=0	
				If 'tLocked {
					Set tSC = $$$ERROR($$$GeneralError,"Unable to obtain the lock needed for compile: " _ tCubeNameU)
					Quit
				}
				// -DTB130

				#; Analyze cube and get meta-structures
				Set tSC = ##class(%DeepSee.Generator).%BuildCubeInfo(tCube,tSchema,.tMbrInfo,.tMbrNames,.tFactIndex,.tFactInfo,.tStarInfo,.tMsrIndex,.tRelationInfo,.tRelIndex,.tCaptions,.tCubeMeta,.tLevelDepends,.tComputedDims,.tDescriptions) // JSL4475 - fill in tDescriptions
				If $$$ISERR(tSC) Quit

				#; save meta data to global
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbr#") = tMbrInfo
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbrs") = tMbrNames
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"fact#") = tFactIndex
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"msr#") = tMsrIndex
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"fact") = tFactInfo
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"star") = tStarInfo
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"relations") = tRelationInfo
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"rel#") = tRelIndex

				#; JMD1453 compute *actual* fact count
				Set tFactCount = 0
				Set k = $O(tFactIndex(""))
				While (k'="") {
					Set:(k>tFactCount) tFactCount = k
					Set k = $O(tFactIndex(k))
				}
				Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"factCount") = tFactCount

				#; JMD910 levelDepends: (d#,h#,l#,masterFact#)
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"levelDepends") = tLevelDepends

				#; JMD1329
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"computedDims") = tComputedDims

				#; JMD1059 get factDepends info: (MasterFact#,SlaveFact#)
				Set xd = $O(tLevelDepends(""))
				While (xd'="") {
					Set xh = $O(tLevelDepends(xd,""))
					While (xh'="") {
						Set xl = $O(tLevelDepends(xd,xh,""))
						While (xl'="") {
							Set tMasterFactNo = $O(tLevelDepends(xd,xh,xl,""))
							While (tMasterFactNo'="") {
								Set tSlaveInfo = $G(tMbrInfo(xd,xh,xl))
								Set tSlaveFactNo = $LG(tSlaveInfo,5)
								If (tSlaveFactNo'="") {
									Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"factDepends",tMasterFactNo,tSlaveFactNo) = ""
								}
								Set tMasterFactNo = $O(tLevelDepends(xd,xh,xl,tMasterFactNo))
							}
							Set xl = $O(tLevelDepends(xd,xh,xl))
						}
						Set xh = $O(tLevelDepends(xd,xh))
					}
					Set xd = $O(tLevelDepends(xd))
				}

				// DTB886 - Look at anything that might have been packed into the metadata and place
				// it in the appropriate global node
				Set tMetaProp = $O(tCubeMeta(""),1,tMetaPropValue)
				While (tMetaProp'="") {
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,tMetaProp) = tMetaPropValue
					Set tMetaProp = $O(tCubeMeta(tMetaProp),1,tMetaPropValue)
				}

				// BDB267: create any iKnow domains for iKnow measures in this cube.
				// To verify if any domains created for a previous version of this cube
				// can be reused (and need to be renamed) or should be dropped, first
				// browse through the "prior" facts and note all iKnow domains
				set tOldCubeNameU = $s(tOldCubeName'="":$$$UPPER(tOldCubeName), 1:tCubeNameU)
				set tFact = "", gPriorFacts = $name($$$DeepSeeMetaGLVN("prior",tOldCubeNameU,"fact","prop"))
				for {
					set tFact = $order(@gPriorFacts@(tFact))
					quit:tFact=""
				
					set tIndexType = $g(@gPriorFacts@(tFact,"index"))
					continue:$piece(tIndexType,":",1)'="iKnow"
				
					// skip iKnow-managed domains
					continue:$piece(tIndexType,":",2)="domain"
				
					set tIKMeasure = $g(@gPriorFacts@(tFact,"msrname"))
					set tExprOrProp = $g(@gPriorFacts@(tFact,"expr"), $g(@gPriorFacts@(tFact,"source")))
					continue:tExprOrProp=""
				
					set tDomainName = $piece(tIndexType,":",3)
					set tDomainParams = $piece(tIndexType,":",5,9999)
					if (tDomainName="") {
						set tDomainName = ##class(%iKnow.DeepSee.CubeUtils).GetDeepSeeDomainName(tOldCubeNameU,tIKMeasure)
					}
					
					set ^||%Cls(%compiledclass.Name,"iKnow","props",tExprOrProp, tDomainName) = $$$UPPER(tIKMeasure)
				}
				kill tFixedDomainNames
				set tFact = ""
				for {
					set tFact = $order(tFactInfo("prop",tFact))
					quit:tFact=""
					
					set tIndexType = $g(tFactInfo("prop",tFact,"index"))
					continue:$piece(tIndexType,":",1)'="iKnow"
					
					// skip iKnow-managed domains
					continue:$piece(tIndexType,":",2)="domain"
					
					set tIKMeasure = $g(tFactInfo("prop",tFact,"msrname"))
					
					// license check to avoid trouble further downstream and make sure
					// we can display a proper warning
					if '$$iKnow^%SYS.LICENSE() {
						write !,$$$FormatText($$$Text("WARNING: Cube '%1' contains iKnow measures but iKnow is not licensed for this instance.","%DeepSee"),tCube.name)
						quit
					}
					
					set tExprOrProp = $g(tFactInfo("prop",tFact,"expr"), $g(tFactInfo("prop",tFact,"source")))
					continue:tExprOrProp=""
					
					set tDomainName = $piece(tIndexType,":",3)
					set tDomainDictionaries = $piece(tIndexType,":",4) // BDB387
					set tDomainParams = $piece(tIndexType,":",5,9999)
					if (tDomainName="") {
						set tDomainName = ##class(%iKnow.DeepSee.CubeUtils).GetDeepSeeDomainName(tCubeName,tIKMeasure)
					}
					
					// Check if this domain name is not already in use by another measure
					if $d(tFixedDomainNames($$$UPPER(tDomainName)), tOtherMeasure) {
						set tSC = $$$ERROR($$$GeneralError, "Domain name """_tDomainName_""" already in use by "_tOtherMeasure)
						quit
					}
					set tFixedDomainNames($$$UPPER(tDomainName)) = tIKMeasure
					
					// if we have a domain with the same name, we'll reuse it
					set gPrevDomains = $name(^||%Cls(%compiledclass.Name,"iKnow","props",tExprOrProp))
					if $d(@gPrevDomains@(tDomainName)) {
						
						// reuse as is, remove from the to-be-dropped list
						kill @gPrevDomains@(tDomainName)
						
					} elseif $d(@gPrevDomains) {
						
						// usually there's only one domain, but let's make sure to make
						// a well-educated guess if there's more.
						
						// check if the measure name happens to be the same
						// (fe if only the cube name changed)
						set tPrevDomainName=""
						for {
							set tPrevDomainName = $order(@gPrevDomains@(tPrevDomainName),1,tPrevIKMeasure)
							quit:tPrevDomainName=""
							quit:$$$UPPER(tIKMeasure)=tPrevIKMeasure
						}
						
						// if we didn't find any, just take the first
						set:tPrevDomainName="" tPrevDomainName = $order(@gPrevDomains@(""))
					
						// now try to rename tPrevDomainName to the new domain name 
						/// BDB348 - delegate to CubeUtils (domain manager)
						set tSC = ##class(%iKnow.DeepSee.CubeUtils).RenameDomain(tPrevDomainName, tDomainName)
						quit:$$$ISERR(tSC)
					
						// if we were able to rename it, just remove it from the list to indicate
						// we'll be reusing it as tDomainName
						kill @gPrevDomains@(tPrevDomainName)
					}
					
					// now create the domain, which will just apply the required parameters if it
					// already exists
					set tDomainId = ##class(%iKnow.DeepSee.CubeUtils).CreateDomain(tCubeName, tIKMeasure, tDomainParams, tDomainDictionaries, .tDomainName, .tSC)
					quit:$$$ISERR(tSC)
				}
				quit:$$$ISERR(tSC)
				
				// if there's any domains left from a previous version, drop them
				if ($d(^||%Cls(%compiledclass.Name,"iKnow","props"))) {
					set tExprOrProp=""
					for {
						set tExprOrProp = $order(^||%Cls(%compiledclass.Name,"iKnow","props",tExprOrProp))
						quit:tExprOrProp=""
						
						set tDomainName=""
						for {
							set tDomainName = $order(^||%Cls(%compiledclass.Name,"iKnow","props",tExprOrProp, tDomainName))
							quit:tDomainName=""
							
							/// BDB348 - delegate to CubeUtils (domain manager)
							do ##class(%iKnow.DeepSee.CubeUtils).DropDomain(tDomainName)
						}
					}
					kill ^||%Cls(%compiledclass.Name,"iKnow","props")
				}

				#; additional meta data
				Set:tCube.actionClass'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"actionClass") = tCube.actionClass
				Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"sourceType") = tSourceType
				Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"sourceClass") = tCube.sourceClass
				Set:tCube.resource'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"resource") = tCube.resource
				Set:tCube.buildRestriction'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"buildRestriction") = tCube.buildRestriction

				#; reset sharesFrom index
				Set tSCube1 = $O($$$DeepSeeMetaGLVN("sharesIndex",""))
				While (tSCube1'="") {
					Set tFNO = $O($$$DeepSeeMetaGLVN("sharesIndex",tSCube1,""))
					While (tFNO'="") {
						Set tSCube2 = $O($$$DeepSeeMetaGLVN("sharesIndex",tSCube1,tFNO,""))
						While (tSCube2'="") {
							If (tSCube2=tCubeNameU) {
								Kill $$$DeepSeeMetaGLVN("sharesIndex",tSCube1,tFNO,tSCube2)
							}
							Set tSCube2 = $O($$$DeepSeeMetaGLVN("sharesIndex",tSCube1,tFNO,tSCube2))
						}
						Set tFNO = $O($$$DeepSeeMetaGLVN("sharesIndex",tSCube1,tFNO))
					}

					If (tSCube1=tCubeNameU) {
						Kill $$$DeepSeeMetaGLVN("sharesIndex",tSCube1)
					}
					Set tSCube1 = $O($$$DeepSeeMetaGLVN("sharesIndex",tSCube1))
				}

				If $D(tSharedInfo) {
					#; tSharedInfo(OTHERCUBE,DIMENSION) = ""
					Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"sharesFrom") = tSharedInfo
					Set tSC = ..%UpdateSharesIndex(tCubeNameU)
					If $$$ISERR(tSC) Quit
				}

				If (tSourceType = "dataconnector") {
					Set tVersion = $zobjclassmethod(tCube.sourceClass,"%GetVersion")
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"connectorVersion") = tVersion
				}

				#; listings
				Set tDefaultListing = ""
				Set tDefaultListingOrder = ""
				Set tDefaultListingSQL = ""
				Set tDefaultSourceClass = ""
				Set tDefaultListingFormat = ""
				Set tDefaultListingResource = ""

				// DTB082 
				Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"disableListingGroups") = tCube.disableListingGroups

				// DTB717 - Set up a special computed dimension to support %SQLRESTRICT
				If tCube.enableSqlRestrict {
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbrs","%SQLRESTRICT") = $LB(-1,1,1)
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbr#",-1,0,0) = $LB("d","%SQLRESRICT",,"")
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbr#",-1,1,0) = $LB("h","%SQLRESTRICT","H1",,,"%DeepSee.Query.memberComputed",,,,,,,,,,,0)
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbr#",-1,1,1) = $LB("l","%SQLRESTRICT","H1","%SQLRESTRICT",-1,"%DeepSee.ComputedDimension.SQL","%sourceId","","","",1,"%sourceId")
				}

				For n=1:1:tCube.listings.Count() {
					Set tListing = tCube.listings.GetAt(n)
					If ('tListing.disabled) {
						Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listing",tListing.name,"fieldList") = tListing.fieldList
						Set:tListing.formatList'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listing",tListing.name,"formatList") = tListing.formatList
						Set:tListing.orderBy'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listing",tListing.name,"orderBy") = tListing.orderBy
						Set:tListing.sql'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listing",tListing.name,"sql") = tListing.sql
						Set:tListing.sourceClass'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listing",tListing.name,"sourceClass") = tListing.sourceClass
						Set:(tListing.listingType'="")&&(tListing.listingType'="table") $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listing",tListing.name,"listingType") = tListing.listingType
						Set:tListing.resource'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listing",tListing.name,"resource") = tListing.resource
						// JMD989: store display name
						Set:tListing.displayName'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listing",tListing.name,"displayName") = tListing.displayName
						// JSL4477: store display name
						Set:tListing.description'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listing",tListing.name,"description") = tListing.description

						If ((n=1)||($$$UPPER(tListing.name)=$$$UPPER(tCube.defaultListing))) {
							Set tDefaultListing = tListing.fieldList
							Set tDefaultListingOrder = tListing.orderBy
							Set tDefaultListingSQL = tListing.sql
							Set tDefaultSourceClass = tListing.sourceClass
							Set tDefaultListingFormat = tListing.formatList
							Set tDefaultListingResource = tListing.resource
						}
					}
				}

				Set:tDefaultListing'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"defaultListing") = tDefaultListing
				Set:tDefaultListingOrder'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"defaultListingOrder") = tDefaultListingOrder
				Set:tDefaultListingSQL'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"defaultListingSQL") = tDefaultListingSQL
				Set:tDefaultSourceClass'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"defaultListingSourceClass") = tDefaultSourceClass
				Set:tDefaultListingFormat'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"defaultListingFormat") = tDefaultListingFormat
				Set:tDefaultListingResource'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"defaultListingResource") = tDefaultListingResource

				#; listing fields
				For n=1:1:tCube.listingFields.Count() {
					Set tField = tCube.listingFields.GetAt(n)
					If ('tField.disabled) {
						Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listingFields",tField.name,"fieldExpression") = tField.fieldExpression
						Set:tField.resource'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listingFields",tField.name,"resource") = tField.resource
						Set:tField.displayName'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listingFields",tField.name,"displayName") = tField.displayName
						Set:tField.description'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"listingFields",tField.name,"description") = tField.description // JSL4477
					}
				}

				#; specify where data comes from
				Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"factClass") = %compiledclass.Name_".Fact"
				Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"indexName") = tCubeNameU

				#; find list of classes that provide data for dimensions (used for synchronization)
				If (tSourceType="persistent") {
					Set tProp = $O(tFactInfo("prop",""))
					While (tProp '= "") {
						Set tPropLocalSource = $G($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"fact","prop",tProp,"localSource"))
						Set tPropLocalExpr = $G($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"fact","prop",tProp,"localExpr"))

						#; ignore shared properties
						If ((tPropLocalSource="")&&(tPropLocalExpr="")) {
							// !!! we have to pick up expressions also !!!
							// what about ref fields? -- we can ignore these
							Set tPropSource = $G($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"fact","prop",tProp,"source"))
							Set tDepth = $L(tPropSource,".")
							Set tPropRef = $P(tPropSource,".",1,tDepth-1)
							If (tPropRef'="") {
								// find type of reference *before* final property
								Set tSC = ##class(%DeepSee.Generator).%AnalyzeStarProperty(tCube.sourceClass,tPropRef,.tType,,"cube")
								If $$$ISERR(tSC) Quit
								If (tType'="") {
									// check if DSTIME is in play
									$$$comMemberKeyGetLvar(tDSTIME,tType,$$$cCLASSparameter,"DSTIME",$$$cPARAMdefault)
									If ((tDSTIME'="")&&($$$UPPER(tDSTIME)'="NONE")) {
										Set tSourceExpr = ##class(%DeepSee.Generator).%GetSQLFieldExpression(.tSC,tCube.sourceClass,tPropRef)
										If $$$ISERR(tSC) Quit
										Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"depends",tType) = tSourceExpr
									}
								}
							}
						}
						Set tProp = $O(tFactInfo("prop",tProp))
					}
				}
				If $$$ISERR(tSC) Quit

				#; Analyze calculated members and named sets
				// + WAL065 -- pass tMbrNames array so that we don't overwrite captions for standard dimensions
				//             this array is created above by %BuildCubeInfo and contains all of the standard dimensions, hierarchies and levels
				Set tSC = ##class(%DeepSee.Generator).%ProcessVirtualMembers(tCube,.tNamedSets,.tCalcMbrs, .tCaptions,.tDescriptions,.tMbrNames)
				// - WAL065
				If $$$ISERR(tSC) Quit

				Merge ^||%Cls(%compiledclass.Name,"captions") = tCaptions
				Merge ^||%Cls(%compiledclass.Name,"descriptions") = tDescriptions // JSL4475
				Set ^||%Cls(%compiledclass.Name,"precompute") = tCube.precompute
				Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"precompute") = tCube.precompute
				Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"caption") = tCube.caption

				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"namedSets") = tNamedSets
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"calcMbrs") = tCalcMbrs

				#; apply bucket size
				Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"bucketSize") = tCube.bucketSize

				If (tCube.defaultMeasure'="") {
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"defmsr") = tCube.defaultMeasure
				}
				If (tCube.defaultMember'="") {
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"defmbr") = tCube.defaultMember
				}
				Set tDimNode = $G($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbr#",1,0,0))
				Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"defdim") = $LG(tDimNode,2)

				If ($$$UPPER(tOldCubeName)=tCubeNameU) {
					If (tOldDSTIME'="") {
						// restore sync point (timestamp)
						Set tSC = ##class(%DeepSee.Utils).%SetCubeDSTime(tCubeNameU,tOldDSTIME)		// DTB838 - Use API
						If $$$ISERR(tSC) Quit
					}
				}

				#; test if *other* cubes share from *this* cube
				Set tOtherCube = $O($$$DeepSeeMetaGLVN("cubes",""))
				While (tOtherCube'="") {
					If $D($$$DeepSeeMetaGLVN("cubes",tOtherCube,"sharesFrom",tCubeNameU)) {
						Write:tDisplay !,"Updating shared cube info: ",tOtherCube,!
						Set tSC = ..%UpdateSharesIndex(tOtherCube)
						If $$$ISERR(tSC) Quit
					}
					Set tOtherCube = $O($$$DeepSeeMetaGLVN("cubes",tOtherCube))
				}
				If $$$ISERR(tSC) Quit

				#; compute fact order
				#; this is the order in which facts are ANDed, most selective first
				Set tProp = $O(tFactInfo("prop",""))
				While (tProp '= "") {
					Set tFactNo = $G(tFactInfo("prop",tProp))
					If ((tFactNo = +tFactNo) && (tFactNo>0)) {
						Set tLevelNo = +$G(tFactInfo("prop",tProp,"levelNo"))
						If ((tCube.initialBuildOrder'="")&&($G(tFactInfo("prop",tProp,"source"))=tCube.initialBuildOrder)) {
							#; give slight edge to the initial sort property
							Set tLevelNo = tLevelNo + 1
						}
						Set tFactOrder(tLevelNo,tFactNo) = tProp
					}
					Set tProp = $O(tFactInfo("prop",tProp))
				}
				
				Set tFactOrderList = $LB("")
				Set k = $O(tFactOrder(""),-1)
				While (k'="") {
					Set f = $O(tFactOrder(k,""),-1)
					While (f'="") {
						Set tFactOrderList = tFactOrderList_$LB(f)
						Set f = $O(tFactOrder(k,f),-1)
					}
					Set k = $O(tFactOrder(k),-1)
				}

				Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"factOrder") = tFactOrderList

				#; compare meta data with prior data
				Set tSC = ##class(%DeepSee.Generator).%CompareMetaData(tCubeName,.tDelta)
				If $$$ISERR(tSC) Quit
				If (('+$G(tDelta("dims")))||('+$G(tDelta("bucketSize")))||('+$G(tDelta("facts")))||('+$G(tDelta("cube")))) {
					// meta data change
					If (('+$G(tDelta("dims")))&&(+$G(tDelta("bucketSize")))&&(+$G(tDelta("facts")))&&(+$G(tDelta("cube")))) {
						// results cache only
						Set tSC = ##class(%DeepSee.Query.Engine).%ClearCache(tCubeName,1)
						If $$$ISERR(tSC) Quit
					}
					Else {
						Set tSC = ##class(%DeepSee.Query.Engine).%ClearCache(tCubeName)
						If $$$ISERR(tSC) Quit
					}
					#; time stamps (utc)
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"lastSchemaUpdate") = $ZTIMESTAMP
					Set $$$DeepSeeUpdateQueue("cubes",tCubeNameU,"lastDataUpdate") = ""		// DTB422 - Store data updates in the updates global
				}
				Else {
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"lastSchemaUpdate") = $G($$$DeepSeeMetaGLVN("prior",tCubeNameU,"lastSchemaUpdate"))
				}
				// !!! for this last test, we need to track our own dependencies!!!
				If (1||('+$G(tDelta("facts")))||('+$G(tDelta("cube")))) {
					#; build FACT and STAR tables
					// DTB961 - Provide the previous fact storage information in the creation of the 
					// fact table. This will get processed and be returned with the proper metadata
					// to store with this compile of the cube.
					Set tSC = ##class(%DeepSee.Generator).%CreateFactTable(tCube,%compiledclass.Name,tSchema,tSourceType,.tFactIndex,.tFactInfo,.tStarInfo,.tMsrIndex,.tRelationInfo,.tStorage)
					If $$$ISERR(tSC) Quit
				}

				// pick up some additional metadata created by create fact table
				Set tStar = $O(tStarInfo(""))
				While (tStar'="") {
					Set tPrimary = $G(tStarInfo(tStar,"primary"))
					Set:tPrimary'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"star",tStar,"primary") = tPrimary
					Set tStar = $O(tStarInfo(tStar))
				}
				
				// + DTB908 - Copy over "enabled" settings from the prior if fact numbers are stable.
				// If no prior exists for the cube, mark all facts as enabled=0.
				If $$$dsSupportsSelectedList(tCubeNameU) {
					If '$D($$$DeepSeeMetaGLVN("prior",tCubeNameU)) {
						// If there is no prior, this is the first compile. Mark all dimensions enabled=0
						Set tSC = ##class(%DeepSee.Utils).%MarkFactsEnabled(tCubeNameU,"",0)
						If $$$ISERR(tSC) Quit
					}
					Else {
						Set tProperty = $O($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"fact","prop",""))
						While (tProperty'="") {
							If $D($$$DeepSeeMetaGLVN("prior",tCubeNameU,"fact","prop",tProperty,"enabled")) {
								// If there is a prior, copy t over to the current metadata
								Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"fact","prop",tProperty,"enabled") = $$$DeepSeeMetaGLVN("prior",tCubeNameU,"fact","prop",tProperty,"enabled")
							}
							ElseIf '$D($$$DeepSeeMetaGLVN("prior",tCubeNameU,"fact","prop",tProperty)) {
								// DTB918 - Specifically test for missing property in the prior.
								// A property without a prior at all will be marked enabled=0
								Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"fact","prop",tProperty,"enabled") = 0
							}

							Set tProperty = $O($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"fact","prop",tProperty))
						}
					}
				}
				// - DTB908
				
				// + DTB961 - Log the storage location for each fact as assigned to the .Fact class.
				Kill $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"storage")
				Merge $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"storage") = tStorage
				// - DTB961
			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"No Cube definition in cube definition class: " _ %class.Name)
				Quit
			}
		}
		Else {
			Do %code.WriteLine(" Set tCube1 = """"")
		}

		Do %code.WriteLine(" Quit tCube1")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	#; remove lock
	If $G(tLocked) {
		Lock -^DeepSee.Build(tCubeNameU)
	}
	
	// DTB949 - If there was an error, communicate it to the projection for recording in the metadata
	Set:$$$ISERR(tSC) ^||%Cls(%compiledclass.Name,"error") = tSC

	Quit tSC
]]></Implementation>
</Method>

<Method name="%UpdateSharesIndex">
<Description>
Update the "sharesIndex" for the given cube.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		#; add facts to sharesIndex
		#; this takes the form: META("sharesFrom","CUBE1",FACT,"CUBE2") = ""

		Set tCubeNameU = $$$UPPER(pCubeName)
		Merge tSharedInfo = $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"sharesFrom")

		Set tShareCube = $O(tSharedInfo(""))
		While (tShareCube'="") {
			Set tShareDim = $O(tSharedInfo(tShareCube,""))
			While (tShareDim'="") {
				// loop over facts for the dimension in *this* cube
				Set tDimNo = +$LG($G($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbrs",tShareDim)),1)
				Set tOtherDimNo = +$LG($G($$$DeepSeeMetaGLVN("cubes",tShareCube,"mbrs",tShareDim)),1)

				If (tDimNo>0) {
					Set h = $O($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbr#",tDimNo,""))
					While (h'="") {
						Set l = $O($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbr#",tDimNo,h,""))
						While (l'="") {
							Set tLevelInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbr#",tDimNo,h,l))
							Set tFactNo = $LG(tLevelInfo,5)
							If (+tFactNo) {
								// get fact info for *other* cube
								Set tOtherLevelInfo = $G($$$DeepSeeMetaGLVN("cubes",tShareCube,"mbr#",tOtherDimNo,h,l))
								Set tOtherFactNo = $LG(tOtherLevelInfo,5)

								// set both index entries
								// JMD920: prevent subscript error
								If (tOtherFactNo'="") {
									Set $$$DeepSeeMetaGLVN("sharesIndex",tCubeNameU,tFactNo,tShareCube) = tOtherFactNo
									Set $$$DeepSeeMetaGLVN("sharesIndex",tShareCube,tOtherFactNo,tCubeNameU) = tFactNo
								}
							}
							Set l = $O($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbr#",tDimNo,h,l))
						}
						Set h = $O($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"mbr#",tDimNo,h))
					}
				}

				Set tShareDim = $O(tSharedInfo(tShareCube,tShareDim))
			}
			Set tShareCube = $O(tSharedInfo(tShareCube))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetSourceInfo">
<Description>
Return information on the source data for this cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pInfo</FormalSpec>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition")) {
			Quit
		}
		Do %code.WriteLine(" Kill pInfo")
		Set tSourceClass = $G(^||%Cls(%compiledclass.Name,"sourceClass"))
		Set tSourceType = $G(^||%Cls(%compiledclass.Name,"sourceType"))
		Set tMaxFacts = $G(^||%Cls(%compiledclass.Name,"maxFacts"))
		Set tInitialBuildOrder = $G(^||%Cls(%compiledclass.Name,"initialBuildOrder"))
		Set tBuildRestriction = $G(^||%Cls(%compiledclass.Name,"buildRestriction"))

		If (tSourceClass '= "") {
			Do %code.WriteLine(" Set pInfo(""sourceType"") = " _ $$$quote(tSourceType))
			Do %code.WriteLine(" Set pInfo(""sourceClass"") = " _ $$$quote(tSourceClass))
			Do %code.WriteLine(" Set pInfo(""maxFacts"") = " _ $$$quote(tMaxFacts))

			If (tSourceType = "persistent") {
				Do:tInitialBuildOrder'="" %code.WriteLine(" Set pInfo(""initialBuildOrder"") = " _ $$$quote(tInitialBuildOrder))
				Do:tBuildRestriction'="" %code.WriteLine(" Set pInfo(""buildRestriction"") = " _ $$$quote(tBuildRestriction))

				// JMD1177: find out if DSTIME and DSINTERVAL are defined
				$$$comMemberKeyGetLvar(tDSTIME,tSourceClass,$$$cCLASSparameter,"DSTIME",$$$cPARAMdefault)
				$$$comMemberKeyGetLvar(tDSINTERVAL,tSourceClass,$$$cCLASSparameter,"DSINTERVAL",$$$cPARAMdefault)

				Do %code.WriteLine(" Set pInfo(""dstime"") = " _ $$$quote(tDSTIME))
				Do %code.WriteLine(" Set pInfo(""dsinterval"") = " _ $$$quote(tDSINTERVAL))

				// find out if source class is final
				Set tFinal = $$$comClassKeyGet(tSourceClass,$$$cCLASSfinal)
				Do:+tFinal %code.WriteLine(" Set pInfo(""sourceFinal"") = 1")

				// if not final, build a list of sourceClass subclasses,
				// these are used by %SynchronizeCube
				If ('tFinal) {
					// Find all subclasses of the source class
					Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
					Set tSC = tRS.Execute(tSourceClass)
					If $$$ISERR(tSC) Quit
					While (tRS.Next(.tSC)) {
						If $$$ISERR(tSC) Quit
						Set tName = $G(tRS.Data("Name"))
						Do %code.WriteLine(" Set pInfo(""sourceSubClass"","_$$$quote(tName)_") = """"")
					}
					If $$$ISERR(tSC) Quit
				}

				// determine if the source class is bitmap friendly
				Set tIDKEY = $G($$$EXTidkey($$$pEXT,tSourceClass))
				Do %code.WriteLine(" Set pInfo(""idkey"") = " _ $$$quote(tIDKEY))
				If (tIDKEY'="") {
					Set tIndex = ##class(%Dictionary.CompiledIndex).IDKEYOpen(tSourceClass,tIDKEY)
					If $IsObject(tIndex) {
						Do %code.WriteLine(" Set pInfo(""posint"") = " _ tIndex.PosInt)
					}
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Do %code.WriteLine(" Quit $$$OK")
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCountName">
<Description>
Return the logical name for the %COUNT measure used by this cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition")) {
			Do %code.WriteLine(" Quit ""%COUNT""")
			Quit
		}

		Set tName = $G(^||%Cls(%compiledclass.Name,"countName"))
		If (tName="") {
			Do %code.WriteLine(" Quit ""%COUNT""")
			Quit
		}
		Do %code.WriteLine(" Quit "_$$$quote(tName))
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCountCaption">
<Description>
Return the (localized) caption for the %COUNT measure used by this cube.
Returns "" if this has not been overridden by the cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tName = $G(^||%Cls(%compiledclass.Name,"countCaption"))
		If (tName="") {
			Do %code.WriteLine(" Quit """"")
			Quit
		}
		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		If (tLocalize) {
			Do %code.WriteLine(" Quit $$$Text("_$$$quote(tName)_","_$$$quote(DOMAIN)_")")
		}
		Else {
			Do %code.WriteLine(" Quit "_$$$quote(tName))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetListingCaption">
<Description>
Return the (localized) caption for a given listing within this cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pListing:%String</FormalSpec>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))

		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition") || (tCubeName="")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Do %code.WriteLine(" Set pListing = $$$UPPER(pListing)")

		Set n = 0
		Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",""))
		While (k'="") {
			Set n = n + 1
			Set tName = $$$UPPER(k)
			Set tCaption = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",k,"displayName"))
			Set:tCaption="" tCaption = k
			Set tIf = $S(n>1:"ElseIf",1:"If")
			Do %code.WriteLine(" "_tIf_" ("_$$$quote(tName)_"=pListing) {")
			If (tLocalize) {
				Do %code.WriteLine("  Quit $$$Text("_$$$quote(tCaption)_","_$$$quote(DOMAIN)_")")
			}
			Else {
				Do %code.WriteLine("  Quit "_$$$quote(tCaption))
			}
			Do %code.WriteLine(" }")
			Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",k))
		}
		Do %code.WriteLine(" Quit """"")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetListingDescription">
<Description>
Return the (localized) description for a given listing within this cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pListing:%String</FormalSpec>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// method added by JSL4477
	Set tSC = $$$OK
	Try {
		Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))

		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition") || (tCubeName="")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Do %code.WriteLine(" Set pListing = $$$UPPER(pListing)")

		Set n = 0
		Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",""))
		While (k'="") {
			Set n = n + 1
			Set tName = $$$UPPER(k)
			Set tDescription = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",k,"description")) // JSL4477
			;Set:tDescription="" tDescription = k
			Set tIf = $S(n>1:"ElseIf",1:"If")
			Do %code.WriteLine(" "_tIf_" ("_$$$quote(tName)_"=pListing) {")
			If (tLocalize) {
				Do %code.WriteLine("  Quit $$$Text("_$$$quote(tDescription)_","_$$$quote(DOMAIN)_")")
			}
			Else {
				Do %code.WriteLine("  Quit "_$$$quote(tDescription))
			}
			Do %code.WriteLine(" }")
			Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",k))
		}
		Do %code.WriteLine(" Quit """"")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetListingFieldCaption">
<Description>
Return the (localized) caption for a given listing field within this cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pField:%String</FormalSpec>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))

		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition") || (tCubeName="")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Do %code.WriteLine(" Set pField = $$$UPPER(pField)")

		Set n = 0
		Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",""))
		While (k'="") {
			Set n = n + 1
			Set tName = $$$UPPER(k)
			Set tCaption = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",k,"displayName"))
			Set:tCaption="" tCaption = k
			Set tIf = $S(n>1:"ElseIf",1:"If")
			Do %code.WriteLine(" "_tIf_" ("_$$$quote(tName)_"=pField) {")
			If (tLocalize) {
				Do %code.WriteLine("  Quit $$$Text("_$$$quote(tCaption)_","_$$$quote(DOMAIN)_")")
			}
			Else {
				Do %code.WriteLine("  Quit "_$$$quote(tCaption))
			}
			Do %code.WriteLine(" }")
			Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",k))
		}
		Do %code.WriteLine(" Quit """"")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetListingFieldDescription">
<Description>
Return the (localized) description for a given listing field within this cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pField:%String</FormalSpec>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))

		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition") || (tCubeName="")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Do %code.WriteLine(" Set pField = $$$UPPER(pField)")

		Set n = 0
		Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",""))
		While (k'="") {
			Set n = n + 1
			Set tName = $$$UPPER(k)
			Set tDescription = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",k,"description")) // JSL4477
			;Set:tDescription="" tDescription = k
			Set tIf = $S(n>1:"ElseIf",1:"If")
			Do %code.WriteLine(" "_tIf_" ("_$$$quote(tName)_"=pField) {")
			If (tLocalize) {
				Do %code.WriteLine("  Quit $$$Text("_$$$quote(tDescription)_","_$$$quote(DOMAIN)_")")
			}
			Else {
				Do %code.WriteLine("  Quit "_$$$quote(tDescription))
			}
			Do %code.WriteLine(" }")
			Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",k))
		}
		Do %code.WriteLine(" Quit """"")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetLevelMemberCaption">
<Description>
For a pre-defined member within a given level in this cube, return its (localized) caption (display name).</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pDimNo:%Integer,pHierNo:%Integer,pLevelNo:%Integer,pName:%String</FormalSpec>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// JMD1010
		Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))

		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition") || (tCubeName="")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Do %code.WriteLine(" Set pName = $$$UPPER(pName)")

		Set tCaseCount = 0
		Set dno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",""))
		While (dno'="") {
			Set hno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,""))
			While (hno'="") {
				Set lno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,""))
				While (lno'="") {
					If $D($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno,"mbr")) {
						Set tCaseCount = tCaseCount + 1
						Do %code.WriteLine(" "_$S(tCaseCount>1:"Else",1:"")_"If ((pDimNo="_dno_")&&(pHierNo="_hno_")&&(pLevelNo="_lno_")) {")

						Set mc = 0
						Set m = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno,"mbr",""))
						While (m'="") {
							Set mc = mc + 1
							Set tName = $LG($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno,"mbr",m)),1)
							Set tCaption = $LG($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno,"mbr",m)),3)
							Do %code.Write("  "_$S(mc>1:"Else",1:"")_"If (pName="_$$$quote($$$UPPER(tName))_") {")
							If (tLocalize && (tCaption'="")) {
								Do %code.Write(" Quit $$$Text("_$$$quote(tCaption)_","_$$$quote(DOMAIN)_")")
							}
							Else {
								Set:tCaption="" tCaption = tName
								Do %code.Write(" Quit "_$$$quote(tCaption))
							}
							Do %code.WriteLine("  }")
							Set m = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno,"mbr",m))
						}

						Do %code.WriteLine(" }")
					}
					Set lno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno))
				}
				Set hno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno))
			}
			Set dno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno))
		}
		Do %code.WriteLine(" Quit """"")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetMemberCaption">
<Description>
For a given dimension, hierarchy, and level return its localized caption.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pDimName:%String,pHierName:%String="",pLevelName:%String="",pPropName:%String=""</FormalSpec>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Do %code.WriteLine(" Set tCaption = """"")
		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition")) {
			Quit
		}

		Do %code.WriteLine(" Set pDimName = $$$UPPER(pDimName)")
		Do %code.WriteLine(" Set pHierName = $$$UPPER(pHierName)")
		Do %code.WriteLine(" Set pLevelName = $$$UPPER(pLevelName)")
		Do %code.WriteLine(" Set pPropName = $$$UPPER(pPropName)")

		// first check captions global
		// (if %dsCaptionContext is defined)
		Set tCubeName = $$$UPPER($G(^||%Cls(%compiledclass.Name,"cubeName")))
		Do %code.WriteLine(" If ($G(%dsCaptionContext)'="""") {")
		Do %code.WriteLine("  If (pDimName'="""") {")
		Do %code.WriteLine("   If (pHierName="""") {")
		Do %code.WriteLine("    Set tCaption = $G(^DeepSee.Captions(%dsCaptionContext,"_$$$quote(tCubeName)_",pDimName))")
		Do %code.WriteLine("   }")
		Do %code.WriteLine("   Else {")
		Do %code.WriteLine("    If (pLevelName="""") {")
		Do %code.WriteLine("     Set tCaption = $G(^DeepSee.Captions(%dsCaptionContext,"_$$$quote(tCubeName)_",pDimName,pHierName))")
		Do %code.WriteLine("    }")
		Do %code.WriteLine("    Else {")
		Do %code.WriteLine("     If (pPropName="""") {")
		Do %code.WriteLine("      Set tCaption = $G(^DeepSee.Captions(%dsCaptionContext,"_$$$quote(tCubeName)_",pDimName,pHierName,pLevelName))")
		Do %code.WriteLine("     }")
		Do %code.WriteLine("     Else {")
		Do %code.WriteLine("      Set tCaption = $G(^DeepSee.Captions(%dsCaptionContext,"_$$$quote(tCubeName)_",pDimName,pHierName,pLevelName,pPropName))")
		Do %code.WriteLine("     }")
		Do %code.WriteLine("    }")
		Do %code.WriteLine("   }")
		Do %code.WriteLine("  }")
		Do %code.WriteLine(" If (tCaption'="""") Quit tCaption")
		Do %code.WriteLine(" }")

		// test for count measure
		Do %code.WriteLine(" If (pDimName = ""MEASURES"") {")
		Do %code.WriteLine("  Set tCountName = ..%GetCountName()")
		Do %code.WriteLine("  If (pHierName = $$$UPPER(tCountName)) {")
		Do %code.WriteLine("   Set tCountCaption = ..%GetCountCaption()")
		Do %code.WriteLine("   Quit $S(tCountCaption="""":$S(tCountName=""%COUNT"":""Count"",1:tCountName),1:tCountCaption)")
		Do %code.WriteLine("  }")
		Do %code.WriteLine(" }")

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Merge tCaptions = ^||%Cls(%compiledclass.Name,"captions")
		// tCaptions(d,h,l...) = $LB(name, displayName)

		Set tDimTest = "If"
		Set tDimName = $O(tCaptions(""))
		While (tDimName '= "") {
			Do %code.WriteLine(" "_tDimTest_" (pDimName="_$$$quote($$$UPPER(tDimName))_") {")
			Set tDimTest = "ElseIf"

			Do %code.Write("  If ((pHierName="""")&&(pLevelName="""")) {")

			If ($LG($G(tCaptions(tDimName)),2)'="") {
				If (tLocalize) {
					Do %code.WriteLine(" Quit $$$Text("_$$$quote($LG(tCaptions(tDimName),2))_","_$$$quote(DOMAIN)_") }")
				}
				Else {
					Do %code.WriteLine(" Quit "_$$$quote($LG(tCaptions(tDimName),2))_" }")
				}
			}
			Else {
				Do %code.WriteLine(" Quit "_$$$quote($LG($G(tCaptions(tDimName)),1))_" }")
			}
			
			Set tHierName = $O(tCaptions(tDimName,""))
			While (tHierName '= "") {
				Do %code.WriteLine("  ElseIf (pHierName="_$$$quote($$$UPPER(tHierName))_") {")

				Do %code.Write("   If (pLevelName="""") {")

				If ($LG($G(tCaptions(tDimName,tHierName)),2)'="") {
					If (tLocalize) {
						Do %code.WriteLine(" Quit $$$Text("_$$$quote($LG(tCaptions(tDimName,tHierName),2))_","_$$$quote(DOMAIN)_")"_" }")
					}
					Else {
						Do %code.WriteLine(" Quit "_$$$quote($LG(tCaptions(tDimName,tHierName),2))_" }")
					}
				}
				Else {
					Do %code.WriteLine(" Quit "_$$$quote($LG($G(tCaptions(tDimName,tHierName)),1))_" }")
				}

				Set tLevelName = $O(tCaptions(tDimName,tHierName,""))
				While (tLevelName '= "") {
					Set tPropName = $O(tCaptions(tDimName,tHierName,tLevelName,""))
					Set tHasProps = (tPropName '= "")

					Do %code.WriteLine("   ElseIf (pLevelName="_$$$quote($$$UPPER(tLevelName))_") {")
					Do:tHasProps %code.WriteLine("    If (pPropName="""") {")
					If ($LG($G(tCaptions(tDimName,tHierName,tLevelName)),2)'="") {
						If (tLocalize) {
							Do %code.WriteLine("     Quit $$$Text("_$$$quote($LG(tCaptions(tDimName,tHierName,tLevelName),2))_","_$$$quote(DOMAIN)_")")
						}
						Else {
							Do %code.WriteLine("     Quit "_$$$quote($LG(tCaptions(tDimName,tHierName,tLevelName),2)))
						}
					}
					Else {
						// JMD817
						If (tLocalize) {
							Do %code.WriteLine("     Quit $$$Text("_$$$quote($LG($G(tCaptions(tDimName,tHierName,tLevelName)),1))_","_$$$quote(DOMAIN)_")")
						}
						Else {
							Do %code.WriteLine("     Quit "_$$$quote($LG($G(tCaptions(tDimName,tHierName,tLevelName)),1)))
						}
					}
					Do %code.WriteLine("    }")

					While (tPropName '= "") {
						Do %code.WriteLine("    ElseIf (pPropName="_$$$quote($$$UPPER(tPropName))_") {")
						If ($LG($G(tCaptions(tDimName,tHierName,tLevelName,tPropName)),2)'="") {
							If (tLocalize) {
								Do %code.WriteLine("     Quit $$$Text("_$$$quote($LG(tCaptions(tDimName,tHierName,tLevelName,tPropName),2))_","_$$$quote(DOMAIN)_")")
							}
							Else {
								Do %code.WriteLine("     Quit "_$$$quote($LG(tCaptions(tDimName,tHierName,tLevelName,tPropName),2)))
							}
						}
						Else {
							Do %code.WriteLine("     Quit "_$$$quote($LG($G(tCaptions(tDimName,tHierName,tLevelName,tPropName)),1)))
						}
						Do %code.WriteLine("    }")
						Set tPropName = $O(tCaptions(tDimName,tHierName,tLevelName,tPropName))
					}
					Do:tHasProps %code.WriteLine("   }")

					Set tLevelName = $O(tCaptions(tDimName,tHierName,tLevelName))
				}
				Do %code.WriteLine("  }")
				Set tHierName = $O(tCaptions(tDimName,tHierName))
			}
			Do %code.WriteLine(" }")
			Set tDimName = $O(tCaptions(tDimName))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Do %code.WriteLine(" Quit tCaption")
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetMemberDescription">
<Description>
For a given dimension, hierarchy, and level return its localized description.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pDimName:%String,pHierName:%String="",pLevelName:%String="",pPropName:%String=""</FormalSpec>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	/// This code added as part of JSL4475
	Set tSC = $$$OK
	Try {
		Do %code.WriteLine(" Set tDescription = """"")
		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition")) {
			Quit
		}

		Do %code.WriteLine(" Set pDimName = $$$UPPER(pDimName)")
		Do %code.WriteLine(" Set pHierName = $$$UPPER(pHierName)")
		Do %code.WriteLine(" Set pLevelName = $$$UPPER(pLevelName)")
		Do %code.WriteLine(" Set pPropName = $$$UPPER(pPropName)")

		Set tCubeName = $$$UPPER($G(^||%Cls(%compiledclass.Name,"cubeName")))

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Merge tDescriptions = ^||%Cls(%compiledclass.Name,"descriptions")
		// tDescriptions(d,h,l...) = $LB(name, displayName)

		Set tDimTest = "If"
		Set tDimName = $O(tDescriptions(""))
		While (tDimName '= "") {
			Do %code.WriteLine(" "_tDimTest_" (pDimName="_$$$quote($$$UPPER(tDimName))_") {")
			Set tDimTest = "ElseIf"

			Do %code.Write("  If ((pHierName="""")&&(pLevelName="""")) {")

			If ($LG($G(tDescriptions(tDimName)),1)'="") {
				If (tLocalize) {
					Do %code.WriteLine(" Quit $$$Text("_$$$quote($LG(tDescriptions(tDimName),1))_","_$$$quote(DOMAIN)_") }")
				}
				Else {
					Do %code.WriteLine(" Quit "_$$$quote($LG(tDescriptions(tDimName),1))_" }")
				}
			}
			Else {
				Do %code.WriteLine(" Quit "_$$$quote($LG($G(tDescriptions(tDimName)),1))_" }")
			}
			
			Set tHierName = $O(tDescriptions(tDimName,""))
			While (tHierName '= "") {
				Do %code.WriteLine("  ElseIf (pHierName="_$$$quote($$$UPPER(tHierName))_") {")

				Do %code.Write("   If (pLevelName="""") {")

				If ($LG($G(tDescriptions(tDimName,tHierName)),1)'="") {
					If (tLocalize) {
						Do %code.WriteLine(" Quit $$$Text("_$$$quote($LG(tDescriptions(tDimName,tHierName),1))_","_$$$quote(DOMAIN)_")"_" }")
					}
					Else {
						Do %code.WriteLine(" Quit "_$$$quote($LG(tDescriptions(tDimName,tHierName),1))_" }")
					}
				}
				Else {
					Do %code.WriteLine(" Quit "_$$$quote($LG($G(tDescriptions(tDimName,tHierName)),1))_" }")
				}

				Set tLevelName = $O(tDescriptions(tDimName,tHierName,""))
				While (tLevelName '= "") {
					Set tPropName = $O(tDescriptions(tDimName,tHierName,tLevelName,""))
					Set tHasProps = (tPropName '= "")

					Do %code.WriteLine("   ElseIf (pLevelName="_$$$quote($$$UPPER(tLevelName))_") {")
					Do:tHasProps %code.WriteLine("    If (pPropName="""") {")
					If ($LG($G(tDescriptions(tDimName,tHierName,tLevelName)),1)'="") {
						If (tLocalize) {
							Do %code.WriteLine("     Quit $$$Text("_$$$quote($LG(tDescriptions(tDimName,tHierName,tLevelName),1))_","_$$$quote(DOMAIN)_")")
						}
						Else {
							Do %code.WriteLine("     Quit "_$$$quote($LG(tDescriptions(tDimName,tHierName,tLevelName),1)))
						}
					}
					Else {
						// JMD817
						If (tLocalize) {
							Do %code.WriteLine("     Quit $$$Text("_$$$quote($LG($G(tDescriptions(tDimName,tHierName,tLevelName)),1))_","_$$$quote(DOMAIN)_")")
						}
						Else {
							Do %code.WriteLine("     Quit "_$$$quote($LG($G(tDescriptions(tDimName,tHierName,tLevelName)),1)))
						}
					}
					Do %code.WriteLine("    }")

					While (tPropName '= "") {
						Do %code.WriteLine("    ElseIf (pPropName="_$$$quote($$$UPPER(tPropName))_") {")
						If ($LG($G(tDescriptions(tDimName,tHierName,tLevelName,tPropName)),1)'="") {
							If (tLocalize) {
								Do %code.WriteLine("     Quit $$$Text("_$$$quote($LG(tDescriptions(tDimName,tHierName,tLevelName,tPropName),1))_","_$$$quote(DOMAIN)_")")
							}
							Else {
								Do %code.WriteLine("     Quit "_$$$quote($LG(tDescriptions(tDimName,tHierName,tLevelName,tPropName),1)))
							}
						}
						Else {
							Do %code.WriteLine("     Quit "_$$$quote($LG($G(tDescriptions(tDimName,tHierName,tLevelName,tPropName)),1)))
						}
						Do %code.WriteLine("    }")
						Set tPropName = $O(tDescriptions(tDimName,tHierName,tLevelName,tPropName))
					}
					Do:tHasProps %code.WriteLine("   }")

					Set tLevelName = $O(tDescriptions(tDimName,tHierName,tLevelName))
				}
				Do %code.WriteLine("  }")
				Set tHierName = $O(tDescriptions(tDimName,tHierName))
			}
			Do %code.WriteLine(" }")
			Set tDimName = $O(tDescriptions(tDimName))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Do %code.WriteLine(" Quit tDescription")
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCellCachePreLoads">
<Description><![CDATA[
Return the list of cell-cache values that should be pre-loaded.
On return <var>pList</var> will contain an array of the form:<br/>
pList(n,spec) = factNo<br/>]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pList</FormalSpec>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition")) {
			Quit
		}

		#; find XDATA block named CellCache
		Set tIndex = %compiledclass.XDatas.FindObjectId(%class.Name_"||CellCache")
		Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))

		If ((tCubeName'="")&&(tIndex '= "")) {
			#; get XDATA as stream
			Set tStream = %compiledclass.XDatas.GetAt(tIndex).Data
			Do tStream.Rewind()

			If (tStream.Size > 0) {
				#; render the stream into cube meta-data object (with children)
				Set tReader = ##class(%XML.Reader).%New()

				Set tSC = tReader.OpenStream(tStream)
				If $$$ISERR(tSC) Quit

				Do tReader.Correlate("cellCache","%DeepSee.Model.cellCache")

				#; there should only be one cellCache defined
				Do tReader.Next(.tCache,.tSC)
				If $$$ISERR(tSC) Quit
				If '$IsObject(tCache) {
					Set tSC = $$$ERROR($$$GeneralError,"No <cellCache> element defined in CellCache block.")
					Quit
				}

				#; is cache disabled?
				If (tCache.disabled) {
					Write !,$$$FormatText($$$Text("CellCache is disabled","%DeepSee"))
					Quit
				}

				#; walk down cache spec and generate code
				Set tCount = 0
				For g = 1:1:tCache.cellGroups.Count() {
					Set tGroup = tCache.cellGroups.GetAt(g)
					If ('tGroup.disabled) {
						Set tGroupName = $S(tGroup.name="":"group"_g,1:tGroup.name)
						Set tCount = tCount + 1
						For i = 1:1:tGroup.items.Count() {
							Set tItem = tGroup.items.GetAt(i)
							If ('tItem.disabled) {
								Set tFactList = ""
								// user may have defined facts or specifications: deal with both
								For e = 1:1:tItem.elements.Count() {
									Set tSpec = tItem.elements.GetAt(e)
									Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(tCubeName,tSpec,.tDNO,.tHNO,.tLNO)
									If $$$ISERR(tSC) {
										Set tSC = $$$ERROR($$$GeneralError,"Invalid cell specification within cell cache definition: " _ tSpec)
										Quit
									}
									
									If (tDNO<0) {
										// DTB211 - A dimension number of <1 is returned for calcMbrs, qualMsrs, and namedSets. There is no 
										// processing of MDX in the computation of the cell cache, so these cannot be generally resolved.
										Set tSC = $$$ERROR($$$GeneralError,"Unsupported cell specification within cell cache definition: " _ tSpec)
										Quit
									}

									Set tNode = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",tDNO,tHNO,tLNO))
									Set tFactNo = $LG(tNode,5)

									If ($E(tFactNo,1,1)="M") {
										Set tFactName = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"msr#",tFactNo))
									}
									Else {
										Set tFactName = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"fact#",tFactNo))
									}
									Set tFactList = tFactList _ $S(tFactList="":"",1:",") _ tFactName
								}
								For f = 1:1:tItem.facts.Count() {
									Set tFactName = tItem.facts.GetAt(f)
									If ('$D($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"fact","prop",tFactName))) {
										Set tSC = $$$ERROR($$$GeneralError,"Invalid fact name within cube definition: " _ tFactName)
										Quit
									}
									Set tFactList = tFactList _ $S(tFactList="":"",1:",") _ tFactName
								}
								Do %code.WriteLine(" Set pList("_$$$quote($$$UPPER(tGroupName))_","_+i_") = "_$$$quote(tFactList))
							}
						}
					}
					If $$$ISERR(tSC) Quit
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Do %code.WriteLine(" Quit $$$OK")
	Quit tSC
]]></Implementation>
</Method>

<Method name="%BuildFactTable">
<Description><![CDATA[
Build the entire fact table with data from the source table.<br/>
If <var>pVerbose</var> is true, then status information is written to the console.<br/>
Users should not call this method; they should used the %BuildCube method
in the <class>%DeepSee.Utils</class> class.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pVerbose:%Boolean=0,pFactList:%String=""</FormalSpec>
<GenerateAfter>%GetModel,%OnProcessFact</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (%class.Abstract) {
		Do %code.WriteLine(" Quit $$$OK")
		Quit $$$OK
	}

	// JMD1137
	Do %code.WriteLine(" Set tSC = ..%OnBuildCube(pFactList)")		// DTB891 - Pass the fact list into the user callback
	Do %code.WriteLine(" If $$$ISERR(tSC) Quit tSC")

	// Dispatch to Fact table
	Set tFactName = %class.Name_".Fact"
	Do %code.WriteLine(" Set tSC = ##class("_tFactName_").%BuildAllFacts(pVerbose,pFactList)")		// DTB891 - Pass the fact list
	Do %code.WriteLine(" If $$$ISERR(tSC) Quit tSC")

	// Invalidate the cube's result cache.
	Do %code.WriteLine(" Set tSC = ..%KillCache()")
	Do %code.WriteLine(" Quit tSC")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%UpdateFacts">
<Description><![CDATA[
Update Fact indices with data from the source table.<br/>
Read all rows from the source table between <var>pStartId</var> and 
<var>pEndId</var>.<br/>
If <var>pEndId</var> is missing (""), then update one fact with source id <var>pStartId</var><br/>.
If <var>pVerbose</var> is true, then write status information to the console.<br/>
<var>pTaskGroup</var> is used when this method is called by the DeepSee TaskMaster.<br/>
If <var>pBatchMode</var> is true, then perform the update in batch mode.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[pStartId:%String,pEndId:%String="",pBatchMode:%Boolean=0,pVerbose:%Boolean=0,pTaskGroup:%String="",*pUpdates:%Integer,pRefProp:%String="",pRefID:%String="",&pDimTables]]></FormalSpec>
<GenerateAfter>%GetModel,%OnProcessFact</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (%class.Abstract) {
		Do %code.WriteLine(" Quit $$$OK")
		Quit $$$OK
	}

	Do %code.WriteLine(" Set tSC = $$$OK")

	// Dispatch to Fact table
	Set tFactName = %class.Name_".Fact"
	Do %code.WriteLine(" Set tSC = ##class("_tFactName_").%UpdateFacts(pStartId,pEndId,pBatchMode,.tChunks, pVerbose,pTaskGroup,.pUpdates,pRefProp,pRefID,.pDimTables)")
	Do %code.WriteLine(" If $$$ISERR(tSC) Quit tSC")

	// Invalidate the needed portions of this cube's result cache.
	Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))
	If (tCubeName '= "") {
		Set tCubeName = $$$UPPER(tCubeName)

		// invalidate buckets
		Do %code.WriteLine(" Set tSC = ##class(%DeepSee.Query.Engine).%InvalidateBuckets("_$$$quote(tCubeName)_","_$$$quote(tFactName)_",.tChunks)")
		Do %code.WriteLine(" If $$$ISERR(tSC) Quit tSC")

		// update cube timestamp
		Set tResultsGLVN = $Name($$$DeepSeeResultsGLVN(tCubeName))
		Do %code.WriteLine(" #; update cube timestamp")
		Do %code.WriteLine(" Set tTimeStamp = $I("_tResultsGLVN_")")
	}
	Do %code.WriteLine(" Quit tSC")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%UpdateFactsList">
<Description><![CDATA[
Update Fact indices with data from selected columns in the source table.<br/>
The fact list is limited using the <var>pFactList</var> parameter, which can be either a comma-delimited list or a $LB.
Read all rows from the source table between <var>pStartId</var> and 
<var>pEndId</var>.<br/>
If <var>pEndId</var> is missing (""), then update one fact with source id <var>pStartId</var><br/>.
If <var>pVerbose</var> is true, then write status information to the console.<br/>
<var>pTaskGroup</var> is used when this method is called by the DeepSee TaskMaster.<br/>
If <var>pBatchMode</var> is true, then perform the update in batch mode.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[pFactList:%String="",pStartId:%String,pEndId:%String="",pBatchMode:%Boolean=0,pVerbose:%Boolean=0,pTaskGroup:%String="",*pUpdates:%Integer,pRefProp:%String="",pRefID:%String="",&pDimTables]]></FormalSpec>
<GenerateAfter>%GetModel,%OnProcessFact</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB886
	Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))
	Set tCubeName = $$$UPPER(tCubeName)
	
	If (%class.Abstract) {
		Do %code.WriteLine(" Quit $$$OK")
		Quit $$$OK
	}
	If $D($$$DeepSeeMetaGLVN("cubes",tCubeName))&&'$G($$$DeepSeeMetaGLVN("cubes",tCubeName,"namedFactNums")) {
		// DTB886 - Consult the namedFactNums setting for this cube and quit with an error if it is not enabled
		Do %code.WriteLine(" Quit $$$ERROR($$$GeneralError,""%UpdateFactsList cannot be called without enabling namedFactNums for this cube."")")
		Quit $$$OK
	}

	Do %code.WriteLine(" Set tSC = $$$OK")
	Do %code.WriteLine(" Try {")
	// DTB886 - Pre-process the incoming pFatList to normalize as a $lb for the internal methods 
	Do %code.WriteLine("  Set tFactList = $S($ListValid(pFactList):pFactList,1:$ListFromString(pFactList,"",""))")
	// Dispatch to Fact table
	Set tFactName = %class.Name_".Fact"
	Do %code.WriteLine("  Set tSC = ##class("_tFactName_").%UpdateFacts(pStartId,pEndId,pBatchMode,.tChunks, pVerbose,pTaskGroup,.pUpdates,pRefProp,pRefID,.pDimTables,tFactList)")
	Do %code.WriteLine("  If $$$ISERR(tSC) Quit")

	// Invalidate the needed portions of this cube's result cache.
	If (tCubeName '= "") {
		// invalidate buckets
		Do %code.WriteLine("  Set tSC = ##class(%DeepSee.Query.Engine).%InvalidateBuckets("_$$$quote(tCubeName)_","_$$$quote(tFactName)_",.tChunks)")
		Do %code.WriteLine("  If $$$ISERR(tSC) Quit")

		// update cube timestamp
		Set tResultsGLVN = $Name($$$DeepSeeResultsGLVN(tCubeName))
		Do %code.WriteLine("  #; update cube timestamp")
		Do %code.WriteLine("  Set tTimeStamp = $I("_tResultsGLVN_")")
	}
	Do %code.WriteLine(" }")
	Do %code.WriteLine(" Catch ex {")
	Do %code.WriteLine("   Set tSC = ex.AsStatus()")
	Do %code.WriteLine(" }")
	Do %code.WriteLine(" Quit tSC")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%DeleteFact">
<Description><![CDATA[
Delete facts from this cube that correspond to rows in the source table with source id <var>pSourceId</var><br/>.
If <var>pVerbose</var> is true, then write status information to the console.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pSourceId:%String</FormalSpec>
<GenerateAfter>%GetModel,%OnProcessFact</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (%class.Abstract) {
		Do %code.WriteLine(" Quit $$$OK")
		Quit $$$OK
	}

	// Dispatch to Fact table
	Set tFactName = %class.Name_".Fact"

	Do %code.WriteLine(" Set tSC = ##class("_tFactName_").%DeleteFact(pSourceId,.tFactId)")
	Do %code.WriteLine(" If $$$ISERR(tSC) Quit tSC")
	Do %code.WriteLine(" Set:(tFactId'="""") tChunks(tFactId\64000+1)=""""")

	// Invalidate the needed portions of this cube's result cache.
	Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))
	If (tCubeName '= "") {
		Set tCubeName = $$$UPPER(tCubeName)

		// invalidate buckets
		Do %code.WriteLine(" Set tSC = ##class(%DeepSee.Query.Engine).%InvalidateBuckets("_$$$quote(tCubeName)_","_$$$quote(tFactName)_",.tChunks)")
		Do %code.WriteLine(" If $$$ISERR(tSC) Quit tSC")

		// update cube timestamp
		Set tResultsGLVN = $Name($$$DeepSeeResultsGLVN(tCubeName))
		Do %code.WriteLine(" #; update cube timestamp")
		Do %code.WriteLine(" Set tTimeStamp = $I("_tResultsGLVN_")")
	}
	Do %code.WriteLine(" Quit tSC")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%CheckSourceId">
<Description><![CDATA[
Check to make sure a given ID exists in the source table.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pSourceId:%String,pVerbose:%Boolean=0,pStatus:%Status</FormalSpec>
<GenerateAfter>%GetModel,%OnProcessFact</GenerateAfter>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB422
	If (%class.Abstract) {
		Do %code.WriteLine(" Quit $$$OK")
		Quit $$$OK
	}

	// Dispatch to Fact table
	Set tFactName = %class.Name_".Fact"

	Do %code.WriteLine(" Quit ##class("_tFactName_").%CheckSourceId(pSourceId,pVerbose,.pStatus)")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetSourceIds">
<Description><![CDATA[
Find the starting and ending id values for this cube's source data class.<br/>
This is used when populating an entire cube.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pStartId:%String,*pEndId:%String</FormalSpec>
<GenerateAfter>%GetModel,%OnGetSourceIds</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine(" Set (pStartId,pEndId)=""""")
	If (%class.Abstract) {
		Do %code.WriteLine(" Quit $$$OK")
		Quit $$$OK
	}
	// invoke %OnGetSourceIds if present
	If ($$$comMemberKeyGet(%compiledclass.Name,$$$cCLASSmethod,"%OnGetSourceIds",$$$cMETHrunnable)) {
		Do %code.WriteLine("   Quit ..%OnGetSourceIds(.pStartId,.pEndId)")
		Quit $$$OK
	}

	Set tSourceType = $G(^||%Cls(%compiledclass.Name,"sourceType"))
	Set tSourceClass = $G(^||%Cls(%compiledclass.Name,"sourceClass"))
	If (tSourceClass '= "") {
		If ((tSourceType = "kpi")||(tSourceType = "worksheet")||(tSourceType = "metric")) {
			// skip
		}
		ElseIf (tSourceType = "persistent") {
			Set tTable = ##class(%DeepSee.Generator).%GetSQLTableName(tSourceClass)
			Do %code.WriteLine(" Set tSC = $$$OK")

			// find first, last id of source table
			Do %code.WriteLine(" &sql(SELECT MIN(%ID),MAX(%ID) INTO :pStartId,:pEndId FROM "_tTable_")")
			
			// +DTB495 - If the first and last IDs are null, double check to make sure there are truly no source records
			Do %code.WriteLine(" If (pStartId="""")&&(pEndId="""") {")
			Do %code.WriteLine("  &sql(SELECT TOP 1 %ID FROM "_tTable_" WHERE %NOINDEX %ID IS NOT NULL)")		// DTB672
			Do %code.WriteLine("  If (+$G(%ROWCOUNT)>0) {		// DTB495 - Double check that there are in fact zero source records.")
			Do %code.WriteLine("   Quit $$$ERROR($$$GeneralError,""Failure to determine first and last IDs in source table '"_tTable_"'. Check indices on the source."")")
			Do %code.WriteLine("  }")
			Do %code.WriteLine(" }")
			// -DTB495
		}
		Else {
			// dispatch to data source class
			Do %code.WriteLine(" Set tSC = ##class("_tSourceClass_").%OnGetSourceIds(.pStartId,.pEndId)")
		}
	}
	Else {
		Do %code.WriteLine(" Set tSC = $$$ERROR($$$GeneralError,""Cube is not enabled or does not have a valid source class"")")
	}
	Do %code.WriteLine(" Quit tSC")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnGetSourceIds">
<Description><![CDATA[
If implemented, this method is called when a cube is being completely rebuilt *and*
the rebuild is not using parallel processing.<br/>
On return <var>pStartId</var> and <var>pEndId</var> must contain the first and last row id values
for this cube's source data table, such that a query of the form:<br/>
SELECT ... FROM SOURCE WHERE %ID BETWEEN pStartId AND pEndId<br/>
will return all the rows of the source table.<br/>
This gives the developer the opportunity to bypass the built-in query that fetchs these values.<br/>]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pStartId:%String,*pEndId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="%KillCache">
<Description>
Delete all cached values for this cube.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%KillCellCache()
	If $$$ISERR(tSC) Quit tSC
	Set tSC = ..%KillResultsCache()
	If $$$ISERR(tSC) Quit tSC

	Set tCube = $$$UPPER(..%GetCubeName())
	Kill $$$DeepSeeJoinGLVN(tCube)
	Kill $$$DeepSeeBucketsGLVN(tCube)
	Quit tSC
]]></Implementation>
</Method>

<Method name="%KillCellCache">
<Description>
Delete the cell cache for this cube.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	Kill $$$DeepSeeCellsGLVN($$$UPPER(..%GetCubeName()))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%KillResultsCache">
<Description>
Delete the results cache for this cube.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tCube = $$$UPPER(..%GetCubeName())
	// WAL295 -- Preserve cache timestamp
	Set tResultsCacheTimestamp = $G($$$DeepSeeResultsGLVN(tCube))
	Kill $$$DeepSeeAxisGLVN(tCube)
	Kill $$$DeepSeeResultsGLVN(tCube)
	Kill $$$DeepSeeListingGLVN(tCube)
	Kill $$$DeepSeeJoinGLVN(tCube)
	Set:(tResultsCacheTimestamp'="") $$$DeepSeeResultsGLVN(tCube) = tResultsCacheTimestamp // WAL295
	// JMD900: kill KPI cache based on this cube
	Set tSC = ##class(%DeepSee.Utils).%KillKPICacheForCube(tCube) 
	Quit tSC
]]></Implementation>
</Method>

<Method name="%KillFacts">
<Description>
Delete all Facts as well as cached results from the cube.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (%class.Abstract) {
		Do %code.WriteLine(" Quit $$$OK")
		Quit $$$OK
	}

	Do %code.WriteLine(" Set tSC = $$$OK")
	Do %code.WriteLine(" Try {")

	// star tables
	Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))
	If (tCubeName '= "") {
		Set tStar = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"star",""))
		While (tStar '= "") {
			// don't kill shared dimensions
			Set tShared = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"star",tStar,"sharedCube"))
			If (tShared="") {
				Do %code.WriteLine(" Do ##class("_tStar_").%KillExtent()")
			}
			Set tStar = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"star",tStar))
		}
		
		// computed dimensions
		set tDim = 0
		for {
			set tDim = $order($$$DeepSeeMetaGLVN("cubes", $$$UPPER(tCubeName), "mbr#", tDim))
			quit:tDim=""
			set tHier = 0
			for {
				set tHier = $order($$$DeepSeeMetaGLVN("cubes", $$$UPPER(tCubeName), "mbr#", tDim, tHier))
				quit:tHier=""
				set tLevel = 0
				for {
					set tLevel = $order($$$DeepSeeMetaGLVN("cubes", $$$UPPER(tCubeName), "mbr#", tDim, tHier, tLevel), 1, tInfo)
					quit:tLevel=""
					set tDimClass = $lg(tInfo,6)
					if $$IsDerivedFrom^%occLibrary(tDimClass, "%DeepSee.ComputedDimension.Base") {
						do %code.WriteLine(" do ##class("_tDimClass_").%OnKillFacts("_$$$QUOTE(tCubeName)_", "_$lg(tInfo,5)_", "_tDim_", "_tHier_", "_tLevel_")")
					}
				}
			}
		}
	}

	// kill cache
	Do %code.WriteLine(" Set tSC = ..%KillCache()")
	Do %code.WriteLine(" If $$$ISERR(tSC) Quit")

	// kill facts
	Do %code.WriteLine(" Set tSC = ##class("_%class.Name_".Fact).%KillExtent()")
	Do %code.WriteLine(" If $$$ISERR(tSC) Quit")

	// kill source index and reverse source index
	Do %code.WriteLine(" Kill $$$DeepSeeIndexGLVN("_$$$quote($$$UPPER(tCubeName))_",""%sourceId"")")
	Do %code.WriteLine(" Kill $$$DeepSeeIndexGLVN("_$$$quote($$$UPPER(tCubeName))_",""%sourceIdReverse"")")

	// kill any streams stored for this cube
	Set tClassName = %class.Name_".Fact"
	Set tStreamGLVN = $Name($$$DeepSeeFactGLVN)_"S"
	Do %code.WriteLine(" Kill "_tStreamGLVN_"("_$$$quote($$$UPPER(tClassName))_")")
	
	// DTB163 - Clean up the previous relation index
	Do %code.WriteLine(" Kill $$$DeepSeeRelationGLVN("_$$$quote($$$UPPER(tCubeName))_")")

	// notify fact table
	Do %code.WriteLine(" Set tSC = ##class("_%class.Name_".Fact).%OnKillFacts()")
	Do %code.WriteLine(" If $$$ISERR(tSC) Quit")

	// invoke callback
	Do %code.WriteLine(" Set tSC = ..%OnKillFacts()")
	Do %code.WriteLine(" If $$$ISERR(tSC) Quit")
	Do %code.WriteLine(" }")
	Do %code.WriteLine("  Catch(ex) {")
	Do %code.WriteLine("  Set tSC = ex.AsStatus()")
	Do %code.WriteLine(" }")
	Do %code.WriteLine(" Quit tSC")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnKillFacts">
<Description><![CDATA[
Notification that all facts have been deleted.<br/>
If implemented, this is called when the <method>%KillFacts</method> is called.]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnBuildCube">
<Description><![CDATA[
Notification that this cube is about to be built.<br/>
If the build is invoked using a selected <var>pFactList</var>, this list will be passed to the callback in a $LB format.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFactList:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterBuildCube">
<Description><![CDATA[
Notification that this cube has completed its build.<br/>
The status of the overall build is contained in <var>pBuildStatus</var>. If the build is otherwise successful, 
the value of <var>pBuildStatus</var> can be changed within the callback to become the new status returned by %BuildCube.
If there were any build errors in the individual facts the count of these errors is reported in 
<var>pBuildErrors</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBuildStatus:%Status,pBuildErrors:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnProcessFact">
<Description><![CDATA[
Notification that a fact within the cube is to be processed (inserted
or updated).<br/>
<var>pID</var> is the id of the row in the source data being processed.<br/>
<var>pFacts</var> is an array containing the values that will be used for the
row, subscripted by fact name.<br/>
<var>pSkip</var> is a boolean value returned by reference; If true then the record
is not processed.<br/>
<var>pInsert</var> is true if the current fact will be inserted into the cube's fact table.]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pID:%String,&pFacts:%String,*pSkip:%Boolean,pInsert:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterProcessFact">
<Description><![CDATA[
Notification that a fact within the cube has been processed (inserted
or updated). This method does not allow for any intervention of the processing of the fact,
but rather provides an opportunity to react to success or failure in processing. The return status is ignored by the caller.<br/>
<var>pID</var> is the id of the row in the source data being processed.<br/>
<var>pFacts</var> is an array containing the values that will be used for the
row, subscripted by fact name.<br/>
<var>pUpdateStatus</var> is the status about to be returned by %ProcessFact. If an error is passed in, this error will
already be logged in the DeepSee logs and the ^DeepSee.BuildErrors global.]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pID:%String,&pFactArray:%String,pUpdateStatus:%Status]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB290
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetFactCount">
<Description>
Return number of facts in this cube's fact table.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Quit $zobjclassmethod(..%GetFactClass(),"%Count")
]]></Implementation>
</Method>

<Method name="%GetFactClass">
<Description>
Return name of the fact class used by this cube.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..%ClassName(1)_".Fact"
]]></Implementation>
</Method>

<Method name="%GetFactIdRange">
<Description>
Return the approximate starting and ending id values for this cubes fact table.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pStartId:%Integer,*pEndId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pStartId = ""
		Set pEndId = ""
		Set tFactClass = ..%GetFactClass()
		If ($D($$$DeepSeeFactGLVN($$$UPPER(tFactClass)))) {
			Set pStartId = $O($$$DeepSeeFactGLVN($$$UPPER(tFactClass),""))
			Set pEndId = $$$DeepSeeFactGLVN($$$UPPER(tFactClass))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCubeName">
<Description>
Return the logical name of the cube defined by this class (in its original case).</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine(" Quit "_$$$quote($G(^||%Cls(%compiledclass.Name,"cubeName"))))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%IsAbstract">
<Description>
Test whether this cube is abstract or not.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine(" Quit "_+$G(^||%Cls(%compiledclass.Name,"abstract")))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%IsCompound">
<Description>
Test whether this cube is compound or not.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pJoinList:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set pJoinList = ""
	Quit 0
]]></Implementation>
</Method>

<Method name="%GetCubeCaption">
<Description>
Return the caption of the cube defined by this class.
If not defined, the cube name is returned.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tCaption = $G(^||%Cls(%compiledclass.Name,"cubeCaption"))
	If (tCaption = "") {
		Set tCaption = $G(^||%Cls(%compiledclass.Name,"cubeName"))
	}

	Set tLocalize = 0
	Set DOMAIN = $G(%parameter("DOMAIN"))
	If (%class.System > 0) {
		Set tLocalize = (DOMAIN '= "")
	}
	Else {
		Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
	}
	If (tLocalize) {
		Do %code.WriteLine(" Quit $$$Text("_$$$quote(tCaption)_","_$$$quote(DOMAIN)_")")
	}
	Else {
		Do %code.WriteLine(" Quit "_$$$quote(tCaption))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetPrecomputeLevel">
<Description>
Return the precompute level of the cube defined by this class.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tPrecompute = +$G(^||%Cls(%compiledclass.Name,"precompute"))
	Do %code.WriteLine(" Quit "_tPrecompute)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%CanDrillThrough">
<Description>
Test if this cube supports drill through (listing) queries.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// see if any listings are available to the current user
	Set tSC = ##class(%DeepSee.Utils).%GetCubeListings(..%GetCubeName(),.tListings)
	Quit $S($D(tListings):1,1:0)
]]></Implementation>
</Method>

<Method name="%GetRelationshipId">
<Description><![CDATA[
Take cube relationship  with name <var>pRelationName</var>
and transform the original key value <var>pKey</var> into
the id of the corresponding fact in the fact table and return it
via <var>pID</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pRelationName:%String,pKey:%String,*pID:%Integer</FormalSpec>
<GenerateAfter>%GetModel</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine(" Set (pStartId,pEndId)=""""")
	If (%class.Abstract) {
		Do %code.WriteLine(" Quit $$$OK")
		Quit $$$OK
	}

	Do %code.WriteLine(" Set tSC = $$$OK")
	Do %code.WriteLine(" Set pID = """"")

	Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))
	Set tCubeNameU = $$$UPPER(tCubeName)

	If (tCubeName = "") {
		Quit $$$OK
	}

	// walk down set of relations
	Set tCount = 0
	Set f = $O($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"relations",""))
	While (f'="") {
		Set tStoredSide = +$G($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"relations",f,"storedSide"))
		Set tRelName = $G($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"relations",f,"name"))
		If ('tStoredSide) {
			If (tCount = 0) {
				Do %code.Write(" If")
			}
			Else {
				Do %code.Write(" ElseIf")
			}
			Set tCount = tCount + 1
			Do %code.WriteLine(" ($$$UPPER(pRelationName)=" _ $$$quote($$$UPPER(tRelName)) _ ") {")

			Do %code.WriteLine(" }")
		}
		Set f = $O($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"relations",f))
	}

	Do %code.WriteLine(" Quit tSC")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnExecuteListing">
<Description><![CDATA[
Notification that a listing (drillthrough) query is about to be executed.<br/>
This is called immediately before a listing query is executed.
This is useful for cases where additional setup work is required before
a listing query can run.<br/>
<var>pSQL</var> is the listing query that will be executed.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetFilterSpec">
<Description>
Return the filter spec for this cube, if any.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If '$D(%dsUserName) {
		// DTB687 - If this does not exist, make sure it is set
		New %dsUserName
		Set %dsUserName = $UserName
	}
	
	Set tFilter = ..%OnGetFilterSpec("")
	Quit tFilter
]]></Implementation>
</Method>

<Method name="%OnGetFilterSpec">
<Description>
This callback gives a Cube a chance to programmatically define a filter spec.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFilterSpec:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit pFilterSpec
]]></Implementation>
</Method>

<Method name="%GetDefaultListing">
<Description>
Return the name of the default listing for this cube, if any.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..%OnGetDefaultListing()
]]></Implementation>
</Method>

<Method name="%OnGetDefaultListing">
<Description>
This callback gives a cube a chance to programmatically return the name 
of the listing to use as its default listing.
This must be the name of a defined listing within the cube.
Return "" to use the pre-defined default listing.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<Method name="%GetActionList">
<Description><![CDATA[
Return list of possible actions for this Cube.
This list is supplied from the KPI class specified by the cube's actionClass property, if defined.
This drives the list of action selections for widget connected to this cube.
This takes the form:<br/>
pActions(n)=$LB(name,caption)<br/>]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pActions:%List]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCubeName = $$$UPPER(..%GetCubeName())
		Set tActionClass = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"actionClass"))
		If (tActionClass'="") {
			Set tSC = $zobjclassmethod(tActionClass,"%GetActionList",.pActions)
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%InjectFact">
<Description><![CDATA[
Inject a fact into the fact table for this cube that is not associated with the source data table.<br/>
<var>pFactId</var> is the id of the fact in the fact table. Set this to "" for an insert. On return
it will contain the id used for the fact.<br/>
<var>pValues</var> is an array of fact values subscripted by sourceProperty name (case must match <b>exactly</b>.
If <var>pDimensionsOnly</var> is true, then only the dimension tables for the cube are affected;
no facts are inserted.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&pFactId:%String,&pValues:%String,pDimensionsOnly:%Boolean=0,pFactList:%String=""]]></FormalSpec>
<GenerateAfter>%GetModel,%OnProcessFact</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// JMD1137 add pDimensionsOnly
	// DTB886 - Add pFactList
	If (%class.Abstract) {
		Do %code.WriteLine(" Quit $$$OK")
		Quit $$$OK
	}

	Do %code.WriteLine(" Set tSC = $$$OK")
	
	// DTB893
	Do %code.WriteLine(" Set tFactList = $S($ListValid(pFactList):pFactList,1:$ListFromString(pFactList,"",""))")

	// Dispatch to Fact table
	Set tFactName = %class.Name_".Fact"
	Do %code.WriteLine(" Set tSC = ##class("_tFactName_").%InjectFact(.pFactId,.pValues,.tChunks,pDimensionsOnly,tFactList)")		// DTB893 - Use tFactList
	Do %code.WriteLine(" If $$$ISERR(tSC) Quit tSC")

	Do %code.WriteLine(" If ('pDimensionsOnly) {")

	// Invalidate the needed portions of this cube's result cache.
	Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))
	If (tCubeName '= "") {
		Set tCubeName = $$$UPPER(tCubeName)

		// invalidate buckets
		Do %code.WriteLine("  Set tSC = ##class(%DeepSee.Query.Engine).%InvalidateBuckets("_$$$quote(tCubeName)_","_$$$quote(tFactName)_",.tChunks)")
		Do %code.WriteLine("  If $$$ISERR(tSC) Quit tSC")

		// update cube timestamp
		Set tResultsGLVN = $Name($$$DeepSeeResultsGLVN(tCubeName))
		Do %code.WriteLine("  #; update cube timestamp")
		Do %code.WriteLine("  Set tTimeStamp = $I("_tResultsGLVN_")")
	}
	Do %code.WriteLine(" }")
	Do %code.WriteLine(" Quit tSC")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnGetModel">
<Description>
Callback used for XSL transforms.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pXSL:%String,tSource:%Stream.TmpCharacter,*tOutput:%BinaryStream</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Get a stream of XSL from the XSL block contained in this class
		Set tXSL=##class(%Dictionary.CompiledXData).%OpenId(pXSL).Data
		If '$IsObject(tXSL) Set tSC=%objlasterror Quit

		// Transform the source according to the XSL
		Set tSC=##class(%XML.XSLT.Transformer).TransformStream(tSource,tXSL,.tOutput)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OnApplyOverrides">
<Description>
If implemented, this is called before the cube model is processed.
It gives the class a change to modify the ^DeepSee.Overrides global.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%Lookup">
<Description><![CDATA[
Lookup a single value with the given key and DeepSee term list name.
This can be invoked by source expressions within this cube.<br/>
<var>pTermList</var> is the name (with no extension) of the termlist.<br/>
<var>pKey</var> is the key to lookup within the termlist.<br/>
<var>pDefault</var> is an optional default value to return if the key is not found within the termlist.<br/>
<var>pField</var> is an optional field to lookup within the termlist. By default, this is the "value" field.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTermList:%String="",pKey:%String="",pDefault:%String,pField:%String="VALUE"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// Return original value if key is not in table
	If '$D(pDefault) {
		Set pDefault = pKey
	}
	Quit ##class(%DeepSee.TermList).%Lookup(pTermList,pKey,pField,pDefault)
]]></Implementation>
</Method>

<Method name="%Rule">
<Description><![CDATA[
Invoke a Business Rule on the current record within the source class.
<var>pID</var> should contain the object id of the record within the source class.
This can be invoked by source expressions within this cube.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRuleName:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tValue = ""
	Set tSC = $$$OK
	Try {
		Do ..%GetSourceInfo(.tInfo)
		Set tSourceClass = $G(tInfo("sourceClass"))
		If $$$ISERR(tSC) Quit

		// open instance of source class
		// use sourceId in context
		// share open object
		If (('$IsObject($G(%dsSourceObj)))||(%dsSourceObj.%Id()'=$G(%dsSourceId))) {
			Set %dsSourceObj = $classmethod(tSourceClass,"%OpenId",$G(%dsSourceId))
		}
		If $IsObject(%dsSourceObj) {
			// invoke rule
			Set tSessionId = 1
			Set tSC = ##class(Ens.Rule.Definition).EvaluateRules(pRuleName,tSessionId,%dsSourceObj,"DeepSee",.tValue, .tReason)
			If $$$ISERR(tSC) Quit
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		// JMD920
		Set tText = $System.Status.GetErrorText(tSC)
		Do ##class(%DeepSee.Utils).%WriteToLog("Rule","Error in %Rule " _ tText)

		// return error code
		Set tValue = $System.Status.GetErrorText(tSC)
	}

	Quit tValue
]]></Implementation>
</Method>

<Method name="%OnGetComputedMembers">
<Description><![CDATA[
This callback gives a Cube a chance to programmatically provide a set of
members for a computed dimension.<br/>
Find the set of members for this computed dimension object satisfying
<var>pRollupKey</var> and <var>pRange</var> (if applicable for this implementation).<br/>
This is passed and returns:<br/>
pMemberList($I(pMemberList)) = $LB(id (expression for MDX computed dimension),caption,key,[format])<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDimName:%String,pHierName:%String,pLevelName:%String,&pMemberList,pRollupKey:%String="",&pRange:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.CubeProjection">
<Description><![CDATA[
Projection class used by the <class>%DeepSee.CubeDefinition</class> class.
This class takes care of any work that needs to happen when
a cube definition is created (compiled) or deleted.
This class should be considered INTERNAL.]]></Description>
<IncludeCode>%DeepSee</IncludeCode>
<Super>%Projection.AbstractProjection</Super>
<System>3</System>
<TimeCreated>60165,76060.833051</TimeCreated>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClassName:%String,&parameters:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	Set tSC=$$$OK
	Try {
		If ($$$comClassDefined(pClassName)) {
			Set tAbstract = +$$$comClassKeyGet(pClassName,$$$cCLASSabstract)
			If ('tAbstract && (pClassName'="%DeepSee.CubeDefinition")) {

				Set tCubeName = $zobjclassmethod(pClassName,"%GetCubeName")
				If (tCubeName="")&&$D(^||%Cls(pClassName,"oldCubeName"),tOldCubeName) {
					// DTB949 - Try to preserve the old cube name if the %GetCubeName method didn't compile
					// or could not return a value for any reason
 					Set tCubeName = tOldCubeName
				}
				Set tCubeNameU = $$$UPPER(tCubeName)

				#; Add this cube to the (local) index of Cubes
				If (tCubeNameU '= "") {
					If $D(^||%Cls(pClassName,"error"),tCompileError) {
						// DTB949 - Log a compile error in the metadata
						Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"compileError") = tCompileError
					}
					
					Set tRegClass = $G($$$DeepSeeMetaGLVN("cubes",tCubeNameU))
					If (tRegClass = "") {
						Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU) = pClassName
						Set $$$DeepSeeMetaGLVN("classes",pClassName) = tCubeName
					}
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClassName:%String,&parameters:%String,recompile:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	Set tSC=$$$OK
	Try {
		If ($$$comClassDefined(pClassName)) {
			Set tAbstract = +$$$comClassKeyGet(pClassName,$$$cCLASSabstract)
			If ('tAbstract && (pClassName'="%DeepSee.CubeDefinition")) {

				#; Remove this cube from the list of Cubes
				Set tCubeName = $G($$$DeepSeeMetaGLVN("classes",pClassName))
				Set tCubeNameU = $$$UPPER(tCubeName)

				#; make sure we are the right cube
				If ((tCubeNameU'="")&&(pClassName = $G($$$DeepSeeMetaGLVN("cubes",tCubeNameU)))) {
					#; remember current cube name and sync time (for recompile)
					If (recompile) {
						Set ^||%Cls(pClassName,"cube") = tCubeName
						Set tLastTimeStamp = ##class(%DeepSee.Utils).%GetCubeDSTime(tCubeNameU)		// DTB838 - Use API
						If (tLastTimeStamp'="") {
							Set ^||%Cls(pClassName,"dstime") = tLastTimeStamp
						}
						
						// DTB961 - Try to preserve the previous storage definition
						Merge ^||%Cls(pClassName,"storage") = $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"storage")

						// remember current meta data
						// DTB949 - Log the prior if there is no previous error, so the prior only ever represents
						// the last *successful* compile.
						If '$D($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"compileError")) {
							Kill $$$DeepSeeMetaGLVN("prior",tCubeNameU)
							Merge $$$DeepSeeMetaGLVN("prior",tCubeNameU) = $$$DeepSeeMetaGLVN("cubes",tCubeNameU)	
						}
						Else {
							// DTB961 - There was a compile error, try to fetch the storage from the prior
							Merge ^||%Cls(pClassName,"storage") = $$$DeepSeeMetaGLVN("prior",tCubeNameU,"storage")
						}
					}

					Kill $$$DeepSeeMetaGLVN("classes",pClassName)
					Kill:tCubeNameU'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU)

					#; kill cache
					If ('recompile) {
						Set tSC = ##class(%DeepSee.Query.Engine).%CubeRemoved(tCubeName,pClassName)
						Quit:$$$ISERR(tSC)
					}
					
					// BDB267: delete iKnow domains managed by this cube if not recompiling.
					// when recompiling, this will be taken care of by
					// %DeepSee.CubeDefinition.%GetModel()
					if ('recompile) {
						set tMsrPropName = ""
						for {
							set tMsrPropName = $order($$$DeepSeeMetaGLVN("prior", tCubeNameU, "fact", "prop", tMsrPropName))
							quit:tMsrPropName=""
						
							set tMeasure = $g($$$DeepSeeMetaGLVN("prior", tCubeNameU, "fact", "prop", tMsrPropName, "msrname"))
							set tIndexType = $g($$$DeepSeeMetaGLVN("prior", tCubeNameU, "fact", "prop", tMsrPropName, "index"))
							continue:$piece(tIndexType,":",1)'="iKnow"
						
							// skip iKnow-managed domains
							continue:$piece(tIndexType,":",2)="domain"
						
							// derive domain name
							set tDomainName = $piece(tIndexType,":",3)
							set:tDomainName="" tDomainName = ##class(%iKnow.DeepSee.CubeUtils).GetDeepSeeDomainName(tCubeNameU,tMeasure)
						
							set tSC = ##class(%iKnow.DeepSee.CubeUtils).DropDomain(tDomainName)
							quit:$$$ISERR(tSC)
						}
						quit:$$$ISERR(tSC)
					}
					
					// +DTB130 - Clean up the ^DeepSee.Cubes("versionIndex")
					If ##class(%DeepSee.CubeVersion.Utils).%IsVersion(tCubeNameU,.tGenericCubeName,.tVersion) {
						If ('recompile) {
							If (##class(%DeepSee.CubeVersion.Utils).%IsActiveVersion(tCubeNameU)) {
								Kill $$$DeepSeeMetaGLVN("versionIndex","versions",$$$UPPER(tGenericCubeName),"activeVersion")
							}
							If (##class(%DeepSee.CubeVersion.Utils).%IsPendingVersion(tCubeNameU)) {
								Kill $$$DeepSeeMetaGLVN("versionIndex","versions",$$$UPPER(tGenericCubeName),"pendingVersion")
							}
							
							Kill $$$DeepSeeMetaGLVN("versionIndex","versions",$$$UPPER(tGenericCubeName),tVersion)
							Kill $$$DeepSeeMetaGLVN("versionIndex","versionOf",tCubeNameU)
						}
					}
					// -DTB130
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.Dashboard.Pivot">
<Description><![CDATA[
This persistent class represents a saved DeepSee pivot table.<br/>]]></Description>
<Super>%DeepSee.UserLibrary.FolderItem</Super>
<System>4</System>
<TimeCreated>61333,44070.180139</TimeCreated>

<Parameter name="XMLNAME">
<Default>pivot</Default>
</Parameter>

<Parameter name="ITEMTYPE">
<Default>pivot</Default>
</Parameter>

<Parameter name="ICON">
<Default>deepsee/ds2_layers2_44.png</Default>
</Parameter>

<Parameter name="LARGEICON">
<Default>deepsee/ds2_layers2_44.png</Default>
</Parameter>

<Parameter name="PUBLIC">
<Description>
Default value of public property for the class.</Description>
<Default>0</Default>
</Parameter>

<Property name="mdx">
<Description><![CDATA[
If defined and <property>dataSource</property> is set to "manual", then 
this is the MDX statement used to provide the contents of the pivot table.]]></Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="MAXLEN" value="32000"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="cellWidth">
<Description>
This is the width (in pixels) used for all cells within the table.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>120</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="columnHeaderStyle">
<Description>
Optional style to apply to column headers.</Description>
<Type>%ZEN.Datatype.style</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="rowHeaderStyle">
<Description>
Optional style to apply to row headers.</Description>
<Type>%ZEN.Datatype.style</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="cellStyle">
<Description>
Optional style to apply to cells.</Description>
<Type>%ZEN.Datatype.style</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="rowLabelSpan">
<Description><![CDATA[
This specifies how parent row labels with multiple child labels are displayed.<br/>
If true, then one parent label is displayed for each set of children.
If false, then the parent row label is repeated for each child.]]></Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="columnLabelSpan">
<Description><![CDATA[
This specifies how parent column labels with multiple child labels are displayed.<br/>
If true, then one parent label is displayed for each set of children.
If false, then the parent row label is repeated for each child.]]></Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="cellHeight">
<Description>
This is the height (in pixels) used for all cells within the table.
The default is 22.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>22</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showEmptyRows">
<Description><![CDATA[
If true, display rows containing only empty values.<br/>
If <var>mdx</var> is specified, this is ignored.]]></Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showEmptyColumns">
<Description><![CDATA[
If true, display columns containing only empty values.<br/>
If <var>mdx</var> is specified, this is ignored.]]></Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="cubeName">
<Description>
Name of the cube that will provide data for this pivot table.</Description>
<Type>%ZEN.Datatype.className</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="caption">
<Description>
Caption to display. If not specified, the caption for the cube will be used.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="listing">
<Description>
Name of listing to use for detail listings. If not specified, the default listing for the cube will be used.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="listingRows">
<Description>
Maximum number of rows to show in a listing.
If not specified, the default value used.</Description>
<Type>%ZEN.Datatype.integer</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showStatus">
<Description>
If true, show status area along the bottom of the table.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="rowAxisOptions">
<Description>
This is used to define functions to apply to the entire row axis.</Description>
<Type>PivotLevel</Type>
</Property>

<Property name="columnAxisOptions">
<Description>
This is used to define functions to apply to the entire column axis.</Description>
<Type>PivotLevel</Type>
</Property>

<Property name="rowLevels">
<Description>
This contains the definition of the row dimensions for this pivot table.</Description>
<Type>PivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="rowLevel"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="columnLevels">
<Description>
This contains the definition of the column dimensions for this pivot table.</Description>
<Type>PivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="columnLevel"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="filters">
<Description>
This contains the definition of the filters for this pivot table.</Description>
<Type>PivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="filter"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="sqlRestriction">
<Description>
This contains an SQL restriction that should be applied to this pivot table.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLNAME" value="sqlRestriction"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="listingFilters">
<Description>
This contains the definition of the listing filters for this pivot table.</Description>
<Type>PivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="listingFilter"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="measures">
<Description>
This contains the default measure(s) (e.g., "[Measures].[Sales]") to show for this pivot table.</Description>
<Type>PivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="measure"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="canDrillDown">
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="drillLevels">
<Description>
This contains the drillLevels for this pivot table.</Description>
<Type>PivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="drillLevel"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="listingFields">
<Description>
This contains the definition of the listing fields for this pivot table.</Description>
<Type>PivotLevel</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="listingField"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="formatRules">
<Description>
This contains the formatting rule for this pivot table.</Description>
<Type>PivotCondition</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="formatRule"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="pageSize">
<Description>
Number of result rows to show at one time.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>100</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="colorScale">
<Description>
If set, this is the name of the color-scaling scheme to apply.
red-to-black,green-to-black,blue-to-black,salmon-to-black,purple-to-black,gray-to-black
or "custom:r1,g1,b1:r2,g2,b2".</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="rowTotals">
<Description>
If true, then display row totals.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="columnTotals">
<Description>
If true, then display column totals.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="rowTotalAgg">
<Description>
Aggregate for row totals.</Description>
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"sum"</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="columnTotalAgg">
<Description>
Aggregate for column totals.</Description>
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"sum"</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="rowTotalSource">
<Description>
Where row totals come from.</Description>
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"page"</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="calculatedMembers">
<Description>
This contains the (local) calculated memmers for this pivot table.</Description>
<Type>CalculatedMember</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="calculatedMember"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="showZebra">
<Description>
If true, then display zebra striping.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showRowCaption">
<Description>
If true, then display row captions.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printTitle">
<Description>
Title to display when pivot is printed.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printSubtitle">
<Description>
Subtitle to display when pivot is printed.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printSubtitleOn">
<Description>
Display subtitle when exporting to PDF</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showUser">
<Description>
Display the user when exporting to PDF</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printPageSize">
<Description>
Page size when pivot is printed. This takes the form "8.5x11 in" (w x h).</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printOrientation">
<Description>
Orientation when pivot is printed.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printMarginTop">
<Description>
Page top margin when pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printMarginLeft">
<Description>
Page left margin when pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printMarginRight">
<Description>
Page right margin when pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printMarginBottom">
<Description>
Page bottom margin when pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printLabelWidth">
<Description>
Width of row labels when the pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="printCellWidth">
<Description>
Width of data cells when the pivot is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="autoExecute">
<Description>
pivotTable autoExecute flag.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="previewMode">
<Description>
Save of previewMode setting. The Analyzer will transfer this value to the previewMode property,
widgets will not.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="manualMode">
<Description>
pivotTable manualMode (dataSource) flag.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="userMDX">
<Description>
pivotTable manualMode query.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="MAXLEN" value="5000"/>
</Property>

<Property name="chartMarginTop">
<Description>
Page top margin when chart is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="chartMarginLeft">
<Description>
Page left margin when chart is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="chartMarginRight">
<Description>
Page right margin when chart is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="chartMarginBottom">
<Description>
Page bottom margin when chart is printed. This is in the same units as the page size.</Description>
<Type>%ZEN.Datatype.float</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="maxRows">
<Description>
Max rows exported to PDF</Description>
<Type>%ZEN.Datatype.integer</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderLeftCell">
<Description>
Table borders</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderRightCell">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderTopCell">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderBottomCell">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderLeftCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderRightCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderTopCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderBottomCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderLeftRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderRightRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderTopRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="borderBottomRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="fontFamilyCell">
<Description>
Table styles</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="fontSizeCell">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="fontFamilyCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="fontSizeCol">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="fontFamilyRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="fontSizeRow">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showFilters">
<Description>
showFilters - byTable, byTitle, off</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showListingFilters">
<Description>
showListingFilters - on, off</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showDate">
<Description>
showDate - on, off</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="listingFontSize">
<Description>
Font size for listings</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="showZebraStripes">
<Description>
showZebraStripes - on, off</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="filterTableStyle">
<Description>
filterTableStyle</Description>
<Type>%ZEN.Datatype.style</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="filterTableCaptionStyle">
<Description>
filterTableCaptionStyle;</Description>
<Type>%ZEN.Datatype.style</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="filterTableItemStyle">
<Description>
filterTableItemStyle;</Description>
<Type>%ZEN.Datatype.style</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="nowDisplayFormat">
<Description>
nowDisplayFormat</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="measureLocation">
<Description>
measureLocation for pivot.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="hideMeasures">
<Description>
hide measure captions or not for pivot.</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="backgroundImage">
<Description>
Optional image to show in background of pivot table.</Description>
<Type>%ZEN.Datatype.uri</Type>
</Property>

<Property name="backgroundOpacity">
<Description>
Opacity (0 to 1) of pivot table background image.</Description>
<Type>%ZEN.Datatype.float</Type>
<InitialExpression>0.12</InitialExpression>
</Property>

<Method name="%CopyToComponent">
<Description><![CDATA[
Copy the contents of this pivot definition to pivot table <var>pPivot</var>.]]></Description>
<Internal>1</Internal>
<FormalSpec>pPivot:%DeepSee.Component.pivotTable</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pPivot.mdx = ..mdx
		Set pPivot.sqlRestriction = ..sqlRestriction		// DTB723
		If ($E(..mdx,1,12)="DRILLTHROUGH") {
			Set pPivot.isDrillThrough = 1
		}
		Set pPivot.cellStyle = ..cellStyle
		Set pPivot.columnHeaderStyle = ..columnHeaderStyle
		Set pPivot.rowHeaderStyle = ..rowHeaderStyle
		Set pPivot.cellWidth = ..cellWidth
		Set pPivot.cellHeight = ..cellHeight
		Set pPivot.rowLabelSpan = ..rowLabelSpan
		Set pPivot.columnLabelSpan = ..columnLabelSpan
		Set pPivot.showEmptyRows = ..showEmptyRows
		Set pPivot.showEmptyColumns = ..showEmptyColumns
		Set pPivot.cubeName = ..cubeName
		Set pPivot.caption = ..caption
		Set pPivot.listing = ..listing
		Set pPivot.defaultListing = ..listing		// DTB732 (2) - Remember the original listing as the default whenever the defintion is loaded into the component
		Set pPivot.listingRows = ..listingRows
		Set pPivot.showStatus = ..showStatus
		Set pPivot.pageSize = ..pageSize
		Set pPivot.colorScale = ..colorScale
		Set pPivot.rowTotals = ..rowTotals
		Set pPivot.showZebra = ..showZebra
		Set pPivot.showRowCaption = ..showRowCaption
		Set pPivot.columnTotals = ..columnTotals
		Set pPivot.columnTotalAgg = ..columnTotalAgg
		Set pPivot.rowTotalAgg = ..rowTotalAgg
		Set pPivot.rowTotalSource = ..rowTotalSource
		Set pPivot.measureLocation = $S(..measureLocation="":"columns",1:..measureLocation)
		// + WAL120 -- fix default so that pivots pre-dating WAL114 load with
		//             "If more than one measure"
		//Set pPivot.hideMeasures = $S(..hideMeasures="":0,1:..hideMeasures) // + WAL114
		Set pPivot.hideMeasures = $S(..hideMeasures="":1,1:..hideMeasures)
		// - WAL120

		Set pPivot.printPageSize = ..printPageSize
		Set pPivot.printOrientation = ..printOrientation
		Set pPivot.printTitle = ..printTitle
		Set pPivot.printSubtitle = ..printSubtitle
		Set pPivot.printSubtitleOn = ..printSubtitleOn // JSL4302
		Set pPivot.showUser = ..showUser // JSL4320
		Set pPivot.printMarginLeft = ..printMarginLeft
		Set pPivot.printMarginTop = ..printMarginTop
		Set pPivot.printMarginRight = ..printMarginRight
		Set pPivot.printMarginBottom = ..printMarginBottom
		Set pPivot.printLabelWidth = ..printLabelWidth
		Set pPivot.printCellWidth = ..printCellWidth
		// JSL4219
		Set pPivot.maxRows = ..maxRows
		// JSL4218
		Set pPivot.borderLeftCell = ..borderLeftCell
		Set pPivot.borderRightCell = ..borderRightCell
		Set pPivot.borderTopCell = ..borderTopCell		
		Set pPivot.borderBottomCell = ..borderBottomCell
		
		Set pPivot.backgroundImage = ..backgroundImage
		Set pPivot.backgroundOpacity = ..backgroundOpacity

		Set pPivot.borderLeftCol = ..borderLeftCol
		Set pPivot.borderRightCol = ..borderRightCol
		Set pPivot.borderTopCol = ..borderTopCol
		Set pPivot.borderBottomCol = ..borderBottomCol

		Set pPivot.borderLeftRow = ..borderLeftRow
		Set pPivot.borderRightRow = ..borderRightRow
		Set pPivot.borderTopRow = ..borderTopRow
		Set pPivot.borderBottomRow = ..borderBottomRow
		
		// + WAL100 -- table styles
		/// Table styles
		Set pPivot.fontFamilyCell = ..fontFamilyCell 
		Set pPivot.fontSizeCell  = ..fontSizeCell
		Set pPivot.fontFamilyCol = ..fontFamilyCol
		Set pPivot.fontSizeCol = ..fontSizeCol
		Set pPivot.fontFamilyRow = ..fontFamilyRow
		Set pPivot.fontSizeRow  = ..fontSizeRow
		// - WAL100

		// JSL4184
		Set pPivot.showFilters = ..showFilters
		Set pPivot.filterTableStyle = ..filterTableStyle
		Set pPivot.filterTableCaptionStyle = ..filterTableCaptionStyle
		Set pPivot.filterTableItemStyle = ..filterTableItemStyle

		// JSL4308
		Set pPivot.nowDisplayFormat = ..nowDisplayFormat
				
		// JSL4250
		Set pPivot.showListingFilters = ..showListingFilters
		Set pPivot.showDate = ..showDate
		// JSL4279
		Set pPivot.listingFontSize = ..listingFontSize
		
		// JSL4526
		Set pPivot.showZebraStripes = ..showZebraStripes
						
		// JMD1025
		Set pPivot.autoExecute = $S(..autoExecute="":1,1:..autoExecute)
		Set pPivot.previewMode = $S(..previewMode="":0,1:..previewMode)		// DTB701
		Set pPivot.canDrillDown = ..canDrillDown		// DTB958
		
		// JMD1031
		If (+..manualMode) {
			Set pPivot.dataSource = "manual"
		}
		Else {
			Set pPivot.dataSource = "automatic"
		}
		Set pPivot.userMDX = ..userMDX

		Set tSC = ..rowAxisOptions.%CopyToComponent(pPivot.rowAxisOptions)
		If $$$ISERR(tSC) Quit
		Set tSC = ..columnAxisOptions.%CopyToComponent(pPivot.columnAxisOptions)
		If $$$ISERR(tSC) Quit

		Do pPivot.rowLevels.Clear()
		For n=1:1:..rowLevels.Count() {
			Set tLevel = ##class(%DeepSee.Component.pivotLevel).%New()
			Set tSC = ..rowLevels.GetAt(n).%CopyToComponent(tLevel)
			If $$$ISERR(tSC) Quit
			Do pPivot.rowLevels.Insert(tLevel)
			Do:$IsObject($G(%page)) %page.%AddComponent(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do pPivot.columnLevels.Clear()
		For n=1:1:..columnLevels.Count() {
			Set tLevel = ##class(%DeepSee.Component.pivotLevel).%New()
			Set tSC = ..columnLevels.GetAt(n).%CopyToComponent(tLevel)
			If $$$ISERR(tSC) Quit
			Do pPivot.columnLevels.Insert(tLevel)
			Do:$IsObject($G(%page)) %page.%AddComponent(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do pPivot.filters.Clear()
		For n=1:1:..filters.Count() {
			Set tLevel = ##class(%DeepSee.Component.pivotLevel).%New()
			Set tSC = ..filters.GetAt(n).%CopyToComponent(tLevel)
			If $$$ISERR(tSC) Quit
			Do pPivot.filters.Insert(tLevel)
			Do:$IsObject($G(%page)) %page.%AddComponent(tLevel)
		}
		If $$$ISERR(tSC) Quit

		// JMD1360
		Do pPivot.listingFilters.Clear()
		For n=1:1:..listingFilters.Count() {
			Set tLevel = ##class(%DeepSee.Component.pivotLevel).%New()
			Set tSC = ..listingFilters.GetAt(n).%CopyToComponent(tLevel)
			If $$$ISERR(tSC) Quit
			Do pPivot.listingFilters.Insert(tLevel)
			Do:$IsObject($G(%page)) %page.%AddComponent(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do pPivot.drillLevels.Clear()
		For n=1:1:..drillLevels.Count() {
			Set tLevel = ##class(%DeepSee.Component.pivotLevel).%New()
			Set tSC = ..drillLevels.GetAt(n).%CopyToComponent(tLevel)
			If $$$ISERR(tSC) Quit
			Do pPivot.drillLevels.Insert(tLevel)
			Do:$IsObject($G(%page)) %page.%AddComponent(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do pPivot.measures.Clear()
		For n=1:1:..measures.Count() {
			Set tLevel = ##class(%DeepSee.Component.pivotLevel).%New()
			Set tSC = ..measures.GetAt(n).%CopyToComponent(tLevel)
			If $$$ISERR(tSC) Quit
			Do pPivot.measures.Insert(tLevel)
			Do:$IsObject($G(%page)) %page.%AddComponent(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do pPivot.listingFields.Clear()
		For n=1:1:..listingFields.Count() {
			Set tLevel = ##class(%DeepSee.Component.pivotLevel).%New()
			Set tSC = ..listingFields.GetAt(n).%CopyToComponent(tLevel)
			If $$$ISERR(tSC) Quit
			Do pPivot.listingFields.Insert(tLevel)
			Do:$IsObject($G(%page)) %page.%AddComponent(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do pPivot.formatRules.Clear()
		For n=1:1:..formatRules.Count() {
			Set tRule = ##class(%DeepSee.Component.pivotCondition).%New()
			Set tSC = ..formatRules.GetAt(n).%CopyToComponent(tRule)
			If $$$ISERR(tSC) Quit
			Do pPivot.formatRules.Insert(tRule)
			Do:$IsObject($G(%page)) %page.%AddComponent(tRule)
		}
		If $$$ISERR(tSC) Quit

		Do pPivot.calculatedMembers.Clear()
		For n=1:1:..calculatedMembers.Count() {
			Set tCalcMbr = ##class(%DeepSee.Component.calculatedMember).%New()
			Set tSC = ..calculatedMembers.GetAt(n).%CopyToComponent(tCalcMbr)
			If $$$ISERR(tSC) Quit
			Do pPivot.calculatedMembers.Insert(tCalcMbr)
			Do:$IsObject($G(%page)) %page.%AddComponent(tCalcMbr)
		}
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%CopyFromComponent">
<Description><![CDATA[
Set the contents of this pivot definition from pivot table <var>pPivot</var>.]]></Description>
<Internal>1</Internal>
<FormalSpec>pPivot:%DeepSee.Component.pivotTable</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// +DTB130 - do not persist the version number, store the cube's generic reference identifier
		Set tCubeName = pPivot.cubeName
		If ##class(%DeepSee.CubeVersion.Utils).%IsVersion(tCubeName) {
			Set tCubeName = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(tCubeName)
		}
		Set ..cubeName = tCubeName	
		// -DTB130
		
		Set ..mdx = pPivot.mdx
		Set ..sqlRestriction = pPivot.sqlRestriction		// DTB723
		Set ..cellStyle = pPivot.cellStyle
		Set ..columnHeaderStyle = pPivot.columnHeaderStyle
		Set ..rowHeaderStyle = pPivot.rowHeaderStyle
		Set ..cellWidth = pPivot.cellWidth
		Set ..cellHeight = pPivot.cellHeight
		Set ..rowLabelSpan = pPivot.rowLabelSpan
		Set ..columnLabelSpan = pPivot.columnLabelSpan
		Set ..showEmptyRows = pPivot.showEmptyRows
		Set ..showEmptyColumns = pPivot.showEmptyColumns
		Set ..caption = pPivot.caption
		Set ..listing = pPivot.listing // JMD1024
		Set ..listingRows = pPivot.listingRows
		Set ..showStatus = pPivot.showStatus
		Set ..pageSize = pPivot.pageSize
		Set ..colorScale = pPivot.colorScale
		Set ..rowTotals = pPivot.rowTotals
		Set ..showZebra = pPivot.showZebra
		Set ..showRowCaption = pPivot.showRowCaption
		Set ..columnTotals = pPivot.columnTotals
		Set ..columnTotalAgg = pPivot.columnTotalAgg
		Set ..rowTotalAgg = pPivot.rowTotalAgg
		Set ..rowTotalSource = pPivot.rowTotalSource
		Set ..measureLocation = pPivot.measureLocation
		Set ..hideMeasures = pPivot.hideMeasures // + WAL114

		Set ..printPageSize = pPivot.printPageSize
		Set ..printOrientation = pPivot.printOrientation
		Set ..printTitle = pPivot.printTitle
		Set ..printSubtitle = pPivot.printSubtitle
		Set ..printSubtitleOn = pPivot.printSubtitleOn
		Set ..showUser = pPivot.showUser // JSL4320
		Set ..printMarginLeft = pPivot.printMarginLeft
		Set ..printMarginTop = pPivot.printMarginTop
		Set ..printMarginRight = pPivot.printMarginRight
		Set ..printMarginBottom = pPivot.printMarginBottom
		Set ..printLabelWidth = pPivot.printLabelWidth
		Set ..printCellWidth = pPivot.printCellWidth
		// JSL4219
		Set ..maxRows = pPivot.maxRows
		// JSL4218
		Set ..borderLeftCell = pPivot.borderLeftCell
		Set ..borderRightCell = pPivot.borderRightCell
		Set ..borderTopCell = pPivot.borderTopCell		
		Set ..borderBottomCell = pPivot.borderBottomCell

		Set ..borderLeftCol = pPivot.borderLeftCol
		Set ..borderRightCol = pPivot.borderRightCol
		Set ..borderTopCol = pPivot.borderTopCol
		Set ..borderBottomCol = pPivot.borderBottomCol

		Set ..borderLeftRow = pPivot.borderLeftRow
		Set ..borderRightRow = pPivot.borderRightRow
		Set ..borderTopRow = pPivot.borderTopRow
		Set ..borderBottomRow = pPivot.borderBottomRow
		
		// + WAL100 -- table styles
		/// Table styles
		Set ..fontFamilyCell  = pPivot.fontFamilyCell
		Set ..fontSizeCell = pPivot.fontSizeCell
		Set ..fontFamilyCol = pPivot.fontFamilyCol 
		Set ..fontSizeCol = pPivot.fontSizeCol
		Set ..fontFamilyRow = pPivot.fontFamilyRow
		Set ..fontSizeRow = pPivot.fontSizeRow 
		// - WAL100
		
		Set ..backgroundImage = pPivot.backgroundImage
		Set ..backgroundOpacity = pPivot.backgroundOpacity

		// JSL4184
		Set ..showFilters = pPivot.showFilters
		Set ..filterTableStyle = pPivot.filterTableStyle
		Set ..filterTableCaptionStyle = pPivot.filterTableCaptionStyle
		Set ..filterTableItemStyle = pPivot.filterTableItemStyle

		// JSL4308
		Set ..nowDisplayFormat = pPivot.nowDisplayFormat
		
		// JSL4250
		Set ..showListingFilters = pPivot.showListingFilters
		Set ..showDate = pPivot.showDate
		// JSL4256
		Set ..showZebraStripes = pPivot.showZebraStripes
		// JSL4279
		Set ..listingFontSize = pPivot.listingFontSize
				
		// JMD1025
		Set ..autoExecute = $S(pPivot.autoExecute="":1,1:pPivot.autoExecute)
		Set ..previewMode = $S(pPivot.previewMode="":0,1:pPivot.previewMode)		// DTB701
		Set ..canDrillDown = pPivot.canDrillDown		// DTB958

		// JMD1031
		Set ..manualMode = $S(pPivot.dataSource="manual":1,1:0)
		Set ..userMDX = pPivot.userMDX

		Set tSC = ..rowAxisOptions.%CopyFromComponent(pPivot.rowAxisOptions)
		If $$$ISERR(tSC) Quit
		Set tSC = ..columnAxisOptions.%CopyFromComponent(pPivot.columnAxisOptions)
		If $$$ISERR(tSC) Quit

		Do ..rowLevels.Clear()
		For n=1:1:pPivot.rowLevels.Count() {
			Set tLevel = ##class(PivotLevel).%New()
			Set tSC = tLevel.%CopyFromComponent(pPivot.rowLevels.GetAt(n))
			If $$$ISERR(tSC) Quit
			Do ..rowLevels.Insert(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do ..columnLevels.Clear()
		For n=1:1:pPivot.columnLevels.Count() {
			Set tLevel = ##class(PivotLevel).%New()
			Set tSC = tLevel.%CopyFromComponent(pPivot.columnLevels.GetAt(n))
			If $$$ISERR(tSC) Quit
			Do ..columnLevels.Insert(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do ..filters.Clear()
		For n=1:1:pPivot.filters.Count() {
			If ('pPivot.filters.GetAt(n).transient) {
				Set tLevel = ##class(PivotLevel).%New()
				Set tSC = tLevel.%CopyFromComponent(pPivot.filters.GetAt(n))
				If $$$ISERR(tSC) Quit
				Do ..filters.Insert(tLevel)
			}
		}
		If $$$ISERR(tSC) Quit

		// JMD1360
		Do ..listingFilters.Clear()
		For n=1:1:pPivot.listingFilters.Count() {
			Set tLevel = ##class(PivotLevel).%New()
			Set tSC = tLevel.%CopyFromComponent(pPivot.listingFilters.GetAt(n))
			If $$$ISERR(tSC) Quit
			Do ..listingFilters.Insert(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do ..drillLevels.Clear()
		For n=1:1:pPivot.drillLevels.Count() {
			Set tLevel = ##class(PivotLevel).%New()
			Set tSC = tLevel.%CopyFromComponent(pPivot.drillLevels.GetAt(n))
			If $$$ISERR(tSC) Quit
			Do ..drillLevels.Insert(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do ..measures.Clear()
		For n=1:1:pPivot.measures.Count() {
			Set tLevel = ##class(PivotLevel).%New()
			Set tSC = tLevel.%CopyFromComponent(pPivot.measures.GetAt(n))
			If $$$ISERR(tSC) Quit
			Do ..measures.Insert(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do ..listingFields.Clear()
		For n=1:1:pPivot.listingFields.Count() {
			Set tLevel = ##class(PivotLevel).%New()
			Set tSC = tLevel.%CopyFromComponent(pPivot.listingFields.GetAt(n))
			If $$$ISERR(tSC) Quit
			Do ..listingFields.Insert(tLevel)
		}
		If $$$ISERR(tSC) Quit

		Do ..formatRules.Clear()
		For n=1:1:pPivot.formatRules.Count() {
			Set tRule = ##class(PivotCondition).%New()
			Set tSC = tRule.%CopyFromComponent(pPivot.formatRules.GetAt(n))
			If $$$ISERR(tSC) Quit
			Do ..formatRules.Insert(tRule)
		}
		If $$$ISERR(tSC) Quit

		Do ..calculatedMembers.Clear()
		For n=1:1:pPivot.calculatedMembers.Count() {
			Set tMember = ##class(CalculatedMember).%New()
			Set tSC = tMember.%CopyFromComponent(pPivot.calculatedMembers.GetAt(n))
			If $$$ISERR(tSC) Quit
			Do ..calculatedMembers.Insert(tMember)
		}
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetDependencies">
<Description>
Return a list of all other folder items (including cubes or kpis) that this item depends upon.</Description>
<FormalSpec>pList:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// !!! what about ..mdx
	If (..cubeName'="") {
		Set tName = ..cubeName_".cube"
		Set pList($$$UPPER(tName)) = tName
	}
	Quit ##super(.pList)
]]></Implementation>
</Method>

<Method name="%GetCubeName">
<Description>
Return the cube name that provides data for this pivot.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	/// !!!!
	Quit ..cubeName
]]></Implementation>
</Method>

<Method name="%GetURL">
<Description>
Return the URL for this item.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tURL = "_DeepSee.UserPortal.Analyzer.zen"
	Set tURL = tURL _ "?PIVOT="_$ZCVT($ZCVT(..fullName,"O","UTF8"),"O","URL")
	Quit tURL
]]></Implementation>
</Method>

<Method name="%GetTypeName">
<Description>
Return the localized type name for this item.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $$$Text("Pivot","%DeepSee")
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DefaultData>PivotDefaultData</DefaultData>
<Data name="PivotDefaultData">
<Subscript>"Pivot"</Subscript>
<Value name="1">
<Value>mdx</Value>
</Value>
<Value name="2">
<Value>cellWidth</Value>
</Value>
<Value name="3">
<Value>rowLabelSpan</Value>
</Value>
<Value name="4">
<Value>columnLabelSpan</Value>
</Value>
<Value name="5">
<Value>cellHeight</Value>
</Value>
<Value name="6">
<Value>showEmptyRows</Value>
</Value>
<Value name="7">
<Value>showEmptyColumns</Value>
</Value>
<Value name="8">
<Value>cubeName</Value>
</Value>
<Value name="9">
<Value>caption</Value>
</Value>
<Value name="10">
<Value>showFilters</Value>
</Value>
<Value name="11">
<Value>showStatus</Value>
</Value>
<Value name="12">
<Value>rowAxisOptions</Value>
</Value>
<Value name="13">
<Value>columnAxisOptions</Value>
</Value>
<Value name="14">
<Value>rowLevels</Value>
</Value>
<Value name="15">
<Value>columnLevels</Value>
</Value>
<Value name="16">
<Value>filters</Value>
</Value>
<Value name="17">
<Value>measures</Value>
</Value>
<Value name="18">
<Value>pageSize</Value>
</Value>
<Value name="19">
<Value>drillLevels</Value>
</Value>
<Value name="20">
<Value>colorScale</Value>
</Value>
<Value name="21">
<Value>formatRules</Value>
</Value>
<Value name="22">
<Value>listing</Value>
</Value>
<Value name="23">
<Value>rowTotals</Value>
</Value>
<Value name="24">
<Value>columnTotals</Value>
</Value>
<Value name="25">
<Value>calculatedMembers</Value>
</Value>
<Value name="26">
<Value>columnHeaderStyle</Value>
</Value>
<Value name="27">
<Value>rowHeaderStyle</Value>
</Value>
<Value name="28">
<Value>cellStyle</Value>
</Value>
<Value name="29">
<Value>listingRows</Value>
</Value>
<Value name="30">
<Value>showZebra</Value>
</Value>
<Value name="31">
<Value>showRowCaption</Value>
</Value>
<Value name="32">
<Value>rowTotalAgg</Value>
</Value>
<Value name="33">
<Value>columnTotalAgg</Value>
</Value>
<Value name="34">
<Value>rowTotalSource</Value>
</Value>
<Value name="35">
<Value>printTitle</Value>
</Value>
<Value name="36">
<Value>printSubtitle</Value>
</Value>
<Value name="37">
<Value>printPageSize</Value>
</Value>
<Value name="38">
<Value>printOrientation</Value>
</Value>
<Value name="39">
<Value>printMarginTop</Value>
</Value>
<Value name="40">
<Value>printMarginLeft</Value>
</Value>
<Value name="41">
<Value>printMarginRight</Value>
</Value>
<Value name="42">
<Value>printMarginBottom</Value>
</Value>
<Value name="43">
<Value>printLabelWidth</Value>
</Value>
<Value name="44">
<Value>printCellWidth</Value>
</Value>
<Value name="45">
<Value>autoExecute</Value>
</Value>
<Value name="46">
<Value>manualMode</Value>
</Value>
<Value name="47">
<Value>userMDX</Value>
</Value>
<Value name="48">
<Value>chartMarginTop</Value>
</Value>
<Value name="49">
<Value>chartMarginLeft</Value>
</Value>
<Value name="50">
<Value>chartMarginRight</Value>
</Value>
<Value name="51">
<Value>chartMarginBottom</Value>
</Value>
<Value name="52">
<Value>listingFields</Value>
</Value>
<Value name="53">
<Value>filterTableStyle</Value>
</Value>
<Value name="54">
<Value>filterTableCaptionStyle</Value>
</Value>
<Value name="55">
<Value>filterTableItemStyle</Value>
</Value>
<Value name="56">
<Value>borderLeftCell</Value>
</Value>
<Value name="57">
<Value>borderRightCell</Value>
</Value>
<Value name="58">
<Value>borderTopCell</Value>
</Value>
<Value name="59">
<Value>borderBottomCell</Value>
</Value>
<Value name="60">
<Value>borderLeftCol</Value>
</Value>
<Value name="61">
<Value>borderRightCol</Value>
</Value>
<Value name="62">
<Value>borderTopCol</Value>
</Value>
<Value name="63">
<Value>borderBottomCol</Value>
</Value>
<Value name="64">
<Value>borderLeftRow</Value>
</Value>
<Value name="65">
<Value>borderRightRow</Value>
</Value>
<Value name="66">
<Value>borderTopRow</Value>
</Value>
<Value name="67">
<Value>borderBottomRow</Value>
</Value>
<Value name="68">
<Value>maxRows</Value>
</Value>
<Value name="69">
<Value>showListingFilters</Value>
</Value>
<Value name="70">
<Value>showDate</Value>
</Value>
<Value name="71">
<Value>showZebraStripes</Value>
</Value>
<Value name="72">
<Value>listingFontSize</Value>
</Value>
<Value name="73">
<Value>printSubtitleOn</Value>
</Value>
<Value name="74">
<Value>nowDisplayFormat</Value>
</Value>
<Value name="75">
<Value>showUser</Value>
</Value>
<Value name="76">
<Value>listingFilters</Value>
</Value>
<Value name="77">
<Value>measureLocation</Value>
</Value>
<Value name="78">
<Value>backgroundImage</Value>
</Value>
<Value name="79">
<Value>backgroundOpacity</Value>
</Value>
<Value name="80">
<Value>fontFamilyCell</Value>
</Value>
<Value name="81">
<Value>fontSizeCell</Value>
</Value>
<Value name="82">
<Value>fontFamilyCol</Value>
</Value>
<Value name="83">
<Value>fontSizeCol</Value>
</Value>
<Value name="84">
<Value>fontFamilyRow</Value>
</Value>
<Value name="85">
<Value>fontSizeRow</Value>
</Value>
<Value name="86">
<Value>hideMeasures</Value>
</Value>
<Value name="87">
<Value>previewMode</Value>
</Value>
<Value name="88">
<Value>sqlRestriction</Value>
</Value>
<Value name="89">
<Value>canDrillDown</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.Generator">
<Description><![CDATA[
This class contains methods used by the various
DeepSee code generators.<br/>
This class should be consider to be INTERNAL to DeepSee;
There are no methods intended for public use.]]></Description>
<IncludeCode>%occUtility,%DeepSee</IncludeCode>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeCreated>61100,60588.221955</TimeCreated>

<Method name="%ProcessVirtualMembers">
<Description><![CDATA[
Given a cube model, fill in a set of arrays with meta data 
about the named sets and calculated members for the cube.<br/>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%DeepSee.Model.cube,*pNamedSets:%List,*pCalcMembers:%List,&pCaptions:%String,&pDescriptions:%String,&pMemberList:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// calculated members
		For m=1:1:pCube.calculatedMembers.Count() {
			Set tMbr = pCube.calculatedMembers.GetAt(m)
			If (tMbr.disabled) {
				Continue
			}
			// WAL190 -- add tMbr.listingFilter in position 6
			Set pCalcMembers($$$UPPER(tMbr.dimension),$$$UPPER(tMbr.name)) = $LB(tMbr.dimension,tMbr.name,tMbr.valueExpression,tMbr.formatString,tMbr.hidden,tMbr.listingFilter)
			// + WAL065 -- don't overwrite dimension caption if this calculated member 
			//             belongs to a standard dimension
			If ('$D(pMemberList($$$UPPER(tMbr.dimension)))) {
				Set pCaptions($$$UPPER(tMbr.dimension)) = $LB(tMbr.dimension,tMbr.dimension)
				Set pDescriptions($$$UPPER(tMbr.dimension)) = $LB(tMbr.description) // + WAL124 -- same for descriptions
			}
			// - WAL065
			Set pCaptions($$$UPPER(tMbr.dimension),$$$UPPER(tMbr.name)) = $LB(tMbr.name,tMbr.displayName)
			Set pDescriptions($$$UPPER(tMbr.dimension),$$$UPPER(tMbr.name)) = $LB(tMbr.description)
		}

		// named sets
		For m=1:1:pCube.namedSets.Count() {
			Set tMbr = pCube.namedSets.GetAt(m)
			If (tMbr.disabled) {
				Continue
			}
			Set pNamedSets($$$UPPER(tMbr.name)) = $LB(tMbr.name,tMbr.setExpression)

			// use special %%NAMEDSETS dimension name
			Set pCaptions("%%NAMEDSETS",$$$UPPER(tMbr.name)) = $LB(tMbr.name,tMbr.displayName)
			Set pDescriptions("%%NAMEDSETS",$$$UPPER(tMbr.name)) = $LB(tMbr.description)
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%BuildCubeInfo">
<Description><![CDATA[
Given a cube model, fill in a set of arrays with meta data for the cube.<br/>
This meta data takes the form:<br/>
pDimIndex(dno,hno,lno) = $LB(mbrType,dimName,hierName,lvlName,factName,mbrClass,mbrField,...)<br/>
pDimIndex(dno,hno,lno,"opt",...) = member options (for time classes)<br/>
pDimIndex(dno,hno,lno,"prop",prop) = $LB("p",mbrClass,mbrField,propName,propType)<br/>
pDimIndex(dno,hno,lno,"mbr",mbr#) = $LB(mbrName,mbrSpec) (for explicit members)<br/>
pDimNames(dname,hname,lname) = $LB(dimNo,hierNo,lvlNo)<br/>
pFactIndex(factno)=factname<br/>
pFactInfo(factname...)<br/>
pStarInfo(starname...)<br/>
pMsrIndex(msrno)=msrname<br/>
pRelationInfo(relname...)<br/>
pRelIndex(relno)=relname<br/>
pCaptions(dname,hname,lname) = $LB(name,displayName)<br/>
pMeta(key) = value -- additional information ("hasAge").<br/>
pDependList(dno,hno,lno,tFactNo) -- dependOn info <br/>
pComputedDims(dname) -- indicates that this is a computed dimension<br/>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%DeepSee.Model.cube,pSchema:%String,*pDimIndex:%List,*pDimNames:%List,&pFactIndex:%String,*pFactInfo:%List,*pStarInfo:%List,&pMsrIndex:%String,&pRelationInfo:%String,&pRelIndex:%String,&pCaptions:%String,&pMeta:%String,&pDependList:%String,&pComputedDims:%String,&pDescriptions]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pDimIndex // index of members by ordinal position
		Kill pDimNames // index of members by name
		Kill pFactInfo
		Kill pStarInfo
		Kill pRelationInfo
		Kill pRelIndex
		Kill pMeta
		// pFactIndex // fact #s to names (could be passed in)
		// pMsrIndex // measure #s to names (could be passed in)
		Kill tActualFactNo // counter for allocated fact #s
		Kill pComputedDims

		//
		// <dimNo>: dimension #; 0 = "Measures" dimension.
		// <hierNo>: hierarchy #; 0 for dimension-level data;
		// <lvlNo>: level #; 0 for dim or hierarchy-level data;
		// pDimIndex(<dimNo>,<hierNo>,<lvlNo>) =
		//	$LB(<1:mbrType>,<2:dimName>,<3:hierName>,<4:lvlName>,<5:factNumber>,<6:mbrClass>,<7:mbrNameField>,<8:orderBy>,<9:rollUp>,<10:sortDir>,<11:hasMemberList>,<12:mbrKeyField>,<13:nullMarker>,<14:timeFormat>,<15:timeOffset>,<16:isList>,<17:hidden>,<18:showHierarchies>,<19:useAsFilter>)
		// or for measures:
		// pDimIndex(0,<msrNo>,0) =
		//	$LB("m","Measures",<3:msrName>,,<5:factName>,,<7:msrAggregate>,<8:msrType>,<9:msrScale>,,<11:hidden>,<12:format>,<13:searchable>,<14:sourceCube>,<15:listingFilterOperator>,<16:listingFilter>)
		//
		// mbrType can be: 	"h" - hierarchy
		// 					"d" - dimension, "m" - measure
		// 					"l" - level
		// 					"p" - level property (in subnode)
		//
		// pDimNames(<DIMNAME>,[<HIERNAME>],[<LVLNAME>]) =
		//		$LB(<dimNo>,<heirNo>,<lvlNo>)

		// walk down cube,
		// build list of dimensions
		// determine properties of the FACT table
		// and any STAR tables
		// Names of Fact properties are based on their
		// source fields

		Set tDimNo = 0

		#; add intrinsic "%SEARCH" dimension (hidden)
		#; this is to allow filtering on *searchable* measures
		Set tDimNo = tDimNo + 1
		Set tSMbrName = "%Search"
		Set pDimIndex(tDimNo,0,0) = $LB("d",tSMbrName)
		Set pCaptions($$$UPPER(tSMbrName)) = $LB(tSMbrName,tSMbrName)
		Set pDescriptions($$$UPPER(tSMbrName)) = $LB(tSMbrName)

		Set pDimIndex(tDimNo,1,0) = $LB("h",tSMbrName,tSMbrName,,,"%DeepSee.Query.memberComputed")
		Set pCaptions($$$UPPER(tSMbrName),$$$UPPER(tSMbrName)) = $LB(tSMbrName,tSMbrName)
		Set pDescriptions($$$UPPER(tSMbrName),$$$UPPER(tSMbrName)) = $LB(tSMbrName)

		Set pComputedDims($$$UPPER(tSMbrName)) = "%DeepSee.ComputedDimension.SQL"

		Set x = $I(pFactIndex)
		Set tSearchFactNo = $I(tActualFactNo)
		Set pDimIndex(tDimNo,1,1) = $LB("l",tSMbrName,tSMbrName,tSMbrName,tSearchFactNo,"%DeepSee.ComputedDimension.SQL","","","","","","",pCube.nullReplacement)
		Set pCaptions($$$UPPER(tSMbrName),$$$UPPER(tSMbrName),$$$UPPER(tSMbrName)) = $LB(tSMbrName,tSMbrName)
		Set pDescriptions($$$UPPER(tSMbrName),$$$UPPER(tSMbrName),$$$UPPER(tSMbrName)) = $LB(tSMbrName)

		Set pMeta("namedFactNums") = pCube.namedFactNums		// DTB886 - Log the setting for fixed fact numbers

		// now visit each defined dimension
		For d=1:1:pCube.dimensions.Count() {
			Set tDim = pCube.dimensions.GetAt(d)
			If (tDim.disabled) {
				Continue
			}
			Set tDimNo = tDimNo + 1
			Set tHasAll = tDim.hasAll
			If (tHasAll) {
				Set tAllName = $S(tDim.allCaption'="":tDim.allCaption,1:"All " _ tDim.name)
			}
			Else {
				Set tAllName = ""
			}

			Set pDimIndex(tDimNo,0,0) = $LB("d",tDim.name,,tAllName)
			If (tDim.hidden) {
				Set $List(pDimIndex(tDimNo,0,0),17) = 1
			}
			If ((tDim.showHierarchies'="")&&(tDim.showHierarchies'="default")) {
				Set $List(pDimIndex(tDimNo,0,0),18) = $S(tDim.showHierarchies="true":1,1:0)
			}

			Set pCaptions($$$UPPER(tDim.name)) = $LB(tDim.name,tDim.displayName)
			Set pDescriptions($$$UPPER(tDim.name)) = $LB(tDim.description) // JSL4475
			
			#; walk down hierarchies and levels
			Set tHierNo = 0
			Set tHierCount = tDim.hierarchies.Count()
			For h=1:1:tHierCount {
				Set tHier = tDim.hierarchies.GetAt(h)
				If (tHier.disabled) {
					Continue
				}
				Set tHierNo = tHierNo + 1
				Set tMbrClass = ""
				If ((tDim.type = "time")||(tDim.type = "age")) {
					Set tMbrClass = "%DeepSee.Query.memberTime"
				}
				ElseIf (tDim.type = "computed") {
					Set tMbrClass = "%DeepSee.Query.memberComputed"
				}
				
				// DTB283 - Hierarchies may now be hidden, but there must be more than 1 to do so!
				If (tHierCount=1)&&(tHier.hidden) {
					Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("'%1' is the only hierarchy in the dimension '%2' and may not be marked hidden",tHier.name,tDim.name))
					Quit
				}
				
				Set pDimIndex(tDimNo,tHierNo,0) = $LB("h",tDim.name,tHier.name,,,tMbrClass,,,,,,,,,,,tHier.hidden)
				Set pCaptions($$$UPPER(tDim.name),$$$UPPER(tHier.name)) = $LB(tHier.name,tHier.displayName)
				Set pDescriptions($$$UPPER(tDim.name),$$$UPPER(tHier.name)) = $LB(tHier.description) // JSL4475
				
				// all level
				If (tHasAll) {
					Set pDimIndex(tDimNo,tHierNo,1) = $LB("all",tDim.name,tHier.name,tAllName)
					Set pCaptions($$$UPPER(tDim.name),$$$UPPER(tAllName)) = $LB(tAllName,tDim.allDisplayName)
				}

				// process levels
				Set tRollupFact = "" // used to get rollup information
				Set tRollupField = ""
				Set tLevelCount = tHier.levels.Count()
				Set tLevelNo = $S(tHasAll:1,1:0)
				For lvl=1:1:tLevelCount {
					Set tLevel = tHier.levels.GetAt(lvl)
					If (tLevel.disabled) {
						Continue
					}
					
					// + DTB859 - [Validation] Check factNumber assignments against cube setting
					If (pCube.namedFactNums) {
						Set tLevelSpec = tDim.name _"."_ tHier.name _"."_ tLevel.name
						If 'tLevel.factNumber {
							$$$ThrowStatus($$$ERROR($$$GeneralError,"Fact number is required and unassigned to level: " _ tLevelSpec))
						}
						ElseIf '$IsValidNum(tLevel.factNumber) || (tLevel.factNumber '= (tLevel.factNumber\1)) {
							$$$ThrowStatus($$$ERROR($$$GeneralError,"Fact number must be an integer: " _ tLevelSpec _ " value: " _ tLevel.factNumber))
						}
						ElseIf '(tLevel.factNumber>=2) {
							$$$ThrowStatus($$$ERROR($$$GeneralError,"Fact number must have a value greater than 1: " _ tLevelSpec _ " value: " _ tLevel.factNumber))
						}
						Else {
							Set tAssignedFactNum = tLevel.factNumber
						}
					}
					// - DTB859
					
					Set tLevelNo = tLevelNo + 1
					Set tFactName = ""
					Set tMbrType = "l"
					Set tMbrSource = ""
					Kill tMbrOptions
					Set tTimeFunction = 0
					Set tSName = ""

					// get spec for this level, apply defaults
					Set tSourceProperty = tDim.sourceProperty
					Set tSourceExpression = tDim.sourceExpression
					// (local is an override in a shared dimension)
					Set tLocalSourceProperty = tDim.localSourceProperty
					Set tLocalSourceExpression = tDim.localSourceExpression
					Set tLevelClass = ""
					Set tContext = tDim.name_"."_tHier.name_"."_tLevel.name // used for error messages
					Set tFactName = ""
					Set tElName = ""
					Set tLevelFact = "" // passed onto next level

					// JMD910 test for dependsOn attribute
					If (tLevel.dependsOn'="") {
						// add to list; process later
						Set tDependsList(tDimNo,tHierNo,tLevelNo) = tLevel.dependsOn
					}

					// now get overrides from current level
					// preserve sourceProperty as the *names* have to be the same!
					Set tElName = tLevel.name
					Set:tLevel.sourceProperty'="" tSourceProperty = tLevel.sourceProperty
					Set:tLevel.sourceExpression'="" tSourceExpression = tLevel.sourceExpression
					Set:tLevel.localSourceProperty'="" tLocalSourceProperty = tLevel.localSourceProperty
					Set:tLevel.localSourceExpression'="" tLocalSourceExpression = tLevel.localSourceExpression

					Set tLevelClass = tLevel.timeFunction
					Set tLevelIsList = tLevel.list
					Set tLevelUseDisplay = +tLevel.useDisplayValue
					Set tLevelDelim = tLevel.listDelimiter
					Set tLevelNull = tLevel.nullReplacement
					Set tLevelRangeExpr = tLevel.rangeExpression
					Set tMemberList = tLevel.memberList
					Set tHasMemberList = 0
					Set tTimeOffset = tLevel.timeOffset
					Set tTimeFormat = tLevel.timeFormat

					// default null replacement is cube default or "" (which means we plug in a default at member processing time)
					Set tLevelNull = $S(tLevelNull'="":tLevelNull,pCube.nullReplacement'="":pCube.nullReplacement,1:"")

					Set tLinkClass = tLevel.linkClass
					Set tLinkProperty = tLevel.linkProperty
					
					// PFS097 - Throw error if list is defined and range expression is defined
					If (tLevelIsList) && (tLevelRangeExpr'="") {
						Set tSC=$$$ERROR($$$GeneralError,"List-Based Level cannot define a Range Expression: "_tElName)
						$$$ThrowStatus(tSC)
					}

					// process members defined for this level, if any
					Set tMbrNo = 0
					Set tMemberCount = tLevel.members.Count()
					For m = 1:1:tMemberCount {
						Set tMbr = tLevel.members.GetAt(m)
						If (tMbr.disabled) {
							Continue
						}
						Set tHasMemberList = 1
						Set tMbrNo = tMbrNo + 1
						Set tDisplayName=tMbr.displayName // JSL4431
						Set tDescription=tMbr.description // DTB219
						;Set:tDisplayName="" tDisplayName=tMbr.name // JSL4431 - note JSL4432 comments this line out to avoid cube recompilation
						Set pDimIndex(tDimNo,tHierNo,tLevelNo,"mbr",tMbrNo) = $LB(tMbr.name,tMbr.spec,tDisplayName,tDescription) // JSL4430 (use tDisplayName)
					}
					
					// If the old memberList property is defined, fold it in
					If (tMemberList'="") {
						For m = 1:1:$L(tMemberList,",") {
							Set tMName = $P(tMemberList,",",m)
							If (tMName'="") {
								Set tHasMemberList = 1
								Set tMbrNo = tMbrNo + 1
								Set pDimIndex(tDimNo,tHierNo,tLevelNo,"mbr",tMbrNo) = $LB(tMName,"")
							}
						}
					}

					// process range expr and add items to memberList if no list defined
					If ((tLevelRangeExpr'="")&&('tHasMemberList)) {
						Set tSC = ##class(%DeepSee.Utils).%ParseRangeExpression(tLevelRangeExpr,.tRList)
					    If $$$ISERR(tSC) Quit
						Set j = $O(tRList(""))
						While (j'="") {
							Set tMName = $LG(tRList(j),6)
							If (tMName'="") {
								Set tHasMemberList = 1
								Set tMbrNo = tMbrNo + 1
								Set pDimIndex(tDimNo,tHierNo,tLevelNo,"mbr",tMbrNo) = $LB(tMName,"")
							}
							Set j = $O(tRList(j))
						}
						// JMD1408: add null entry
						If $D(tRList)&&(tLevelNull'="") {
							Set tMbrNo = tMbrNo + 1
							Set pDimIndex(tDimNo,tHierNo,tLevelNo,"mbr",tMbrNo) = $LB(tLevelNull,"<null>")
						}
					}

					// create facts and star table info according to spec

					// create base fact for this level
					// JMD1329: avoid creating facts for MDX/Computed dimensions
					// do this by using a dummy fact name in this case
					Set tMDXComputed = 0
					If ((tDim.type = "computed")&&(tDim.dimensionClass'="")) {
						Set tMDXComputed = ($classmethod(tDim.dimensionClass,"%GetBehavior")="MDX")
					}
					If (tMDXComputed) {
						Set tFactName = "$MDXCOMPUTED"
					}
					Else { 
						Set tFactName = ..%GetFactName("Dx",tElName,tSourceProperty,tSourceExpression,,tLevelRangeExpr,tLinkClass,tLinkProperty)
					}

					// BDB429 - Avoid fact name conflicts for duplicate iKnow dimension level names,
					// as the fact name would just be based on the level's name, which is not 
					// necessarily unique across dimensions.
					if (tDim.iKnowMeasure'="") {
						while $d(pFactInfo("prop",tFactName)) {
							set tFactName = tFactName_$i(tAliasCounter)
						}
					}
					
					// JMD847
					// if there are 2 identical facts but with different "factNames"
					// give one a different name to avoid conflict!
					If $D(pFactInfo("prop",tFactName,"alias")) {
						Set tFactName = tFactName_$I(tAliasCounter)
					}
					
					Do AddFact(tFactName,,tLevel.factName,tDim.type)
					Set tLevelFact = tFactName
					Set tLevelFieldName = $S(tLevel.factName="":tFactName,1:tLevel.factName)
					Set:($G(tDimNo)'="") pFactInfo("prop",tFactName,"dimNo") = tDimNo			// DTB567 - Store complete level information
					Set:($G(tHierNo)'="") pFactInfo("prop",tFactName,"hierNo") = tHierNo		// DTB567
					Set pFactInfo("prop",tFactName,"levelNo") = tLevelNo

					// JMD878 selectivity
					Set:(tLevel.factSelectivity'="") pFactInfo("prop",tFactName,"parms","SELECTIVITY") = tLevel.factSelectivity

					Set:tLocalSourceExpression'="" pFactInfo("prop",tFactName,"localExpr") = tLocalSourceExpression
					Set:tLocalSourceProperty'="" pFactInfo("prop",tFactName,"localSource") = tLocalSourceProperty

					// determine more details on the fact
					If (tSourceExpression'="") {
						// expression takes precedence over sourceProperty
						Set pFactInfo("prop",tFactName,"expr") = tSourceExpression
						Set:tLevel.castAsNumeric pFactInfo("prop",tFactName,"sourceType") = "NUMERIC"		// DTB243
					}
					Else {
						Set pFactInfo("prop",tFactName,"source") = tSourceProperty

						// test for different date types
						If (tSourceProperty'="") {
							Set tDType = ..%GetPropertyType(.tSC, .mvp, pCube.sourceClass,$S(tLocalSourceProperty'="":tLocalSourceProperty,1:tSourceProperty),tDim.name_"."_tHier.name_"."_tLevel.name)
							Quit:$$$ISERR(tSC)

							Set tDType = $$$NormalizeClassname(tDType)
							If ($$$getClassType(tDType) = "datatype") {
								Set tClientType = $$$comClassKeyGet(tDType,$$$cCLASSclientdatatype)
								If ("MVDATE"=tClientType) {
		   							Set pFactInfo("prop",tFactName,"dateType") = "MVDATE"
								}
								ElseIf ("FTIMESTAMP"=tClientType) {
		   							Set pFactInfo("prop",tFactName,"dateType") = "FTIMESTAMP"
								}
								ElseIf ("FDATE"=tClientType) {
		   							Set pFactInfo("prop",tFactName,"dateType") = "FDATE"
								}
								ElseIf ("TIMESTAMP"=tClientType) {
		   							Set pFactInfo("prop",tFactName,"dateType") = "TIMESTAMP"
								}
								ElseIf ("TIME"=tClientType) {
		   							Set pFactInfo("prop",tFactName,"dateType") = "TIME"
								}
								ElseIf ("DECIMAL"=tClientType) ||		// DTB243 - Add numeric source types to metadata
										("DOUBLE"=tClientType) ||
										("FLOAT"=tClientType) ||
										("INTEGER"=tClientType) ||
										("NUMERIC"=tClientType) {		
									Set pFactInfo("prop",tFactName,"sourceType") = tClientType
								}
							}
						}
					}

					If ((tDim.type = "time")||(tDim.type = "age")) {
						If (tDim.type = "time") {
							If tDim.calendar="partial" {
								Set pFactInfo("prop",tFactName,"type") = "%String"		// DTB - Property type needs to accommodate partial dates
							}
							Else {
   								Set pFactInfo("prop",tFactName,"type") = "%DeepSee.Datatype.dateTime"
							}
						}
						Else {
							Set pMeta("hasAge") = 1
   							Set pFactInfo("prop",tFactName,"type") = "%Integer"
						}
						// For time dimensions source is a time level class
						Set tSC = ..%ParseTimeFunction(tLevel.timeFunction,.tFuncName,.tOptions)
						Quit:$$$ISERR(tSC)

						Set tMbrSource = $G(pCube.%timeFunctions(tDim.calendar,$$$UPPER(tFuncName)))		// DTB177 - Look up time function by calendar
						Merge tMbrOptions = tOptions
						Set tTimeFunction = 1
					}
					ElseIf (tDim.type = "computed") {
						// no star table for computed
						Set tMbrSource = tDim.dimensionClass
   						Set pFactInfo("prop",tFactName,"type") = "$none"
						// JMD890: if we are linked to an iKnow measure, note that
						If (tDim.iKnowMeasure'="") {
	 						Set pFactInfo("prop",tFactName,"iKnowMsr") = tDim.iKnowMeasure
						}
						// JMD1329: note that this is a computed dimension
						Set pComputedDims($$$UPPER(tDim.name)) = tDim.dimensionClass
					}
					Else {
						Set pFactInfo("prop",tFactName,"index") = "bitmap"
						Set pFactInfo("prop",tFactName,"mbrtype") = "d"

						// test for shared dimension
						Set tShared = tDim.sharesFrom

						// create star table for fact to refer to
						Set tCollation = $Case(tLevel.sort,"desc numeric":"exact","asc numeric":"exact",:"")
						Set tSC = ..%AddStarTable(pCube,tShared,pSchema,.pStarInfo,.tSName,pCube.sourceClass,tLevel.name,tSourceProperty,tSourceExpression,tLinkClass,tLinkProperty,tLevelRangeExpr,tLevel.factName,tContext,tCollation)
						Quit:$$$ISERR(tSC)

   						Set pFactInfo("prop",tFactName,"type") = tSName
						Set tMbrSource = tSName
						Kill tMbrOptions

						// indicate that this is a star table
   						Set pFactInfo("prop",tFactName,"star") = 1

						// add rollup to star table
						If (tRollupFact '= "") {
							Set tRollType = $G(pFactInfo("prop",tRollupFact,"type"))
							Set tSC = ..%AddRollupToStar(tSName,tRollupFact,.pFactInfo,.pStarInfo,tContext)
							Quit:$$$ISERR(tSC)
						}
					}

					// is there a function defined?
					If (tTimeFunction) {
						Set tFactNameBase = tFactName
						Set tFuncName = "%Convert"
						// N.b. this *requires* time/age class names to be unique within a given calendar
						Set tFactFuncName = $P(tMbrSource,".",$L(tMbrSource,"."))

						// add additional derived Fact to support this level
						Set tFxFactName = ..%GetFactName("Dx",tElName,tSourceProperty,tSourceExpression,tFactFuncName,tLevelRangeExpr,,,tTimeOffset)
						Set tCalendarCode = $$$dsCodeCalendar(tDim.calendar)
						Set:(tCalendarCode'="G") tFxFactName = tFxFactName _ "Cx" _ tCalendarCode		// DTB181 - Add a calendar code for Hijri calendars.		// DTB - Add calendar code for partial dates
						Do AddFact(tFxFactName,,tLevel.factName)

						Set:($G(tDimNo)'="") pFactInfo("prop",tFxFactName,"dimNo") = tDimNo			// DTB840 - record dimNo
						Set:($G(tHierNo)'="") pFactInfo("prop",tFxFactName,"hierNo") = tHierNo		// DTB840 - record hierNo
						Set pFactInfo("prop",tFxFactName,"levelNo") = tLevelNo						// DTB840 - Use the current level number

						// JMD selectivity
						Set:(tLevel.factSelectivity'="") pFactInfo("prop",tFxFactName,"parms","SELECTIVITY") = tLevel.factSelectivity

						// fact needs function
						Set tDimClass = tMbrSource
						Set tRetType = "%Integer"

						If (tRetType '= "") {
							// inject the function into the Fact class
							Set tFunctions(tFuncName) = tDimClass

							Set pFactInfo("prop",tFxFactName,"type") = tRetType
							Set pFactInfo("prop",tFxFactName,"source") = tSourceProperty
							Set pFactInfo("prop",tFxFactName,"index") = "bitmap"
							Set pFactInfo("prop",tFxFactName,"mbrtype") = "d"

							// info for sql compute
							Set pFactInfo("prop",tFxFactName,"function") = tFuncName
							Set pFactInfo("prop",tFxFactName,"functionClass") = tDimClass
							Merge pFactInfo("prop",tFxFactName,"options") = tMbrOptions
							Set pFactInfo("prop",tFxFactName,"base") = tFactNameBase
							Set pFactInfo("prop",tFxFactName,"isTime") = 1
							
							// PFS039 - Add Shared Dimension local overrides to time levels
							Set:tLocalSourceExpression'="" pFactInfo("prop",tFxFactName,"localExpr") = tLocalSourceExpression
							Set:tLocalSourceProperty'="" pFactInfo("prop",tFxFactName,"localSource") = tLocalSourceProperty

							Set:tTimeOffset'="" pFactInfo("prop",tFxFactName,"timeOffset") = tTimeOffset

							If (tDim.type = "age") {
								// treat age property as a ref so that we always
								// retest axis value that use it.
								Set pMeta("hasAge") = 1
								Set pFactInfo("prop",tFxFactName,"hasref") = 1
							}

							Set tFactName = tFxFactName // associate this member with new fact
						}
						Else {
							Set tSC = $$$ERROR($$$GeneralError,"Unable to find function for level (1):" _ tContext _ "->" _ tTimeFunction)
							Quit
						}
					}

					// link fact to member
					If (tLevelIsList) {
						Set pFactInfo("prop",tFactName,"list") = 1
						Set:tLevelDelim'="" pFactInfo("prop",tFactName,"listDelimiter") = tLevelDelim
						Set pFactInfo("prop",tFactName,"index") = "bitmap"
						Set pFactInfo("prop",tFactName,"mbrtype") = "d"
					}

					If ((tFactName'="")&&(tLevelUseDisplay)) {
						Set pFactInfo("prop",tFactName,"useDisplay") = 1
					}
					If ((tFactName'="")&&(tLevelRangeExpr '= "")) {
						Set pFactInfo("prop",tFactName,"rangeExpr") = tLevelRangeExpr
					}

					If (tLinkClass'="") {
						Set pFactInfo("prop",tFactName,"linkClass") = tLinkClass
						Set pFactInfo("prop",tFactName,"linkProperty") = tLinkProperty
					}

					// process member properties for this level, if any
					Set tDisplayBy = ""
					Set tSortBy = ""
					Set tSortDir = ""
					Set tPropCount = tLevel.properties.Count()
					For p = 1:1:tPropCount {
						Set tProp = tLevel.properties.GetAt(p)
						If (tProp.disabled) {
							Continue
						}

						// special case for internal/external values
						// prevent name conflict between property and level
						If (tProp.useDisplayValue && (tProp.factName="") && (tSourceProperty = tProp.sourceProperty)) {
							Set tProp.factName = tFactName_"Ext"
						}

						// JMD840: special case for linkProperty
						// prevent name conflict between property and level
						If ((tProp.factName="") && (tSourceProperty = tProp.sourceProperty) && (tLinkClass = tProp.linkClass)  && (tLinkProperty '= tProp.linkProperty)) {
							Set tProp.factName = tFactName_"Link"
						}

						Set tCollation = $Case(tProp.sort,"desc numeric":"exact","asc numeric":"exact",:"")
						If (tShared="") {
							Set tSC = ..%AddPropertyToStar(tSName, tProp.name, .pStarInfo, .tStarProp, pCube.sourceClass, tProp.sourceProperty,tProp.sourceExpression,tProp.isReference,tLinkClass,tLinkProperty,tLevelRangeExpr,tProp.factName,tContext,tCollation)
							If $$$ISERR(tSC) Quit
						}
						Else {
							// JMD935
							Set:tProp.localSourceProperty="" tProp.localSourceProperty = tProp.sourceProperty
							Set:tProp.localSourceExpression="" tProp.localSourceExpression = tProp.sourceExpression

							Set tSC = ..%AddPropertyToStar(tSName, tProp.name, .pStarInfo, .tStarProp, pCube.sourceClass, tProp.localSourceProperty,tProp.localSourceExpression,tProp.isReference,tLinkClass,tLinkProperty,tLevelRangeExpr,tProp.factName,tContext,tCollation)
							If $$$ISERR(tSC) Quit
						}

						// add "virtual" fact for this property
						Do AddFact(tStarProp,1,tProp.factName)
						Set tFieldName = $S(tProp.factName="":tStarProp,1:tProp.factName)

						If (tProp.isName) {
							Set tDisplayBy = tFieldName
							If ($G(pStarInfo(tSName,"prop",tStarProp,"use")) '= "key") {
								// do not let name override key
								// this should not get past earlier validation!
								Set pStarInfo(tSName,"prop",tStarProp,"use") = "name"
							}
						}
						If (tProp.isDescription) {
							If ($G(pStarInfo(tSName,"prop",tStarProp,"use")) '= "key") {
								// do not let description override key
								// this should not get past earlier validation!
								Set pStarInfo(tSName,"prop",tStarProp,"use") = "description"
							}
						}
						If (tProp.sort'="") {
							Set tSD = $Case(tProp.sort,"asc":"asc","desc":"desc","desc numeric":"desc#","asc numeric":"asc#",:"")
							Set tSortBy = tSortBy _ $S(tSortBy="":"",1:",") _ tFieldName
							Set tSortDir = tSortDir _ $S(tSortDir="":"",1:",") _ tSD
						}

						Set pFactInfo("prop",tStarProp,"type") = $G(pStarInfo(tSName,"prop",tStarProp,"type"))
						Merge pFactInfo("prop",tStarProp,"parms") = pStarInfo(tSName,"prop",tStarProp,"parms")

						// JMD909
						If (tProp.formatString'="") {
							Set pStarInfo(tSName,"prop",tStarProp,"format") = tProp.formatString
						}

						If (tProp.useDisplayValue) {
							Set pFactInfo("prop",tStarProp,"useDisplay") = 1
						}

						If (tProp.sourceExpression '= "") {
							Set pFactInfo("prop",tStarProp,"expr") = tProp.sourceExpression
						}
						Else {
							Set pFactInfo("prop",tStarProp,"source") = tProp.sourceProperty
						}

						Set:tProp.localSourceExpression'="" pFactInfo("prop",tStarProp,"localExpr") = tProp.localSourceExpression
						Set:tProp.localSourceProperty'="" pFactInfo("prop",tStarProp,"localSource") = tProp.localSourceProperty

						If (tProp.linkClass'="") {
							Set pFactInfo("prop",tStarProp,"linkClass") = tProp.linkClass
							Set pFactInfo("prop",tStarProp,"linkProperty") = tProp.linkProperty
						}

						If (tProp.isReference) {
							// note this property *is* a reference
							// and that this level *has* a reference
							Set pFactInfo("prop",tFactName,"hasref") = 1
							Set pFactInfo("prop",tStarProp,"isref") = 1
						}

						Set pDimIndex(tDimNo,tHierNo,tLevelNo,"prop",$$$UPPER(tProp.name)) = $LB("p",tSName,tStarProp,tProp.name,$G(pStarInfo(tSName,"prop",tStarProp,"type")),$G(pStarInfo(tSName,"prop",tStarProp,"format")))
						Set pCaptions($$$UPPER(tDim.name),$$$UPPER(tHier.name),$$$UPPER(tLevel.name),$$$UPPER(tProp.name)) = $LB(tProp.name,tProp.displayName)
						Set pDescriptions($$$UPPER(tDim.name),$$$UPPER(tHier.name),$$$UPPER(tLevel.name),$$$UPPER(tProp.name)) = $LB(tProp.description) // JSL4475
						If (tProp.hidden) {
							Set $List(pDimIndex(tDimNo,tHierNo,tLevelNo,"prop",$$$UPPER(tProp.name)),17) = 1
						}
					}

					// if no display field, use key field
					If (tDisplayBy = "") {
						Set tDisplayBy = tLevelFieldName
					}

					// add details on this member to the metadata
					If ($$FactNo(tFactName) < 0) {
						// JMD1329: no real fact for mdx/computed
						If (tFactName'="$MDXCOMPUTED") {
							// assign a real fact number
							Set tActualNo = $S($G(tAssignedFactNum)'="":tAssignedFactNum,1:$I(tActualFactNo))		// DTB859 - Use the assigned number if defined
							Kill pFactIndex($$FactNo(tFactName))
							Set pFactIndex(tActualNo) = tFactName
							Set pFactInfo("prop",tFactName) = tActualNo
						}
					}

					// if no sort direction, apply default from level
					If (tSortDir="") {
						Set tSortDir = $Case(tLevel.sort,"asc":"asc","desc":"desc","desc numeric":"desc#","asc numeric":"asc#",:"")
					}

					// JMD938: pass sortBy along so we can create an index on it
					Set:((tSName'="")&&(tSortBy'="")) pStarInfo(tSName,"sortBy") = tSortBy

					// DTB283 - Levels may now be hidden, but there must be more than 1 to do so!
					If (tLevelCount=1)&&(tLevel.hidden) {
						Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("'%1' is the only level in the hierarchy '%2' and may not be marked hidden",tLevel.name,tDim.name_"."_tHier.name))
						Quit
					}

					Set pDimIndex(tDimNo,tHierNo,tLevelNo) = $LB(tMbrType,tDim.name,tHier.name,tLevel.name,$$FactNo(tFactName),tMbrSource,tDisplayBy,tSortBy,tRollupField,tSortDir,$S(tHasMemberList:1,1:""),tLevelFieldName,tLevelNull,tTimeFormat,tTimeOffset,tLevelIsList,tLevel.hidden,,tLevel.useAsFilter)
					Merge pDimIndex(tDimNo,tHierNo,tLevelNo,"opt") = tMbrOptions

					Set pCaptions($$$UPPER(tDim.name),$$$UPPER(tHier.name),$$$UPPER(tLevel.name)) = $LB(tLevel.name,tLevel.displayName)
					Set pDescriptions($$$UPPER(tDim.name),$$$UPPER(tHier.name),$$$UPPER(tLevel.name)) = $LB(tLevel.description) // JSL4475

					// remember current fact for next level
					If ((tDim.type '= "time")&&(tDim.type '= "age")) {
						If (tLevelFact '= "") {
							Set tRollupFact = tLevelFact
							Set tRollupField = tLevelFieldName
						}
					}
				} // for lvl
				Quit:$$$ISERR(tSC)
			} // for hier
			Quit:$$$ISERR(tSC)
		} // for dim
		Quit:$$$ISERR(tSC)

		#; now get measures (these are not in pCube.dimensions)
		Set tMsrNo = 0

		#; add intrinsic "%COUNT" measure
		Set tMsrNo = tMsrNo + 1
		Set pDimIndex(0,0,0) = $LB("d","Measures")
		Set tCountName = pCube.countMeasureName
		Set:tCountName="" tCountName = "%COUNT"
		Set pDimIndex(0,tMsrNo,0) = $LB("m","Measures",tCountName,,"",,"COUNT","integer",0,,0)

		#; JMD1497 set def format for %COUNT
		Set $List(pDimIndex(0,tMsrNo,0),12) = "#,###"

		For m=1:1:pCube.measures.Count() {
			Set tMsr = pCube.measures.GetAt(m)
			If (tMsr.disabled) {
				Continue
			}
			
			// + DTB859 - [Validation] Check fctNumber assignments against cube setting
			If (pCube.namedFactNums) {
				If 'tMsr.factNumber {
					$$$ThrowStatus($$$ERROR($$$GeneralError,"Fact number is required and unassigned to measure: " _ tMsr.name))
				}
				ElseIf '$IsValidNum(tMsr.factNumber) || (tMsr.factNumber '= (tMsr.factNumber\1)) {
					$$$ThrowStatus($$$ERROR($$$GeneralError,"Fact number must be an integer: " _ tMsr.name _ " value: " _ tMsr.factNumber))
				}
				Else {
					Set tAssignedMsrNum = tMsr.factNumber
				}
			}
			// - DTB859
			
			Set tSourceProperty = tMsr.sourceProperty
			Set tSourceExpression = tMsr.sourceExpression
			Set tMsrType = ""
			Set tScale = 0
			Kill tFParms
			Set tMsrDataType = ""
			Set tMsrIndexType = ""
			Set tScaleName = ""
			Set tTypeName = ""
			Set tMsrHidden = +tMsr.hidden
			Set tLinkClass = tMsr.linkClass
			Set tLinkProperty = tMsr.linkProperty
			Set tMsrDateType = ""
			Set tMsrFormat = tMsr.formatString

			// JMD878 selectivity
			Set:(tMsr.factSelectivity'="") tFParms("SELECTIVITY") = tMsr.factSelectivity

			// compute characteristics first, then find fact name
			Set tNeedType = 1
			If (tLinkClass'="") {
			}
			ElseIf (tSourceExpression'="") {
				Set tNeedType = 0
				// expression takes precedence over sourceProperty
				// n.b. we *could* analyze the expression to find the default type
				// but let's leave this up to the cube designer
				Set tDefType = "number"
				If ((tMsr.type = "number")||(tMsr.type = "")) {
					Set tMsrType = "number"
					Set tScale = tMsr.scale
					If (tScale = "") {
						Set tScale = 2 // default
					}
					ElseIf (tScale '= 2) {
						Set tScaleName = "Sx" _ tScale
					}
					Set tMsrDataType = "%Double"
					Set tMsrIndexType = "bitslice"
					Set tFParms("SCALE") = tScale
					// JMD1502
					If (tMsrFormat="") {
						Set tMsrFormat = "#,###"_$S(tScale>0:"."_$TR($J(" ",tScale)," ","#"),1:"")
					}
				}
				ElseIf (tMsr.type = "integer") {
					Set tMsrType = "integer"
					Set tScale = 0
					Set tMsrDataType = "%Integer"
					Set tMsrIndexType = "bitslice"
					// JMD1502
					If ((tMsrFormat="")&&(tMsr.aggregate = "AVG")) {
						Set tMsrFormat = "#,###.##"
					}
				}
				ElseIf (tMsr.type = "boolean") {
					Set tMsrType = "boolean"
					Set tScale = 0
					Set tMsrDataType = "%Boolean"
					Set tMsrIndexType = "bitmap"
				}
				ElseIf (tMsr.type = "date") {
					Set tMsrType = "date"
					Set tScale = 0
					Set tMsrDataType = "%DeepSee.Datatype.dateTime"
					Set tMsrIndexType = "bitslice"
				}
				ElseIf (tMsr.type = "age") {
					Set tMsrType = "age"
					Set tScale = 0
					Set tMsrDataType = "%Integer"
					Set tMsrIndexType = "bitslice"
				}
				ElseIf (tMsr.type = "text") {
					Set tMsrType = "text"
					Set tScale = 0
					Set tMsrDataType = "%Text"
					Set tMsrIndexType = "text"
					Set tFParms("MAXLEN") = 32000
					Set tMsrHidden = 1 // hide text measures
				}
				ElseIf (tMsr.type = "iKnow") {
					Set tMsrType = tMsr.type
					Set tScale = 0
					Set tMsrDataType = "%String"
					Set tFParms("MAXLEN") = 32000
					// tack on source type
					Set tMsrIndexType = tMsr.type_":"_tMsr.iKnowSource
					
					// BDB260: append domain name and user-defined domain parameters
					Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowDomain
					Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowDictionaries
					Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowParameters
					Set tMsrHidden = 1 // hide text measures
				}
				Else {
					Set tMsrType = "string"
					Set tScale = 0
					Set tMsrDataType = "%String"
					Set tMsrIndexType = "$none"
					Set tFParms("MAXLEN") = 32000
					Set tMsrHidden = 1 // hide string measures
				}

				If (tMsrType '= tDefType) {
					Set tTypeName = $Case(tMsrType,"date":"D","age":"AD","integer":"I","number":"N","boolean":"B","string":"S","text":"T","iKnow":"iK",:"")
				}
			}
			ElseIf (tSourceProperty = "") {
				Set tNeedType = 0
				Set tDefType = "number"
				If ((tMsr.type = "number")||(tMsr.type = "")) {
					Set tMsrType = "number"
					Set tScale = tMsr.scale
					If (tScale = "") {
						Set tScale = 2 // default
					}
					ElseIf (tScale '= 2) {
						Set tScaleName = "Sx" _ tScale
					}
					Set tMsrDataType = "%Double"
					Set tMsrIndexType = "bitslice"
					Set tFParms("SCALE") = tScale
					// JMD1502
					If (tMsrFormat="") {
						Set tMsrFormat = "#,###"_$S(tScale>0:"."_$TR($J(" ",tScale)," ","#"),1:"")
					}
				}
				ElseIf (tMsr.type = "integer") {
					Set tMsrType = "integer"
					Set tScale = 0
					Set tMsrDataType = "%Integer"
					Set tMsrIndexType = "bitslice"
					// JMD1502
					If ((tMsrFormat="")&&(tMsr.aggregate = "AVG")) {
						Set tMsrFormat = "#,###.##"
					}
				}
				ElseIf (tMsr.type = "boolean") {
					Set tMsrType = "boolean"
					Set tScale = 0
					Set tMsrDataType = "%Boolean"
					Set tMsrIndexType = "bitmap"
				}
				ElseIf (tMsr.type = "date") {
					Set tMsrType = "date"
					Set tScale = 0
					Set tMsrDataType = "%DeepSee.Datatype.dateTime"
					Set tMsrIndexType = "bitslice"
				}
				ElseIf (tMsr.type = "age") {
					Set tMsrType = "age"
					Set tScale = 0
					Set tMsrDataType = "%Integer"
					Set tMsrIndexType = "bitslice"
				}
				ElseIf (tMsr.type = "text") {
					Set tMsrType = "text"
					Set tScale = 0
					Set tMsrDataType = "%Text"
					Set tMsrIndexType = "text"
					Set tFParms("MAXLEN") = 32000
					Set tMsrHidden = 1 // hide text measures
				}
				ElseIf (tMsr.type = "iKnow") {
					Set tMsrType = tMsr.type
					Set tScale = 0
					If (tMsr.type = "stream") {
						Set tMsrDataType = "%GlobalCharacterStream"
					}
					Else {
						Set tMsrDataType = "%String"
						Set tFParms("MAXLEN") = 32000
					}
					// tack on source type
					Set tMsrIndexType = tMsr.type_":"_tMsr.iKnowSource
					
					// BDB260: append domain name and user-defined domain parameters
					Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowDomain
					Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowDictionaries
					Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowParameters
					Set tMsrHidden = 1 // hide text measures
				}
				Else {
					Set tMsrType = "string"
					Set tScale = 0
					Set tMsrDataType = "%String"
					Set tMsrIndexType = "$none"
					Set tFParms("MAXLEN") = 32000
					Set tMsrHidden = 1 // hide string measures
				}
				If (tMsrType '= tDefType) {
					Set tTypeName = $Case(tMsrType,"date":"D","age":"AD","integer":"I","number":"N","boolean":"B","string":"S","text":"T","iKnow":"iK",:"")
				}
			}

			// if we have not yet found the type, do it now
			If (tNeedType) {
				// Find type of source field
				// Make sure it is a literal type
				If (tLinkClass'="") {
					Set tFType = ..%GetPropertyType(.tSC, .p, tLinkClass,tLinkProperty,"Measures."_tMsr.name)
					Quit:$$$ISERR(tSC)
				}
				Else {
					Set tFType = ..%GetPropertyType(.tSC, .p, pCube.sourceClass,tSourceProperty,"Measures."_tMsr.name)
					Quit:$$$ISERR(tSC)
				}
				Merge tFParms = p // fold in defaults from property
				Set tFType = $$$NormalizeClassname(tFType)
				Set tFClsType = $$$getClassType(tFType)
				If (tFClsType = "datatype") {
					// use client type to determine *real* type of datatype
					Set tClientType = $$$comClassKeyGet(tFType,$$$cCLASSclientdatatype)
					If ("MVDATE"=tClientType) {
						Set tMsrDateType = "MVDATE"
					}
					ElseIf ("FDATE"=tClientType) {
						Set tMsrDateType = "FDATE"
					}
					ElseIf ("FTIMESTAMP"=tClientType) {
						Set tMsrDateType = "FTIMESTAMP"
					}
					ElseIf ("TIMESTAMP"=tClientType) {
						Set tMsrDateType = "TIMESTAMP"
					}
					ElseIf ("TIME"=tClientType) {
						Set tMsrDateType = "TIME"
					}

					Set tDefType = $Case(tClientType,"DOUBLE":"number","NUMERIC":"number","CURRENCY":"number","INTEGER":"integer","BOOLEAN":"boolean","DATE":"date","MVDATE":"date","FDATE":"date","FTIMESTAMP":"date","TIMESTAMP":"date","TIME":"date",:"string")
					If ((tMsr.type="number")||((tMsr.type="")&&((tClientType = "DOUBLE")||(tClientType = "NUMERIC")||(tClientType = "CURRENCY")))) {
						// Unless specified, use scale from source property
						// JMD1486
						Set tDefScale=2
						If (tClientType="CURRENCY") {
							Set tDefScale=4
						}
						Set tScale = $S(tMsr.scale="":$G(tFParms("SCALE"),tDefScale),1:tMsr.scale)
						If ((tMsr.scale'="")&&(tScale '= $G(tFParms("SCALE"),tDefScale))) {
							Set tScaleName = "Sx" _ tScale
						}
						Set tFParms("SCALE") = tScale
						Kill tFParms("MAXLEN")
						Set tMsrType = "number"
						Set tMsrDataType = $Case(tClientType,"NUMERIC":"%Numeric","CURRENCY":"%Currency",:"%Double")
						Set tMsrIndexType = "bitslice"
						// JMD1502
						If (tMsrFormat="") {
							Set tMsrFormat = "#,###"_$S(tScale>0:"."_$TR($J(" ",tScale)," ","#"),1:"")
						}
					}
					ElseIf ((tMsr.type="integer")||((tMsr.type="")&&(tClientType = "INTEGER"))) {
						Set tScale = 0
						Set tMsrType = "integer"
						Kill tFParms("SCALE")
						Kill tFParms("MAXLEN")
						Set tMsrDataType = "%Integer"
						Set tMsrIndexType = "bitslice"
						// JMD1502
						If ((tMsrFormat="")&&(tMsr.aggregate = "AVG")) {
							Set tMsrFormat = "#,###.##"
						}
					}
					ElseIf ((tMsr.type = "boolean")||((tMsr.type="")&&(tClientType = "BOOLEAN"))) {
						Set tMsrType = "boolean"
						Set tScale = 0
						Kill tFParms("SCALE")
						Set tMsrDataType = "%Boolean"
						Set tMsrIndexType = "bitmap"
					}
					ElseIf ((tMsr.type="date")||((tMsr.type="")&&((tClientType = "DATE")||(tClientType = "MVDATE")||(tClientType = "FDATE")||(tClientType = "FTIMESTAMP")||(tClientType = "TIMESTAMP")||(tClientType = "TIME")))) {
						Set tScale = 0
						Set tMsrType = "date"
						Kill tFParms("SCALE")
						Kill tFParms("MAXLEN")
						Set tMsrDataType = "%DeepSee.Datatype.dateTime"
						Set tMsrIndexType = "bitslice"
					}
					ElseIf ((tMsr.type="age")) {
						Set tScale = 0
						Set tMsrType = "age"
						Kill tFParms("SCALE")
						Kill tFParms("MAXLEN")
						Set tMsrDataType = "%Integer"
						Set tMsrIndexType = "bitslice"
					}
					ElseIf ((tMsr.type="text")) {
						Set tScale = 0
						Kill tFParms("SCALE")
						Kill tFParms("MAXVAL")
						Kill tFParms("MINVAL")
						Set tMsrType = "text"
						Set tMsrDataType = "%Text"
						Set tMsrIndexType = "text"
						Set tMsrHidden = 1 // hide text measures
					}
					ElseIf ((tMsr.type="iKnow")) {
						Set tScale = 0
						Kill tFParms
						Set tMsrType = tMsr.type
						If (tMsr.iKnowSource = "stream") {
							Set tMsrDataType = "%GlobalCharacterStream"
						}
						Else {
							Set tMsrDataType = "%String"
							Set tFParms("MAXLEN") = 32000
						}
						// tack on source type
						Set tMsrIndexType = tMsr.type_":"_tMsr.iKnowSource
						
						// BDB260: append domain name and  user-defined domain parameters
						Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowDomain
						Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowDictionaries
						Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowParameters
						Set tMsrHidden = 1 // hide text measures
					}
					Else {
						Set tScale = 0
						Kill tFParms("SCALE")
						Kill tFParms("MAXVAL")
						Kill tFParms("MINVAL")
						Set tMsrType = "string"
						Set tMsrDataType = "%String"
						Set tMsrIndexType = "$none"
						Set tMsrHidden = 1 // hide string measures
					}

					If (tMsrType '= tDefType) {
						Set tTypeName = $Case(tMsrType,"date":"D","age":"AD","integer":"I","number":"N","boolean":"B","string":"S",:"")
					}
				}
				ElseIf (tFClsType="stream") && (tMsr.type="iKnow") && (tMsr.iKnowSource="stream") {
					Set tScale = 0
					Kill tFParms
					Set tMsrType = tMsr.type
					Set tMsrDataType = tFType
					Set tMsrIndexType = tMsr.type_":"_tMsr.iKnowSource
					
					// BDB260: append domain name and user-defined domain parameters
					Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowDomain
					Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowDictionaries
					Set tMsrIndexType = tMsrIndexType _ ":" _ tMsr.iKnowParameters
					Set tMsrHidden = 1 // hide text measures
				}
				Else {
					Set tSC = $$$ERROR($$$GeneralError,"The source type for a measure must be a literal value: " _ "Measures." _ tMsr.name _ ":" _ tMsr.sourceProperty)
					Quit
				}
			}
			
			// + WAL190
			Set tListingFilter = tMsr.listingFilterValue  // WAL222
			Set tListingFilterOperator = tMsr.listingFilterOperator
			// - WAL190

			// create fact for measure
			Set tAggregate = ""

			// validate and/or determine aggregate for this measure
			If ((tMsrType = "integer")||(tMsrType = "number")) {
				If (tMsr.aggregate = "") {
					Set tAggregate = "SUM"
				}
				Else {
					Set tAggregate = tMsr.aggregate
				}
			}
			ElseIf (tMsrType = "date") {
				If (tMsr.aggregate = "") {
					Set tAggregate = "AVG"
				}
				Else {
					Set tAggregate = tMsr.aggregate
				}
				If ((tAggregate'="MIN")&&(tAggregate'="MAX")&&(tAggregate'="AVG")) {
					Set tSC = $$$ERROR($$$GeneralError,"Aggregate function for date measure must be MIN, MAX, or AVG: " _ tMsr.name)
				}
			}
			ElseIf (tMsrType = "age") {
				If (tMsr.aggregate = "") {
					Set tAggregate = "AVG"
				}
				Else {
					// Invert min/max for age
					Set tAggregate = $CASE(tMsr.aggregate,"MIN":"MAX","MAX":"MIN",:tMsr.aggregate)
				}
				If ((tAggregate'="MIN")&&(tAggregate'="MAX")&&(tAggregate'="AVG")) {
					Set tSC = $$$ERROR($$$GeneralError,"Aggregate function for age measure must be MIN, MAX, or AVG: " _ tMsr.name)
				}
			}
			ElseIf (tMsrType = "boolean") {
				If (tMsr.aggregate = "") {
					Set tAggregate = "COUNT"
				}
				Else {
					Set tAggregate = tMsr.aggregate
				}
				If (tAggregate'="COUNT") {
					Set tSC = $$$ERROR($$$GeneralError,"Aggregate function for boolean measure must be COUNT: " _ tMsr.name)
				}
			}
			Else {
				If (tMsr.aggregate = "") {
					Set tAggregate = "COUNT"
				}
				Else {
					Set tAggregate = tMsr.aggregate
				}
				If (tAggregate'="COUNT") {
					Set tSC = $$$ERROR($$$GeneralError,"Aggregate function for string measure must be COUNT: " _ tMsr.name)
				}
			}
			If $$$ISERR(tSC) Quit
			
			// + WAL233 -- throw compile error if aggregate/operator mismatch
			If ((tAggregate'="")&&(tListingFilterOperator'="")) {
				If ((tAggregate="MAX")&&(tListingFilterOperator'="MAX")) {
					
					Set tSC = $$$ERROR($$$GeneralError,"Measure with MAX measure-specific listing operator must have MAX aggregate: " _ tMsr.name)
				}
				ElseIf ((tAggregate="MIN")&&(tListingFilterOperator'="MIN")) {
					
					Set tSC = $$$ERROR($$$GeneralError,"Measure with MIN measure-specific listing operator must have MIN aggregate: " _ tMsr.name)
				}
			}
			// - WAL233

			If (tMsrType = "age") {
				Set pMeta("hasAge") = 1
				Set tFactName = ..%GetFactName("Mx",tMsr.name,tSourceProperty,tSourceExpression,,,tLinkClass,tLinkProperty)
				Set tFactName = tFactName _ tScaleName _ tTypeName

				Do AddFact(tFactName,,"")
				Set pFactInfo("prop",tFactName,"mbrtype") = "m"
				Set pFactInfo("prop",tFactName,"msrname") = tMsr.name
				Set:tSourceProperty'="" pFactInfo("prop",tFactName,"source") = tSourceProperty
				Set:tSourceExpression'="" pFactInfo("prop",tFactName,"expr") = tSourceExpression
				Set pFactInfo("prop",tFactName,"type") = "%DeepSee.Datatype.dateTime"
				Set pFactInfo("prop",tFactName,"index") = "$none"
				Set:tLinkClass'="" pFactInfo("prop",tFactName,"linkClass") = tLinkClass
				Set:tLinkProperty'="" pFactInfo("prop",tFactName,"linkProperty") = tLinkProperty
				If (tMsrDateType'="") {
					Set pFactInfo("prop",tFactName,"dateType") = tMsrDateType
				}
				Set:tListingFilter'="" pFactInfo("prop",tFactName,"listingFilter") = tListingFilter // WAL190
				Set:tListingFilterOperator'="" pFactInfo("prop",tFactName,"listingFilterOperator") = tListingFilterOperator // WAL190

				// new fact for holding age
				Set tFxFactName = ..%GetFactName("MxFx",tMsr.name,tSourceProperty,tSourceExpression,,,tLinkClass,tLinkProperty)
				Set tFxFactName = tFxFactName _ tTypeName

				Do AddMeasure(tFxFactName,tMsr.factName)
				Set pFactInfo("prop",tFxFactName,"mbrtype") = "m"
				Set pFactInfo("prop",tFxFactName,"msrname") = tMsr.name
				Set pFactInfo("prop",tFxFactName,"type") = tMsrDataType
				Set pFactInfo("prop",tFxFactName,"index") = tMsrIndexType
				Set:+tMsr.searchable pFactInfo("prop",tFxFactName,"searchable") = tMsr.searchable
				Set pFactInfo("prop",tFxFactName,"function") = "%Convert"
				Set pFactInfo("prop",tFxFactName,"functionClass") = "%DeepSee.Age.Days"
				Set pFactInfo("prop",tFxFactName,"base") = tFactName
				Set tFactName = tFxFactName
				
				// Use special aggregate type for age
				// when we consolidate this value, we will convert age to current date
				Set tAggregate = tAggregate_":Days"
			}
			Else {
				Set tFactName = ..%GetFactName("Mx",tMsr.name,tSourceProperty,tSourceExpression,,,tLinkClass,tLinkProperty)
				// fact name must reflect if scale or type is overridden
				Set tFactName = tFactName _ tScaleName _ tTypeName

				Do AddMeasure(tFactName,tMsr.factName)
				Set pFactInfo("prop",tFactName,"mbrtype") = "m"
				Set pFactInfo("prop",tFactName,"msrname") = tMsr.name
				Set:tSourceProperty'="" pFactInfo("prop",tFactName,"source") = tSourceProperty
				Set:tSourceExpression'="" pFactInfo("prop",tFactName,"expr") = tSourceExpression
				Set pFactInfo("prop",tFactName,"type") = tMsrDataType
				Set pFactInfo("prop",tFactName,"index") = tMsrIndexType
				Set:+tMsr.searchable pFactInfo("prop",tFactName,"searchable") = tMsr.searchable
				Merge pFactInfo("prop",tFactName,"parms") = tFParms
				Set:tLinkClass'="" pFactInfo("prop",tFactName,"linkClass") = tLinkClass
				Set:tLinkProperty'="" pFactInfo("prop",tFactName,"linkProperty") = tLinkProperty
				Set:tListingFilter'="" pFactInfo("prop",tFactName,"listingFilter") = tListingFilter // WAL190
				Set:tListingFilterOperator'="" pFactInfo("prop",tFactName,"listingFilterOperator") = tListingFilterOperator // WAL190
				If (tMsrDateType'="") {
					Set pFactInfo("prop",tFactName,"dateType") = tMsrDateType
				}
			}

			// JMD1412
			If ((tMsrFormat="")&&(tMsrType = "date")) {
				Set tMsrFormat = "%date%"
			}
			// Link measure to Fact (d=0 for "measures")
			Set tMsrNo = tMsrNo + 1
			// WAL232 -- add listing filter info here
			Set pDimIndex(0,tMsrNo,0) = $LB("m","Measures",tMsr.name,,$$FactNo(tFactName),,tAggregate,tMsrType,+tScale,,tMsrHidden,tMsrFormat,tMsr.searchable,,$G(tListingFilterOperator),$G(tListingFilter))
			Set pCaptions("MEASURES",$$$UPPER(tMsr.name)) = $LB(tMsr.name,tMsr.displayName)
			Set pDescriptions("MEASURES",$$$UPPER(tMsr.name)) = $LB(tMsr.description) // JSL4475
		} // next measure
		If $$$ISERR(tSC) Quit
 
		#; now process relationships
		For r=1:1:pCube.relationships.Count() {
			Set tRel = pCube.relationships.GetAt(r)
			If (tRel.disabled) {
				Continue
			}
			
			// + DTB859 - [Validation] Check fctNumber assignments against cube setting
			If (pCube.namedFactNums) {
				If 'tRel.factNumber {
					$$$ThrowStatus($$$ERROR($$$GeneralError,"Fact number is required and unassigned to relationship " _ tRel.name))
				}
				ElseIf '$IsValidNum(tRel.factNumber) || (tRel.factNumber '= (tRel.factNumber\1)) {
					$$$ThrowStatus($$$ERROR($$$GeneralError,"Fact number must be an integer: " _ tRel.name _ " value: " _ tRel.factNumber))
				}
				Else {
					Set tAssignedFactNum = tRel.factNumber		// DTB918
				}
			}
			// - DTB859
			
			// PFS046 - Cubes can not define a relationship to themselves
			If ($$$UPPER(tRel.relatedCube)=$$$UPPER(pCube.name)) {
				Set tSC=$$$ERROR($$$GeneralError,"Cube relationship can not have itself as the relatedCube: "_tRel.name)
				$$$ThrowStatus(tSC)
			}
			Set tDimNo = tDimNo + 1
			Set tSourceProperty = tRel.sourceProperty
			Set tSourceExpression = tRel.sourceExpression

			Set tFactName = ..%GetFactName("Rx",tRel.name,tSourceProperty,tSourceExpression)
			Do AddFact(tFactName,,tRel.factName)

			Set tRelName = $$$UPPER(tRel.name)
			Set pRelationInfo(tRelName,"name") = tRel.name
			Set pRelationInfo(tRelName,"fact") = $S(tRel.factName="":tFactName,1:tRel.factName)
			Set pRelationInfo(tRelName,"relatedCube") = tRel.relatedCube
			Set pRelationInfo(tRelName,"inverse") = tRel.inverse
			Set pRelationInfo(tRelName,"cardinality") = tRel.cardinality
			Set pRelationInfo(tRelName,"nullReplacement") = tRel.nullReplacement
			
			// DTB639 - Do not allow a cardinality "one" to compile without a source property or expression
			If ((tRel.cardinality="one")&&(tSourceExpression="")&&(tSourceProperty="")) {
				Set tSC = $$$ERROR($$$GeneralError,"Relationship with cardinality 'one' must define a source: "_tRel.name)
				$$$ThrowStatus(tSC)
			}

			// determine which is the "stored" side of the relationship
			If ((tSourceExpression'="")||(tSourceProperty'="")) {
				Set pRelationInfo(tRelName,"storedSide") = 1
			}
			Else {
				Set pRelationInfo(tRelName,"storedSide") = 0
			}

			If ('pRelationInfo(tRelName,"storedSide")) {
				// there is no actual property on the "many" side
				Set pFactInfo("prop",tFactName,"type") = "$none"
			}
			Else {
				// if related cube exists, then use it as the property type
				Set tRelType = ##class(%DeepSee.Utils).%GetCubeFactClass(tRel.relatedCube,.x)
				Set:tRelType="" tRelType = "%Integer"

				// use list for "many" on the stored side
				If (tRel.cardinality = "many") {
					Set tRelType = "%DeepSee.Datatype.list"
					Set pFactInfo("prop",tFactName,"list") = 1
				}

				Set pFactInfo("prop",tFactName,"type") = tRelType
				Set pFactInfo("prop",tFactName,"mbrtype") = "r"
				// index on reference to fact in related cube
				Set pFactInfo("prop",tFactName,"index") = "bitmap"

				If (tSourceExpression'="") {
					// expression takes precedence over sourceProperty
					Set pFactInfo("prop",tFactName,"expr") = tSourceExpression
				}
				ElseIf (tSourceProperty '= "") {
					Set pFactInfo("prop",tFactName,"source") = tSourceProperty
				}

				// JMD1059 process dependsOn
				If (tRel.dependsOn'="") {
					// add to list; process later
					Set tDependsList(tDimNo,0,0) = tRel.dependsOn
				}
			}
			If ($$FactNo(tFactName) < 0) {
				// assign a real fact number
				Set tActualNo = $S($G(tAssignedFactNum)'="":tAssignedFactNum,1:$I(tActualFactNo))		// DTB918 - Use the assigned fact number if defined
				Kill pFactIndex($$FactNo(tFactName))
				Set pFactIndex(tActualNo) = tFactName
				Set pFactInfo("prop",tFactName) = tActualNo
				Set pRelIndex(tActualNo) = tRel.name
			}
			Set pDimIndex(tDimNo,0,0) = $LB("r",tRel.name,,,$$FactNo(tFactName),tRel.relatedCube,tRel.cardinality,tRel.inverse,+$G(pRelationInfo(tRelName,"storedSide")))
			Set pCaptions($$$UPPER(tRel.name)) = $LB(tRel.name,tRel.displayName)
			Set pDescriptions($$$UPPER(tRel.name)) = $LB(tRel.description) // JSL4475
		} // next relationship
		If $$$ISERR(tSC) Quit

		// construct index of member names
		Set tDimCount = 0
		Set d = $O(pDimIndex(""))
		While (d'="") {
			Set:d=+d d = +d // normalize numeric
			Set tAllName = $LG($G(pDimIndex(d,0,0)),4)

			Set tDimCount = tDimCount + 1
			Set tHierCount = 0
			Set h = $O(pDimIndex(d,""))
			While (h'="") {
				Set:h=+h h = +h // normalize numeric
				Set:+h>0 tHierCount = tHierCount + 1
				Set tLevelCount = 0
				Set lvl = $O(pDimIndex(d,h,""))
				While (lvl'="") {
					Set:+lvl>0 tLevelCount = tLevelCount + 1
					Set tDimName = $$$UPPER($LG(pDimIndex(d,h,lvl),2))
					Set tHierName = $$$UPPER($LG(pDimIndex(d,h,lvl),3))
					Set tLvlName = $$$UPPER($LG(pDimIndex(d,h,lvl),4))

					If (lvl = 0) {
						If (h = 0) {
							Set pDimNames(tDimName) = $LB(d,0,0)
							If (tAllName '= "") {
								Set pDimNames(tDimName,$$$UPPER(tAllName)) = $LB(d,1,1)
							}
						}
						Else {
							Set pDimNames(tDimName,tHierName) = $LB(d,h,0)
						}
					}
					Else {
						Set pDimNames(tDimName,tHierName,tLvlName) = $LB(d,h,lvl)
					}
					Set lvl = $O(pDimIndex(d,h,lvl))
				}
				If ((tLevelCount = 1)&&(tHierName '= "")) {
					// only one level, so reference to hier is a reference to this level
					Set pDimNames(tDimName,tHierName) = $LB(d,h,1)
				}
				Set h = $O(pDimIndex(d,h))
			}
			If ((tHierCount = 1) && (tDimName '= "MEASURES") && (tDimName '= "PROPERTIES")) {
				// only one hier, so reference to dim is a reference to this hier (or level)
				If (tLevelCount = 1) {
					Set pDimNames(tDimName) = $LB(d,1,1)
				}
				Else {
					Set pDimNames(tDimName) = $LB(d,1,0)
				}
			}
			Set d = $O(pDimIndex(d))
		}

		// JMD910: process dependsOn list
		If ($D(tDependsList)) {
			Set tDimNo = $O(tDependsList(""))
			While (tDimNo'="") {
				Set tHierNo = $O(tDependsList(tDimNo,""))
				While (tHierNo'="") {
					Set tLevelNo = $O(tDependsList(tDimNo,tHierNo,""))
					While (tLevelNo'="") {
						Set tSpecCSV = $G(tDependsList(tDimNo,tHierNo,tLevelNo))
						// spec can be csv list
						For px = 1:1:$L(tSpecCSV,",") {
							Set tSpec = $P(tSpecCSV,",",px)
							Kill tSpecInfo,tQuoted
							Set tRelAddr = ""
							Set tSC = ##class(%DeepSee.Query.Parser).%ParseMemberSpec(tSpec,.tSpecInfo,.tQuoted)
							If ($$$ISERR(tSC)) {
								Set tSC = $$$ERROR($$$GeneralError,"Invalid dependsOn spec: " _ tSpec)
								Quit
							}

							// JMD1059: test for [Relationship]
							If (($G(tSpecInfo(1))'="")&&($G(tSpecInfo(2))="")&&($G(tSpecInfo(3))="")) {
								// lookup relationship
								Set tRelAddr = $G(pDimNames($$$UPPER(tSpecInfo(1))))
								If (tRelAddr="") {
									Set tSC = $$$ERROR($$$GeneralError,"Level dependsOn refers to non-existing relationship: " _ tSpec)
									Quit
								}
							}
							ElseIf (($G(tSpecInfo(1))="")||($G(tSpecInfo(2))="")||($G(tSpecInfo(3))="")) {
								Set tSC = $$$ERROR($$$GeneralError,"Incomplete dependsOn spec: " _ tSpec)
								Quit
							}

							If (tRelAddr'="") {
								Set tRelInfo = $G(pDimIndex($LG(tRelAddr,1),$LG(tRelAddr,2),$LG(tRelAddr,3)))
								Set tFactNo = $LG(tRelInfo,5)
								If (tFactNo'="") {
									Set pDependList(tDimNo,tHierNo,tLevelNo,tFactNo) = tRelAddr
								}
							}
							Else {
								Set tLevelAddr = $G(pDimNames($$$UPPER(tSpecInfo(1)),$$$UPPER(tSpecInfo(2)),$$$UPPER(tSpecInfo(3))))
								If (tLevelAddr="") {
									Set tSC = $$$ERROR($$$GeneralError,"Level dependsOn refers to non-existing level: " _ tSpec)
									Quit
								}

								Set tLevelInfo = $G(pDimIndex($LG(tLevelAddr,1),$LG(tLevelAddr,2),$LG(tLevelAddr,3)))
								Set tFactNo = $LG(tLevelInfo,5)
						
								If (tFactNo'="") {
									Set pDependList(tDimNo,tHierNo,tLevelNo,tFactNo) = tLevelAddr
								}
							}
						}

						If $$$ISERR(tSC) Quit
						Set tLevelNo = $O(tDependsList(tDimNo,tHierNo,tLevelNo))
					}
					If $$$ISERR(tSC) Quit
					Set tHierNo = $O(tDependsList(tDimNo,tHierNo))
				}
				If $$$ISERR(tSC) Quit
				Set tDimNo = $O(tDependsList(tDimNo))
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC

	// add fact to local index of names
	Set (f,fname,alias) = ""
AddFact(f,virtual,alias,dimType)
	Set:'$D(virtual) virtual = 0
	If '$D(pFactInfo("prop",f)) {
		// we use negative fact numbers until we are sure
		// this is an actual level
		Set fno = -$I(pFactIndex)
		Set pFactIndex(fno) = f
		Set pFactInfo("prop",f) = fno
	}
	Else {
		// DTB918 - Check that the factNumber *and* $G(alias) matches what is already filed under this factID
		// If any of these don't match, the fact numbers can't be used.
		Set tPreviousFactNum = $G(pFactInfo("prop",f))
		If ($G(tAssignedFactNum)'="") && (tPreviousFactNum>0) && (tPreviousFactNum '= tAssignedFactNum) {
			Set tSC = $$$ERROR($$$GeneralError,"Multiple fact numbers defined for factID:"_f_":"_tAssignedFactNum)
			$$$ThrowStatus(tSC)
		}
		
		// DTB918 - Do an alias check if namedFactNums is on
		If pCube.namedFactNums && ($G(pFactInfo("prop",f,"alias")) '= $G(alias)) {
			Set tSC = $$$ERROR($$$GeneralError,"Alias mismatch when filing '" _ f _ "' : '" _ $G(pFactInfo("prop",f,"alias")) _ "' : '" _ $G(alias) _"'")
			$$$ThrowStatus(tSC)
		}
	}
	
	If ('$D(pFactInfo("prop",f,"virtual"))||'virtual) {
		// if there is a request to use a fact as "real"
		// that was initially virtual, make sure this happens
		Set pFactInfo("prop",f,"virtual") = virtual
	}
	If ($G(alias)'="") {
		If (($G(dimType) '= "time")&&($G(dimType) '= "age")) {
			Set pFactInfo("prop",f,"alias") = alias
		}
	}
	
	Quit

	// return fact/measure index for given name
FactNo(fname)
	Quit pFactInfo("prop",fname)

	// add measure to local index of names
AddMeasure(m,alias)
	If '$D(pFactInfo("prop",m)) {
		// This fact is not defined yet, free to go forward
		Set tActualMsrNo = $S($G(tAssignedMsrNum)'="":tAssignedMsrNum,1:$I(pMsrIndex))		// DTB859 - Use the assigned number if defined
		If $D(pMsrIndex("M"_tActualMsrNo ),prevM) && (prevM '= m) {
			Set tSC = $$$ERROR($$$GeneralError,"Multiple factID's defined for fact number:'M"_tAssignedMsrNum_"'")
		}
		Else {
			Set pMsrIndex("M"_tActualMsrNo ) = m
		}
		Set pFactInfo("prop",m) = "M"_tActualMsrNo
	}
	Else {
		// DTB918 - Check that the factNumber *and* $G(alias) matches what is already filed under this factID
		// If any of these don't match, the fact numbers can't be used.
		If ($G(tAssignedMsrNum)'="") && ($G(pFactInfo("prop",m)) '= ("M"_tAssignedMsrNum)) {
			Set tSC = $$$ERROR($$$GeneralError,"Multiple fact numbers defined for factID:'"_m_"':'M"_tAssignedMsrNum_"'")
			$$$ThrowStatus(tSC)
		}
		
		// DTB918 - Do an alias check if namedFactNums is on
		If pCube.namedFactNums && ($G(pFactInfo("prop",m,"alias")) '= $G(alias)) {
			Set tSC = $$$ERROR($$$GeneralError,"Alias mismatch when filing '" _ m _ "' : '" _ $G(pFactInfo("prop",m,"alias")) _ "' : '" _ $G(alias) _"'")
			$$$ThrowStatus(tSC)
		}
	}

	If ($G(alias)'="") {
		Set pFactInfo("prop",m,"alias") = alias
	}
	Quit
]]></Implementation>
</Method>

<Method name="%GetFactName">
<Description><![CDATA[
Construct a Fact (property) name based on the given specifications.<br/>
<var>pPrefix</var> is a prefix, such as "Dx".<br/>
<var>pName</var> is the name of an element (such as a level).<br/>
<var>pSourceProperty</var> is a source property name.<br/>
<var>pSourceExpression</var> is a source expression used to derive the fact.<br/>
<var>pFunction</var> is a function (or name of time level class) applied to the fact.<br/>
<var>pRangeExpression</var> is a range expression applied to the fact.<br/>
<var>pTimeOffset</var> is a time offset applied to the fact.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPrefix:%String,pName:%String,pSourceProperty:%String,pSourceExpression:%String="",pFunction:%String="",pRangeExpression:%String="",pLinkClass:%String="",pLinkProperty:%String="",pTimeOffset:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tFactName = ""
	If ((pSourceProperty = "")&&(pSourceExpression="")) {
		Set tFactName = $ZSTRIP(pName,"*P")
	}
	Else {
		// Process source name
		Set tSourceName = ""
		If (pSourceExpression'="") {
			// Use hash of expression
			Set tSourceName = $ZCRC(pSourceExpression,7)
		}
		Else {
			For j=$L(pSourceProperty,"."):-1:1 {
				Set tSourceName = tSourceName _ $S(tSourceName="":"",1:"Via")_ $P(pSourceProperty,".",j)
			}
		}
		Set tFactName = tSourceName
		If (pFunction'="") {
			Set tFactName = tFactName _ "Fx"_ pFunction
		}
		If (pRangeExpression'="") {
			Set tFactName = tFactName _ "Rg"_ $ZCRC(pRangeExpression,7)
		}
		If (pLinkClass'="") {
			Set tFactName = tFactName _ "Lx"_ $ZCRC(pLinkClass_pLinkProperty,7)
		}
		If (pTimeOffset'="") {
			Set tFactName = tFactName _ "Tx"_ $TR(pTimeOffset,"-","n")
		}
		Set tFactName = $ZSTRIP(tFactName,"*P")
	}
	// test if name is too long or is invalid
	If (($L(tFactName) > 25)||'$ZNAME(tFactName)) {
		Set tFactName = $ZCRC(tFactName,7)
	}
	Quit pPrefix _ tFactName
]]></Implementation>
</Method>

<Method name="%AddStarTable">
<Description><![CDATA[
Create a star (dimension) table to hold information for a given
level. The table may already exist.???
<var>pStarInfo</var> contains information about known star tables (and
gets modified by this method).<br/>
<var>pSchema</var> is the SQL schema to which the fact table belongs.<br/>
<var>pStarName</var> is the name of the star table (returned by reference).
This is used as the type of the fact.<br/>
<var>pLevelName</var> is the name of the current level.<br/>
<var>pSourceClass</var> is the source class for the cube.<br/>
<var>pSourceProperty</var> is the source property for the base fact.<br/>
<var>pSourceExpression</var> is the source expression for the base fact.<br/>
<var>pAlias</var> is the optional field name alias.<br/>
<var>pContext</var> contains the name of the model element currently
being processed (e.g., "Product.H1.Name"). This is used for error reporting.<br/>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%DeepSee.Model.cube,pSharedCube:%String,pSchema:%String,&pStarInfo:%String,*pStarName,pSourceClass:%String,pLevelName:%String,pSourceProperty:%String,pSourceExpression:%String,pLinkClass:%String,pLinkProperty:%String,pRangeExpression:%String,pAlias:%String,pContext:%String,pCollation:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// create a fact name; this will be the table name (unless an alias is in play)
		// the fact name is also used to disambiguate star tables
		Set tFactName = ..%GetFactName("Star", pLevelName, pSourceProperty, pSourceExpression,,pRangeExpression,pLinkClass,pLinkProperty)
		If (pAlias = "") {
			Set pStarName = tFactName
		}
		Else {
			Set pStarName = $ZSTRIP(pAlias,"*P")
		}

		If (pSharedCube'="") {
			// get schema from reference cube
			Set tRefClass = ##class(%DeepSee.Utils).%GetCubeFactClass(pSharedCube)
			Set pSchema = $P(tRefClass,".",1,$L(tRefClass,".")-1)
			Set pStarName = pSchema_"."_pStarName
		}
		Else {
			Set pStarName = pSchema_"."_pStarName
		}

		If $D(pStarInfo(pStarName)) {
			If ($G(pStarInfo(pStarName,"source")) '= tFactName) {
				Set tSC = $$$ERROR($$$GeneralError,"Ambiguous Star Table Name: " _ pStarName_" ("_pContext_")")
				Quit
			}
		}
		Else {
			Set pStarInfo(pStarName,"source") = tFactName
		}

		// add key property to star table
		If (pSharedCube="") {
			Set tSC = ..%AddPropertyToStar(pStarName,pLevelName,.pStarInfo,.tStarProp,pSourceClass,pSourceProperty,pSourceExpression,0,pLinkClass,pLinkProperty,pRangeExpression,pAlias,pContext,pCollation)
			If $$$ISERR(tSC) Quit
		}
		Else {
			Set tSourceClass = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pSharedCube),"sourceClass"))
			Set tSC = ..%AddPropertyToStar(pStarName,pLevelName,.pStarInfo,.tStarProp,tSourceClass,pSourceProperty,pSourceExpression,0,pLinkClass,pLinkProperty,pRangeExpression,pAlias,pContext,pCollation)
			If $$$ISERR(tSC) Quit
		}

		Set pStarInfo(pStarName,"prop",tStarProp,"use") = "key"
		Set:pCollation'="" pStarInfo(pStarName,"prop",tStarProp,"collation") = pCollation

		If (pSharedCube'="") {
			Set pStarInfo(pStarName,"sharedCube") = pSharedCube
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%AddPropertyToStar">
<Description><![CDATA[
Add an additional field to the given star table.<br/>
<var>pStarName</var> is the name of the star table.<br/>
<var>pPropName</var> is the name of the property (from the model).<br/>
<var>pStarInfo</var> contains information about known star tables (and
gets modified by this method).<br/>
<var>pStarProp</var> returns (by reference) the name of the new property.<br/>
<var>pSourceClass</var> is the source class for the cube.<br/>
<var>pSourceProperty</var> is the source property for the base fact.<br/>
<var>pSourceExpression</var> is the source expression for the base fact.<br/>
<var>pAlias</var> is the optional field name alias.<br/>
<var>pCollation</var> is the optional collation to apply ("" or "exact").<br/>
<var>pContext</var> contains the name of the model element currently
being processed (e.g., "Product.H1.Name"). This is used for error reporting.<br/>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStarName:%String,pPropName:%String,&pStarInfo:%String,*pStarProp:%String,pSourceClass:%String,pSourceProperty:%String,pSourceExpression:%String,pIsReference:%Boolean,pLinkClass:%String,pLinkProperty:%String,pRangeExpression:%String,pAlias:%String,pContext:%String,pCollation:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// create a fact name for the property.
		// use Dxr as prefix for reference properties
		Set tFactName = ..%GetFactName($S(pIsReference:"Dxr",1:"Dx"), pPropName, pSourceProperty, pSourceExpression,,pRangeExpression,pLinkClass,pLinkProperty)
		If (pAlias = "") {
			Set pStarProp = tFactName
		}
		Else {
			Set pStarProp = pAlias
		}

		// find the type of the property
		If ((pSourceProperty'="")&&(pRangeExpression="")&&(pSourceExpression="")) {
			Set tSC = ..%AnalyzeStarProperty(pSourceClass,pSourceProperty,.tType,.tParms,pContext)
			Set:tType="" tType="%Library.String"
			If ("datatype" '= $$$getClassType($$$NormalizeClassname(tType))) {
				// property is a reference (in the orginal source data)
				// treat is as a string in the model
				Set tType = "%Library.String"
				Set tParms("MAXLEN") = 1000
			}
			Quit:$$$ISERR(tSC)
		}
		Else {
			// expression
			Set tType = "%Library.String"
			Set tParms("MAXLEN") = 4000
		}

		If (pCollation="exact") {
			// JMD1080: always remember collation
			Set tParms("COLLATION") = "EXACT"
		}

		If $D(pStarInfo(pStarName,"prop",pStarProp)) {
			If ($G(pStarInfo(pStarName,"prop",pStarProp,"fact")) '= tFactName) {
				Set tSC = $$$ERROR($$$GeneralError,"Ambiguous Star Table Property Name: " _ pPropName_" ("_pContext_")")
				Quit
			}
		}
		If (pIsReference) {
			Set pStarInfo(pStarName,"prop",pStarProp,"isref") = 1
		}

		Set pStarInfo(pStarName,"prop",pStarProp,"type") = tType
		Merge pStarInfo(pStarName,"prop",pStarProp,"parms") = tParms 

		Set pStarInfo(pStarName,"prop",pStarProp,"vname") = pStarProp
		Set pStarInfo(pStarName,"prop",pStarProp,"fact") = tFactName
		If (pSourceExpression '= "") {
			Set pStarInfo(pStarName,"prop",pStarProp,"expr") = pSourceExpression
		}
		Else {
			Set pStarInfo(pStarName,"prop",pStarProp,"source") = pSourceProperty
		}
		Set pStarInfo(pStarName,"prop",pStarProp,"use") = "property"
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%AddRollupToStar">
<Description><![CDATA[
Add a rollup property to the given star table.<br/>
<var>pStarName</var> is the name of the star table.<br/>
<var>pRollupFact</var> is the name of the rollup fact.<br/>
<var>pFactInfo</var> is the array of information about facts.<br/>
<var>pStarInfo</var> contains information about known star tables.<br/>
<var>pContext</var> contains the name of the model element currently
being processed (e.g., "Product.H1.Name"). This is used for error reporting.<br/>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStarName:%String,pRollupFact:%String,&pFactInfo:%String,&pStarInfo:%String,pContext:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// find type of rollup fact-- this will be the rollup table
		Set tRollupType = $G(pFactInfo("prop",pRollupFact,"type"))
		Set tAlias = $G(pFactInfo("prop",pRollupFact,"alias"))
		Set tExpr = $G(pFactInfo("prop",pRollupFact,"expr"))
		Set tSource = $G(pFactInfo("prop",pRollupFact,"source"))

		Set tStarProp = pRollupFact
		If (tAlias'="") {
			Set tStarProp = tAlias
		}

		Set pStarInfo(pStarName,"prop",tStarProp,"type") = tRollupType
		Set pStarInfo(pStarName,"prop",tStarProp,"vname") = tStarProp
		Set pStarInfo(pStarName,"prop",tStarProp,"fact") = pRollupFact
		Set pStarInfo(pStarName,"prop",tStarProp,"use") = "rollup"
		If (tExpr '= "") {
			Set pStarInfo(pStarName,"prop",tStarProp,"expr") = tExpr
		}
		Else {
			Set pStarInfo(pStarName,"prop",tStarProp,"source") = tSource
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%CreateFactTable">
<Description><![CDATA[
Given meta data for a cube, create the set of Fact 
and Star Table classes related to it.<br/>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%DeepSee.Model.cube,pCubeClass:%String,pSchema:%String,pSourceType:%String,&pFactIndex:%String,&pFactInfo:%List,&pStarInfo:%List,&pMsrIndex:%String,&pRelationInfo:%String,&pStorage:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		#; create fact table class
		Set tClassDefName = pSchema_".Fact"
		Set tCubeName = $$$UPPER(pCube.name)

		#; we have to get SQL name manually as oddCOM does not exist yet!
		Set tFactTableName = $TR(pSchema,".","_")_".Fact"
		Set tListingTableName = $TR(pSchema,".","_")_".Listing"

		#; create star tables
		#; first find dependencies of star tables
		Set tStar = $O(pStarInfo(""))
		While (tStar '= "") {
			Set tDependsOn(tStar) = ""
			Set tProp = $O(pStarInfo(tStar,"prop",""))
			While (tProp '= "") {
				Set tType = $G(pStarInfo(tStar,"prop",tProp,"type"))
				If (tType '= "$none") {
					Set tClsType = $$$getClassType($$$NormalizeClassname(tType))
					If (tClsType '= "datatype") {
						// tType has precedence over tStar
						Set tDependsOn(tStar,tType) = ""
					}
				}
				Set tProp = $O(pStarInfo(tStar,"prop",tProp))
			}
			Set tStar = $O(pStarInfo(tStar))
		}

		Set tSC = ..%BuildOrderedList(.tDependsOn, .tOrderedStar)
	    If $$$ISERR(tSC) Quit

		Set n = $O(tOrderedStar(""))
		While (n '= "") {
			Set tStar = tOrderedStar(n)
			Set tShared = $G(pStarInfo(tStar,"sharedCube"))
			If (tShared="") {
				Set tSC = ..%CreateStarTable(pCube, pCubeClass, tStar, .pStarInfo)
			    If $$$ISERR(tSC) Quit
			}
			Else {
				// get index from ref cube
				Set tPrimaryIndex = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tShared),"star",tStar,"primary"))
				Set pStarInfo(tStar,"primary") = tPrimaryIndex
			}
			Set n = $O(tOrderedStar(n))
		}
	    If $$$ISERR(tSC) Quit

		#; Now create the fact table
		#; Delete any pre-existing definition
		If $$$defClassDefined(tClassDefName) {
		    Set tSC = $$Delete^%apiOBJ(tClassDefName,"-d")
		    If $$$ISERR(tSC) Quit
		}

		#; Create a new class definition
		Set tClassDef = ##class(%Dictionary.ClassDefinition).%New(tClassDefName)
		If tClassDef = $$$NULLOREF Set tSC=$$$ERROR($$$CannotCreateObject,"%Dictionary.ClassDefinition") Quit
		Set tClassDef.Super = "%DeepSee.FactTable,%DeepSee.CubeFunctionSet"
        Set tClassDef.IncludeCode = "%DeepSee"

		#; JMD1248: pick up includes from cube definition class
		If $IsObject($G(%class)) {
			Set:%class.IncludeCode'="" tClassDef.IncludeCode = tClassDef.IncludeCode_","_%class.IncludeCode
		}

        Set tClassDef.ProcedureBlock = 1
        Set tClassDef.Final = 1
		Set tClassDef.Owner = pCube.owner
        Set tClassDef.Description = "Fact table for cube '"_pCube.name_"'.<br/>"_$C(13,10)_
        							"THIS IS A GENERATED CLASS, DO NOT EDIT.<br/>"_$C(13,10)_
        							"Generated by %DeepSee.Generator:%CreateFactTable."

		#; CUBENAME param
		Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(tClassDefName_":"_"CUBENAME")
		Set tParmDef.Default = pCube.name
		Do tClassDef.Parameters.Insert(tParmDef)

		#; SOURCECLASS param
		Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(tClassDefName_":"_"SOURCECLASS")
		Set tParmDef.Default = pCube.sourceClass
		Do tClassDef.Parameters.Insert(tParmDef)

		#; BITMAPCHUNKINMEMORY param
		Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(tClassDefName_":"_"BITMAPCHUNKINMEMORY")
		Set tParmDef.Default = pCube.bitmapChunkInMemory
		Do tClassDef.Parameters.Insert(tParmDef)

		#; INITIALBUILDORDER param (for information only)
		If (pCube.initialBuildOrder'="") {
			Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(tClassDefName_":"_"INITIALBUILDORDER")
			Set tParmDef.Default = pCube.initialBuildOrder
			Do tClassDef.Parameters.Insert(tParmDef)
		}

		#; BUILDRESTRICTION param (for information only)
		If (pCube.buildRestriction'="") {
			Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(tClassDefName_":"_"INITIALBUILDRESTRICTION")
			Set tParmDef.Default = pCube.buildRestriction
			Do tClassDef.Parameters.Insert(tParmDef)
		}

		#; storage for fact table
		#dim tStorage As %Dictionary.StorageDefinition
		Set tStorage = ##class(%Dictionary.StorageDefinition).%New(tClassDefName_"||Default")
		Set tStorage.Name = "Default"
		Set tStorage.ExtentSize = 10000000
		Set tStorage.DataLocation = ..%GetFactLocation(tClassDefName)
		Set tStorage.StreamLocation = ..%GetFactLocation(tClassDefName,"S")
		
		// + DTB961 - Manage the actual data in the storage definition. This should be the only
		// <Data> tag present in a fact table's Storage definition. If the generated
		//   FactDefaultData
		// is also present in the compiled fact class, it means one or more properties were not properly 
		// accounted for in the manufacturing of storage data Value entries. Any properties that end
		// up in storage generated by the compiler instead of being assigned by this Generator 
		// should be considered an error.
		Set tFactStorageData = ##class(%Dictionary.StorageDataDefinition).%New()
		Do tFactStorageData.NameSet("FactManagedData")
		Do tStorage.Data.Insert(tFactStorageData)
		// - DTB961
		
		Do tClassDef.Storages.Insert(tStorage)

		#; extent index
		Set tExtent = "$" _ $P(tClassDefName,".",$L(tClassDefName,"."))
		Set tIndexStore = ##class(%Dictionary.StorageIndexDefinition).%New(tClassDefName_":Default"_tExtent)
		Set tIndexStore.Name = tExtent
		Set tIndexStore.Location = ..%GetIndexLocation(pCube.name,tExtent)
		Do tStorage.Indices.Insert(tIndexStore)

		#; count method
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%Count")
		Set tMeth.Name = "%Count"
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = ""
		Set tMeth.ReturnType = "%Integer"
		Set tMeth.Description = "Return the total number of items within the Fact table.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateFactTable."

		Set tMeth.SequenceNumber = $I(tSeq) + 2000

		Do tMeth.Implementation.WriteLine(" Set tCount = 0")
		Do tMeth.Implementation.WriteLine(" &sql(SELECT COUNT(*) INTO :tCount FROM "_tFactTableName_")")
		Do tMeth.Implementation.WriteLine(" Quit tCount")

		Do tClassDef.Methods.Insert(tMeth)

		#; create properties and indices
		#; link to source table
		Set tProp = ##class(%Dictionary.PropertyDefinition).%New(tClassDefName_"||%sourceId")
		Set tProp.Name = "%sourceId"
		If ((pSourceType = "kpi")||(pSourceType = "worksheet")||(pSourceType = "metric")) {
			Set tProp.Type = "%String"
		}
		Else {
			Set tProp.Type = $S(pCube.sourceClass'="":pCube.sourceClass,1:"%String")
		}
		Set tProp.Type = ..%DenormalizeType(tProp.Type)
		If (tProp.Type = "%String") {
			Do tProp.Parameters.SetAt(512,"MAXLEN")
		}
		Set tProp.Description = "Reference to original data in source table."
		Set tProp.SequenceNumber = $I(tSeq) + 1000
		Do tClassDef.Properties.Insert(tProp)
		
		// DTB961 - Insert %sourceId Storage. This is always name=1
		Set tValueDef = ..%MakePropStorageDef("%sourceId",.pStorage,.tNewStorage)
		Do:$IsObject(tValueDef) tFactStorageData.Values.Insert(tValueDef)
		// - DTB961

		// sourceId index
		/* 
		n.b. this is built manually
		Set tIndexDef = ##class(%Dictionary.IndexDefinition).%New(tClassDefName_"||"_tProp.Name)
		Set tIndexDef.Name = tProp.Name
		Set tIndexDef.Properties = tProp.Name
		Set tIndexDef.SequenceNumber = $I(tSeq)
		Do tClassDef.Indices.Insert(tIndexDef)

		Set tIndexStore = ##class(%Dictionary.StorageIndexDefinition).%New(tClassDefName_":"_tProp.Name)
		Set tIndexStore.Name = tProp.Name
		Set tIndexStore.Location = ..%GetIndexLocation(pCube.name,tProp.Name)
		Do tStorage.Indices.Insert(tIndexStore)
		*/

		/*
		// reverse sourceId index
		Set tReverseName = "%sourceIdReverse"
		Set tIndexDef = ##class(%Dictionary.IndexDefinition).%New(tClassDefName_"||"_tReverseName)
		Set tIndexDef.Name = tReverseName
		Set tIndexDef.Properties = "%%ID"
		Set tIndexDef.Data = tProp.Name
		Set tIndexDef.SequenceNumber = $I(tSeq)
		Do tClassDef.Indices.Insert(tIndexDef)

		Set tIndexStore = ##class(%Dictionary.StorageIndexDefinition).%New(tClassDefName_":"_tReverseName)
		Set tIndexStore.Name = tReverseName
		Set tIndexStore.Location = ..%GetIndexLocation(pCube.name,tReverseName)
		Do tStorage.Indices.Insert(tIndexStore)
		*/

		#; partition #
		Set tProp = ##class(%Dictionary.PropertyDefinition).%New(tClassDefName_"||%dspartition")
		Set tProp.Name = "%dspartition"
		Set tProp.Type = "%Integer"
		Set tProp.Calculated = 1
		Set tProp.SqlComputed = 1
		Set tProp.SqlComputeCode = "Set {"_tProp.Name_"}=({ID}\"_(16*64000)_")+1"
		Set tProp.Description = "This indicates which partition (set of 1M) this fact is in."
		Set tProp.SequenceNumber = $I(tSeq) + 1000
		Do tClassDef.Properties.Insert(tProp)
		// NB - This is computed, so it is not inserted into the storage definition

		#; JMD910 indices for level dependsOn
		Kill tDependsList
		Merge tDependsList = $$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCube.name),"levelDepends")
		If $D(tDependsList) {
			Set tDimNo = $O(tDependsList(""))
			While (tDimNo'="") {
				Set tHierNo = $O(tDependsList(tDimNo,""))
				While (tHierNo'="") {
					Set tLevelNo = $O(tDependsList(tDimNo,tHierNo,""))
					While (tLevelNo'="") {
						Set tLevelInfo = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCube.name),"mbr#",tDimNo,tHierNo,tLevelNo))
						Set tLevelFactNo = $LG(tLevelInfo,5)
						Set tLevelFactName =  $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCube.name),"fact#",tLevelFactNo))
						Set tLevelFactIsList = ($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCube.name),"fact","prop",tLevelFactName,"list"))) // WAL093
						If ($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCube.name),"fact","prop",tLevelFactName,"alias"))'="") {
							Set tLevelFactName = $$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCube.name),"fact","prop",tLevelFactName,"alias")
						}
			
						Set tFactNo = $O(tDependsList(tDimNo,tHierNo,tLevelNo,""))
						While (tFactNo'="") {
							Set tMasterFactName =  $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCube.name),"fact#",tFactNo))
							Set tMasterFactIsList = ($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCube.name),"fact","prop",tMasterFactName,"list"))) // WAL093
							If ($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCube.name),"fact","prop",tMasterFactName,"alias"))'="") {
								Set tMasterFactName = $$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCube.name),"fact","prop",tMasterFactName,"alias")
							}

							// define an index for this combination
							Set tIndexName = tMasterFactName_"AND"_tLevelFactName

							Set tIndexDef = ##class(%Dictionary.IndexDefinition).%New(tClassDefName_"||"_tIndexName)
							Set tIndexDef.Description = "Index for combination of "_tMasterFactName_" and "_tLevelFactName_"."
							Set tIndexDef.Name = tIndexName
							Set tIndexDef.Type = "bitmap"
							//
							// + WAL093 -- if either the master or the dependent level is a list we want to create
							//             the index with the keys of the list
							//
							//             For age a favorite color, we previously would have
							//
							//                Index(0,$lb("purple","yellow"))
							//
							//             Now we will have:
							//
							//               Index(0,"purple")         
							//               Index(0,"yellow")
							//
							//             This is the form that %DeepSee.Query.member*::%GetData and
							//             %DeepSee.Query.Engine::%FindDependentMembers need to return results
							//
							Set tMasterFactIndexSpec = $S(tMasterFactIsList:tMasterFactName_"(KEYS)",1:tMasterFactName)
							Set tLevelFactIndexSpec = $S(tLevelFactIsList:tLevelFactName_"(KEYS)",1:tLevelFactName)
							Set tIndexDef.Properties = tMasterFactIndexSpec_","_tLevelFactIndexSpec
							// - WAL093
							Set tIndexDef.SequenceNumber = $I(tSeq)
							Do tClassDef.Indices.Insert(tIndexDef)

							Set tIndexStore = ##class(%Dictionary.StorageIndexDefinition).%New(tClassDefName_":"_tIndexName)
							Set tIndexStore.Name = tIndexName
							Set tIndexStore.Location = ..%GetIndexLocation(pCube.name,tFactNo_"&"_tLevelFactNo)
							Do tStorage.Indices.Insert(tIndexStore)

							Set tFactNo = $O(tDependsList(tDimNo,tHierNo,tLevelNo,tFactNo))
						}
						Set tLevelNo = $O(tDependsList(tDimNo,tHierNo,tLevelNo))
					}
					Set tHierNo = $O(tDependsList(tDimNo,tHierNo))
				}
				Set tDimNo = $O(tDependsList(tDimNo))
			}
		}

		#; additional indices
		For n=1:1:pCube.indices.Count() {
			Set tIndex = pCube.indices.GetAt(n)
			If (tIndex.disabled) Continue
			Set tIndexName = "%User"_tIndex.name
			Set tIndexDef = ##class(%Dictionary.IndexDefinition).%New(tClassDefName_"||"_tIndexName)
			Set tIndexDef.Name = tIndexName
			Set tIndexDef.Properties = tIndex.properties
			Set tIndexDef.Type = tIndex.type
			Set tIndexDef.Description = tIndex.description
			Set tIndexDef.SequenceNumber = $I(tSeq)
			Do tClassDef.Indices.Insert(tIndexDef)

			// use same storage as built-in indices
			Set tIndexStore = ##class(%Dictionary.StorageIndexDefinition).%New(tClassDefName_":Default"_tIndexName)
			Set tIndexStore.Name = tIndexName
			// use index name as index subscript
			Set tIndexStore.Location = ..%GetIndexLocation(pCube.name,tIndexName)
			Do tStorage.Indices.Insert(tIndexStore)
		}

		#; check for local expressions; add to xform list
		#; first pass; pick up names of expressions
		Kill tExprNames
		For e=1:1:pCube.expressions.Count() {
			Set tExpr = pCube.expressions.GetAt(e)
			If ('tExpr.disabled) {
				Set tExprNames($$$UPPER(tExpr.name)) = ""
			}
		}

		#; second pass-process and validate
		Kill tExprDepends 	// list of dependencies
		Kill tExprList		// list of expression names (used to rank dependencies)
		Set tExprCount = pCube.expressions.Count()
		For e=1:1:tExprCount {
			Set tExpr = pCube.expressions.GetAt(e)
			If (tExpr.disabled) {
				Continue
			}
			Set tExprList(tExpr.name) = ""
			If (tExpr.sourceExpression'="") {
				Set tSC = ..%ParseExpression(tExpr.sourceExpression, .tCode, .tPropList)
				If $$$ISERR(tSC) Quit

				// now replace %expression
				Set tSC = ..%ParseExpression(tCode, .tCode, .tPropListX,"%expression")
				If $$$ISERR(tSC) Quit

				// make sure expression reference is valid
				Set ex = $O(tPropListX(""))
				While (ex'="") {
					If '$D(tExprNames($$$UPPER(ex))) {
						Set tSC = $$$ERROR($$$GeneralError,"Local expression is not defined: "_ ex)
						Quit
					}

					// remember which other expressions *this* expression relies on
					// so that we can process them in order
					Set tExprDepends(tExpr.name,ex) = ""

					// check for simple cycles
					If $D(tExprDepends(ex,tExpr.name)) {
						Set tSC = $$$ERROR($$$GeneralError,"Circular dependency in local expressions: "_ tExpr.name _ " and " _ ex)
						Quit
					}

					Set ex = $O(tPropListX(ex))
				}
				If $$$ISERR(tSC) Quit

				Merge tXFormProps = tPropList
				Set tXFormCodeLocal(tExpr.name) = tCode
			}
			ElseIf (tExpr.sourceProperty'="") {
				Set tXFormProps(tExpr.sourceProperty) = ""
				Set tXFormCodeLocal(tExpr.name) = "%source("_$$$quote(tExpr.sourceProperty)_")"
			}
		}
		If $$$ISERR(tSC) Quit

		#; compute score for expressions
		Kill tExprScore
		Kill tExprRanked
		Set tIter = 0
		While ($D(tExprList)&&(tIter < (tExprCount+1))) {
			Set x1 = $O(tExprList(""))
			While (x1'="") {
				If '$D(tExprDepends(x1)) {
					// we don't depend on anything
					Set tExprRanked(tIter,x1) = ""
					Set tExprScore(x1) = tIter
					Kill tExprList(x1)
				}
				Else {
					// check our dependencies
					Set tResolved = 1
					Set x2 = $O(tExprDepends(x1,""))
					While (x2'="") {
						If '$D(tExprScore(x2)) {
							Set tResolved = 0
							Quit
						}
						Set x2 = $O(tExprDepends(x1,x2))
					}
					If (tResolved) {
						Set tExprRanked(tIter,x1) = ""
						Set tExprScore(x1) = tIter
						Kill tExprList(x1)
					}
				}
				Set x1 = $O(tExprList(x1))
			}
			Set tIter = tIter + 1
		}

		If $D(tExprList) {
			Set x1 = $O(tExprList(""))
			Set tSC = $$$ERROR($$$GeneralError,"Unresolved dependencies in local expression: " _ x1)
			Quit
		}

		#; properties (in fact # order)
		#; (merge fact and measure lists)
		Merge tPropIndex = pFactIndex
		Merge tPropIndex = pMsrIndex

		Set tFactNo = $O(tPropIndex(""))
		While (tFactNo '= "") {
			Set tName = tPropIndex(tFactNo)
			Set tType = $G(pFactInfo("prop",tName,"type"))
			If (tType '= "$none") {
				Set tAlias = $G(pFactInfo("prop",tName,"alias"))
				Set tPropName = $S(tAlias'="":tAlias,1:tName)
				Set tIsList = +$G(pFactInfo("prop",tName,"list"))
				Set tIsTime = +$G(pFactInfo("prop",tName,"isTime"))
				Set tIsRef = +$G(pFactInfo("prop",tName,"isref"))
				Set tDelim = $G(pFactInfo("prop",tName,"listDelimiter"))
				Set tRangeExpr = $G(pFactInfo("prop",tName,"rangeExpr"))
				Set tUseDisplay = +$G(pFactInfo("prop",tName,"useDisplay"))
				Set tVirtual = +$G(pFactInfo("prop",tName,"virtual"))
				Set tDateType = $G(pFactInfo("prop",tName,"dateType"))
				Set tTimeOffset = $G(pFactInfo("prop",tName,"timeOffset"))

				Set tIndexType = $G(pFactInfo("prop",tName,"index"))
				Set tFunction = $G(pFactInfo("prop",tName,"function"))
				Set tFunctionClass = $G(pFactInfo("prop",tName,"functionClass"))
				Kill tOptions
				Merge tOptions = pFactInfo("prop",tName,"options")
				Set tBase = $G(pFactInfo("prop",tName,"base"))
				Set tMbrType = $G(pFactInfo("prop",tName,"mbrtype"))
				Set tMemberType = $Case(tMbrType,"r":$$$Text("Relationship","%DeepSee"),"m":$$$Text("Measure","%DeepSee"),:$$$Text("Dimension","%DeepSee"))
				Set tSource = $G(pFactInfo("prop",tName,"source"))
				Set tSourceExpression = $G(pFactInfo("prop",tName,"expr"))
				Set tLocalSource = $G(pFactInfo("prop",tName,"localSource"))
				Set tLocalSourceExpression = $G(pFactInfo("prop",tName,"localExpr"))
				Set tIsStar = +$G(pFactInfo("prop",tName,"star"))
				Set tMsrSearchable = +$G(pFactInfo("prop",tName,"searchable"))

				Set tLinkClass = $G(pFactInfo("prop",tName,"linkClass"))
				Set tLinkProperty = $G(pFactInfo("prop",tName,"linkProperty"))

				// test for null replacement
				If (('tIsTime) && ('tVirtual) && (tMbrType="d")) {
					Set tNullProps(tPropName) = ""
				}

				If (tIsList && (tDelim="")) {
					// this is a $List; we will need to know this in null replacement
					Set tNullPropsList(tPropName) = ""
				}

				If ((tLinkClass'="")&&(tLinkProperty'="")) {
					Set tLinkProps(tName) = tPropName
				}
				
				// overrides
				If (tLocalSourceExpression'="") {
					Set tSourceExpression = tLocalSourceExpression
				}
				ElseIf ((tSourceExpression'="")&&(tLocalSource'="")) {
					// replace expression with synthetic expression
					Set tSourceExpression = "%source."_tLocalSource
				}

				If (tRangeExpr'="") {
					Set tRangeProps(tPropName) = tRangeExpr
					If (tIsList && (tDelim="")) {
						// this is a $List; we will need to know this later
						Set tRangePropsList(tPropName) = ""
					}
				}

				If (tDateType'="") {
					Set tDateTypeProps(tPropName) = tDateType
				}

				// gather info used to test if dimensions are modified by update
				// JMD1077: make sure member is not a measure or relation
				If ((tFactNo>0)&&(tMbrType'="m")&&(tMbrType'="r")&&('tVirtual)) {
					// JMD1452 add list and delim info
					Set tLevelTest(tFactNo) = $LB(tPropName,tFunctionClass,tFunction,tBase,tTimeOffset,tIsList,tDelim)
				}

				Set tSQLCompute = ""
				If ((tBase'="")&&(tFunction'="")&&(tFunctionClass'="")) {
					Set tFunctions(tFunction) = ""
					// pass (inverse) time offset along
					Set tTimeOffset = $ZSTRIP(tTimeOffset,"<>W")
					// Invert offset
					If ($E(tTimeOffset)="-") {
						Set tTimeOffset = $E(tTimeOffset,2,$L(tTimeOffset))
					}
					ElseIf (tTimeOffset'="") {
						Set tTimeOffset = "-"_tTimeOffset
					}
					Set tOptions("POFFSET") = tTimeOffset
					Set tSC = ..%MakeSQLCompute(.tSQLCompute,tFunctionClass,tFunction,tBase,.tOptions)
					If $$$ISERR(tSC) Quit
				}

				#; gather info for %ProcessFact (all facts)
				If (tSourceExpression'="") {
					Set tSC = ..%ParseExpression(tSourceExpression, .tCode, .tPropList)
					If $$$ISERR(tSC) Quit

					// now replace %expression
					Set tSC = ..%ParseExpression(tCode, .tCode, .tPropListX,"%expression")
					If $$$ISERR(tSC) Quit

					// make sure expression reference is valid
					Set ex = $O(tPropListX(""))
					While (ex'="") {
						If '$D(tXFormCodeLocal(ex)) {
							Set tSC = $$$ERROR($$$GeneralError,"Local expression is not defined: "_ ex)
							Quit
						}
						Set ex = $O(tPropListX(ex))
					}
					If $$$ISERR(tSC) Quit

					Set tXFormCode(tPropName) = tCode
					// JMD929: track properties used by this expression if %value is used
					If (tCode["%value") {
						Merge tXFormCode(tPropName,"src") = tPropList
						Merge tXFormCode(tPropName,"exp") = tPropListX
					}
					Merge tXFormProps = tPropList
					If (tIsStar) {
						Set tStarField(tType,tPropName) = ""
						Set tStarField(tType,tPropName,"fact") = tFactNo
						If (tIsList) {
							Set tStarField(tType,tPropName,"list") = 1
							Set tStarField(tType,tPropName,"listDelimiter") = tDelim
						}
					}
				}
				ElseIf (tSource'="") {
					// JMD1184: modify the source field name by tacking on modifiers with "~~"
					// This makes it possible to refer to the same source fields with
					// different modifiers (specifically: logical and display value of same field)
					// source~~EXTERNAL - indicates that we need to fetch the display value
					// n.b.: this affects users of %InjectFact
					If (tUseDisplay) {
						Set tSource = tSource _ "~~EXTERNAL"
					}
					If '$D(tSelectList(tSource)) {
						If ('tIsRef) {
							// don't fetch reference props
							Set tSelectList(tSource) = tPropName
							Set:tLocalSource'="" tLocalSelectList(tSource) = tLocalSource
						}
					}
					// JMD1256 do not test for virtual fields
					ElseIf (tSQLCompute="") {
						// this property is based on a source field already in the list
						Set tCopyFromList(tPropName) = tSelectList(tSource)
					}

					If (('tVirtual) && (tSQLCompute="")) {
						// do not insert computed or virtual fields
						Set tInsertList(tPropName) = tSelectList(tSource)
					}

					// reference to STAR table
					If (tIsStar) {
						Set tStarField(tType,tPropName) = ""
						Set tStarField(tType,tPropName,"fact") = tFactNo
						If (tIsList) {
							Set tStarField(tType,tPropName,"list") = 1
							Set tStarField(tType,tPropName,"listDelimiter") = tDelim
						}
					}
				}
				// Create properties for all non-virtual facts
				// tFactsPrecompute contains a list of facts that can be precomputed
				// (in combination with measures in tMeasuresPrecompute)
				If ('tVirtual) {
					// keep track of iKnow properties; do not store them
					If (tIndexType["iKnow") {
						Set tiKnowProps(tName) = tIndexType, tiKnowSkip(tPropName) = ""
					}
					Else {
						Set tProp = ##class(%Dictionary.PropertyDefinition).%New(tClassDefName_"||"_tPropName)
						Set tProp.Name = tPropName
						If (tIsList) {
							Set tProp.Type = "%DeepSee.Datatype.list"
						}
						Else {
							If (..%IsString(tType)) {
								// DTB491 - If this is a custom type that extends %String, treat it like a %String
								Set tType = "%String"
							}
							Set tProp.Type = ..%DenormalizeType(tType)
						}
						Set tOrigSource = $P(tSource,"~~",1)
						Set tProp.Description = ..%MakeDescription(tMemberType,tPropName,tOrigSource)
						If (tSourceExpression '= "") {
							Set tProp.Description = tProp.Description _ $C(13,10) _ $$$Text("Expression: ","%DeepSee") _ tSourceExpression
						}
						Set tProp.SequenceNumber = $I(tSeq) + 1000

						If (tSQLCompute'="") {
							Set tProp.Calculated = 1
							Set tProp.SqlComputed = 1
							Set tProp.SqlComputeCode = "Set {"_tPropName_"}=" _ tSQLCompute
							// + WAL212
							If (tIsTime) {
								Set tProp.Type = "%Library.String" // WAL212 -- the compute code we use returns strings
								Do tProp.Parameters.SetAt("EXACT","COLLATION")
							}
							// - WAL212
						}
						Do tClassDef.Properties.Insert(tProp)
						
						// + DTB961 - Insert Data Value into the storage definition for non-calculated properties
						If ('tProp.Calculated) {
							// Manufacture the storage definition for the current property
							Set tValueDef = ..%MakePropStorageDef(tPropName,.pStorage,.tNewStorage)
							Do:$IsObject(tValueDef) tFactStorageData.Values.Insert(tValueDef)
						}
						// - DTB961
						

						// property parameters
						Set tFType = $$$getClassType($$$NormalizeClassname(tProp.Type))
						If (tIsList) {
							Do tProp.Parameters.SetAt("EXACT","COLLATION")
							If (tDelim = "") {
								Do tProp.Parameters.SetAt("LIST","LISTTYPE")
							}
							Else {
								Do tProp.Parameters.SetAt(tDelim,"DELIMITER")
							}
						}
						ElseIf (tFType = "datatype") {
							Set parm = $O(pFactInfo("prop",tName,"parms",""))
							While (parm '= "") {
								Set value = $G(pFactInfo("prop",tName,"parms",parm))
								Do tProp.Parameters.SetAt(value,parm)
								Set parm = $O(pFactInfo("prop",tName,"parms",parm))
							}
						}
						Else {
							// JMD878 selectivity
							Set value = $G(pFactInfo("prop",tName,"parms","SELECTIVITY"))
							Do:value'="" tProp.Parameters.SetAt(value,"SELECTIVITY")
						}
					} // iknow

					// create index for property (if it is a measure or a level)
					If ((tMbrType'="")&&(tIndexType '= "$none")&&(tIndexType'["iKnow")) {
						Set tIndexDef = ##class(%Dictionary.IndexDefinition).%New(tClassDefName_"||"_tPropName)
						Set tIndexDef.Name = tPropName
						If (tIndexType = "bitmap") {
							Set tIndexDef.Description = "Index for fact "_tFactNo_"."
							If (tMbrType="d") {
								Set tFactsPrecompute(tPropName) = $LB(tFactNo)
							}
							ElseIf (tMbrType="m") {
								Set tMeasuresPrecompute(tPropName) = $LB(tFactNo)
							}

							If (tIsList) {
								// collection index
								Set tIndexDef.Properties = tPropName_"(KEYS)"
							}
							Else {
								Set tIndexDef.Properties = tPropName
							}
						}
						ElseIf (tIndexType = "bitslice") {
							// n.b., bitslice does not support multiple properties.
							// !!! we need this to support partitioned indices
							Set tIndexDef.Description = "Index for measure "_tFactNo_"."
							Set tIndexDef.Properties = tPropName
							Set tMeasuresPrecompute(tPropName) = $LB(tFactNo)
						}
						ElseIf (tIndexType = "text") {
							Set tIndexDef.Description = "Index for measure "_tFactNo_"."
							Set tIndexDef.Properties = tPropName _ "(KEYS)"
							Set tIndexType = "bitmap"
						}
						Else {
							Set tIndexDef.Description = "Index for measure "_tFactNo_"."
							Set tIndexDef.Properties = tPropName
						}

						Set tIndexDef.Type = tIndexType
						Set tIndexDef.SequenceNumber = $I(tSeq)
						Do tClassDef.Indices.Insert(tIndexDef)

						Set tIndexStore = ##class(%Dictionary.StorageIndexDefinition).%New(tClassDefName_":Default"_tPropName)
						Set tIndexStore.Name = tPropName
						// use fact # as index subscript
						Set tIndexStore.Location = ..%GetIndexLocation(pCube.name,tFactNo)
						Do tStorage.Indices.Insert(tIndexStore)

						If (tMsrSearchable && (tIndexType = "bitslice")) {
							// add additional index for this measure
							Set tIndexDef = ##class(%Dictionary.IndexDefinition).%New(tClassDefName_"||"_tPropName_"Search")
							Set tIndexDef.Name = tPropName_"Search"
							Set tIndexDef.Description = "Search index for fact "_tFactNo_"."
							Set tIndexDef.Properties = tPropName
							Set tIndexDef.Type = "bitmap"
							Set tIndexDef.SequenceNumber = $I(tSeq)
							Do tClassDef.Indices.Insert(tIndexDef)

							Set tIndexStore = ##class(%Dictionary.StorageIndexDefinition).%New(tClassDefName_":Default"_tPropName_"Search")
							Set tIndexStore.Name = tPropName_"Search"
							// use propname as index subscript
							Set tIndexStore.Location = ..%GetSearchIndexLocation(pCube.name,tPropName_"Search")
							Do tStorage.Indices.Insert(tIndexStore)
						}
						
						// DTB753 - Add Foreign Key constraint
						If ($E(tType)'="%") { 
							Set tFKDef = ##class(%Dictionary.ForeignKeyDefinition).%New()
							Set tFKDef.Name = tPropName
							Set tFKDef.NoCheck = 1		// Check is not needed and carries a performance penalty. Turn it off.
							Set tFKDef.Properties = tPropName
							Set tFKDef.ReferencedClass = tType
							Set tFKDef.ReferencedKey = ""		// blank means use ID
							Do tClassDef.ForeignKeys.Insert(tFKDef)
						}
					}
				} // 'tVirtual
			} // '$none
			If $$$ISERR(tSC) Quit

			Set tFactNo = $O(tPropIndex(tFactNo))
		}
		If $$$ISERR(tSC) Quit
		
		// DTB961 - Return the list of storage positions that were actually encountered when
		// processing the columns in the cube definition. This is where deleted elements will be
		// removed from the incoming storage, freeing up storage slots for creation of future elements
		Kill pStorage
		Merge pStorage = tNewStorage

		#; %UpdateFacts, %BuildAllFacts, and %BuildTempFile methods
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%UpdateFacts")
		Set tMeth.Name = "%UpdateFacts"
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = "pStartId:%String,pEndId:%String,pBatchMode:%Boolean=0,&pChunks:%Integer,pVerbose:%Boolean=0,pTaskGroup:%String="""",*pUpdates:%Integer,pRefProp:%String="""",pRefID:%String="""",&pDimTables,pFactList:%String="""""		// DTB886 - Add pFactList
		Set tMeth.ReturnType = "%Status"
		Set tMeth.Description = "Update a range of Facts with data from the source table row with ids from <var>pStartId</var> to <var>pEndId</var>.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateFactTable.<br/>"_$C(13,10)_
       							"DO NOT CALL THIS METHOD DIRECTLY"
		Set tMeth.SequenceNumber = $I(tSeq) + 2000

		// tMeth2 is the %BuildAllFacts method
		// which is *almost* the same as the %UpdateFacts method
		Set tMeth2 = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%BuildAllFacts")
		Set tMeth2.Name = "%BuildAllFacts"
		Set tMeth2.ClassMethod = 1
		Set tMeth2.FormalSpec = "pVerbose:%Boolean=0,pFactList:%String="""""		// DTB886 - Add the pFactList
		Set tMeth2.ReturnType = "%Status"
		Set tMeth2.Description = "Update all Facts with data from the source table.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateFactTable.<br/>"_$C(13,10)_
       							"DO NOT CALL THIS METHOD DIRECTLY"
		Set tMeth2.SequenceNumber = $I(tSeq) + 2000

		// tMeth3 is the %BuildTempFile method
		// which uses a similar SQL query to get source id values
		Set tMeth3 = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%BuildTempFile")
		Set tMeth3.Name = "%BuildTempFile"
		Set tMeth3.ClassMethod = 1
		Set tMeth3.FormalSpec = "pTempKey:%String,*pImplemented:%Boolean,pVerbose:%Boolean=0"
		Set tMeth3.ReturnType = "%Status"
		Set tMeth3.Description = "Create a temp file of all source ids.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateFactTable.<br/>"_$C(13,10)_
       							"DO NOT CALL THIS METHOD DIRECTLY"
		Set tMeth3.SequenceNumber = $I(tSeq) + 2000
		
		// DTB422 - tMeth4 is the %CheckSourceId method
		Set tMeth4 = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%CheckSourceId")
		Set tMeth4.Name = "%CheckSourceId"
		Set tMeth4.ClassMethod = 1
		Set tMeth4.FormalSpec = "pTestId:%String,pVerbose:%Boolean=0,*pSC:%Status"
		Set tMeth4.ReturnType = "%Boolean"
		Set tMeth4.Description = "Check for the existence of a single ID in the source table.<br/>"_$C(13,10)_
       							"DO NOT CALL THIS METHOD DIRECTLY"
		Set tMeth4.SequenceNumber = $I(tSeq) + 2000

		// come up with cursor names for this class
		Set tCursorSq = ..%CreateCursorName("sq",tClassDefName) 
		Set tCursorSq2 = ..%CreateCursorName("sq2",tClassDefName)
		Set tCursorSq3 = ..%CreateCursorName("sq3",tClassDefName)
		Set tCursorEq = ..%CreateCursorName("sqeq",tClassDefName)

		Set tPersistent = (pSourceType = "persistent")
		Set tKPI = (pSourceType = "kpi")||(pSourceType = "worksheet")||(pSourceType = "metric")
		// generate different code for different data sources
		If (tKPI) {
			// get data from KPI
			Do tMeth.Implementation.WriteLine(" Set tSC = $$$OK")
			Do tMeth.Implementation.WriteLine(" New %var,%source,%ROWID,%msg,%dsSourceId,%dsSourceObj")
			Do tMeth2.Implementation.WriteLine(" Set tSC = $$$OK")
			Do tMeth2.Implementation.WriteLine(" New %var,%source,%ROWID,%msg,%dsSourceId,%dsSourceObj")

			Do tMeth3.Implementation.WriteLine(" Set tSC = $$$OK")
			Do tMeth3.Implementation.WriteLine(" Set pImplemented = 0")
			
			// DTB422
			Do tMeth4.Implementation.WriteLine(" // Method generation added by DTB422")
			Do tMeth4.Implementation.WriteLine(" Set tSourceExists = 0")
			Do tMeth4.Implementation.WriteLine(" Set pSC = $$$OK")
			Do tMeth4.Implementation.WriteLine(" Try {")

			Do tMeth.Implementation.WriteLine(" Try {")
			Do tMeth.Implementation.WriteLine(" Set tUseFactList = ($G(pFactList)'="""")")		// DTB893 - Test for factList
			Do tMeth.Implementation.WriteLine(" Set (tStarId,tRecord) = """"")
			Do tMeth.Implementation.WriteLine(" Set pUpdates = 0")
			Do tMeth.Implementation.WriteLine(" Set tLastCount = 0")

			Do tMeth2.Implementation.WriteLine(" Try {")
			Do tMeth2.Implementation.WriteLine(" Set tUseFactList = ($G(pFactList)'="""")")		// DTB893 - Test for factList
			Do tMeth2.Implementation.WriteLine(" Set (tStarId,tRecord) = """"")
			Do tMeth2.Implementation.WriteLine(" Set tLastCount = 0")

			Do tMeth3.Implementation.WriteLine(" Try {")
		}
		ElseIf ('tPersistent) {
			// get data from data connector API
			Do tMeth.Implementation.WriteLine(" Set tSC = $$$OK")
			Do tMeth.Implementation.WriteLine(" New %var,%source,%ROWID,%msg,%dsSourceId,%dsSourceObj")
			Do tMeth2.Implementation.WriteLine(" Set tSC = $$$OK")
			Do tMeth2.Implementation.WriteLine(" New %var,%source,%ROWID,%msg,%dsSourceId,%dsSourceObj")
			Do tMeth3.Implementation.WriteLine(" Set tSC = $$$OK")
			Do tMeth3.Implementation.WriteLine(" Set pImplemented = 0")
			
			// DTB422
			Do tMeth4.Implementation.WriteLine(" // Method generation added by DTB422")
			Do tMeth4.Implementation.WriteLine(" Set tSourceExists = 0")
			Do tMeth4.Implementation.WriteLine(" Set pSC = $$$OK")
			Do tMeth4.Implementation.WriteLine(" Try {")

			Do tMeth.Implementation.WriteLine(" Try {")
			Do tMeth.Implementation.WriteLine(" Set tUseFactList = ($G(pFactList)'="""")")		// DTB893 - Test for factList
			Do tMeth.Implementation.WriteLine(" Set (tStarId,tRecord) = """"")
			Do tMeth.Implementation.WriteLine(" Set pUpdates = 0")
			Do tMeth.Implementation.WriteLine(" Set tLastCount = 0")

			Do tMeth2.Implementation.WriteLine(" Try {")
			Do tMeth.Implementation.WriteLine(" Set tUseFactList = ($G(pFactList)'="""")")		// DTB893 - Test for factList
			Do tMeth2.Implementation.WriteLine(" Set (tStarId,tRecord) = """"")
			Do tMeth2.Implementation.WriteLine(" Set tLastCount = 0")

			Do tMeth3.Implementation.WriteLine(" Try {")
		}
		Else {
			// generate queries against source class
			Do tMeth.Implementation.WriteLine(" Set tSC = $$$OK")
			Do tMeth.Implementation.WriteLine(" Set tRS = """"")
			Do tMeth.Implementation.WriteLine(" New %var,%source,%ROWID,%msg,%dsSourceId,%dsSourceObj")
			Do tMeth2.Implementation.WriteLine(" Set tSC = $$$OK")
			Do tMeth2.Implementation.WriteLine(" New %var,%source,%ROWID,%msg,%dsSourceId,%dsSourceObj")
			Do tMeth3.Implementation.WriteLine(" Set tSC = $$$OK")
			Do tMeth3.Implementation.WriteLine(" New %var,%source,%ROWID,%msg,%dsSourceId,%dsSourceObj")
			Do tMeth3.Implementation.WriteLine(" Set pImplemented = 1")
			
			// DTB422
			Do tMeth4.Implementation.WriteLine(" // Method generation added by DTB422") 
			Do tMeth4.Implementation.WriteLine(" Set tSourceExists = 0")
			Do tMeth4.Implementation.WriteLine(" Set pSC = $$$OK")
			Do tMeth4.Implementation.WriteLine(" Try {")

			Do tMeth.Implementation.WriteLine(" Try {")
			Do tMeth.Implementation.WriteLine(" Set tUseFactList = ($G(pFactList)'="""")")		// DTB893 - Test for factList
			Do tMeth.Implementation.WriteLine(" Set (SQLCODE,tStarId) = """"")
			Do tMeth.Implementation.WriteLine(" Set pUpdates = 0")
			Do tMeth.Implementation.WriteLine(" Set tLastCount = 0")

			Do tMeth2.Implementation.WriteLine(" Try {")
			Do tMeth.Implementation.WriteLine(" Set tUseFactList = ($G(pFactList)'="""")")		// DTB893 - Test for factList
			Do tMeth2.Implementation.WriteLine(" Set (SQLCODE,tStarId) = """"")
			Do tMeth2.Implementation.WriteLine(" Set tLastCount = 0")

			Do tMeth3.Implementation.WriteLine(" Try {")
			Do tMeth3.Implementation.WriteLine(" Set (SQLCODE,tStarId) = """"")
			Do tMeth3.Implementation.WriteLine(" Kill $$$DeepSeeTempSourceId(pTempKey)")

			#; generate query against source table
			Set tSourceTableName = ..%GetSQLTableName(pCube.sourceClass)
			If (tSourceTableName = "") {
				Set tSC = $$$ERROR($$$GeneralError,"No source table specified '" _ pCube.sourceClass _ "'")
				Quit
			}

			#; generate 3 queries for %UpdateFacts: 2 embedded and 1 dynamic
			#; 1 embedded uses BETWEEN, the other =
			#; we use the dynamic one for processing changes to source reference tables

			Set tSourceId = "%ID"
			Set SELECT = tSourceId		// between & equals
			Set SELECTDYN = tSourceId	// dynamic
			Set INTO = " :tID"
			Set f = $O(tSelectList(""))
			While (f '= "") {
				Set tFName = $P(f,"~~",1)	// JMD1184
				Set tFModifier = $P(f,"~~",2)
				// translate fx from property to field name
				If ($G(tLocalSelectList(f))'="") {
					// if there is a local override, select that and provide an alias
					// to the real name
					Set fld = ..%GetSQLFieldExpression(.tSC,pCube.sourceClass,tLocalSelectList(f),1)
				    If $$$ISERR(tSC) Quit
				}
				Else {
					Set fld = ..%GetSQLFieldExpression(.tSC,pCube.sourceClass,tFName,1)
				    If $$$ISERR(tSC) Quit
				}

				Set tExternalTable=($$$defMemberKeyGet(pCube.sourceClass,$$$cCLASSparameter,"CONNECTION",$$$cPARAMdefault)'="")
			    // apply %EXTERNAL if useDisplay is in effect
			    // ignore this for linked tables as SQL cannot handle this!
				// JMD1184 remove tDisplay, use modifier
			    If ((tFModifier="EXTERNAL")&&'tExternalTable) {
					Set fld =  "%EXTERNAL(" _ fld _ ")"
				}

				// use fact name as alias for each column (unless it is the same)
				Set SELECT = SELECT _ "," _ fld
				Set:(fld'=tSelectList(f)) SELECT = SELECT _ " " _ $$$quoteIfDelimId(tSelectList(f)) // JSL4470 only quote if delimited identifiers is on
				Set SELECTDYN = SELECTDYN _ "," _ fld
				Set:(fld'=tSelectList(f)) SELECTDYN = SELECTDYN _ " " _ $$$quoteIfDelimId(tSelectList(f)) // JSL4470 only quote if delimited identifiers is on

				Set INTO = INTO _ ",:%var("_$$$quote(tSelectList(f))_")"
				Set f = $O(tSelectList(f))
			}
		    If $$$ISERR(tSC) Quit

			// pick up additional fields that are referred to by expressions
			Set f = $O(tXFormProps(""))
			While (f '= "") {
				// translate f from property to field name
				Set fld = ..%GetSQLFieldExpression(.tSC,pCube.sourceClass,f,1)
			    If $$$ISERR(tSC) Quit

				// make sure propname is valid sql (without delim idents)
				Set fq = $TR(f,".","_")
				if '$$$DelIds {
					Set fq=$e(fq)_$tr($e(fq,2,*),"%","x")
				}

				// n.b., %source is subscripted by source name
				Set SELECT = SELECT _ "," _ fld
				Set:fq'=fld SELECT = SELECT _ " " _ $$$quoteIfDelimId(fq) // alias // JSL4470 only quote if delimited identifiers is on
				Set SELECTDYN = SELECTDYN _ "," _ fld
				Set:fq'=fld SELECTDYN = SELECTDYN _ " " _ $$$quoteIfDelimId(fq) // alias // JSL4470 only quote if delimited identifiers is on
				Set INTO = INTO _ ",:%source("_$$$quote(f)_")"	// don't use esc'd name!
				Set f = $O(tXFormProps(f))
			}
		    If $$$ISERR(tSC) Quit

			Set tSELRESTRICT = ""
			If (pCube.buildRestriction'="") {
				// for queries used for update, add restrict expression to SELECT list
				Set tSELRESTRICT = "CASE WHEN " _ pCube.buildRestriction _ " THEN 1 ELSE 0 END %TEST, "
				Set INTO1 = " INTO :tTest," _ INTO
			}
			Else {
				Set INTO1 = " INTO" _ INTO
			}
			Set INTO2 = " INTO" _ INTO
			Set INTO3 = " INTO :tID"

			Set SQL = "SELECT " _ tSELRESTRICT _ SELECT _ " FROM " _ tSourceTableName
			Set SQLDYN = "SELECT " _ tSELRESTRICT _ SELECTDYN _ " FROM " _ tSourceTableName

			// no WHERE clause for %BuildAll (unless user supplied one)
			Set SQL2 = "SELECT " _ $S(+pCube.maxFacts>0:"TOP ("_pCube.maxFacts_") ",1:"") _ SELECT _ " FROM " _ tSourceTableName
			// SQL3 for BuildTempFile
			Set SQL3 = "SELECT " _ $S(+pCube.maxFacts>0:"TOP ("_pCube.maxFacts_") ",1:"") _ tSourceId _ " FROM " _ tSourceTableName
			If (pCube.buildRestriction'="") {
				Set SQL2 = SQL2 _ " WHERE " _ pCube.buildRestriction
				Set SQL3 = SQL3 _ " WHERE " _ pCube.buildRestriction
			}
			If (pCube.initialBuildOrder'="") {
				Set SQL2 = SQL2 _ " ORDER BY " _ pCube.initialBuildOrder
				Set SQL3 = SQL3 _ " ORDER BY " _ pCube.initialBuildOrder
			}

			Set SQLEQ = SQL _ $C(13,10) _ "  WHERE "_tSourceId_" = :pStartId"
			Set SQL = SQL _ $C(13,10) _ "  WHERE "_tSourceId_" BETWEEN :pStartId  AND :pEndId"
			
			// DTB422 - SQL to check existence of a single ID
			Set tSQLIdCheck = "SELECT COUNT(%ID) INTO :tExists FROM "_tSourceTableName_" WHERE %ID = :pTestId"
			
		} // tPersistent

		Do tMeth.Implementation.WriteLine(" Set tID = """"")
		Do tMeth.Implementation.WriteLine(" Set tRows = 0")
		Do tMeth.Implementation.WriteLine(" If (pEndId="""") {")

		// single fact or reference update, use read committed!
		// JMD1033: test flag
		Do tMeth.Implementation.WriteLine("  Set:+$G(%dsReadCommitted,1) oldzu=$ZU(115,2,1)")
		Do tMeth.Implementation.WriteLine("  Set pEndId=pStartId")
		Do tMeth.Implementation.WriteLine(" }")

		Do tMeth2.Implementation.WriteLine(" Set tID = """"")
		Do tMeth2.Implementation.WriteLine(" Set tRows = 0")
		// DTB903 - Test for factList
		Do tMeth2.Implementation.WriteLine("  Set tUseFactList = ($G(pFactList)'="""")")

		Do tMeth3.Implementation.WriteLine(" Set tID = """"")
		Do tMeth3.Implementation.WriteLine(" Set tRows = 0")
		Do tMeth3.Implementation.WriteLine(" Set tUpdate = ..%Count()")		// DTB927 - Check the current size of the fact table

		If (tKPI) {
			// get data from kpi into %var
			Set tExt = $P(pCube.sourceClass,".",$L(pCube.sourceClass,"."))
			If (tExt="kpi") {
				Set tName = $P(pCube.sourceClass,".",1,$L(pCube.sourceClass,".")-1)
				Set tKPIClass = ##class(%DeepSee.Utils).%GetKPIClass(tName)
				Set tName = ""
			}
			ElseIf (tExt="worksheet") {
				Set tName = pCube.sourceClass
				Set tKPIClass = "%DeepSee.KPIWorksheet"
			}
			Else {
				Set tName = pCube.sourceClass
				Set tKPIClass = "Ens.BusinessMetricKPI"
			}

			Do tMeth.Implementation.WriteLine(" New %datacontroller")
			Do tMeth.Implementation.WriteLine(" Set tCriteria = ##class(%ZEN.proxyObject).%New()")
			Do tMeth.Implementation.WriteLine(" Set tSC = ##class(%DeepSee.AbstractKPI).%CreateLocalController(.tController,"_$$$quote(tKPIClass)_","_$$$quote(tName)_",tCriteria)")
			Do tMeth.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")
			Do tMeth.Implementation.WriteLine(" Set %datacontroller = tController")

			Do tMeth.Implementation.WriteLine(" Set tSC = tController.%AcquireData()")
			Do tMeth.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")

			Do tMeth2.Implementation.WriteLine(" New %datacontroller")
			Do tMeth2.Implementation.WriteLine(" Set tCriteria = ##class(%ZEN.proxyObject).%New()")
			Do tMeth2.Implementation.WriteLine(" Set tSC = ##class(%DeepSee.AbstractKPI).%CreateLocalController(.tController,"_$$$quote(tKPIClass)_","_$$$quote(tName)_",tCriteria)")
			Do tMeth2.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")
			Do tMeth2.Implementation.WriteLine(" Set %datacontroller = tController")

			Do tMeth2.Implementation.WriteLine(" Set tSC = tController.%AcquireData()")
			Do tMeth2.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")

			Do tMeth2.Implementation.WriteLine(" Set tSeriesCount = tController.dataBag.seriesCount")
			If (+pCube.maxFacts>0) {
				Do tMeth2.Implementation.WriteLine(" Set:tSeriesCount>"_+pCube.maxFacts_" tSeriesCount = " _ +pCube.maxFacts)
			}

			// loop
			Do tMeth.Implementation.WriteLine(" For tSingleId = pStartId:1:pEndId {")
			Do tMeth.Implementation.WriteLine(" Kill %var")
			Do tMeth.Implementation.WriteLine(" Set tID = tSingleId")

			// loop
			Do tMeth2.Implementation.WriteLine(" For tID = 1:1:tSeriesCount {")
			Do tMeth2.Implementation.WriteLine(" Kill %var")

			// copy
			Set f = $O(tSelectList(""))
			While (f '= "") {
				Set tFName = $P(f,"~~",1)	// JMD1184

				// $$$ZENMISSING is $C(1,1,1)
				Do tMeth.Implementation.WriteLine(" Set tValue = tController.dataBag.%GetValue("_$$$quote(tFName)_",tID)")
				Do tMeth.Implementation.WriteLine(" Set:(tValue=$C(1,1,1)) tValue=""""")
				Do tMeth.Implementation.WriteLine(" Set %var("_$$$quote(tSelectList(f))_") = tValue")

				Do tMeth2.Implementation.WriteLine(" Set tValue = tController.dataBag.%GetValue("_$$$quote(tFName)_",tID)")
				Do tMeth2.Implementation.WriteLine(" Set:(tValue=$C(1,1,1)) tValue=""""")
				Do tMeth2.Implementation.WriteLine(" Set %var("_$$$quote(tSelectList(f))_") = tValue")
				Set f = $O(tSelectList(f))
			}

			// copy data into %source
			Set f = $O(tXFormProps(""))
			While (f '= "") {
				Do tMeth.Implementation.WriteLine(" Set tValue = tController.dataBag.%GetValue("_$$$quote(f)_",tID)")
				Do tMeth.Implementation.WriteLine(" Set:(tValue=$C(1,1,1)) tValue=""""")
				Do tMeth.Implementation.WriteLine(" Set %source("_$$$quote(f)_") = tValue")

				Do tMeth2.Implementation.WriteLine(" Set tValue = tController.dataBag.%GetValue("_$$$quote(f)_",tID)")
				Do tMeth2.Implementation.WriteLine(" Set:(tValue=$C(1,1,1)) tValue=""""")
				Do tMeth2.Implementation.WriteLine(" Set %source("_$$$quote(f)_") = tValue")
				Set f = $O(tXFormProps(f))
			}

		} // kpi
		ElseIf ('tPersistent) {
			Set tVersion = $zobjclassmethod(pCube.sourceClass,"%GetVersion")
			Set tSC = $zobjclassmethod(pCube.sourceClass,"%GetKeyFields",.tKeyFields)
		    If $$$ISERR(tSC) Quit

			If (tVersion'="") {
				Do tMeth.Implementation.WriteLine(" If ("_tVersion_"'=##class("_pCube.sourceClass_").%GetVersion()) {")
				Do tMeth.Implementation.WriteLine("  Set tSC = $$$ERROR($$$GeneralError,""DataConnector has different version than cube; recompile cube: "_pCube.name_""")")
				Do tMeth.Implementation.WriteLine("  Quit")
				Do tMeth.Implementation.WriteLine(" }")
			}

			// get data from dataconnector into %var
			// JMD841: Do tMeth.Implementation.WriteLine(" For tSingleId = pStartId:1:pEndId {")
			Do tMeth.Implementation.WriteLine(" Set tSingleId = pStartId")
			Do tMeth.Implementation.WriteLine(" While (tSingleId'="""") {")
			
			// WAL030 - try block begin for data connector case, %UpdateFacts
			Do tMeth.Implementation.WriteLine(" Try {")
			// WAL030

			Do tMeth.Implementation.WriteLine(" Kill %var")
			Do tMeth.Implementation.WriteLine(" Set tConnector = ##class("_pCube.sourceClass_").%New()")
			Do tMeth.Implementation.WriteLine(" Set tSC = tConnector.%SetMode(""single"")")
			Do tMeth.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")

			Do tMeth.Implementation.WriteLine(" Set tSC = tConnector.%SetSingleId(tSingleId)")
			Do tMeth.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")

			Do tMeth.Implementation.WriteLine(" Set tRecord = tConnector.%Execute(.tParms,.tSC)")
			Do tMeth.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")

			// JMD1016: test if there is a record
			Do tMeth.Implementation.WriteLine(" If (tRecord.%Next(.tSC)) {")
			Do tMeth.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")

			// create instance of data connector
			// check version #
			If (tVersion'="") {
				Do tMeth2.Implementation.WriteLine(" If ("_tVersion_"'=##class("_pCube.sourceClass_").%GetVersion()) {")
				Do tMeth2.Implementation.WriteLine("  Set tSC = $$$ERROR($$$GeneralError,""DataConnector has different version than cube; recompile cube: "_pCube.name_""")")
				Do tMeth2.Implementation.WriteLine("  Quit")
				Do tMeth2.Implementation.WriteLine(" }")
			}

			Do tMeth2.Implementation.WriteLine(" Set tConnector = ##class("_pCube.sourceClass_").%New()")
			Do tMeth2.Implementation.WriteLine(" Set tRecord = tConnector.%Execute(.tParms,.tSC)")
			Do tMeth2.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")

			If (+pCube.maxFacts<=0) {
				Do tMeth2.Implementation.WriteLine(" While(tRecord.%Next(.tSC)) {")
			}
			Else {
				// test count
				Do tMeth2.Implementation.WriteLine(" While((tRows<"_+pCube.maxFacts_")&&tRecord.%Next(.tSC)) {")
			}
			Do tMeth2.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")
			Do tMeth2.Implementation.WriteLine(" Kill %var")

			// get sourceId (if any)
			If ($D(tKeyFields)) {
				Set kfx = ""
				Set f = $O(tKeyFields(""))
				While (f '= "") {
					Set kfx = kfx _ $S(kfx="":"",1:"_""||""_") _ "tRecord."_f
					Set f = $O(tKeyFields(f))
				}
				Do tMeth.Implementation.WriteLine(" Set tID = "_kfx)
				Do tMeth2.Implementation.WriteLine(" Set tID = "_kfx)
			}

			// copy
			Set f = $O(tSelectList(""))
			While (f '= "") {
				Set tFName = $P(f,"~~",1)	// JMD1184
				Do tMeth.Implementation.WriteLine(" Set %var("_$$$quote(tSelectList(f))_") = tRecord."_tFName)
				Do tMeth2.Implementation.WriteLine(" Set %var("_$$$quote(tSelectList(f))_") = tRecord."_tFName)
				Set f = $O(tSelectList(f))
			}

			// copy data into %source
			Set f = $O(tXFormProps(""))
			While (f '= "") {
				Do tMeth.Implementation.WriteLine(" Set %source("_$$$quote(f)_") = tRecord."_f)
				Do tMeth2.Implementation.WriteLine(" Set %source("_$$$quote(f)_") = tRecord."_f)
				Set f = $O(tXFormProps(f))
			}
			
			// +DTB422 - Open the connector and check the ID
			Do tMeth4.Implementation.WriteLine("  Set tConnector = ##class(DeepSee.Model.ConnectorExample).%New()")
			Do tMeth4.Implementation.WriteLine("  Set tSC = tConnector.%SetMode(""single"")")
			Do tMeth4.Implementation.WriteLine("  If $$$ISERR(tSC) Quit")
			Do tMeth4.Implementation.WriteLine("  Set tSC = tConnector.%SetSingleId(pTestId)")
			Do tMeth4.Implementation.WriteLine("  If $$$ISERR(tSC) Quit")
			Do tMeth4.Implementation.WriteLine("  Set tRecord = tConnector.%Execute(.tParms,.tSC)")
			Do tMeth4.Implementation.WriteLine("  If $$$ISERR(tSC) Quit")
			Do tMeth4.Implementation.WriteLine("  If (tRecord.%Next(.tSC)) {")
			Do tMeth4.Implementation.WriteLine("   If $$$ISERR(tSC) Quit")
			Do tMeth4.Implementation.WriteLine("   Set tSourceExists = 1")
			Do tMeth4.Implementation.WriteLine("  }")
			// -DTB422
		} // data connect
		Else {
			// If RefProp is provided we use dynamic SQL
			Do tMeth.Implementation.WriteLine(" If (pRefProp'="""") {")
			Do tMeth.Implementation.WriteLine("  Set tRS = ##class(%ResultSet).%New()")
			Do tMeth.Implementation.WriteLine("  Set tSC = tRS.Prepare("_$$$quote(SQLDYN)_"_"" WHERE ""_pRefProp_""=?"")")
			Do tMeth.Implementation.WriteLine("  If $$$ISERR(tSC) Quit")

			Do tMeth.Implementation.WriteLine("  Set tSC = tRS.Execute(pRefID)")
			Do tMeth.Implementation.WriteLine("  If $$$ISERR(tSC) Quit")
			Do tMeth.Implementation.WriteLine(" }")

			// update eq
			Do tMeth.Implementation.WriteLine(" ElseIf (pStartId=pEndId) {")

			Do tMeth.Implementation.WriteLine("  &sql(DECLARE "_tCursorEq_" CURSOR FOR")
			Do tMeth.Implementation.WriteLine("  " _ SQLEQ)
			Do tMeth.Implementation.WriteLine("  )")
			Do tMeth.Implementation.WriteLine("  &sql(OPEN "_tCursorEq_")")
			Do tMeth.Implementation.WriteLine("  If (SQLCODE'=0) {")
			Do tMeth.Implementation.WriteLine("   Set tSC = $$$ERROR($$$GeneralError,""Error opening SQL cursor: (""_$G(SQLCODE)_"") ""_$G(%msg))")
			Do tMeth.Implementation.WriteLine("   Quit")
			Do tMeth.Implementation.WriteLine("  }")
			Do tMeth.Implementation.WriteLine("  &sql(FETCH "_tCursorEq_INTO1_")")
			// + WAL129 -- FETCH error handling
			Do tMeth.Implementation.WriteLine("  If (SQLCODE'=0) {")
			Do tMeth.Implementation.WriteLine("    Set tSC = $$$ERROR($$$GeneralError,""Error fetching row: (""_$G(SQLCODE)_"") ""_$G(%msg))")		// DTB371 - Set the status before closing the cursor
			Do tMeth.Implementation.WriteLine("    &sql(CLOSE "_tCursorEq_")")
			// + WAL243 -- report SQL cursor problems to build errors global
			Do tMeth.Implementation.WriteLine("      Do ##class(%DeepSee.Utils).%LogBuildError("_$$$quote(tCubeName)_",pStartId,tSC)")		// DTB836 - Call API to log the error
			// + WAL243 -- report SQL cursor problems to build errors global
			Do tMeth.Implementation.WriteLine("    Quit")
			Do tMeth.Implementation.WriteLine("  }")
			// - WAL129
			Do tMeth.Implementation.WriteLine(" }")

			// update
			Do tMeth.Implementation.WriteLine(" Else {")

			Do tMeth.Implementation.WriteLine("  &sql(DECLARE "_tCursorSq_" CURSOR FOR")
			Do tMeth.Implementation.WriteLine("  " _ SQL)
			Do tMeth.Implementation.WriteLine("  )")
			Do tMeth.Implementation.WriteLine("  &sql(OPEN "_tCursorSq_")")
			Do tMeth.Implementation.WriteLine("  If (SQLCODE'=0) {")
			Do tMeth.Implementation.WriteLine("   Set tSC = $$$ERROR($$$GeneralError,""Error opening SQL cursor: (""_$G(SQLCODE)_"") ""_$G(%msg))")
			Do tMeth.Implementation.WriteLine("   Quit")
			Do tMeth.Implementation.WriteLine("  }")
			Do tMeth.Implementation.WriteLine("  &sql(FETCH "_tCursorSq_INTO1_")")
			// + WAL129 -- FETCH error handling
			Do tMeth.Implementation.WriteLine("  If (SQLCODE'=0) {")
			Do tMeth.Implementation.WriteLine("    Set tSC = $$$ERROR($$$GeneralError,""Error fetching row: (""_$G(SQLCODE)_"") ""_$G(%msg))")		// DTB371 - Set the status before closing the cursor
			Do tMeth.Implementation.WriteLine("    &sql(CLOSE "_tCursorSq_")")
			// + WAL243 -- report SQL cursor problems to build errors global
			// WAL245 -- Check that tID exists
			Do tMeth.Implementation.WriteLine("    If ($G(tID)'="""") {")
			Do tMeth.Implementation.WriteLine("       Do ##class(%DeepSee.Utils).%LogBuildError("_$$$quote(tCubeName)_",tID,tSC)")		// DTB836 - Call API to log the error
			Do tMeth.Implementation.WriteLine("    }")
			// - WAL243
			Do tMeth.Implementation.WriteLine("    Quit")
			Do tMeth.Implementation.WriteLine("  }")
			// - WAL129
			Do tMeth.Implementation.WriteLine(" }")

			// loop
			Do tMeth.Implementation.WriteLine(" While ($S($IsObject(tRS):tRS.Next(.tSC),1:SQLCODE=0)) {")
			
			// WAL030 -- begin loop try block, cube case, %UpdateFacts
			Do tMeth.Implementation.WriteLine(" Try {")
			// WAL030

			// get values from RS
			Do tMeth.Implementation.WriteLine(" If ($IsObject(tRS)) {")
			Do tMeth.Implementation.WriteLine("  If $$$ISERR(tSC) Quit")

			// get id value
			Do tMeth.Implementation.WriteLine("  Set tID = $G(tRS.Data("_$$$quote(tSourceId)_"))")

			If (pCube.buildRestriction'="") {
				// get "test" value
				Do tMeth.Implementation.WriteLine("  Set tTest = $G(tRS.Data("_$$$quote("%TEST")_"),1)")
			}

			// copy data into %var
			Set f = $O(tSelectList(""))
			While (f '= "") {
				Do tMeth.Implementation.WriteLine("  Set %var("_$$$quote(tSelectList(f))_") = $G(tRS.Data("_$$$quote(tSelectList(f))_"))")
				Set f = $O(tSelectList(f))
			}

			// copy data into %source
			Set f = $O(tXFormProps(""))
			While (f '= "") {
				Do tMeth.Implementation.WriteLine("  Set %source("_$$$quote(f)_") = $G(tRS.Data("_$$$quote(f)_"))")
				Set f = $O(tXFormProps(f))
			}

			Do tMeth.Implementation.WriteLine(" }")

			// build
			Do tMeth2.Implementation.WriteLine("  &sql(DECLARE "_tCursorSq2_" CURSOR FOR")
			Do tMeth2.Implementation.WriteLine("  " _ SQL2)
			Do tMeth2.Implementation.WriteLine("  )")
			Do tMeth2.Implementation.WriteLine("  &sql(OPEN "_tCursorSq2_")")
			Do tMeth2.Implementation.WriteLine("  If (SQLCODE'=0) {")
			Do tMeth2.Implementation.WriteLine("   Set tSC = $$$ERROR($$$GeneralError,""Error opening SQL cursor: (""_$G(SQLCODE)_"") ""_$G(%msg))")
			Do tMeth2.Implementation.WriteLine("   Quit")
			Do tMeth2.Implementation.WriteLine("  }")
			Do tMeth2.Implementation.WriteLine("  &sql(FETCH "_tCursorSq2_INTO2_")")
			Do tMeth2.Implementation.WriteLine("  If ((SQLCODE=100)&&pVerbose) {")
			Do tMeth2.Implementation.WriteLine("   Write ""No source data found."",!")
			Do tMeth2.Implementation.WriteLine("  }")
			Do tMeth2.Implementation.WriteLine("  While (SQLCODE=0) {")
			
			// build temp
			// DTB927 - If the fact table currently contains records, build the temp file from that information
			Do tMeth3.Implementation.WriteLine("  If tUpdate {")
			Do tMeth3.Implementation.WriteLine("   Set %dsmaxfacts = tUpdate")
			Do tMeth3.Implementation.WriteLine("   &sql(DECLARE "_tCursorSq3_" CURSOR FOR")
			Do tMeth3.Implementation.WriteLine("   SELECT %sourceId FROM " _ tFactTableName)
			Do tMeth3.Implementation.WriteLine("   )")
			Do tMeth3.Implementation.WriteLine("  }")
			Do tMeth3.Implementation.WriteLine("  Else {")
			Do tMeth3.Implementation.WriteLine("   &sql(DECLARE "_tCursorSq3_" CURSOR FOR")
			Do tMeth3.Implementation.WriteLine("   " _ SQL3)
			Do tMeth3.Implementation.WriteLine("   )")
			Do tMeth3.Implementation.WriteLine("  }")
			Do tMeth3.Implementation.WriteLine("  &sql(OPEN "_tCursorSq3_")")
			Do tMeth3.Implementation.WriteLine("  If (SQLCODE'=0) {")
			Do tMeth3.Implementation.WriteLine("   Set tSC = $$$ERROR($$$GeneralError,""Error opening SQL cursor: (""_$G(SQLCODE)_"") ""_$G(%msg))")
			Do tMeth3.Implementation.WriteLine("   Quit")
			Do tMeth3.Implementation.WriteLine("  }")
			Do tMeth3.Implementation.WriteLine("  &sql(FETCH "_tCursorSq3_INTO3_")")
			Do tMeth3.Implementation.WriteLine("  If ((SQLCODE=100)&&pVerbose) {")
			Do tMeth3.Implementation.WriteLine("   Write ""No source data found."",!")
			Do tMeth3.Implementation.WriteLine("  }")
			Do tMeth3.Implementation.WriteLine("  While (SQLCODE=0) {")

			Do tMeth3.Implementation.WriteLine("  Set tRows = tRows+1")
			Do tMeth3.Implementation.WriteLine("  Set tChunk = tRows\64000+1")
			Do tMeth3.Implementation.WriteLine("  Set tOffset = tRows#64000+1")
			Do tMeth3.Implementation.WriteLine("  Set:tID'="""" $$$DeepSeeTempSourceId(pTempKey,tChunk,tOffset) = $LB(tID,''tUpdate)")		// DTB927
			Do tMeth3.Implementation.WriteLine("  If (pVerbose&&'(tRows#10000)) Write $C(13,27)_""[0J""_""Building temp file: "",?25,$J($FN(tRows,"","",0),10),"" record(s) processed.""")

			Do tMeth3.Implementation.WriteLine("  If ($D(%dsmaxfacts)&&(tRows>=+$G(%dsmaxfacts))) Quit")
			
			// +DTB422
			Do tMeth4.Implementation.WriteLine("  &sql("_tSQLIdCheck_")")
  			Do tMeth4.Implementation.WriteLine("  If (tExists) {")
    		Do tMeth4.Implementation.WriteLine("   Set tSourceExists = 1")
  			Do tMeth4.Implementation.WriteLine("  }")
			// -DTB422
		} // tPersistent

		// check for local override of maxFacts
		Do tMeth2.Implementation.WriteLine("  If ($D(%dsmaxfacts)&&(tRows>=+$G(%dsmaxfacts))) Quit")
		
		// WAL030 -- start try block after maxfacts, data connector and cube, %BuildAllFacts
		If ('tKPI) {
			Do tMeth2.Implementation.WriteLine("  Try {")
		}
		// WAL030

		// apply date type conversions
		If $D(tDateTypeProps) {
			Do tMeth.Implementation.WriteLine("")
			Do tMeth.Implementation.WriteLine(" #; apply date conversions")
			Do tMeth2.Implementation.WriteLine("")
			Do tMeth2.Implementation.WriteLine(" #; apply date conversions")

			Set p = $O(tDateTypeProps(""))
			While (p '= "") {
				// skip this field if it is in the alias list
				If ('$D(tCopyFromList(p))) {
					Do tMeth.Implementation.WriteLine(" Set %var("_$$$quote(p)_") = ##class(%DeepSee.Utils).%ConvertDate(%var("_$$$quote(p)_"),"_$$$quote(tDateTypeProps(p))_")")
					Do tMeth2.Implementation.WriteLine(" Set %var("_$$$quote(p)_") = ##class(%DeepSee.Utils).%ConvertDate(%var("_$$$quote(p)_"),"_$$$quote(tDateTypeProps(p))_")")
				}
				Set p = $O(tDateTypeProps(p))
			}
		}

		// if there are any "copy from" fields, get values for them
		If ($D(tCopyFromList)) {
			Do tMeth.Implementation.WriteLine(" #; Copy aliased fields")
			Do tMeth2.Implementation.WriteLine(" #; Copy aliased fields")
			Set f = $O(tCopyFromList(""))
			While (f '= "") {
				Set src = tCopyFromList(f)
				Do tMeth.Implementation.WriteLine(" Set %var("_$$$quote(f)_") = $G(%var("_$$$quote(src)_"))")		// DTB913
				Do tMeth2.Implementation.WriteLine(" Set %var("_$$$quote(f)_") = $G(%var("_$$$quote(src)_"))")		// DTB913
				Set f = $O(tCopyFromList(f))
			}
		}

		// make source id visible to expressions as %dsSourceId
		// define a holder for the source object (used by %Rule()), %dsSourceObj
		Do tMeth.Implementation.WriteLine(" Set %dsSourceId = $G(tID)")
		Do tMeth2.Implementation.WriteLine(" Set %dsSourceId = $G(tID)")

		// JMD944 Start expression time before local expressions
		Do tMeth.Implementation.WriteLine(" Set tExStartTime = $ZH")
		Do tMeth2.Implementation.WriteLine(" Set tExStartTime = $ZH")

		// Perform transform logic for *local* expressions
		If $D(tXFormCode) {
			Do tMeth.Implementation.WriteLine(" #; apply local expressions")
			Do tMeth2.Implementation.WriteLine(" #; apply local expressions")

			Set rk = $O(tExprRanked(""))
			While (rk'="") {
				Set f = $O(tExprRanked(rk,""))
				While (f'="") {
					Set tCode = tXFormCodeLocal(f)
					If (tCode '= "") {
						// replace method calls
						Set:$IsObject($G(%class)) tCode = $Replace(tCode,"%cube.","##class("_%class.Name_").")
						Set tCode = " Set %expression("_$$$quote(f)_") = " _ tCode
					}
					Else {
						Set tCode = " Set %expression("_$$$quote(f)_") = """""
					}
					Do tMeth.Implementation.WriteLine(tCode)
					Do tMeth2.Implementation.WriteLine(tCode)

					// next expr
					Set f = $O(tExprRanked(rk,f))
				}
				Set rk = $O(tExprRanked(rk))
			}
		}

		// Perform transform logic (from sourceExpressions)
		If $D(tXFormCode) {
			Do tMeth.Implementation.WriteLine(" #; apply source expressions")
			Do tMeth2.Implementation.WriteLine(" #; apply source expressions")
			Set f = $O(tXFormCode(""))
			While (f '= "") {
				Set tCode = tXFormCode(f)
				// JMD929: test for %value reference
				If (tCode [ "%value") {
					// pass properties used by this expression along
					For tx = "src","exp" {
						Set fxp = $O(tXFormCode(f,tx,""))
						While (fxp'="") {
							// store context as subnodes in %var;
							// write out code here
							Set tCode = " Set %var("_$$$quote(f)_","_$$$quote(tx)_","_$$$quote(fxp)_")="_$S(tx="exp":"%expression",1:"%source")_"("_$$$quote(fxp)_")"
							Do tMeth.Implementation.WriteLine(tCode)
							Do tMeth2.Implementation.WriteLine(tCode)
							Set fxp = $O(tXFormCode(f,tx,fxp))
						}
						Set fxp = $O(tXFormCode(f,""))
					}
					Set tCode = " Set %var("_$$$quote(f)_") = """""
				}
				ElseIf (tCode '= "") {
					// replace method calls
					Set:$IsObject($G(%class)) tCode = $Replace(tCode,"%cube.","##class("_%class.Name_").")
					Set tCode = " Set:('tUseFactList||$ListFind(pFactList,"_$$$quote(f)_")) %var("_$$$quote(f)_") = " _ tCode		// DTB893 - Suppress calculation if not in the fact list
				}
				Else {
					Set tCode = " Set %var("_$$$quote(f)_") = """""
				}

				Set tVirtual = +$G(pFactInfo("prop",f,"virtual"))
				If ('tVirtual) {
					Set tInsertList(f) = ""
				}
				Do tMeth.Implementation.WriteLine(tCode)
				Do tMeth2.Implementation.WriteLine(tCode)
				Set f = $O(tXFormCode(f))
			}
		}

		// JMD944: move timer logic outside of source expression block
		Do tMeth.Implementation.WriteLine(" Set x = $I(^IRIS.Temp.DeepSeeBuildStats($namespace,"_$$$quote($$$UPPER(pCube.name))_",""expr""),$ZH-tExStartTime)")
		Do tMeth2.Implementation.WriteLine(" Set x = $I(^IRIS.Temp.DeepSeeBuildStats($namespace,"_$$$quote($$$UPPER(pCube.name))_",""expr""),$ZH-tExStartTime)")

		// invoke the %ProcessFact method
		Do tMeth.Implementation.WriteLine("")
		If (pCube.buildRestriction'="") {
			// test if this row is in or out
			Do tMeth.Implementation.WriteLine(" If ('tTest) {")
			Do tMeth.Implementation.WriteLine("  Do ..%DeleteFact(tID)")
			Do tMeth.Implementation.WriteLine(" }")
			Do tMeth.Implementation.WriteLine(" Else {")
		}

		Do tMeth.Implementation.WriteLine(" #; invoke method to process this fact")
		Do tMeth.Implementation.WriteLine(" Set tFactId = """"")
		Do tMeth.Implementation.WriteLine(" Set tSC = ##class("_tClassDefName_").%ProcessFact(tID,pBatchMode,.%var,.tFactId,.tErrorMsg,.pDimTables,,pFactList,.tUpdater)")		// DTB886 - Pass pFactList	// DTB913 - Pass an iterator by reference

		Do tMeth2.Implementation.WriteLine("")
		Do tMeth2.Implementation.WriteLine(" #; invoke method to process this fact")
		Do tMeth2.Implementation.WriteLine(" Set tFactId = """"")
		Do tMeth2.Implementation.WriteLine(" Set tSC = ##class("_tClassDefName_").%ProcessFact(tID,1,.%var,.tFactId,.tErrorMsg,,,pFactList,.tUpdater)")		// DTB886 - Pass pFactList	// DTB913 - Pass an iterator by reference

		// find bitmap chunk(s) affected by this update (but not for BuildAll)
		Do tMeth.Implementation.WriteLine(" If (tFactId'="""") {")

		Do tMeth.Implementation.WriteLine(" If $$$ISOK(tSC) {")
		Do tMeth.Implementation.WriteLine("  Set pUpdates = pUpdates+1")
		Do tMeth.Implementation.WriteLine("  Set pChunks(tFactId\64000+1) = """"")
		Do tMeth.Implementation.WriteLine(" }")
 		Do tMeth.Implementation.WriteLine(" ElseIf (pVerbose) {")
		Do tMeth.Implementation.WriteLine("  Write ""Error filing row: "",tID,!")
		Do tMeth.Implementation.WriteLine("  Write:tErrorMsg'="""" tErrorMsg,!")
		Do tMeth.Implementation.WriteLine("  Write $System.Status.GetOneStatusText(tSC),!!")		// DTB301 - Improve error display
		Do tMeth.Implementation.WriteLine("  Set tSC = $$$OK")
 		Do tMeth.Implementation.WriteLine(" }")

		Do tMeth2.Implementation.WriteLine(" Set:$$$ISERR(tSC) err = $I(%dserrcount)")
		Do tMeth2.Implementation.WriteLine(" If ($$$ISERR(tSC)&&pVerbose) {")
		Do tMeth2.Implementation.WriteLine("  Write ""Error filing row: "",tID,!")
		Do tMeth2.Implementation.WriteLine("  Write:tErrorMsg'="""" tErrorMsg,!")
		Do tMeth2.Implementation.WriteLine("  Write $System.Status.GetOneStatusText(tSC),!!")		// DTB301 - Improve error display
		Do tMeth2.Implementation.WriteLine("  Set tSC = $$$OK")
 		Do tMeth2.Implementation.WriteLine(" }")

		// we only need to pass DimTables in for the first time
		Do tMeth.Implementation.WriteLine(" Kill pDimTables")
		Do tMeth.Implementation.WriteLine(" Set tRows = tRows + 1")
		Do tMeth.Implementation.WriteLine(" If (pVerbose&&'(tRows#1000)) Write $C(13,27)_""[0J""_""Building fact table: "",?25,$J($FN(tRows,"","",0),10),"" fact(s) updated.""")
		Do tMeth.Implementation.WriteLine(" If (pVerbose&&'(tRows#1000)&&(+$G(%dserrcount))) Write "" "",$J($FN(%dserrcount,"","",0),10),"" error(s)""")

		Do tMeth2.Implementation.WriteLine(" If (tFactId'="""") {")
		Do tMeth2.Implementation.WriteLine("  Set tRows = tRows + 1")
		Do tMeth2.Implementation.WriteLine("  Set %dsfactcount = tRows")		// DTB794 - Always set the fact count for later reference
		Do tMeth2.Implementation.WriteLine("  If (pVerbose&&'(tRows#1000)) Write $C(13,27)_""[0J""_""Building fact table: "",?25,$J($FN(tRows,"","",0),10),"" fact(s) updated.""")
		Do tMeth2.Implementation.WriteLine("  If (pVerbose&&'(tRows#1000)&&(+$G(%dserrcount))) Write "" "",$J($FN(%dserrcount,"","",0),10),"" error(s)""")
		Do tMeth2.Implementation.WriteLine(" } ;factId")
		
		// WAL030 -- If a source expression fails in %BuildAllFacts, log it an continue building
		// data connector and cube cases
		If ('tKPI) {
			Do tMeth2.Implementation.WriteLine("  }")
			Do tMeth2.Implementation.WriteLine("  Catch (ex) {")
			Do tMeth2.Implementation.WriteLine("    Set tSC = ex.AsStatus()")
			Do tMeth2.Implementation.WriteLine("    If ($G(tID)'="""") {")
			Do tMeth2.Implementation.WriteLine("      Do ##class(%DeepSee.Utils).%LogBuildError("_$$$quote(tCubeName)_",tID,tSC)")		// DTB836 - Call API to log the error
			Do tMeth2.Implementation.WriteLine("    }")
			Do tMeth2.Implementation.WriteLine("  }")		
		}
		// WAL030

		Do tMeth.Implementation.WriteLine(" If ((pTaskGroup'="""")&&'(tRows#1000)) {")
		Do tMeth.Implementation.WriteLine("  Set tDelta = tRows - tLastCount")
		Do tMeth.Implementation.WriteLine("  Set inc=$I(^IRIS.Temp.DeepSeeUpdate($namespace,pTaskGroup,""facts""),tDelta)")
		Do tMeth.Implementation.WriteLine("  Set tLastCount = tRows")
		Do tMeth.Implementation.WriteLine(" }")
		
		// end of If (tFactId'="")
		Do tMeth.Implementation.WriteLine(" } ;factId")

		If (pCube.buildRestriction'="") {
			// end of if (tTest)
			Do tMeth.Implementation.WriteLine(" }")
		}

		If (tKPI) {
			Do tMeth.Implementation.WriteLine(" } ;while")
			Do tMeth2.Implementation.WriteLine(" } ;while")

			Do tMeth.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")
			Do tMeth2.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")
		}
		ElseIf ('tPersistent) {
			// JMD1016: end of record test
			Do tMeth.Implementation.WriteLine(" } ;if %Next")
								
			// WAL030 -- If a source expression fails in Data Connector %UpdateFacts, log it and continue building
			Do tMeth.Implementation.WriteLine("  }")
			Do tMeth.Implementation.WriteLine("  Catch (ex) {")
			Do tMeth.Implementation.WriteLine("    Set tSC = ex.AsStatus()")
			Do tMeth.Implementation.WriteLine("    If ($G(tID)'="""") {")
			Do tMeth.Implementation.WriteLine("      Do ##class(%DeepSee.Utils).%LogBuildError("_$$$quote(tCubeName)_",tID,tSC)")		// DTB836 - Call API to log the error
			Do tMeth.Implementation.WriteLine("    }")
			Do tMeth.Implementation.WriteLine("  }")
			// WAL030

			// end of loop test
			Do tMeth.Implementation.WriteLine(" Set tSingleId=$S(pStartId=pEndId:"""",1:tSingleId+1)")
			Do tMeth.Implementation.WriteLine(" } ;while")
			Do tMeth2.Implementation.WriteLine(" } ;while")

			Do tMeth.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")
			Do tMeth2.Implementation.WriteLine(" If $$$ISERR(tSC) Quit")
		}
		Else {
			
			// WAL030 -- If a source expression fails in cube %UpdateFacts, log it and continue building
			Do tMeth.Implementation.WriteLine("  }")
			Do tMeth.Implementation.WriteLine("  Catch (ex) {")
			Do tMeth.Implementation.WriteLine("    Set tSC = ex.AsStatus()")
			Do tMeth.Implementation.WriteLine("    If ($G(tID)'="""") {")
			Do tMeth.Implementation.WriteLine("      Do ##class(%DeepSee.Utils).%LogBuildError("_$$$quote(tCubeName)_",tID,tSC)")		// DTB836 - Call API to log the error
			Do tMeth.Implementation.WriteLine("    }")
			Do tMeth.Implementation.WriteLine("  }")
			// WAL030
			
			Do tMeth.Implementation.WriteLine("  If '$IsObject(tRS) {")
			Do tMeth.Implementation.WriteLine("   If (pStartId=pEndId) {")
			Do tMeth.Implementation.WriteLine("    &sql(FETCH "_tCursorEq_INTO1_")")
			Do tMeth.Implementation.WriteLine("   }")
			Do tMeth.Implementation.WriteLine("   Else {")
			Do tMeth.Implementation.WriteLine("    &sql(FETCH "_tCursorSq_INTO1_")")
			Do tMeth.Implementation.WriteLine("   }")
			Do tMeth.Implementation.WriteLine("  }")
			Do tMeth2.Implementation.WriteLine("  &sql(FETCH "_tCursorSq2_INTO2_")")
			Do tMeth3.Implementation.WriteLine("  &sql(FETCH "_tCursorSq3_INTO3_")")

			Do tMeth.Implementation.WriteLine(" } ;while")
			Do tMeth2.Implementation.WriteLine(" } ;while")
			Do tMeth3.Implementation.WriteLine(" } ;while")

			Do tMeth.Implementation.WriteLine("  If '$IsObject(tRS) {")
			Do tMeth.Implementation.WriteLine("   If (pStartId=pEndId) {")
			Do tMeth.Implementation.WriteLine("    &sql(CLOSE "_tCursorEq_")")
			Do tMeth.Implementation.WriteLine("   }")
			Do tMeth.Implementation.WriteLine("   Else {")
			Do tMeth.Implementation.WriteLine("    &sql(CLOSE "_tCursorSq_")")
			Do tMeth.Implementation.WriteLine("   }")
			Do tMeth.Implementation.WriteLine("  }")
			Do tMeth2.Implementation.WriteLine("  &sql(CLOSE "_tCursorSq2_")")
			Do tMeth3.Implementation.WriteLine("  &sql(CLOSE "_tCursorSq3_")")
		}
		// n.b., in batch mode, indices are built by task manager

		Do tMeth.Implementation.WriteLine(" If (pVerbose) Write $C(13,27)_""[0J""_""Building fact table: ""_$FN(+$G(tRows),"","",0)_"" fact(s) updated""")
		Do tMeth2.Implementation.WriteLine(" If (pVerbose) Write $C(13,27)_""[0J""_""Building fact table: ""_$FN(+$G(tRows),"","",0)_"" fact(s) updated""")
		Do:tPersistent tMeth3.Implementation.WriteLine(" If (pVerbose) Write $C(13,27)_""[0J""_""Building temp file: ""_$FN(+$G(tRows),"","",0)_"" record(s) processed""")

		Do tMeth.Implementation.WriteLine(" If (pTaskGroup'="""") {")
		Do tMeth.Implementation.WriteLine("  Set tDelta = tRows - tLastCount")
		Do tMeth.Implementation.WriteLine("  Set inc=$I(^IRIS.Temp.DeepSeeUpdate($namespace,pTaskGroup,""facts""),tDelta)")
		Do tMeth.Implementation.WriteLine(" }")

		Do tMeth.Implementation.WriteLine(" }") // try
		Do tMeth.Implementation.WriteLine(" Catch(ex) {")
		Do tMeth.Implementation.WriteLine("  Set tSC = ex.AsStatus()")

		If ('tKPI && tPersistent) {
			// JMD1326: make sure cursor gets closed
			Do tMeth.Implementation.WriteLine("  &sql(CLOSE "_tCursorEq_")")
			Do tMeth.Implementation.WriteLine("  &sql(CLOSE "_tCursorSq_")")
		}
		Do tMeth.Implementation.WriteLine(" }")

		Do tMeth2.Implementation.WriteLine(" }") // try
		Do tMeth2.Implementation.WriteLine(" Catch(ex) {")
		Do tMeth2.Implementation.WriteLine("  Set tSC = ex.AsStatus()")
		// JMD1326: make sure cursor gets closed
		If ('tKPI && tPersistent) {
			Do tMeth2.Implementation.WriteLine("  &sql(CLOSE "_tCursorSq2_")")
		}
		Do tMeth2.Implementation.WriteLine(" }")

		Do tMeth3.Implementation.WriteLine(" }") // try
		Do tMeth3.Implementation.WriteLine(" Catch(ex) {")
		Do tMeth3.Implementation.WriteLine("  Set tSC = ex.AsStatus()")

		// JMD1326: make sure cursor gets closed
		If ('tKPI && tPersistent) {
			Do tMeth3.Implementation.WriteLine("  &sql(CLOSE "_tCursorSq3_")")
		}
		Do tMeth3.Implementation.WriteLine(" }")

		// +DTB42
		Do tMeth4.Implementation.WriteLine(" }") // try
		Do tMeth4.Implementation.WriteLine(" Catch(ex) {")
		Do tMeth4.Implementation.WriteLine("  Set pSC = ex.AsStatus()")
		Do tMeth4.Implementation.WriteLine(" }")
		// -DTB422

		// restore read committed mode
		Do tMeth.Implementation.WriteLine("  Set:$D(oldzu) zu=$ZU(115,2,oldzu)")

		Do tMeth.Implementation.WriteLine(" If ($$$ISERR(tSC)) {")
		Do tMeth.Implementation.WriteLine("  Do ..%LogError(tSC)")
		Do tMeth.Implementation.WriteLine("  If (pVerbose) {")
		Do tMeth.Implementation.WriteLine("   Do $System.Status.DisplayError(tSC)")
		Do tMeth.Implementation.WriteLine("  }")
		// JMD1480
		Do tMeth.Implementation.WriteLine("  If ($G(tID)'="""") {")
		Do tMeth.Implementation.WriteLine("   Do ##class(%DeepSee.Utils).%LogBuildError("_$$$quote(tCubeName)_",tID,tSC)")		// DTB836 - Call API to log the error
		Do tMeth.Implementation.WriteLine("  }")
		Do tMeth.Implementation.WriteLine(" }")

		Do tMeth2.Implementation.WriteLine(" If ($$$ISERR(tSC)) {")
		Do tMeth2.Implementation.WriteLine("  Do ..%LogError(tSC)")
		Do tMeth2.Implementation.WriteLine("  If (pVerbose) {")
		Do tMeth2.Implementation.WriteLine("   Do $System.Status.DisplayError(tSC)")
		Do tMeth2.Implementation.WriteLine("  }")
		// JMD1480
		Do tMeth2.Implementation.WriteLine("  If ($G(tID)'="""") {")
		Do tMeth2.Implementation.WriteLine("   Do ##class(%DeepSee.Utils).%LogBuildError("_$$$quote(tCubeName)_",tID,tSC)")		// DTB836 - Call API to log the error
		Do tMeth2.Implementation.WriteLine("  }")
		Do tMeth2.Implementation.WriteLine(" }")

		Do tMeth3.Implementation.WriteLine(" If ($$$ISERR(tSC)) {")
		Do tMeth3.Implementation.WriteLine("  Do ..%LogError(tSC)")
		Do tMeth3.Implementation.WriteLine("  If (pVerbose) {")
		Do tMeth3.Implementation.WriteLine("   Do $System.Status.DisplayError(tSC)")
		Do tMeth3.Implementation.WriteLine("  }")
		Do tMeth3.Implementation.WriteLine(" }")
		
		// +DTB422
		Do tMeth4.Implementation.WriteLine(" If ($$$ISERR(pSC)) {")
		Do tMeth4.Implementation.WriteLine("  Do ..%LogError(pSC)")
		Do tMeth4.Implementation.WriteLine("  If (pVerbose) {")
		Do tMeth4.Implementation.WriteLine("   Do $System.Status.DisplayError(pSC)")
		Do tMeth4.Implementation.WriteLine("  }")
		Do tMeth4.Implementation.WriteLine(" }")
		// -DTB422

		Do tMeth.Implementation.WriteLine(" Quit tSC")
		Do tMeth2.Implementation.WriteLine(" Quit tSC")
		Do tMeth3.Implementation.WriteLine(" Quit tSC")
		Do tMeth4.Implementation.WriteLine(" Quit tSourceExists")

		Do tClassDef.Methods.Insert(tMeth)
		Do tClassDef.Methods.Insert(tMeth2)
		Do tClassDef.Methods.Insert(tMeth3)
		Do tClassDef.Methods.Insert(tMeth4)		// DTB422
		#; End of %UpdateFacts / %BuildAllFacts / %BuildTempFile / %CheckSourceId

		#; %ProcessFact method (called by %UpdateFacts)
		#; JMD1137 add pDimensionsOnly
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%ProcessFact")
		Set tMeth.Name = "%ProcessFact"
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = "pID:%String,pBatchMode:%Boolean=0,&%var:%String,&pFactId:%Integer,*pErrorMsg:%String,&pDimTables,pDimensionsOnly:%Boolean=0,pFactList:%String="""",&pSQLUpdate:%SQL.StatementResult={$$$NULLOREF}"		// DTB886 - Add the pFactList	// DTB913 - Add pSQLUpdate
		Set tMeth.ReturnType = "%Status"
		Set tMeth.Description = "Perform the work of updating one fact in the cube.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateFactTable.<br/>"_$C(13,10)_
       							"DO NOT CALL THIS METHOD DIRECTLY"
		Set tMeth.SequenceNumber = $I(tSeq) + 2000

		Do tMeth.Implementation.WriteLine(" Set tSC = $$$OK")
		Do tMeth.Implementation.WriteLine(" New %ROWID,%msg,%value,%source,%expression")
		Do tMeth.Implementation.WriteLine(" Try {")
		Do tMeth.Implementation.WriteLine("  Set (SQLCODE,tStarId) = """"")
		Do tMeth.Implementation.WriteLine("  Set pErrorMsg = """"")
		Do tMeth.Implementation.WriteLine("  Set pFactId = $G(pFactId)")
		Do tMeth.Implementation.WriteLine("  Set %value = """"")
		
		// DTB886 - If the pFactList is defined, remove everything else from the %var variable.
		// Preserve the original %var for restoration when exiting the method.
		Do tMeth.Implementation.WriteLine("")
		Do tMeth.Implementation.WriteLine("  // + DTB886 - Consult the pFactList. If defined, remove anything that is not in the list from %var")
		Do tMeth.Implementation.WriteLine("  // It is assumed that pFactList is a $lb in this method")
		Do tMeth.Implementation.WriteLine("  Set tLimitedList=0")
		Do tMeth.Implementation.WriteLine("  If (pFactList'="""") {")
		Do tMeth.Implementation.WriteLine("    Set tLimitedList = 1")
		Do tMeth.Implementation.WriteLine("    Set tOrigBatchMode = pBatchMode")		// DTB961 - Remember the original setting
		Do tMeth.Implementation.WriteLine("    Set pBatchMode = 0")		// DTB891 - If the fact list is set, we cannot automatically assume an insert is appropriate
		Do tMeth.Implementation.WriteLine("    Merge tOriginalVar = %var")
		Do tMeth.Implementation.WriteLine("    Set tFact = $O(%var(""""))")
		Do tMeth.Implementation.WriteLine("    While (tFact'="""") {")
		Do tMeth.Implementation.WriteLine("      Kill:'$ListFind(pFactList,tFact) %var(tFact)")
		Do tMeth.Implementation.WriteLine("      Set tFact = $O(%var(tFact))")
		Do tMeth.Implementation.WriteLine("    }")
		Do tMeth.Implementation.WriteLine("  }")
		Do tMeth.Implementation.WriteLine("  If tLimitedList {")
		Do tMeth.Implementation.WriteLine("    If '$G($$$DeepSeeMetaGLVN(""cubes"","_$$$quote(tCubeName)_",""namedFactNums"")) {")
		Do tMeth.Implementation.WriteLine("      Set tSC = $$$ERROR($$$GeneralError,""Cube '"_tCubeName_"' does not support updates using a fact list."")")
		Do tMeth.Implementation.WriteLine("      Quit")
		Do tMeth.Implementation.WriteLine("    }")
		Do tMeth.Implementation.WriteLine("  }")
		Do tMeth.Implementation.WriteLine("  // - DTB886")

		// apply transformations to relationship properties (one-side)
		If $D(pRelationInfo) {
			Do tMeth.Implementation.WriteLine("")
			Do tMeth.Implementation.WriteLine("  #; Transform relationship properties")

			Set r = $O(pRelationInfo(""))
			While (r '= "") {
				Set tStoredSide = +$G(pRelationInfo(r,"storedSide"))
				
				If (tStoredSide) {
					Set tFact = $G(pRelationInfo(r,"fact"))
					Set tInverse = $G(pRelationInfo(r,"inverse"))
					Set tRelatedCube = $G(pRelationInfo(r,"relatedCube"))
					Set tRelatedClass = ##class(%DeepSee.Utils).%GetCubeFactClass(tRelatedCube, .tSC)
					If ((tRelatedClass="")||$$$ISERR(tSC)) {
						Set tSC = $$$ERROR($$$GeneralError,"Related cube must be compiled before this cube: '" _ tRelatedCube _ "'")
						Quit
					}
					Do tMeth.Implementation.WriteLine("  Set tUseCurrFact = $D(%var("_$$$quote(tFact)_"))")		// DTB886 - Note existence of the %var entry
					
					// generate call to transform "source" id into "fact" id
					Set tCardinality = $G(pRelationInfo(r,"cardinality"))
					If (tCardinality="many") {
						Do tMeth.Implementation.WriteLine("  If tUseCurrFact&&$G((%var("_$$$quote(tFact)_"))'="""") {")		// DTB886 - Add $Get
						Do tMeth.Implementation.WriteLine("  Set tList = $G(%var("_$$$quote(tFact)_"))")		// DTB913
						Do tMeth.Implementation.WriteLine("  For ri=1:1:$LL(tList) {")
						Do tMeth.Implementation.WriteLine("  Set tRItem=$LG(tList,ri)")
					}
					Else {
						Do tMeth.Implementation.WriteLine("  Set tRItem=$G(%var("_$$$quote(tFact)_"))")		// DTB886 - Add $Get
					}

					Do tMeth.Implementation.WriteLine("  If (tRItem'="""") {")
					Do tMeth.Implementation.WriteLine("   Set tRItem = $O($$$DeepSeeIndexGLVN("_$$$quote($$$UPPER(tRelatedCube))_",""%sourceId"",tRItem,""""))")
	
					// JMD1450 - make note that remote index is missing this entry
					Do tMeth.Implementation.WriteLine("   If ($D(%dsMissingRef)&&(tRItem="""")) {")
					Do tMeth.Implementation.WriteLine("    Set x = $I(%dsMissingRef)")
					Do tMeth.Implementation.WriteLine("    Set tSC = $$$ERROR($$$GeneralError,""Missing relationship reference in ""_..#CUBENAME_"": source ID ""_pID_"" missing reference to "_tFact_" ""_%var("_$$$quote(tFact)_"))")
					Do tMeth.Implementation.WriteLine("    Do ##class(%DeepSee.Utils).%LogBuildError("_$$$quote(tCubeName)_",pID,tSC)")		// DTB836 - Call API to log the error
					Do tMeth.Implementation.WriteLine("   }")
	
					// JMD746 - skip validation
					/*
						// test if remote index exists
						Do tMeth.Implementation.WriteLine("   If (tRItem="""") {")
						Do tMeth.Implementation.WriteLine("    Set tSC = $$$ERROR($$$GeneralError,""Related item not found in: '"_tRelatedCube_"' for fact ""_"_$$$quote(tFact)_")")
						Do tMeth.Implementation.WriteLine("    Do ..%LogError(tSC)")
						Do tMeth.Implementation.WriteLine("    Quit")
						Do tMeth.Implementation.WriteLine("   }")
					*/

					Do tMeth.Implementation.WriteLine("  }")

					If (tCardinality="many") {

						Do tMeth.Implementation.WriteLine("  Set:tUseCurrFact $List(%var("_$$$quote(tFact)_"),ri)=tRItem")		// DTB886 - Don't set with a null
						Do tMeth.Implementation.WriteLine("  }")

						// if fx'=""
						Do tMeth.Implementation.WriteLine("  }")
					}
					Else {
						Do tMeth.Implementation.WriteLine("  Set:tUseCurrFact %var("_$$$quote(tFact)_") = tRItem")		// DTB886 - Don't set with a null
					}
				}
				Set r = $O(pRelationInfo(r))
				Do tMeth.Implementation.WriteLine("")		// DTB - Added for readability of generated code
			}
		    If $$$ISERR(tSC) Quit
		}

		// apply range expressions
		If $D(tRangeProps) {
			Do tMeth.Implementation.WriteLine("")
			Do tMeth.Implementation.WriteLine("  #; apply range replacements")
			Set p = $O(tRangeProps(""))
			While (p '= "") {
				Set tSC = ##class(%DeepSee.Utils).%ParseRangeExpression(tRangeProps(p),,"",.tRangeCode)
			    If $$$ISERR(tSC) Quit

				Do tMeth.Implementation.WriteLine("  Set x = $G(%var("_$$$quote(p)_"))")

				If ($D(tRangePropsList(p))) {
					// special handling for list types
					Do tMeth.Implementation.WriteLine("  Set %var("_$$$quote(p)_") = "_tRangeCode)
				}
				Else {
					Do tMeth.Implementation.WriteLine("  Set %var("_$$$quote(p)_") = "_tRangeCode)
				}
				Set p = $O(tRangeProps(p))
			}
		    If $$$ISERR(tSC) Quit
		}

		// apply linkProperty replacements
		If $D(tLinkProps) {
			Do tMeth.Implementation.WriteLine("")
			Do tMeth.Implementation.WriteLine("  #; apply linkProperty replacements")
		
			Set p = $O(tLinkProps(""))
			While (p '= "") {
				Set tLinkClass = $G(pFactInfo("prop",p,"linkClass"))
				Set tLinkProperty = $G(pFactInfo("prop",p,"linkProperty"))
				Set tLinkTable = ..%GetSQLTableName(tLinkClass)

				// translate linkProperty from property to field name
				Set tLinkField = ..%GetSQLFieldExpression(.tSC,tLinkClass,tLinkProperty)
			    If $$$ISERR(tSC) Quit
				
				Set tLinkName = tLinkProps(p)

				Do tMeth.Implementation.WriteLine("  If (%var("_$$$quote(tLinkName)_")'="""") {")
				Do tMeth.Implementation.WriteLine("   &SQL(SELECT "_tLinkField_" INTO :tValue FROM "_tLinkTable_" WHERE %ID = :%var("_$$$quote(tLinkName)_"))")
				Do tMeth.Implementation.WriteLine("   Set %var("_$$$quote(tLinkName)_") = $S(((SQLCODE=0)||(SQLCODE=100)):$G(tValue),1:"""")")
				Do tMeth.Implementation.WriteLine("  }")
				Set p = $O(tLinkProps(p))
			}
		    If $$$ISERR(tSC) Quit
		}

		// apply null replacements
		If $D(tNullProps) {
			Set tNullMarker = $$$DeepSeeNullMarker

			Do tMeth.Implementation.WriteLine("")
			Do tMeth.Implementation.WriteLine("  #; apply null replacements")

			Set p = $O(tNullProps(""))
			While (p '= "") {
				If ($D(tNullPropsList(p))) {
					// special handling for list types
					Do tMeth.Implementation.WriteLine("  Set:$D(%var("_$$$quote(p)_"))&&(($G(%var("_$$$quote(p)_"))="""")||($G(%var("_$$$quote(p)_"))=$C(0))) %var("_$$$quote(p)_") = $LB("_$$$quote(tNullMarker)_")")		// DTB886 - Prevent null replacement if the %var entry is removed
				}
				Else {
					// test for null or $C(0)
					Do tMeth.Implementation.WriteLine("  Set:$D(%var("_$$$quote(p)_"))&&(($G(%var("_$$$quote(p)_"))="""")||($G(%var("_$$$quote(p)_"))=$C(0))) %var("_$$$quote(p)_") = "_$$$quote(tNullMarker))		// DTB886 - Prevent null replacement if the %var entry is removed
				}
				Set p = $O(tNullProps(p))
			}
		    If $$$ISERR(tSC) Quit
		}

		Do tMeth.Implementation.WriteLine("")

		// if batch mode: turn off transactions, set insert flag
		Do tMeth.Implementation.WriteLine("  If (pDimensionsOnly) {")
		Do tMeth.Implementation.WriteLine("   Set tFactId=""""")
		Do tMeth.Implementation.WriteLine("   Set tIsInsert = 1")
		Do tMeth.Implementation.WriteLine("  }")

		Do tMeth.Implementation.WriteLine("  ElseIf (pBatchMode) {")
		Do tMeth.Implementation.WriteLine("   Set zuSetting = $zu(115,1,0)")
		Do tMeth.Implementation.WriteLine("   Set tIsInsert = 1")
		Do tMeth.Implementation.WriteLine("  }")
		Do tMeth.Implementation.WriteLine("  ElseIf (pID'="""") {")

		// get fact id from index
		// We have to do this check directly as we do not report this index to SQL
		Do tMeth.Implementation.WriteLine("   Set tFactId = $O($$$DeepSeeIndexGLVN("_$$$quote(tCubeName)_","_$$$quote("%sourceId")_",pID,""""))")
		Do tMeth.Implementation.WriteLine("   Set tIsInsert = ''(tFactId="""")")
		Do tMeth.Implementation.WriteLine("  }")

		Do tMeth.Implementation.WriteLine("  ElseIf (pFactId'="""") {")
		// no source id: see the provided factId exists
		Do tMeth.Implementation.WriteLine("   If ($D($$$DeepSeeIndexGLVN("_$$$quote(tCubeName)_","_$$$quote("%sourceIdReverse")_",pFactId))) {")
		Do tMeth.Implementation.WriteLine("    Set tFactId = pFactId")
		Do tMeth.Implementation.WriteLine("    Set tIsInsert = 0")
		Do tMeth.Implementation.WriteLine("   }")
		Do tMeth.Implementation.WriteLine("   Else {")
		Do tMeth.Implementation.WriteLine("    Set tFactId = """"")
		Do tMeth.Implementation.WriteLine("    Set tIsInsert = 1")
		Do tMeth.Implementation.WriteLine("   }")
		Do tMeth.Implementation.WriteLine("  }")

		Do tMeth.Implementation.WriteLine("  Else {")
		Do tMeth.Implementation.WriteLine("   Set tFactId = """"")
		Do tMeth.Implementation.WriteLine("   Set tIsInsert = 1")
		Do tMeth.Implementation.WriteLine("  }")
		
		// DTB899 - Check conditions and quit out if all are true:
		// - tLimitedList = 1
		// - pBatchMode = 0		(NB: this is the flag that can be used for a "rolling build" insert on the first column)
		// - tInsert = 1
		// This is what establishes the default behavior of UPDATE only for selective update calls
		Do tMeth.Implementation.WriteLine("")
		Do tMeth.Implementation.WriteLine("  If ('pBatchMode && tLimitedList && tIsInsert) {")
		Do tMeth.Implementation.WriteLine("    Quit")
		Do tMeth.Implementation.WriteLine("  }")

		#; check for callback
		If ($$$comMemberKeyGet(pCubeClass,$$$cCLASSmethod,"%OnProcessFact",$$$cMETHrunnable)) {
			Do tMeth.Implementation.WriteLine("  Set tSkip = 0")
			Do tMeth.Implementation.WriteLine("  Set:'pDimensionsOnly tSC = ##class("_pCubeClass_").%OnProcessFact(pID,.%var,.tSkip,tIsInsert)")
			Do tMeth.Implementation.WriteLine("  If (tSkip || $$$ISERR(tSC)) {")
			Do tMeth.Implementation.WriteLine("   Set pFactId=""""")
			Do tMeth.Implementation.WriteLine("   Quit")
			Do tMeth.Implementation.WriteLine("  }")
		}

		// UPDATE STAR TABLES
		// process in dependency order
		Set tUseLocks = 1
		Set n = $O(tOrderedStar(""))
		While (n '= "") {
			Set tStar = tOrderedStar(n)
			Set f = $O(tStarField(tStar,""))
			While (f '= "") {
				Do tMeth.Implementation.WriteLine("")
				Do tMeth.Implementation.WriteLine(" #; STAR Table: " _ tStar)

				Set tFactNo = +$G(tStarField(tStar,f,"fact"))
				Set tIsList = +$G(tStarField(tStar,f,"list"))
				Set tDelim = $G(tStarField(tStar,f,"listDelimiter"))

				#; we have to get SQL name manually as oddCOM does not exist yet!
				Set tStarSchema = $P(tStar,".",1,$L(tStar,".")-1)
				Set tStarClass = $P(tStar,".",$L(tStar,"."))
				Set tStarName = $TR(tStarSchema,".","_")_"."_tStarClass
				Set tShared = $G(pStarInfo(tStar,"sharedCube"))
				If (tShared'="") {
					Set tRefTable = ##class(%DeepSee.Utils).%GetCubeFactTable(tShared)
					Set tRefSchema = $P(tRefTable,".",1)
					Set tStarName = tRefSchema_"."_tStarClass
				}

				// test if we already have the entry in the Star Table
				Do tMeth.Implementation.WriteLine(" If ($G(%var("_$$$quote(f)_"))'="""") {")

				// if list, copy value into temp var
				If (tIsList) {
					Do tMeth.Implementation.WriteLine(" Set tList = $G(%var("_$$$quote(f)_"))")
					If (tDelim="") {
						Do tMeth.Implementation.WriteLine(" For k = 1:1:$LL(tList) {")
						Do tMeth.Implementation.WriteLine("  Set %var("_$$$quote(f)_") = $LG(tList,k)")
					}
					Else {
						Do tMeth.Implementation.WriteLine(" For k = 1:1:$L(tList,"_$$$quote(tDelim)_") {")
						Do tMeth.Implementation.WriteLine("  Set %var("_$$$quote(f)_") = $P(tList,"_$$$quote(tDelim)_",k)")
					}
					// skip missing items within the list
					Do tMeth.Implementation.WriteLine("  If %var("_$$$quote(f)_") = """" Continue")
				}

				// Find primary index for STAR table
				Set tPrimaryIndex = $G(pStarInfo(tStar,"primary"))
				If (tPrimaryIndex="") {
					// This should NEVER happen unless the table/cube we are referring to is not compiled
					Set tSC = $$$ERROR($$$GeneralError,"No primary index found for dimension table: " _ tStar)
					Quit
				}
				Set UPDATEWHERE = ""	// WHERE clause for dim table UPDATE

				Set tKeyExpr = ..%GetDimensionLocation(tStar,"I")
				Set tKeyExpr = $TR(tKeyExpr,")",",") // replace final )
				Set tKeyExpr = tKeyExpr _ """Primary"","
				For t = 1:1:$L(tPrimaryIndex,",") {
					Set tKeyField = $P(tPrimaryIndex,",",t)
					Set tKeyCollation = $G(pStarInfo(tStar,"prop",tKeyField,"collation"))
					If ((t = $L(tPrimaryIndex,","))&&(tKeyCollation'="exact")) {
						// collate last item
						// JMD1190: change to match SQLUPPER(113)
						Set tKeyExpr = tKeyExpr _ $S(t>1:",",1:"") _ "$zu(28,$G(%var("_$$$quote(tKeyField)_")),7,113)"		// DTB913
					}
					Else {
						Set tKeyExpr = tKeyExpr _ $S(t>1:",",1:"") _ "$G(%var("_$$$quote(tKeyField)_"))"		// DTB913
					}
					Set UPDATEWHERE = UPDATEWHERE _ $S(UPDATEWHERE="":"",1:" AND ") _ tKeyField_"=:%var("_$$$quote(tKeyField)_")"
				}
				Set tKeyExpr = tKeyExpr _ ","""")"

				#; find KEY and ROLLUP fields for star table
				Set tKeyField = ""
				Set tRollupClause = ""
				Set tName = $O(pStarInfo(tStar,"prop",""))
				While (tName '= "") {
					Set tUse = $G(pStarInfo(tStar,"prop",tName,"use"))
					If (tUse = "key") {
						Set tKeyField = tName
					}
					Set tName = $O(pStarInfo(tStar,"prop",tName))
				}

				Set tUpdateStarTable = 0
				If (tUpdateStarTable) {
					// special test for UPDATE of dimension table
					// if %SynchronizeCube is calling this, then the pDimTables array will
					// contain this dimension table; this means we have to UPDATE the values
					// in the dimension table
					Do tMeth.Implementation.WriteLine("  If ($D(pDimTables("_$$$quote(tStar)_"))) {")
					Do tMeth.Implementation.WriteLine("   #; update dimension table")

					// create UPDATE statement for STAR table
					// should match INSERT logic below
					Set INTO = tKeyField
					Set VALUES = ":%var("_$$$quote(tKeyField)_")"
					Set tName = $O(pStarInfo(tStar,"prop",""))
					While (tName '= "") {
						Set tUse = $G(pStarInfo(tStar,"prop",tName,"use"))
						Set tIsRef = +$G(pStarInfo(tStar,"prop",tName,"isref"))
						If ('tIsRef && (tUse '= "key")) {
							Set INTO = INTO _ $S(INTO="":"",1:",") _ tName
							Set VALUES = VALUES _ $S(VALUES="":"",1:",") _ ":%var("_$$$quote(tName)_")"
						}
						Set tName = $O(pStarInfo(tStar,"prop",tName))
					}
					Do tMeth.Implementation.WriteLine("   &sql(UPDATE "_tStarName_" ("_INTO_") VALUES ("_VALUES_") WHERE "_UPDATEWHERE_")")

					// make sure axis cache is invalid
					Do tMeth.Implementation.WriteLine("   Kill $$$DeepSeeAxisGLVN("_$$$quote($$$UPPER(pCube.name))_")")
					Do tMeth.Implementation.WriteLine("  }")
				} // end of update

				// test if we already have this member in the dimension table
				// use direct expression against index in dimension table
				Do tMeth.Implementation.WriteLine("  Set tStarId = $O("_tKeyExpr_")")

				// Get local id value
				Do tMeth.Implementation.WriteLine("  If (tStarId '= """") {")
				Do tMeth.Implementation.WriteLine("   Set %var("_$$$quote(f)_") = tStarId")
				Do tMeth.Implementation.WriteLine("  }")

				// Insert into STAR table
				Do tMeth.Implementation.WriteLine("  Else {")

				If (tUseLocks) {
					// take out a lock to ensure valid unique checking
					// JMD1190 apply collation to lock key
					Do tMeth.Implementation.WriteLine("  Set tLockKey = $zu(28,%var("_$$$quote(f)_"),7,113)")
					// JMD843: use hard-coded 15 second lock as users mess with $ZU(115,4)
					Do tMeth.Implementation.WriteLine("  Lock +$$$DeepSeeIndexGLVN("_$$$quote(tStar)_",tLockKey):15")
					Do tMeth.Implementation.WriteLine("  If '$Test {")
					Do tMeth.Implementation.WriteLine("   Set tSC = $$$ERROR($$$GeneralError,""Unable to acquire lock for dimension table: '"_tStarName_"'"")")
					Do tMeth.Implementation.WriteLine("   Quit")
					Do tMeth.Implementation.WriteLine("  }")

					// test again if we already have this member in the dimension table
					Do tMeth.Implementation.WriteLine("  Set tStarId = $O("_tKeyExpr_")")
					Do tMeth.Implementation.WriteLine("   If (tStarId '= """") {")
					Do tMeth.Implementation.WriteLine("    Set %var("_$$$quote(f)_") = tStarId")
					Do tMeth.Implementation.WriteLine("   }")
					Do tMeth.Implementation.WriteLine("   Else {")
				}

				// create insert statement for STAR table
				Set INTO = tKeyField
				Set VALUES = ":%var("_$$$quote(tKeyField)_")"
				Set tName = $O(pStarInfo(tStar,"prop",""))
				While (tName '= "") {
					Set tUse = $G(pStarInfo(tStar,"prop",tName,"use"))
					Set tIsRef = +$G(pStarInfo(tStar,"prop",tName,"isref"))
					If ('tIsRef && (tUse '= "key")) {
						Set INTO = INTO _ $S(INTO="":"",1:",") _ tName
						Set VALUES = VALUES _ $S(VALUES="":"",1:",") _ ":%var("_$$$quote(tName)_")"
					}

					// JMD929: evaluate property expressions containing %value references
					Set tPExpr = $G(pStarInfo(tStar,"prop",tName,"expr"))
					If (tPExpr["%value") {
						// convert expression to code
						Set tSC = ..%ParseExpression(tPExpr, .tPCode, .tPPropList)
						If $$$ISERR(tSC) Quit

						// now replace %expression
						Set tSC = ..%ParseExpression(tPCode, .tPCode, .tPPropListX,"%expression")
						If $$$ISERR(tSC) Quit

						// replace method calls
						Set:$IsObject($G(%class)) tPCode = $Replace(tPCode,"%cube.","##class("_%class.Name_").")

						// build context for expression
						Do tMeth.Implementation.WriteLine("    Kill %source")
						Set p2 = $O(tPPropList(""))
						While (p2'="") {
							Do tMeth.Implementation.WriteLine("    Set %source("_$$$quote(p2)_")=$G(%var("_$$$quote(tName)_",""src"","_$$$quote(p2)_"))")
							Set p2 = $O(tPPropList(p2))
						}
						// build context for expression
						Do tMeth.Implementation.WriteLine("    Kill %expression")
						Set p2 = $O(tPPropListX(""))
						While (p2'="") {
							Do tMeth.Implementation.WriteLine("    Set %expression("_$$$quote(p2)_")=$G(%var("_$$$quote(tName)_",""exp"","_$$$quote(p2)_"))")
							Set p2 = $O(tPPropListX(p2))
						}

						Do tMeth.Implementation.WriteLine("    Set %value = $G(%var("_$$$quote(tKeyField)_"))")		// DTB913
						Do tMeth.Implementation.WriteLine("    Set %var("_$$$quote(tName)_")="_tPCode)
						Do tMeth.Implementation.WriteLine("    Set %value = """"")
					}
					Set tName = $O(pStarInfo(tStar,"prop",tName))
				}


				Do tMeth.Implementation.WriteLine("    &sql(INSERT INTO "_tStarName_" ("_INTO_") VALUES ("_VALUES_"))")
				Do tMeth.Implementation.WriteLine("    If (SQLCODE'=0) {")
				If (tUseLocks) {
					Do tMeth.Implementation.WriteLine("     Lock -$$$DeepSeeIndexGLVN("_$$$quote(tStar)_",tLockKey)")
				}
				Do tMeth.Implementation.WriteLine("     Set tSC = $$$ERROR($$$GeneralError,""Insert into dimension table failed: '"_tStarName_"' SQLCODE=""_SQLCODE)")
				Do tMeth.Implementation.WriteLine("     Quit")
				Do tMeth.Implementation.WriteLine("    }")
				Do tMeth.Implementation.WriteLine("    Set %var("_$$$quote(f)_") = %ROWID")

				Do tMeth.Implementation.WriteLine("   }")

				// release lock
				If (tUseLocks) {
					Do tMeth.Implementation.WriteLine("   Lock -$$$DeepSeeIndexGLVN("_$$$quote(tStar)_",tLockKey)")
					Do tMeth.Implementation.WriteLine("  }")
				}

				If (tIsList) {
					// accumulate results
					If (tDelim="") {
						Do tMeth.Implementation.WriteLine(" Set $List(tList,k) = $G(%var("_$$$quote(f)_"))")
					}
					Else {
						Do tMeth.Implementation.WriteLine(" Set $P(tList,"_$$$quote(tDelim)_",k) = $G(%var("_$$$quote(f)_"))")
					}
					Do tMeth.Implementation.WriteLine(" }") // for k
					Do tMeth.Implementation.WriteLine(" Quit:$$$ISERR(tSC)") // for k
					Do tMeth.Implementation.WriteLine(" Set %var("_$$$quote(f)_") = tList")
				}

				Do tMeth.Implementation.WriteLine(" }")

				Set f = $O(tStarField(tStar,f)) // next field
			}
			If $$$ISERR(tSC) Quit
			Set n = $O(tOrderedStar(n)) // next table
		}
		If $$$ISERR(tSC) Quit

		// test if new dimension level was filed (non-batch mode)
		// if the value for a member is not in the index, then assume
		// we have a new value.

		Do tMeth.Implementation.WriteLine(" If ('pBatchMode) {")
		Set tFactNo = $O(tLevelTest(""),1,data)
		While (tFactNo '= "") {
			Set tPropName = $LG(data,1)
			Set tFunctionClass = $LG(data,2)
			Set tFunction = $LG(data,3)
			Set tBase = $LG(data,4)
			Set tTimeOffset = $LG(data,5)
			Set tIsList = $LG(data,6)
			Set tDelim = $LG(data,7)

			If (tFunction = "") {
				Set tValExpr = "$G(%var("_$$$quote(tPropName)_"))"		// DTB886 - Add $G
			}
			ElseIf ((tFunction="%Convert")&&(tTimeOffset'="")) {
				Set tTimeOffset = $ZSTRIP(tTimeOffset,"<>W")
				// Invert offset
				If ($E(tTimeOffset)="-") {
					Set tTimeOffset = $E(tTimeOffset,2,$L(tTimeOffset))
				}
				ElseIf (tTimeOffset'="") {
					Set tTimeOffset = "-"_tTimeOffset
				}
				Set tValExpr = "##class("_tFunctionClass_")."_tFunction_"($G(%var("_$$$quote(tBase)_")),"_$$$quote(tTimeOffset)_")"		// DTB911 - Add $G
			}
			Else {
				Set tValExpr = "##class("_tFunctionClass_")."_tFunction_"($G(%var("_$$$quote(tBase)_")))"		// DTB911 - Add $G
			}
			Set tTestCode = "'$D($$$DeepSeeIndexGLVN("_$$$quote(tCubeName)_","_tFactNo_",tVal))"

			// JMD1452: check for list data
			If (tIsList) {
				Do tMeth.Implementation.WriteLine("    Set tList = " _ tValExpr)
				If (tDelim="") {
					Do tMeth.Implementation.WriteLine("    For k = 1:1:$LL(tList) {")
					Do tMeth.Implementation.WriteLine("     Set tVal = $LG(tList,k)")
				}
				Else {
					Do tMeth.Implementation.WriteLine("    For k = 1:1:$L(tList,"_$$$quote(tDelim)_") {")
					Do tMeth.Implementation.WriteLine("     Set tVal = $P(tList,"_$$$quote(tDelim)_",k)")
				}
			}
			Else {
				Do tMeth.Implementation.WriteLine("    Set tVal = " _ tValExpr)
			}

			Do tMeth.Implementation.WriteLine("    If ((tVal'="""")&&("_tTestCode_")) {")
			Do tMeth.Implementation.WriteLine("     Set ts = $I($$$DeepSeeResultsGLVN("_$$$quote(tCubeName)_",""fact"","_tFactNo_"))")
			If (tIsList) {
				// one change is enough
				Do tMeth.Implementation.WriteLine("     Quit")
			}
			Do tMeth.Implementation.WriteLine("    }")
			If (tIsList) {
				Do tMeth.Implementation.WriteLine("    }")
			}

			Set tFactNo = $O(tLevelTest(tFactNo),1,data)
		}
		Do tMeth.Implementation.WriteLine(" }")

		// INSERT into FACT table
		Set INTO = "%sourceId"
		Set VALUES = ":pID"
		Set f = $O(tInsertList(""))
		While (f '= "") {
			// skip iknow props
			If '$D(tiKnowSkip(f)) {
				Set INTO = INTO _ $S(INTO="":"",1:",") _ f
				Set VALUES = VALUES _ $S(VALUES="":"",1:",") _ ":%var("_$$$quote(f)_")"
			}
			Set f = $O(tInsertList(f))
		}

		// 2 versions depending on batch mode
		Set tRestrictFlags = " %NOLOCK %NOINDEX"
		Do tMeth.Implementation.WriteLine("")		// DTB - Added for readability of generated code
		Do tMeth.Implementation.WriteLine(" #; INSERT or UPDATE data into fact table")
		
		// + DTB886 - Build these for all the cases below. It's cheap so build it even if it doesn't get used.
		Do tMeth.Implementation.WriteLine(" // DTB886 - Build these for relevant cases below.")
		Do tMeth.Implementation.WriteLine(" Set tListINTO = ""%sourceId""")
		Do tMeth.Implementation.WriteLine(" Set tListParameters = ""?""")
		Do tMeth.Implementation.WriteLine(" Set tListVALUES($I(tListVALUES)) = pID")
		Do tMeth.Implementation.WriteLine(" Set tFact = $O(%var(""""))")
		Do tMeth.Implementation.WriteLine(" While (tFact'="""") {")
		Do tMeth.Implementation.WriteLine("   Set tListINTO = tListINTO _ $S($L(tListINTO):"","",1:"""") _ tFact")
		Do tMeth.Implementation.WriteLine("   Set tListParameters = tListParameters _ $S($L(tListParameters):"","",1:"""") _ ""?""")
		Do tMeth.Implementation.WriteLine("   Set tListVALUES($I(tListVALUES)) = $G(%var(tFact))")
		Do tMeth.Implementation.WriteLine("   Set tFact = $O(%var(tFact))")
		Do tMeth.Implementation.WriteLine(" }")
		Do tMeth.Implementation.WriteLine(" Set:'tIsInsert tListVALUES($I(tListVALUES)) = tFactId")
		Do tMeth.Implementation.WriteLine("")
		// - DTB886
		
		Do tMeth.Implementation.WriteLine(" If (pDimensionsOnly) {")
		Do tMeth.Implementation.WriteLine(" }")
		Do tMeth.Implementation.WriteLine(" ElseIf (pBatchMode) {")

		// in batch mode no need to test for updates
		// + DTB886 - Add treatment of the limited list of facts to update
		Do tMeth.Implementation.WriteLine("  If tLimitedList {")		// DTB866
		Do tMeth.Implementation.WriteLine("    // DTB886 - Handle a defined incoming pFactList. This forces use of dynamic SQL and has trimmed the available %var")

		// + DTB913 - Prepare a single dynamic INSERT that can be reused. This should not interact with UPDATES since it is triggered by pBatchMode
		Do tMeth.Implementation.WriteLine("    If '$IsObject(pSQLUpdate) {")
		Do tMeth.Implementation.WriteLine("    	Set tSQL = ""INSERT"_tRestrictFlags_" INTO "_tFactTableName_" (""_tListINTO_"") VALUES (""_tListParameters_"")""")
		Do tMeth.Implementation.WriteLine("")    		
		Do tMeth.Implementation.WriteLine("    	Set pSQLUpdate = ##class(%SQL.Statement).%New()")
		Do tMeth.Implementation.WriteLine("    	Set tSC = pSQLUpdate.%Prepare(tSQL)")
		Do tMeth.Implementation.WriteLine("    	If $$$ISERR(tSC) Quit")
 		Do tMeth.Implementation.WriteLine("    }")
 		Do tMeth.Implementation.WriteLine("    Set tListResult = pSQLUpdate.%Execute(tListVALUES...)")
		// - DTB913
		
		Do tMeth.Implementation.WriteLine("")
		Do tMeth.Implementation.WriteLine("    Set pFactId = tListResult.%ROWID")
		Do tMeth.Implementation.WriteLine("    Set SQLCODE = tListResult.%SQLCODE")
		Do tMeth.Implementation.WriteLine("  }")
		// - DTB886
		Do tMeth.Implementation.WriteLine("  Else {")
		Do tMeth.Implementation.WriteLine("    &sql(INSERT"_tRestrictFlags_" INTO "_tFactTableName_" ("_INTO_")")
		Do tMeth.Implementation.WriteLine("         VALUES ("_VALUES_"))")
		Do tMeth.Implementation.WriteLine("    Set pFactId = %ROWID")
		
		// set sourceId and reverse sourceId indices
		Do tMeth.Implementation.WriteLine("  }")
		Do tMeth.Implementation.WriteLine("  If (pFactId'="""") {")
		Do tMeth.Implementation.WriteLine("    Set:pID'="""" $$$DeepSeeIndexGLVN("_$$$quote(tCubeName)_","_$$$quote("%sourceId")_",pID,pFactId) = """"")
		Do tMeth.Implementation.WriteLine("    Set $$$DeepSeeIndexGLVN("_$$$quote(tCubeName)_","_$$$quote("%sourceIdReverse")_",pFactId) = pID")
		Do tMeth.Implementation.WriteLine("  }")
		Do tMeth.Implementation.WriteLine(" }")

		Set tRestrictFlags = ""
		Do tMeth.Implementation.WriteLine(" Else {")

		Do tMeth.Implementation.WriteLine("  If ($G(tFactId)'="""") {")
		// + DTB886 - Add treatment of the limited list of facts to update
		Do tMeth.Implementation.WriteLine("   If tLimitedList {")
		Do tMeth.Implementation.WriteLine("    // DTB886 - Handle a defined incoming pFactList. This forces use of dynamic SQL and has trimmed the available %var")

		// + DTB913 - Prepare a single dynamic UPDATE that can be reused. This should not interact with INSERTs since it is triggered by pBatchMode
		Do tMeth.Implementation.WriteLine("    If '$IsObject(pSQLUpdate) {")
		Do tMeth.Implementation.WriteLine("    	Set tSQL = ""UPDATE""_$S(+$G(tOrigBatchMode):"" %NOINDEX"",1:"""")_"" "_tFactTableName_" (""_tListINTO_"") VALUES (""_tListParameters_"") WHERE %ID = ?""")		//< --- Build the list of '?' characters in the loop, build the actual args in an array 
		Do tMeth.Implementation.WriteLine("")    		
		Do tMeth.Implementation.WriteLine("    	Set pSQLUpdate = ##class(%SQL.Statement).%New()")
		Do tMeth.Implementation.WriteLine("    	Set tSC = pSQLUpdate.%Prepare(tSQL)")
		Do tMeth.Implementation.WriteLine("    	If $$$ISERR(tSC) Quit")
 		Do tMeth.Implementation.WriteLine("    }")
 		Do tMeth.Implementation.WriteLine("    Set tListResult = pSQLUpdate.%Execute(tListVALUES...)")
		// - DTB913
		
		Do tMeth.Implementation.WriteLine("")    	
		Do tMeth.Implementation.WriteLine("    Set pFactId = tFactId")
		Do tMeth.Implementation.WriteLine("    Set SQLCODE = tListResult.%SQLCODE")
		Do tMeth.Implementation.WriteLine("   }")
		// - DTB886
		Do tMeth.Implementation.WriteLine("   Else {")
		Do tMeth.Implementation.WriteLine("    &sql(UPDATE"_tRestrictFlags_" "_tFactTableName_" ("_INTO_")")
		Do tMeth.Implementation.WriteLine("         VALUES ("_VALUES_") WHERE %ID = :tFactId)")
		Do tMeth.Implementation.WriteLine("    Set pFactId = tFactId")
		Do tMeth.Implementation.WriteLine("   }")
		Do tMeth.Implementation.WriteLine("  }")
		Do tMeth.Implementation.WriteLine("  Else {")
		// + DTB886 - Add treatment of the limited list of facts to update
		Do tMeth.Implementation.WriteLine("   If tLimitedList {")		// DTB866
		Do tMeth.Implementation.WriteLine("     // DTB886 - Handle a defined incoming pFactList. This forces use of dynamic SQL and has trimmed the available %var")

		// + DTB913 - Prepare a single dynamic INSERT that can be reused. This should not interact with UPDATES since it is triggered by pBatchMode
		Do tMeth.Implementation.WriteLine("    If '$IsObject(pSQLUpdate) {")
		Do tMeth.Implementation.WriteLine("    	Set tSQL = ""INSERT"_tRestrictFlags_" INTO "_tFactTableName_" (""_tListINTO_"") VALUES (""_tListParameters_"")""")
		Do tMeth.Implementation.WriteLine("")    		
		Do tMeth.Implementation.WriteLine("    	Set pSQLUpdate = ##class(%SQL.Statement).%New()")
		Do tMeth.Implementation.WriteLine("    	Set tSC = pSQLUpdate.%Prepare(tSQL)")
		Do tMeth.Implementation.WriteLine("    	If $$$ISERR(tSC) Quit")
 		Do tMeth.Implementation.WriteLine("    }")
 		Do tMeth.Implementation.WriteLine("    Set tListResult = pSQLUpdate.%Execute(tListVALUES...)")
		// - DTB913

		Do tMeth.Implementation.WriteLine("")
		Do tMeth.Implementation.WriteLine("    Set pFactId = tListResult.%ROWID")
		Do tMeth.Implementation.WriteLine("    Set SQLCODE = tListResult.%SQLCODE")
		Do tMeth.Implementation.WriteLine("   }")
		// - DTB886
		Do tMeth.Implementation.WriteLine("   Else {")
		Do tMeth.Implementation.WriteLine("     &sql(INSERT"_tRestrictFlags_" INTO "_tFactTableName_" ("_INTO_")")
		Do tMeth.Implementation.WriteLine("          VALUES ("_VALUES_"))")
		Do tMeth.Implementation.WriteLine("     Set pFactId = %ROWID")

		// set sourceId and reverse sourceId indices
		Do tMeth.Implementation.WriteLine("   }")
		Do tMeth.Implementation.WriteLine("  }")
		Do tMeth.Implementation.WriteLine("  If (pFactId'="""") {")
		Do tMeth.Implementation.WriteLine("    Set:pID'="""" $$$DeepSeeIndexGLVN("_$$$quote(tCubeName)_","_$$$quote("%sourceId")_",pID,pFactId) = """"")
		Do tMeth.Implementation.WriteLine("    Set $$$DeepSeeIndexGLVN("_$$$quote(tCubeName)_","_$$$quote("%sourceIdReverse")_",pFactId) = pID")
		Do tMeth.Implementation.WriteLine("  }")
		Do tMeth.Implementation.WriteLine(" }")

		// test for error
		// !!! on error make sure we remove this fact from the fact table !!!
		// !!! test INSERT/UPDATE errors separately
		// !!! SQLCODE=100 is no good!
		Do tMeth.Implementation.WriteLine(" If (SQLCODE'=0) {")
		Do tMeth.Implementation.WriteLine("  Set pErrorMsg = $G(%msg)")
		Do tMeth.Implementation.WriteLine("  Set tSC = $$$ERROR($$$GeneralError,""Error inserting/updating fact: (Source ID:'""_pID_""') ""_pErrorMsg)")

 		Do tMeth.Implementation.WriteLine(" }")

		// pass iKnow properties on to iKnow class
		If $D(tiKnowProps) {
			// ('pBatchMode)&&
			Do tMeth.Implementation.WriteLine(" If ((pFactId'="""")) {")
			Set tiProp = $O(tiKnowProps(""))
			While (tiProp'="") {
				Do tMeth.Implementation.WriteLine("  Set tFlag = $S(pFactId=$G(tFactId):""U"",1:""I"")")
				Set tiType = $P($G(tiKnowProps(tiProp)),":",2)
				Set:tiType="" tiType = "string"

				// pass measure name to iKnow
				Set tMsrName = $G(pFactInfo("prop",tiProp,"msrname"))
				
				// BDB456 - avoid UNDEFINED if factName was set for iKnow measure
				set tiFactName = $g(pFactInfo("prop",tiProp,"alias"), tiProp)
				
				Do tMeth.Implementation.WriteLine("  Set tIkStartTime = $ZH")
				Do tMeth.Implementation.WriteLine("  Set tSC=##class(%iKnow.DeepSee.CubeUtils).%ProcessIKnowFact("_$$$quote(tCubeName)_",pBatchMode,tFlag,pFactId,"_$$$quote(tMsrName)_","_"%var(" _ $$$quote(tiFactName) _ "),"_$$$quote(tiType)_")")
				Do tMeth.Implementation.WriteLine("  Set tIkTime = $ZH-tIkStartTime")
				Do tMeth.Implementation.WriteLine("  Set x = $I(^IRIS.Temp.DeepSeeBuildStats($namespace,"_$$$quote($$$UPPER(pCube.name))_",""iknow""),tIkTime)")
				Set tiProp = $O(tiKnowProps(tiProp))
			}
			Do tMeth.Implementation.WriteLine(" }")
		}

		Do tMeth.Implementation.WriteLine(" }") // try
		Do tMeth.Implementation.WriteLine(" Catch(ex) {")
		Do tMeth.Implementation.WriteLine("  Set tSC = ex.AsStatus()")
		Do tMeth.Implementation.WriteLine("  Set pErrorMsg = $ZE")
		Do tMeth.Implementation.WriteLine(" }")

		// restore transaction setting
		Do tMeth.Implementation.WriteLine(" Set:$D(zuSetting) zuSetting = $zu(115,1,zuSetting)")
		Do tMeth.Implementation.WriteLine("")
		
 		Do tMeth.Implementation.WriteLine(" // DTB886 - Restore original %var if it was trimmed by pFactList")
 		Do tMeth.Implementation.WriteLine(" Merge %var=tOriginalVar")
 		Do tMeth.Implementation.WriteLine("")
 		
		// DTB290 - Run %OnAfterProcessFact before logging any errors.
		If ($$$comMemberKeyGet(pCubeClass,$$$cCLASSmethod,"%OnAfterProcessFact",$$$cMETHrunnable)) {
			Do tMeth.Implementation.WriteLine(" Do ##class("_pCubeClass_").%OnAfterProcessFact(pID,.%var,tSC)		// DTB290 - Call %OnAfterProcessFact before logging errors")
		}
		
		Do tMeth.Implementation.WriteLine(" If $$$ISERR(tSC) {")
		Do tMeth.Implementation.WriteLine("  Do ..%LogError(tSC)")
		// JMD1480
		// WAL245 -- check to see pID exists
		Do tMeth.Implementation.WriteLine("  If ($G(pID)'="""") {")
		Do tMeth.Implementation.WriteLine("  Do ##class(%DeepSee.Utils).%LogBuildError("_$$$quote(tCubeName)_",pID,tSC)")		// DTB836 - Call API to log the error
		Do tMeth.Implementation.WriteLine(" }")
		Do tMeth.Implementation.WriteLine(" }")

		Do tMeth.Implementation.WriteLine(" Quit tSC")
		Do tClassDef.Methods.Insert(tMeth)
		// End of %ProcessFact

		#; %OnStartBatch method
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%OnStartBatch")
		Set tMeth.Name = "%OnStartBatch"
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = "pCubeName:%String,pVerbose:%Boolean=0"
		Set tMeth.ReturnType = "%Status"
		Set tMeth.Description = "Notification that a batch of facts are about to be processed.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateFactTable.<br/>"_$C(13,10)_
       							"DO NOT CALL THIS METHOD DIRECTLY"
		Set tMeth.SequenceNumber = $I(tSeq) + 2000
		If $D(tiKnowProps) {
			Set ip = $O(tiKnowProps(""))
			While (ip'="") {
				Set tMsrName = $G(pFactInfo("prop",ip,"msrname"))
				Do tMeth.Implementation.WriteLine(" Set tMsrList("_$$$quote(tMsrName)_") = """"")
				Set ip = $O(tiKnowProps(ip))
			}
			Do tMeth.Implementation.WriteLine(" Set tIkStartTime = $ZH")
			Do tMeth.Implementation.WriteLine(" Set tSC = ##class(%iKnow.DeepSee.CubeUtils).%StartIKnowBatch(pCubeName,.tMsrList,pVerbose)")
			Do tMeth.Implementation.WriteLine(" Set tIkTime = $ZH-tIkStartTime")
			Do tMeth.Implementation.WriteLine(" Set x = $I(^IRIS.Temp.DeepSeeBuildStats($namespace,"_$$$quote($$$UPPER(pCube.name))_",""iknow""),tIkTime)")
			Do tMeth.Implementation.WriteLine(" Quit tSC")
		}
		Else {
			Do tMeth.Implementation.WriteLine(" Quit $$$OK")
		}
		Do tClassDef.Methods.Insert(tMeth)

		#; %OnEndBatch method
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%OnEndBatch")
		Set tMeth.Name = "%OnEndBatch"
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = "pCubeName:%String,pVerbose:%Boolean=0"
		Set tMeth.ReturnType = "%Status"
		Set tMeth.Description = "Notification that a batch of facts have just been processed.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateFactTable.<br/>"_$C(13,10)_
       							"DO NOT CALL THIS METHOD DIRECTLY"
		Set tMeth.SequenceNumber = $I(tSeq) + 2000
		If $D(tiKnowProps) {
			Set ip = $O(tiKnowProps(""))
			While (ip'="") {
				Set tMsrName = $G(pFactInfo("prop",ip,"msrname"))
				Do tMeth.Implementation.WriteLine(" Set tMsrList("_$$$quote(tMsrName)_") = """"")
				Set ip = $O(tiKnowProps(ip))
			}

			Do tMeth.Implementation.WriteLine(" Set tIkStartTime = $ZH")
			Do tMeth.Implementation.WriteLine(" Set tSC = ##class(%iKnow.DeepSee.CubeUtils).%EndIKnowBatch(pCubeName,.tMsrList,pVerbose)")
			Do tMeth.Implementation.WriteLine(" Set tIkTime = $ZH-tIkStartTime")
			Do tMeth.Implementation.WriteLine(" Set x = $I(^IRIS.Temp.DeepSeeBuildStats($namespace,"_$$$quote($$$UPPER(pCube.name))_",""iknow""),tIkTime)")
			Do tMeth.Implementation.WriteLine(" Quit tSC")
		}
		Else {
			Do tMeth.Implementation.WriteLine(" Quit $$$OK")
		}
		Do tClassDef.Methods.Insert(tMeth)

		#; %InjectFact method (called by cube %InjectFact method)
		#; JMD1137 add pDimensionsOnly
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%InjectFact")
		Set tMeth.Name = "%InjectFact"
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = "&pFactId:%Integer,&pValues:%String,*pChunks:%Integer,pDimensionsOnly:%Boolean=0,pFactList:%String="""""		// DTB886 - Add pFactList
		Set tMeth.ReturnType = "%Status"
		Set tMeth.Description = "Perform the work of injecting one fact into the cube without associated source data.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateFactTable.<br/>"_$C(13,10)_
       							"DO NOT CALL THIS METHOD DIRECTLY"
		Set tMeth.SequenceNumber = $I(tSeq) + 2000

		Do tMeth.Implementation.WriteLine(" New %var,%source,%value")
		Do tMeth.Implementation.WriteLine(" Set tSC = $$$OK")
		Do tMeth.Implementation.WriteLine(" Try {")
		Do tMeth.Implementation.WriteLine("  Set %value=""""")

		// copy data into %var (use source property names as subscripts for pValues)
		Set f = $O(tSelectList(""))
		While (f '= "") {
			// JMD1184
			Set tFName = $P(f,"~~",1)
			Set tFModifier = $P(f,"~~",2)
			If (tFModifier'="") {
				// attempt backward compatibility:
				// default modified name with unmodified name
				Do tMeth.Implementation.WriteLine("  Set %var("_$$$quote(tSelectList(f))_") = $G(pValues("_$$$quote(f)_"),$G(pValues("_$$$quote(tFName)_")))")
			}
			Else {
				Do tMeth.Implementation.WriteLine("  Set %var("_$$$quote(tSelectList(f))_") = $G(pValues("_$$$quote(f)_"))")
			}
			Set f = $O(tSelectList(f))
		}

		// copy data into %source
		Set f = $O(tXFormProps(""))
		While (f '= "") {
			Do tMeth.Implementation.WriteLine("  Set %source("_$$$quote(f)_") = $G(pValues("_$$$quote(f)_"))")
			Set f = $O(tXFormProps(f))
		}
		
		// DTB893 - Test for factList
		Do tMeth.Implementation.WriteLine("  Set tUseFactList = ($G(pFactList)'="""")")

		// apply date type conversions
		If $D(tDateTypeProps) {
			Do tMeth.Implementation.WriteLine("")
			Do tMeth.Implementation.WriteLine("  #; apply date conversions")

			Set p = $O(tDateTypeProps(""))
			While (p '= "") {
				Do tMeth.Implementation.WriteLine("  Set %var("_$$$quote(p)_") = ##class(%DeepSee.Utils).%ConvertDate(%var("_$$$quote(p)_"),"_$$$quote(tDateTypeProps(p))_")")
				Set p = $O(tDateTypeProps(p))
			}
		}

		// if there are any "copy from" fields, get values for them
		If ($D(tCopyFromList)) {
			Do tMeth.Implementation.WriteLine("")
			Do tMeth.Implementation.WriteLine("  #; Copy aliased fields")
			Set f = $O(tCopyFromList(""))
			While (f '= "") {
				Set src = tCopyFromList(f)
				Do tMeth.Implementation.WriteLine("  Set %var("_$$$quote(f)_") = $G(%var("_$$$quote(src)_"))")		// DTB913
				Set f = $O(tCopyFromList(f))
			}
		}

		// Perform transform logic for *local* expressions
		If $D(tXFormCode) {
			Do tMeth.Implementation.WriteLine("  #; apply local expressions")
			Set f = $O(tXFormCodeLocal(""))
			While (f '= "") {
				Set tCode = tXFormCodeLocal(f)
				If (tCode '= "") {
					// replace method calls
					Set:$IsObject($G(%class)) tCode = $Replace(tCode,"%cube.","##class("_%class.Name_").")
					Set tCode = "  Set %expression("_$$$quote(f)_") = " _ tCode
				}
				Else {
					Set tCode = "  Set %expression("_$$$quote(f)_") = """""
				}

				Do tMeth.Implementation.WriteLine(tCode)
				Set f = $O(tXFormCodeLocal(f))
			}
		}

		// Perform transform logic (from sourceExpressions)
		If $D(tXFormCode) {
			Do tMeth.Implementation.WriteLine("")
			Do tMeth.Implementation.WriteLine("  #; apply source expressions")
			Set f = $O(tXFormCode(""))
			While (f '= "") {
				Set tCode = tXFormCode(f)
				If (tCode '= "") {
					// replace method calls
					Set:$IsObject($G(%class)) tCode = $Replace(tCode,"%cube.","##class("_%class.Name_").")
					Set tCode = "  Set:('tUseFactList||$ListFind(pFactList,"_$$$quote(f)_")) %var("_$$$quote(f)_") = " _ tCode		// DTB893 - Suppress calculation if not in the fact list
				}
				Else {
					Set tCode = "  Set %var("_$$$quote(f)_") = """""
				}

				Do tMeth.Implementation.WriteLine(tCode)
				Set f = $O(tXFormCode(f))
			}
		}

		// invoke the %ProcessFact method
		Do tMeth.Implementation.WriteLine("")
		Do tMeth.Implementation.WriteLine("  #; invoke method to process this fact")
		Do tMeth.Implementation.WriteLine("  Set pFactId = $G(pFactId)")
		Do tMeth.Implementation.WriteLine("  Set tSC = ##class("_tClassDefName_").%ProcessFact("""",0,.%var,.pFactId,.pErrorMsg,,pDimensionsOnly,pFactList,.tUpdater)")		// DTB886 - Add pFactList
		Do tMeth.Implementation.WriteLine("  If $$$ISOK(tSC) {")
		Do tMeth.Implementation.WriteLine("   Set:(pFactId'="""")&&('pDimensionsOnly) pChunks(pFactId\64000+1) = """"")
		Do tMeth.Implementation.WriteLine("  }")

		// !!! detect changes

		Do tMeth.Implementation.WriteLine(" }") // try
		Do tMeth.Implementation.WriteLine(" Catch(ex) {")
		Do tMeth.Implementation.WriteLine("  Set tSC = ex.AsStatus()")
		// JMD1480
		Do tMeth.Implementation.WriteLine("  Do ..%LogError(tSC)")
		Do tMeth.Implementation.WriteLine(" }")

		Do tMeth.Implementation.WriteLine(" Quit tSC")
		Do tClassDef.Methods.Insert(tMeth)
		// End of %InjectFact

		#; %DeleteFact method (called by %UpdateFacts)
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%DeleteFact")
		Set tMeth.Name = "%DeleteFact"
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = "pID:%String,*pFactId:%Integer,*pErrorMsg:%String"
		Set tMeth.ReturnType = "%Status"
		Set tMeth.Description = "Perform the work of deleting one fact in the cube.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateFactTable.<br/>"_$C(13,10)_
       							"DO NOT CALL THIS METHOD DIRECTLY"
		Set tMeth.SequenceNumber = $I(tSeq) + 2000

		Do tMeth.Implementation.WriteLine(" Set tSC = $$$OK")
		Do tMeth.Implementation.WriteLine(" New %ROWID,%msg")
		Do tMeth.Implementation.WriteLine(" Try {")
		Do tMeth.Implementation.WriteLine("  Set (SQLCODE,tStarId) = """"")
		Do tMeth.Implementation.WriteLine("  Set pErrorMsg = """"")
		Do tMeth.Implementation.WriteLine("  Set pFactId = """"")

		// We have to do this check directly as we do not report this index to SQL
		Do tMeth.Implementation.WriteLine("  Set pFactId = $O($$$DeepSeeIndexGLVN("_$$$quote(tCubeName)_","_$$$quote("%sourceId")_",pID,""""))")
		Do tMeth.Implementation.WriteLine("  If (pFactId'="""") {")
		Do tMeth.Implementation.WriteLine("   &sql(DELETE FROM "_tFactTableName_" WHERE %ID = :pFactId)")

		// update source indices
		Do tMeth.Implementation.WriteLine("   Kill $$$DeepSeeIndexGLVN("_$$$quote(tCubeName)_","_$$$quote("%sourceId")_",pID,pFactId)")
		Do tMeth.Implementation.WriteLine("   Kill $$$DeepSeeIndexGLVN("_$$$quote(tCubeName)_","_$$$quote("%sourceIdReverse")_",pFactId)")

		// pass iKnow properties on to iKnow class
		If $D(tiKnowProps) {
			Set tiProp = $O(tiKnowProps(""))
			While (tiProp'="") {
				Set tiType = $P($G(tiKnowProps(tiProp)),":",2)
				Set:tiType="" tiType = "string"

				// pass measure name to iKnow
				Set tMsrName = $G(pFactInfo("prop",tiProp,"msrname"))
				Do tMeth.Implementation.WriteLine("   Set tSC=##class(%iKnow.DeepSee.CubeUtils).%ProcessIKnowFact("_$$$quote(tCubeName)_",0,""D"",pFactId,"_$$$quote(tMsrName)_",,"_$$$quote(tiType)_")")
				Do tMeth.Implementation.WriteLine("   Do:$$$ISERR(tSC) ..%LogError(tSC)")
				Set tiProp = $O(tiKnowProps(tiProp))
			}
		}

		Do tMeth.Implementation.WriteLine("  }")

		Do tMeth.Implementation.WriteLine(" }") // try
		Do tMeth.Implementation.WriteLine(" Catch(ex) {")
		Do tMeth.Implementation.WriteLine("  Set tSC = ex.AsStatus()")
		Do tMeth.Implementation.WriteLine("  Set pErrorMsg = $ZE")
		Do tMeth.Implementation.WriteLine("  Do ..%LogError(tSC)")
		Do tMeth.Implementation.WriteLine(" }")

		Do tMeth.Implementation.WriteLine(" Quit tSC")
		Do tClassDef.Methods.Insert(tMeth)
		// End of %DeleteFact

		#; %OnKillFacts method (called by %KillFacts)
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%OnKillFacts")
		Set tMeth.Name = "%OnKillFacts"
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = ""
		Set tMeth.ReturnType = "%Status"
		Set tMeth.Description = "Notification that this cube is being killed.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateFactTable.<br/>"_$C(13,10)_
       							"DO NOT CALL THIS METHOD DIRECTLY"
		Set tMeth.SequenceNumber = $I(tSeq) + 2000

		Do tMeth.Implementation.WriteLine(" Set tSC = $$$OK")
		Do tMeth.Implementation.WriteLine(" Try {")

		// pass iKnow properties on to iKnow class
		If $D(tiKnowProps) {
			Set ip = $O(tiKnowProps(""))
			While (ip'="") {
				Set tMsrName = $G(pFactInfo("prop",ip,"msrname"))
				Do tMeth.Implementation.WriteLine("  Set tMsrList("_$$$quote(tMsrName)_") = """"")
				Set ip = $O(tiKnowProps(ip))
			}
			Do tMeth.Implementation.WriteLine("  Set tSC=##class(%iKnow.DeepSee.CubeUtils).%OnKillFacts("_$$$quote(tCubeName)_",.tMsrList)")
			Do tMeth.Implementation.WriteLine("  Quit:$$$ISERR(tSC)")
		}
		Do tMeth.Implementation.WriteLine(" }") // try
		Do tMeth.Implementation.WriteLine(" Catch(ex) {")
		Do tMeth.Implementation.WriteLine("  Set tSC = ex.AsStatus()")
		Do tMeth.Implementation.WriteLine("  Do ..%LogError(tSC)")
		Do tMeth.Implementation.WriteLine(" }")

		Do tMeth.Implementation.WriteLine(" Quit tSC")
		Do tClassDef.Methods.Insert(tMeth)
		// End of %OnKillFacts

		#; %PrecomputeAggregates method (called by %BuildCube)
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%PrecomputeAggregates")
		Set tMeth.Name = "%PrecomputeAggregates"
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = "pStartChunk:%Integer,pEndChunk:%Integer,pAggGLVN:%String,pVerbose:%Boolean=0,pTaskGroup:%String="""",&pCount:%Integer=0"
		Set tMeth.ReturnType = "%Status"
		Set tMeth.Description = "Pre-compute certain aggregates.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateFactTable.<br/>"_$C(13,10)_
       							"DO NOT CALL THIS METHOD DIRECTLY"
		Set tMeth.SequenceNumber = $I(tSeq) + 2000

		Do tMeth.Implementation.WriteLine(" Set tSC = $$$OK")
		Do tMeth.Implementation.WriteLine(" New %ROWID,%msg,%var")
		Do tMeth.Implementation.WriteLine(" Kill @pAggGLVN")
		Do tMeth.Implementation.WriteLine(" Try {")
		Do tMeth.Implementation.WriteLine("  Set (SQLCODE) = """"")
		Do tMeth.Implementation.WriteLine("  Set tLastCount = 0")

		If ((pCube.precompute>0) && $D(tMeasuresPrecompute) && $D(tFactsPrecompute)) {
			// generate SQL statement against fact table
			Set tSELECT = "%ID"
			Set tINTO = ":tID"
			Set f = $O(tFactsPrecompute(""))
			While (f'="") {
				Set tSELECT = tSELECT_","_f
				Set tINTO = tINTO_",:%var("_$$$quote(f)_")"
				Set f = $O(tFactsPrecompute(f))
			}
			Set m = $O(tMeasuresPrecompute(""))
			While (m'="") {
				Set tSELECT = tSELECT_","_m
				Set tINTO = tINTO_",:%var("_$$$quote(m)_")"
				Set m = $O(tMeasuresPrecompute(m))
			}

			Do tMeth.Implementation.WriteLine("  Set tStartID = ((pStartChunk-1)*64000)+1")
			Do tMeth.Implementation.WriteLine("  Set tEndID = pEndChunk*64000")

			Do tMeth.Implementation.WriteLine("  &sql(DECLARE sqpc CURSOR FOR")
			Do tMeth.Implementation.WriteLine("  SELECT " _ tSELECT)
			Do tMeth.Implementation.WriteLine("  INTO " _ tINTO)
			Do tMeth.Implementation.WriteLine("  FROM "_tFactTableName)
			Do tMeth.Implementation.WriteLine("  WHERE %ID BETWEEN :tStartID AND :tEndID")
			Do tMeth.Implementation.WriteLine("  )")

			Do tMeth.Implementation.WriteLine("  &sql(OPEN sqpc)")
			Do tMeth.Implementation.WriteLine("  If (SQLCODE'=0) {")
			Do tMeth.Implementation.WriteLine("   Set tSC = $$$ERROR($$$GeneralError,""Error opening SQL cursor: (""_$G(SQLCODE)_"") ""_$G(%msg))")
			Do tMeth.Implementation.WriteLine("   Quit")
			Do tMeth.Implementation.WriteLine("  }")

			Do tMeth.Implementation.WriteLine("  &sql(FETCH sqpc)")
			Do tMeth.Implementation.WriteLine("  While (SQLCODE=0) {")

			Do tMeth.Implementation.WriteLine(" Set pCount = pCount + 1")
			Do tMeth.Implementation.WriteLine(" If (pVerbose&&'(pCount#1000)) Write $C(13,27)_""[0J""_""Computing aggregates: ""_$J($FN(pCount,"","",0),10)_"" fact(s) processed.""")
			Do tMeth.Implementation.WriteLine(" If ((pTaskGroup'="""")&&'(pCount#1000)) {")
			Do tMeth.Implementation.WriteLine("  Set tDelta = pCount - tLastCount")
			Do tMeth.Implementation.WriteLine("  Set inc=$I(^IRIS.Temp.DeepSeeUpdate($namespace,pTaskGroup,""facts""),tDelta)")
			Do tMeth.Implementation.WriteLine("  Set tLastCount = pCount")
			Do tMeth.Implementation.WriteLine(" }")

			// first get counts for each fact by itself
			Do tMeth.Implementation.WriteLine("  // Level 1")
			Set f = $O(tFactsPrecompute(""))
			While (f'="") {
				Set fno = $LG(tFactsPrecompute(f),1)
				Set key = $TR($J("",fno)," ",":")
				Do tMeth.Implementation.WriteLine("  Set x = $I(@pAggGLVN@("_$$$quote(key)_"_%var("_$$$quote(f)_"))) // " _fno)
				Set f = $O(tFactsPrecompute(f))
			}

			If (pCube.precompute>1) {
				Do tMeth.Implementation.WriteLine("  // Level 2")
				// now get combinations of 2
				Set f1 = $O(tFactsPrecompute(""))
				While (f1'="") {
					Set f1no = $LG(tFactsPrecompute(f1),1)
					Set f2 = $O(tFactsPrecompute(""))
					While (f2'="") {
						If (f2'=f1) {
							Set f2no = $LG(tFactsPrecompute(f2),1)
							// determine key expression
							If (f1no < f2no) {
								Set key1 = $TR($J("",f1no)," ",":")
								Set key2 = $TR($J("",f2no-f1no)," ",":")
								Set expr = $$$quote(key1)_"_%var("_$$$quote(f1)_")_"_$$$quote(key2)_"_%var("_$$$quote(f2)_")"
							}
							Else {
								Set key1 = $TR($J("",f2no)," ",":")
								Set key2 = $TR($J("",f1no-f2no)," ",":")
								Set expr = $$$quote(key1)_"_%var("_$$$quote(f2)_")_"_$$$quote(key2)_"_%var("_$$$quote(f1)_")"
							}
							Do tMeth.Implementation.WriteLine("  Set x = $I(@pAggGLVN@("_expr_")) // " _f1no_","_f2no)
						}
						Set f2 = $O(tFactsPrecompute(f2))
					}
					Set f1 = $O(tFactsPrecompute(f1))
				}
			}

			// compute measures
			Do tMeth.Implementation.WriteLine("  // Measures")
			Set m = $O(tMeasuresPrecompute(""))
			While (m'="") {
				Set mno = $LG(tMeasuresPrecompute(m),1)
				Do tMeth.Implementation.WriteLine("  If (%var("_$$$quote(m)_")'="""") {")
				Do tMeth.Implementation.WriteLine("   Set msr = $G(%var("_$$$quote(m)_"))")		// DTB913
				Set f = $O(tFactsPrecompute(""))
				While (f'="") {
					Set fno = $LG(tFactsPrecompute(f),1)
					Set key = $TR($J("",fno)," ",":")

					Do tMeth.Implementation.WriteLine("   Set agg = $G(@pAggGLVN@("_$$$quote(key)_"_%var("_$$$quote(f)_"),"_+$E(mno,2,*)_")) // " _fno)
					Do tMeth.Implementation.WriteLine("   Set min = $LG(agg,2),max=$LG(agg,3),count=$LG(agg,4)")
					Do tMeth.Implementation.WriteLine("   Set min = $S((min="""")||(min>msr):msr,1:min)")
					Do tMeth.Implementation.WriteLine("   Set max = $S((max="""")||(max<msr):msr,1:max)")
					Do tMeth.Implementation.WriteLine("   Set @pAggGLVN@("_$$$quote(key)_"_%var("_$$$quote(f)_"),"_+$E(mno,2,*)_") = $LB(msr+$LG(agg,1),min,max,count+1)")

					Set f = $O(tFactsPrecompute(f))
				}
				// measures against 2 facts
				If (pCube.precompute>1) {
					Do tMeth.Implementation.WriteLine("   // Level 2")
					Set f1 = $O(tFactsPrecompute(""))
					While (f1'="") {
						Set f1no = $LG(tFactsPrecompute(f1),1)
						Set f2 = $O(tFactsPrecompute(""))
						While (f2'="") {
							If (f2'=f1) {
								Set f2no = $LG(tFactsPrecompute(f2),1)
								// determine key expression
								If (f1no < f2no) {
									Set key1 = $TR($J("",f1no)," ",":")
									Set key2 = $TR($J("",f2no-f1no)," ",":")
									Set expr = $$$quote(key1)_"_%var("_$$$quote(f1)_")_"_$$$quote(key2)_"_%var("_$$$quote(f2)_")"
								}
								Else {
									Set key1 = $TR($J("",f2no)," ",":")
									Set key2 = $TR($J("",f1no-f2no)," ",":")
									Set expr = $$$quote(key1)_"_%var("_$$$quote(f2)_")_"_$$$quote(key2)_"_%var("_$$$quote(f1)_")"
								}
								Do tMeth.Implementation.WriteLine("   Set x = $I(@pAggGLVN@("_expr_","_+$E(mno,2,*)_"),%var("_$$$quote(m)_")) // " _f1no_","_f2no)
							}
							Set f2 = $O(tFactsPrecompute(f2))
						}
						Set f1 = $O(tFactsPrecompute(f1))
					}
				}

				Do tMeth.Implementation.WriteLine("  }")
				Set m = $O(tMeasuresPrecompute(m))
			}

			// fetch next fact
			Do tMeth.Implementation.WriteLine("   &sql(FETCH sqpc)")
			Do tMeth.Implementation.WriteLine("  }")
			Do tMeth.Implementation.WriteLine("  &sql(CLOSE sqpc)")
		}

		Do tMeth.Implementation.WriteLine(" If (pTaskGroup'="""") {")
		Do tMeth.Implementation.WriteLine("  Set tDelta = pCount - tLastCount")
		Do tMeth.Implementation.WriteLine("  Set inc=$I(^IRIS.Temp.DeepSeeUpdate($namespace,pTaskGroup,""facts""),tDelta)")
		Do tMeth.Implementation.WriteLine(" }")

		Do tMeth.Implementation.WriteLine(" }") // try
		Do tMeth.Implementation.WriteLine(" Catch(ex) {")
		Do tMeth.Implementation.WriteLine("  Set tSC = ex.AsStatus()")
		Do tMeth.Implementation.WriteLine("  Set pErrorMsg = $ZE")
		Do tMeth.Implementation.WriteLine("  Do ..%LogError(tSC)")
		Do tMeth.Implementation.WriteLine(" }")
		Do tMeth.Implementation.WriteLine(" Quit tSC")
		Do tClassDef.Methods.Insert(tMeth)

		// End of %PrecomputeAggregates

		#; additional methods to support relationships
		#; on the many-side generate one %LookupIdFor<Relation> method per relationship
		#; %LookupIdFor<Relation> method(s)
		#; on the one-side generate triggers to maintain the ID to RelationID index
		Kill tTriggerList
		Set r = $O(pRelationInfo(""))
		While (r'="") {
			Set tCardinality = $G(pRelationInfo(r,"cardinality"))
			Set tStoredSide = +$G(pRelationInfo(r,"storedSide"))
			Set tRelName = $G(pRelationInfo(r,"name"))
			If (tStoredSide) {
				// queue this relation so we can include it in the trigger
				// organize by fact name
				Set tFact = $G(pRelationInfo(r,"fact"))
				Set tTriggerList(tFact) = tRelName
				Set tTriggerList(tFact,"cardinality") = tCardinality
			}
			Set r = $O(pRelationInfo(r))
		}

		#; create relationship indices if needed
		// loop over relationship facts
		Set tFact = $O(tTriggerList(""))
		While (tFact'="") {
			Set tHasMany = $G(tTriggerList(tFact,"cardinality"))="many"
			// special index to map facts on the many(child)-side to
			// facts on the one(parent)-side
			Set tIndexDef = ##class(%Dictionary.IndexDefinition).%New(tClassDefName_"||%Inverse"_tFact)
			Set tIndexDef.Name = "%Inverse"_tFact
			If (tHasMany){
				Set tIndexDef.Properties = "%%ID"_","_tFact_"(KEYS)"
			}
			Else {
				Set tIndexDef.Properties = "%%ID"_","_tFact
			}
			Set tIndexDef.SequenceNumber = $I(tSeq)
			Set tIndexDef.Description = "Inverse index for relationship "_tFact_"."
			Do tClassDef.Indices.Insert(tIndexDef)

			Set tIndexStore = ##class(%Dictionary.StorageIndexDefinition).%New(tClassDefName_":*Inverse"_tProp.Name)
			Set tIndexStore.Name = "%Inverse"_tFact
			Set tLoc = $Name($$$DeepSeeRelationGLVN)_"("_$$$quote(tCubeName)_","_$$$quote($$$UPPER(tFact))_")"
			Set tIndexStore.Location = tLoc
			Do tStorage.Indices.Insert(tIndexStore)

			// next fact
			Set tFact = $O(tTriggerList(tFact))
		}

		#; save the fact table class definition
	    Set tSC = tClassDef.%Save()
	    If $$$ISERR(tSC) Quit

		// Write !,tClassDef.Name," saved"

	    #; Now queue the generated class for compilation
	    Do QueueClass^%occCompile(tClassDefName)
	    #; Mark this class for deletion when the cube class is deleted.
	    $$$comClassArraySet(pCubeClass,$$$cCLASSclasses,tClassDefName_".CLS","")
	    $$$defClassKeySet(tClassDefName,$$$cCLASSgeneratedby,pCubeClass_".CLS")

		#; create the listing table for this cube
		#; Delete any pre-existing definition
		#; create fact table class
		Set tClassDefName = pSchema_".Listing"

		#; we have to get SQL name manually as oddCOM does not exist yet!
		Set tListingTableName = $TR(pSchema,".","_")_".Listing"

		If $$$defClassDefined(tClassDefName) {
		    Set tSC = $$Delete^%apiOBJ(tClassDefName,"-d")
		    If $$$ISERR(tSC) Quit
		}

		#; Create a new class definition
		Set tClassDef = ##class(%Dictionary.ClassDefinition).%New(tClassDefName)
		If tClassDef = $$$NULLOREF Set tSC=$$$ERROR($$$CannotCreateObject,"%Dictionary.ClassDefinition") Quit
		Set tClassDef.Super = "%DeepSee.ListingTable"
        Set tClassDef.IncludeCode = "%DeepSee"
        Set tClassDef.ProcedureBlock = 1
		Set tClassDef.Owner = "_PUBLIC"
        Set tClassDef.Description = "Listing table for cube '"_pCube.name_"'.<br/>"_$C(13,10)_
        							"THIS IS A GENERATED CLASS, DO NOT EDIT.<br/>"_$C(13,10)_
        							"Generated by %DeepSee.Generator:%CreateFactTable."

		#; CUBENAME param
		Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(tClassDefName_":"_"CUBENAME")
		Set tParmDef.Default = pCube.name
		Do tClassDef.Parameters.Insert(tParmDef)

		#; storage for listing table
		Set tStorage = ##class(%Dictionary.StorageDefinition).%New(tClassDefName_"||Default")
		Set tStorage.Name = "Default"
		Set tStorage.ExtentSize = 1000
		Set tStorage.DataLocation = ..%GetListingLocation(pCube.name)
		Do tClassDef.Storages.Insert(tStorage)

		#; save the listing table class definition
	    Set tSC = tClassDef.%Save()
	    If $$$ISERR(tSC) Quit

		// Write !,tClassDef.Name," saved"

	    #; Now queue the generated class for compilation
	    Do QueueClass^%occCompile(tClassDefName)

	    #; Mark this class for deletion when the cube class is deleted.
	    $$$comClassArraySet(pCubeClass,$$$cCLASSclasses,tClassDefName_".CLS","")
	    $$$defClassKeySet(tClassDefName,$$$cCLASSgeneratedby,pCubeClass_".CLS")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%BuildOrderedList">
<Description><![CDATA[
Internal method. Given a list of items of the form:<br/>
pDepends(item) = ""<br/>
pDepend(item,parent)<br/>
Return an ordered list with base items listed first.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pDepends,*pList]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK

	// Process items with dependencies
	While ($D(pDepends)) {
		Set tItem = $O(pDepends(""))
		While (tItem '= "") {
			Kill tList
			Kill tVisits
			Set tSC = ..%GetAncestors(tItem,.pDepends,.tList,.tVisits)
			If $$$ISERR(tSC) Quit

			// add ancestors to the output
			Set n = $O(tList(""))
			While (n '= "") {
				Set pList($I(pList)) = tList(n)
				Set n = $O(tList(n))
			}
			Set tItem = $O(pDepends(tItem))
		}
		If $$$ISERR(tSC) Quit
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetAncestors">
<Description>
Internal method. Given an item within a dependency list,
return its set of ancestors (items with no further dependencies).</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pItem:%String,&pDepends,*pList,&pVisited]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tParent = $O(pDepends(pItem,""))
	If (tParent = "") {
		Set pList($I(pList)) = pItem
		// remove every reference to pItem
		Kill pDepends(pItem)
		Set tItem = $O(pDepends(""))
		While (tItem '= "") {
			If $D(pDepends(tItem,pItem)) {
				Kill pDepends(tItem,pItem)
			}
			Set tItem = $O(pDepends(tItem))
		}
	}
	Else {
		While (tParent '= "") {
			If ($D(pVisited(tParent))) {
				Set tSC = $$$ERROR($$$GeneralError,"Circular dependency encountered: "_pItem_"->"_tParent)
				Quit
			}
			Else {
				Set pVisited(tParent) = ""
				Set tSC = ..%GetAncestors(tParent,.pDepends,.pList,.pVisited)
				If $$$ISERR(tSC) Quit
			}
			Set tParent = $O(pDepends(pItem,tParent))
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetDimensionLocation">
<Description>
Construct a storage location for a dimension (star) table.
Note that these are subscripted by upper-case class name.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClassName:%String,pSuffix:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Name($$$DeepSeeDimGLVN)_pSuffix_"("_$$$quote($$$UPPER(pClassName))_")"
]]></Implementation>
</Method>

<Method name="%GetFactLocation">
<Description>
Construct a storage location for a fact table.
Note that these are subscripted by upper-case class name.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClassName:%String,pSuffix:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Name($$$DeepSeeFactGLVN)_pSuffix_"("_$$$quote($$$UPPER(pClassName))_")"
]]></Implementation>
</Method>

<Method name="%GetListingLocation">
<Description>
Construct a storage location for a listing table.
Note that these are subscripted by upper-case cube name.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pCubeName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Name($$$DeepSeeListingGLVN)_"("_$$$quote($$$UPPER(pCubeName))_")"
]]></Implementation>
</Method>

<Method name="%GetIndexLocation">
<Description>
Construct a storage location for a fact table index.
Note that these are subscripted by cube name and index number.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pCubeName:%String,pIndex:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Name($$$DeepSeeIndexGLVN)_"("_$$$quote($$$UPPER(pCubeName))_","_$$$quote(pIndex)_")"
]]></Implementation>
</Method>

<Method name="%GetSearchIndexLocation">
<Description>
Construct a storage location for a fact table search index.
Note that these are subscripted by cube name and prop name.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pCubeName:%String,pPropName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Name($$$DeepSeeIndexGLVN)_"("_$$$quote($$$UPPER(pCubeName))_","_$$$quote(pPropName)_")"
]]></Implementation>
</Method>

<Method name="%CreateStarTable">
<Description><![CDATA[
Create a Star (dimension) table.<br/>
This table is used to hold members of a dimension level.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%DeepSee.Model.cube,pCubeClass:%String,pStar:%String,&pStarInfo:%List]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tClassDefName = pStar
		Set tSchema = $P(pStar,".",1,$L(pStar,".")-1)
		Set tCls = $P(pStar,".",$L(pStar,"."))

		#; we have to get SQL name manually as oddCOM does not exist yet!
		Set tTableName = $TR(tSchema,".","_")_"."_tCls

		#; create STAR table class
		#; Delete any pre-existing definition
		If $$$defClassDefined(tClassDefName) {
		    Set tSC = $$Delete^%apiOBJ(tClassDefName,"-d")
		    If $$$ISERR(tSC) Quit
		}

		#; find KEY field and NAME field(s) for star table
		Set tKeyField = ""
		Set tDescField = ""
		Kill tNameFields,tRollups
		Set tNameFieldCount = 0
		Set tRollupCount = 0
		Set tName = $O(pStarInfo(pStar,"prop",""))
		While (tName '= "") {
			Set tUse = $G(pStarInfo(pStar,"prop",tName,"use"))
			If (tUse = "key") {
				Set tKeyField = tName
				
				// + WAL131 -- save this value for the reference fields
				Set tKeyFieldSourceProp = $G(pStarInfo(pStar,"prop",tName,"source"))
				// - WAL131
			}
			ElseIf (tUse = "name") {
				Set tNameFields(tName) = ""
				Set tNameFieldCount = tNameFieldCount + 1
			}
			ElseIf (tUse = "description") {
				Set tDescField = tName
				// index as name field
				Set tNameFields(tName) = ""
				Set tNameFieldCount = tNameFieldCount + 1
			}
			ElseIf (tUse = "rollup") {
				Set tRollups(tName) = ""
				Set tRollupCount = tRollupCount + 1
			}
			Set tName = $O(pStarInfo(pStar,"prop",tName))
		}

		If ('$D(tNameFields)) {
			Set:tKeyField'="" tNameFields(tKeyField) = ""
		}
		#; n.b, is there any use for namefields?
		
		#; Create a new class definition
		Set tClassDef = ##class(%Dictionary.ClassDefinition).%New(tClassDefName)
		If tClassDef = $$$NULLOREF Set tSC=$$$ERROR($$$CannotCreateObject,"%Dictionary.ClassDefinition") Quit
		Set tClassDef.Super = "%DeepSee.DimensionTable"
        Set tClassDef.ProcedureBlock = 1
		Set tClassDef.Owner = pCube.owner
        Set tClassDef.Description = "Dimension table for cube '"_pCube.name_"'"_$C(13,10)_
        							"THIS IS A GENERATED CLASS, DO NOT EDIT.<br/>"_$C(13,10)_
        							"Generated by %DeepSee.Generator:%CreateStarTable."

		#; storage for star table
		#dim tStorage As %Dictionary.StorageDefinition
		Set tStorage = ##class(%Dictionary.StorageDefinition).%New(tClassDefName_"||Default")
		Set tStorage.Name = "Default"
		Set tStorage.ExtentSize = 100
		Set tStorage.DataLocation = ..%GetDimensionLocation(tClassDefName)
		Set tStorage.IndexLocation = ..%GetDimensionLocation(tClassDefName,"I")
		Set tStorage.StreamLocation = ..%GetDimensionLocation(tClassDefName,"S")
		Do tClassDef.Storages.Insert(tStorage)

		#; CUBENAME param
		Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(tClassDefName_":"_"CUBENAME")
		Set tParmDef.Default = pCube.name
		Do tClassDef.Parameters.Insert(tParmDef)

		#; KEYPROPERTY param
		Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(tClassDefName_":"_"KEYPROPERTY")
		Set tParmDef.Default = tKeyField
		Do tClassDef.Parameters.Insert(tParmDef)

		#; DESCRIPTIONPROPERTY param
		Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(tClassDefName_":"_"DESCRIPTIONPROPERTY")
		Set tParmDef.Default = tDescField
		Do tClassDef.Parameters.Insert(tParmDef)

		#; %Count method
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%Count")
		Set tMeth.Name = "%Count"
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = ""
		Set tMeth.ReturnType = "%Integer"
		Set tMeth.Description = "Return the total number of members within this dimension.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateStarTable."

		Set tMeth.SequenceNumber = $I(tSeq) + 2000

		Do tMeth.Implementation.WriteLine(" Set tCount = 0")
		Do tMeth.Implementation.WriteLine(" &sql(SELECT COUNT(*) INTO :tCount FROM "_tTableName_")")
		Do tMeth.Implementation.WriteLine(" Quit tCount")

		Do tClassDef.Methods.Insert(tMeth)

		// JMD925: validate KEY
		#; KEYIsValid  method
		If (tKeyField'="") {
			Set tVName = tKeyField_"IsValid"
			Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||"_tVName)
			Set tMeth.Name = tVName
			Set tMeth.ClassMethod = 1
			Set tMeth.FormalSpec = "pArg:%String"
			Set tMeth.ReturnType = "%Status"
			Set tMeth.Description = "Validate the KEY value for this dimension.<br/>"_$C(13,10)_
	       							"Generated by %DeepSee.Generator:%CreateStarTable."

			Set tMeth.SequenceNumber = $I(tSeq) + 2000
			Do tMeth.Implementation.WriteLine(" Quit ##class(%DeepSee.DimensionTable).%ValidateKEY(pArg)")

			Do tClassDef.Methods.Insert(tMeth)
		}

		#; %GetMemberSpec method
		#; This is used by XMLA output to generate a spec for a member
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||%GetMemberSpec")
		Set tMeth.Name = "%GetMemberSpec"
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = "pMemberId:%String,pCubeName:%String,pDimNo:%Integer,pHierNo:%Integer,pLevelNo:%Integer"
		Set tMeth.ReturnType = "%String"
		Set tMeth.Description = "Return the specification string for the given member.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateStarTable."

		Set tMeth.SequenceNumber = $I(tSeq) + 2000

		Do tMeth.Implementation.WriteLine(" Set tSpec = """"")

		// JMD1453: simplify and return &[key] and not name
		Do tMeth.Implementation.WriteLine(" Set:pMemberId'="""" tSpec = ""&[""_$$$dsEscapeIdent(.."_tKeyField_"GetStored(pMemberId))"_"_""]""")
		Do tMeth.Implementation.WriteLine(" Quit tSpec")
		Do tClassDef.Methods.Insert(tMeth)

		#; properties
		#; generate a %GetDimensionProperty method as we go along
		#; this includes embedded SQL statements to fetch each property

		Set tMethName = "%GetDimensionProperty"
		Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||"_tMethName)
		Set tMeth.Name = tMethName
		Set tMeth.ClassMethod = 1
		Set tMeth.FormalSpec = "pProp:%String,pID:%String,*pFormat:%String,*pType:%String"
		Set tMeth.ReturnType = "%String"
		Set tMeth.Description = "Fetch the value of a given dimension property.<br/>"_$C(13,10)_
       							"Generated by %DeepSee.Generator:%CreateStarTable."

		Set tMeth.SequenceNumber = $I(tSeq) + 2000
		Do tMeth.Implementation.WriteLine(" Set pProp = $$$UPPER(pProp)")
		Do tMeth.Implementation.WriteLine(" Set tValue=""""")
		Do tMeth.Implementation.WriteLine(" Set pFormat=""""")

		#; loop over properties
		Set tPropCount = 0
		Set tName = $O(pStarInfo(pStar,"prop",""))
		While (tName '= "") {
			Set tType = $G(pStarInfo(pStar,"prop",tName,"type"))
			Set tSource = $G(pStarInfo(pStar,"prop",tName,"source")) // used for description
			Set tExpr = $G(pStarInfo(pStar,"prop",tName,"expr"))
			Set tUse = $G(pStarInfo(pStar,"prop",tName,"use"))
			Set tIsRef = +$G(pStarInfo(pStar,"prop",tName,"isref"))
			Set tClsType = $$$getClassType($$$NormalizeClassname(tType))
			Set tPropCount = tPropCount + 1

			// JMD909
			Set tFormat = $G(pStarInfo(pStar,"prop",tName,"format"))

			Set tProp = ##class(%Dictionary.PropertyDefinition).%New(tClassDefName_"||"_tName)
			Set tProp.Name = tName
			
			If (..%IsString(tType)) {
				// DTB491 - If this is a custom type that extends %String, treat it like a %String
				Set tType = "%String"
			}
			Set tProp.Type = ..%DenormalizeType(tType)
			If ((tUse="key")||(tUse="rollup")) {
				Set tProp.Required = 1
				If ((tUse="key")&&(tProp.Type'="%String")) {
					// Keys must be strings (to handle NULL and UNIQUE tests)
					Set tProp.Type = "%String"
					// JMD1080: remember collation
					Set tCollation = $G(pStarInfo(pStar,"prop",tName,"parms","COLLATION"))
					Kill pStarInfo(pStar,"prop",tName,"parms")
					Set:tCollation'="" pStarInfo(pStar,"prop",tName,"parms","COLLATION") = tCollation
				}
				ElseIf(tUse="key") {
					// JMD1190: if not specified, use SQLUPPER(113) for string key fields
					Set tCollation = $G(pStarInfo(pStar,"prop",tName,"parms","COLLATION"))
					If (tCollation="") {
						Set pStarInfo(pStar,"prop",tName,"parms","COLLATION") = "SQLUPPER(113)"
					}
				}
			}
			ElseIf (tUse="name")&&((tProp.Type="%String")||(tProp.Type="%Library.String")) {
				// DTB445 - Add SQLUPPER(113) to strings if not already defined.
				Set tCollation = $G(pStarInfo(pStar,"prop",tName,"parms","COLLATION"))
				If (tCollation="") {
					Set pStarInfo(pStar,"prop",tName,"parms","COLLATION") = "SQLUPPER(113)"
				}
			}

			If (tIsRef) {
				// reference field: generated sql compute logic
				Set tRefFields(tName) = tProp.Type
				Set tProp.Calculated = 1
				Set tProp.SqlComputed = 1
				Set tProp.SqlComputeCode = "Set {"_tProp.Name_"}=##class("_tClassDefName_").%Fetch"_tName_"({"_tKeyField_"})"
			}

			Set tProp.Description = ..%MakeDescription($$$Text("Dimension property","%DeepSee"),tName, $S(tSource="":tExpr,1:tSource))
			Set tProp.SequenceNumber = $I(tSeq) + 1000
			Do tClassDef.Properties.Insert(tProp)

			// always ignore maxlen!
			If ((tProp.Type = "%Library.String")||(tProp.Type = "%String")) {
				Do tProp.Parameters.SetAt(2000,"MAXLEN")
			}

			Set parm = $O(pStarInfo(pStar,"prop",tName,"parms",""))
			While (parm '= "") {
				Set value = $G(pStarInfo(pStar,"prop",tName,"parms",parm))
				If ((parm'="MAXLEN")&&(parm'="MINVAL")&&(parm'="MAXVAL")) {
					// skip maxlen and other validation
					// JMD1080 No collation for non-string properties
					If ((parm'="COLLATION")||(tProp.Type = "%Library.String")||(tProp.Type = "%String")) {
						Do tProp.Parameters.SetAt(value,parm)
					}
				}
				Set parm = $O(pStarInfo(pStar,"prop",tName,"parms",parm))
			}

			// add case to method
			If (tPropCount = 1) {
				Do tMeth.Implementation.WriteLine(" If (pProp=" _ $$$quote($$$UPPER(tName))_") {")
			}
			Else {
				Do tMeth.Implementation.WriteLine(" ElseIf (pProp=" _ $$$quote($$$UPPER(tName))_") {")
			}
			Do tMeth.Implementation.WriteLine("  &sql(SELECT "_tName_" INTO :tValue FROM "_tTableName_" WHERE %ID = :pID)")

			// JMD909
			If (tFormat'="") {
				Do tMeth.Implementation.WriteLine("  Set:tValue'="""" pFormat="_$$$quote(tFormat))
			}
			// JMD988 Return type
			Do tMeth.Implementation.WriteLine("  Set pType="_$$$quote(tType))

			Do tMeth.Implementation.WriteLine(" }")
			
			If ($P(tType,".",1,*-1) = $P(pStar,".",1,*-1)) {
				// DTB754 - If the property type is another class in the current package, make a foreign key to point to it.
				Set tFKDef = ##class(%Dictionary.ForeignKeyDefinition).%New()
				Set tFKDef.Name = tName
				Set tFKDef.NoCheck = 1		// Check is not needed and carries a performance penalty. Turn it off.
				Set tFKDef.Properties = tName
				Set tFKDef.ReferencedClass = tType
				Set tFKDef.ReferencedKey = ""		// blank means use ID
				Do tClassDef.ForeignKeys.Insert(tFKDef)
			}

			// next prop
			Set tName = $O(pStarInfo(pStar,"prop",tName))
		}

		#; end of %GetDimensionProperty method
		Do tMeth.Implementation.WriteLine(" Quit tValue")
		Do tClassDef.Methods.Insert(tMeth)

		#; if there are reference fields, generate %Fetch<Field> methods
		#; to fetch their values
		Set tRefField = $O(tRefFields(""))
		While (tRefField'="") {
			Set tMethName = "%Fetch"_tRefField
			Set tMeth = ##class(%Dictionary.MethodDefinition).%New(tClassDefName_"||"_tMethName)
			Set tMeth.Name = tMethName
			Set tMeth.ClassMethod = 1
			Set tMeth.FormalSpec = "pKey:%String"
			Set tMeth.ReturnType = tRefFields(tRefField)
			Set tMeth.Description = "Fetch the current value of "_tMethName_".<br/>"_$C(13,10)_
	       							"Generated by %DeepSee.Generator:%CreateStarTable."

			Set tMeth.SequenceNumber = $I(tSeq) + 2000

			Do tMeth.Implementation.WriteLine(" // If we don't a value, show key as this is most likely the NULL substitute")
			Do tMeth.Implementation.WriteLine(" Set tValue=pKey")
			
			// figure out sql needed to find the source value
			Set tSourceClass = pCube.sourceClass
			Set tSourceProp = $G(pStarInfo(pStar,"prop",tRefField,"source"))
			
			// + WAL131 (3)
			Set tSourcePropRefs = $L(tSourceProp,".")
			Set tKeyFieldSourcePropRefs = $L(tKeyFieldSourceProp,".")
			Set tSourcePropStart = $P(tSourceProp,".",1,$L(tSourceProp,".")-1)
			Set tKeyFieldSourcePropStart = $P(tKeyFieldSourceProp,".",1,$L(tKeyFieldSourceProp,".")-1)		
			Set tNoRefs = ((tSourcePropRefs=1)&&(tKeyFieldSourcePropRefs=1))
			Set tPath = ((tKeyFieldSourceProp [ tSourcePropStart)&&'tNoRefs)
			Set tID = ((((tSourceProp [ tKeyFieldSourceProp)&&($L(tSourceProp,".") = ($L(tKeyFieldSourceProp,".")+1))))&&'tNoRefs)
			// - WAL131 (3)
			
			// properties come from the same table
			// strip off last property
			If ((tSourcePropRefs = tKeyFieldSourcePropRefs)&&(tSourcePropRefs>1)&&(tSourcePropStart=tKeyFieldSourcePropStart)) {
				Set tLastProp = $P(tSourceProp,".",$L(tSourceProp,"."))
				Set tSourceProp = $P(tSourceProp,".",1,$L(tSourceProp,".")-1)
								
				Set tSC = ..%AnalyzeStarProperty(tSourceClass,tSourceProp,.tType,,tSourceClass_"."_tSourceProp)
				If ("datatype" '= $$$getClassType($$$NormalizeClassname(tType))) {
					// had better be the case!
					Set tFTable = ..%GetSQLTableName(tType)
					Set tFField = ..%GetSQLColumnName(tType,tLastProp)
					
					// + WAL131 -- this code assumes that the keyfield and reference property come from the same source table
					// If we will query some other table, ask for the name of the property in that
					// table (i.e., home.address becomes address)
					Set tWhereField = $P(tKeyFieldSourceProp,".",$L(tKeyFieldSourceProp,"."))
					Do tMeth.Implementation.WriteLine(" &SQL(SELECT "_tFField_" INTO :tValue FROM "_tFTable_" WHERE " _ tWhereField _ " = :pKey)")
					// - WAL131
				}
				Quit:$$$ISERR(tSC)	
			}
			// The value of the level is an ID in the property's source table
			ElseIf (tID) {
				Set tLastProp = $P(tSourceProp,".",$L(tSourceProp,"."))
				Set tSourceProp = $P(tSourceProp,".",1,$L(tSourceProp,".")-1)
								
				Set tSC = ..%AnalyzeStarProperty(tSourceClass,tSourceProp,.tType,,tSourceClass_"."_tSourceProp)
				If ("datatype" '= $$$getClassType($$$NormalizeClassname(tType))) {
					// had better be the case!
					Set tFTable = ..%GetSQLTableName(tType)
					Set tFField = ..%GetSQLColumnName(tType,tLastProp)

					Set tWhereField = "%ID"
					Do tMeth.Implementation.WriteLine(" &SQL(SELECT "_tFField_" INTO :tValue FROM "_tFTable_" WHERE " _ tWhereField _ " = :pKey)")
				}
			}
			// tKeyFieldSourceProp is a reference from the table we will query
			ElseIf (tPath) {
				If (tSourceProp [ ".") {
					Set tLastProp = $P(tSourceProp,".",$L(tSourceProp,"."))
					Set tSourceProp = $P(tSourceProp,".",1,$L(tSourceProp,".")-1)
				}
				Else {
					Set tLastProp = "%ID"	
				}
								
				Set tSC = ..%AnalyzeStarProperty(tSourceClass,tSourceProp,.tType,,tSourceClass_"."_tSourceProp)
				If ("datatype" '= $$$getClassType($$$NormalizeClassname(tType))) {
					// had better be the case!
					Set tFTable = ..%GetSQLTableName(tType)
					Set tFField = ..%GetSQLColumnName(tType,tLastProp)
					If (tSourcePropStart'="") {
						Set tWhereField = $E(tKeyFieldSourceProp,$L(tSourcePropStart)+2,*)
					}
					Else {
						Set tWhereField = $E(tKeyFieldSourceProp,$L(tSourceProp)+2,*)	
					}
					Set tWhereField = $REPLACE(tWhereField,".","->")
					Do tMeth.Implementation.WriteLine(" &SQL(SELECT "_tFField_" INTO :tValue FROM "_tFTable_" WHERE " _ tWhereField _ " = :pKey)")
					// - WAL131
				}
			}
			// Don't share a path, use cube source table
			ElseIf (tSourceProp [ ".") {
				Set tCubeSourceClass = pCube.sourceClass
				Set tWhereField = $REPLACE(tKeyFieldSourceProp,".","->")
				Set tSelectField = $REPLACE(tSourceProp,".","->")
				Set tLastProp = $P(tSourceProp,".",$L(tSourceProp,"."))
				Set tSourceProp = $P(tSourceProp,".",1,$L(tSourceProp,".")-1)
								
				Set tSC = ..%AnalyzeStarProperty(tSourceClass,tSourceProp,.tType,,tSourceClass_"."_tSourceProp)
				If ("datatype" '= $$$getClassType($$$NormalizeClassname(tType))) {
					Set tFTable = ..%GetSQLTableName(tCubeSourceClass)
					Set tFField = ..%GetSQLColumnName(tType,tLastProp)
					Do tMeth.Implementation.WriteLine(" &SQL(SELECT "_tSelectField_" INTO :tValue FROM "_tFTable_" WHERE " _ tWhereField _ " = :pKey)")
					// - WAL131
				}
				Quit:$$$ISERR(tSC)
			}
			Else {
				// property is in the source table
				Set tSC = ..%AnalyzeStarProperty(tSourceClass,tSourceProp,.tType,,tSourceClass_"."_tSourceProp)
				If ("datatype" = $$$getClassType($$$NormalizeClassname(tType))) {
					// must be a datatype in this case
					// in this case we need to use dynamic SQL
					// otherwise the External value is baked into the SQL code!
					// note that error in this SQL are not reported
					// most likely because we are stepping on some variable!!!
					Set tSTable = ..%GetSQLTableName(tSourceClass)
					Set tSField = ..%GetSQLColumnName(tSourceClass,tSourceProp)

					// + WAL131 (2)
					Set tWhereField = ..%GetSQLColumnName(tSourceClass,tKeyFieldSourceProp)
					// - WAL131 (2)

					Do tMeth.Implementation.WriteLine(" Set tSC = $$$OK")
					Do tMeth.Implementation.WriteLine(" Try {")
 					Do tMeth.Implementation.WriteLine("  Set tRS = ##class(%ResultSet).%New()")
					Do tMeth.Implementation.WriteLine("  Set tSC = tRS.Prepare(""SELECT TOP (1) %EXTERNAL("_tSField_") Value FROM "_tSTable_" WHERE "_tWhereField_" = ?"")") // + WAl131 (2)
					Do tMeth.Implementation.WriteLine("  If $$$ISERR(tSC) Quit")
 					Do tMeth.Implementation.WriteLine("  Set tSC = tRS.Execute(pKey)")
					Do tMeth.Implementation.WriteLine("  If $$$ISERR(tSC) Quit")
 					Do tMeth.Implementation.WriteLine("  If (tRS.Next(.tSC)) {")
 					Do tMeth.Implementation.WriteLine("   Set tValue = tRS.Data(""Value"")")
					Do tMeth.Implementation.WriteLine("  }")
					Do tMeth.Implementation.WriteLine(" }")
					Do tMeth.Implementation.WriteLine(" Catch(ex) {")
					Do tMeth.Implementation.WriteLine("  Set tSC = ex.AsStatus()")
					Do tMeth.Implementation.WriteLine(" }")
					Do tMeth.Implementation.WriteLine(" If $$$ISERR(tSC) {")
					Do tMeth.Implementation.WriteLine("  Set tValue = $System.Status.GetOneStatusText(tSC)")
					Do tMeth.Implementation.WriteLine(" }")
				}
				Else {
					Set tSC = $$$ERROR($$$GeneralError,"Field referenced in sourceClass must be a datatype: "_tSourceProp)
				}
				Quit:$$$ISERR(tSC)
			}

			Do tMeth.Implementation.WriteLine(" Quit tValue")

			Do tClassDef.Methods.Insert(tMeth)
			Set tRefField = $O(tRefFields(tRefField))
		}
		Quit:$$$ISERR(tSC)

		#; determine what indices are needed
		#; there should be an index for the key and each name (if any)
		#; if there are rollups, then there is an index for the combination
		#; of each rollup and key and rollup and name.
		#; the key (or first rollup and key) serves as the primary key for the
		#; dimension table; this is used to lookup member ids at cube insert time.
		Set tPrimaryIndex = ""
		If ($D(tRollups)) {
			Set tRollup = $O(tRollups(""))
			While (tRollup'="") {
				Set tIndices(tRollup_","_tKeyField) = $LB(tRollup,tKeyField)
				If (tPrimaryIndex="") {
					Set tPrimaryIndex = tRollup_","_tKeyField
				}
				Set tNameField = $O(tNameFields(""))
				While (tNameField'="") {
					If (tNameField'=tKeyField) {
						Set tIsRef = +$G(pStarInfo(pStar,"prop",tNameField,"isref"))
						Set tIsDesc = ($G(pStarInfo(pStar,"prop",tNameField,"use"))="description")		// DTB152
						If ('tIsRef)&&('tIsDesc) {
							// no index on ref fields
							// DTB152 - do not create an index for descriptions
							Set tIndices(tRollup_"AND"_tNameField) = $LB(tRollup,tNameField)

							// JMD883: also include an index on the name by itself
							Set tIndices(tNameField) = $LB(tNameField)
						}
					}
					Set tNameField = $O(tNameFields(tNameField))
				}
				Set tRollup = $O(tRollups(tRollup))
			}
		}
		Else {
			If (tKeyField = "") {
				Set tSC = $$$ERROR($$$GeneralError,"Internal error: no key field found")
				Quit
			}
			Else {
				Set tIndices(tKeyField) = $LB(tKeyField)
				Set tPrimaryIndex = tKeyField
				Set tNameField = $O(tNameFields(""))
				While (tNameField'="") {
					If (tNameField'=tKeyField) {
						Set tIsDesc = ($G(pStarInfo(pStar,"prop",tNameField,"use"))="description")		// DTB152
						If 'tIsDesc {
							// DTB152 - do not create an index for descriptions
							Set tIndices(tNameField) = $LB(tNameField)
						}
					}
					Set tNameField = $O(tNameFields(tNameField))
				}
			}
		}

		// JMD938: add index for sort by properties (unless already indexed)
		Set tSortBy = $G(pStarInfo(pStar,"sortBy"))
		If (tSortBy'="") {
			If '$D(tIndices(tSortBy)) {
				Set tIndices(tSortBy) = $LB(tSortBy)
			}
		}

		#; return primary key info
		Set pStarInfo(pStar,"primary") = tPrimaryIndex

		#; create indices
		Set tIndexCount = 0
		Set tName = $O(tIndices(""))
		While (tName'="") {
			Set tIndexCount = tIndexCount + 1
			Set tUnique = 0
			If (tName = tPrimaryIndex) {
				Set tIndexName = "Primary"
				Set tUnique = 1
			}
			Else {
				Set tIndexName = "Idx"_tIndexCount
			}
			Set tIndexDef = ##class(%Dictionary.IndexDefinition).%New(tClassDefName_"||"_tIndexName)
			Set tIndexDef.Name = tIndexName
			Set tIndexDef.Properties = $ListToString(tIndices(tName))
			Set tIndexDef.Unique = tUnique
			Set tIndexDef.SequenceNumber = $I(tSeq)
			Do tClassDef.Indices.Insert(tIndexDef)
			Set tName = $O(tIndices(tName))
		}

		#; done
	    Set tSC = tClassDef.%Save()
	    If $$$ISERR(tSC) Quit

		// Write !,tClassDef.Name," saved"

	    #; Now queue the generated class for compilation
	    Do QueueClass^%occCompile(tClassDefName)
	    #; Mark this class for deletion when the cube class is deleted.
	    $$$comClassArraySet(pCubeClass,$$$cCLASSclasses,tClassDefName_".CLS","")
	    $$$defClassKeySet(tClassDefName,$$$cCLASSgeneratedby,pCubeClass_".CLS")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetPropertyType">
<Description><![CDATA[
Given a class and property return its type.<br/>
<var>pProp</var> can contain a set of referenced fields using dot syntax.<br/>
Return "" if the property does not exist.<br/>
<var>pContext</var> is used for error messages.
[Previously private]]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>*tSC:%Status,*pParms:%String,pClass:%String,pProp:%String,pContext:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tType = ""
	Kill pParms
	Try {
		Set:pContext="" pContext="Generator"
		Set tTargetClass = pClass
		Set tTargetProp = $P(pProp,".",1)
		Set tRefProps = $P(pProp,".",2,999)
		If (pClass="") {
			Set tSC = $$$ERROR($$$GeneralError,"No class specified: ("_pContext_")")
			Quit
		}

		// special case: test for worksheets and kpis
		Set tExt = $P(pClass,".",$L(pClass,"."))
		If ((tExt="kpi")||(tExt="metric")||(tExt="worksheet")) {
			// !!! return string for now
			Set tType = "%String"
			Quit
		}
		ElseIf '$$$comClassDefined(pClass) {
			Set tSC = $$$ERROR($$$GeneralError,"Class not found: "_pClass_" ("_pContext_")")
			Quit
		}
		If (pProp="") {
			Set tSC = $$$ERROR($$$GeneralError,"No property specified: "_pClass_" ("_pContext_")")
			Quit
		}

		Set tClassType = $$$getClassType(pClass)

		// Use different logic for data connector and persistent sources
		If ((tClassType'="persistent")&&$zobjclassmethod(pClass,"%IsA","%DeepSee.DataConnector")) {
			// get property info from connector
			// no "." allowed in connector property name
			Set tSC = $zobjclassmethod(pClass,"%GetPropertyInfo",.tInfo)
			If $$$ISERR(tSC) Quit

			// look for the property within the list
			Set n = $O(tInfo(""))
			While (n'="") {
				Set tName = $LG(tInfo(n),1)
				If (tName = pProp) {
					Set tType = $LG(tInfo(n),3)
					Quit
				}
				Set n = $O(tInfo(n))
			}
			If (tType = "") {
				Set tSC = $$$ERROR($$$GeneralError,"Property not found in DataConnector: "_pProp_", Class:"_ pClass_" ("_pContext_")")
				Quit
			}
		}
		Else {
			If (pProp="%ID") {
				// special case for id
				Set tType = "%String"
				Quit
			}
			Set tType = $$$comMemberKeyGet(pClass,$$$cCLASSproperty,tTargetProp,$$$cPROPtype)
			If (tType = "") {
				Set tSC = $$$ERROR($$$GeneralError,"Property not found: "_tTargetProp_", Class:"_ pClass_" ("_pContext_")")
				Quit
			}

			If (tRefProps '= "") {
				Set tClsType = $$$getClassType($$$NormalizeClassname(tType))
				If (tClsType = "datatype") {
					Set tSC = $$$ERROR($$$GeneralError,"Cannot use a reference with a literal property: "_pClass_":"_tTargetProp_" ("_pContext_")")
					Quit
				}
				Else {
					// recursively find type
					Set tType = ..%GetPropertyType(.tSC, .pParms, tType, tRefProps, pContext)
					Quit
				}
			}

			// get popular parameters
			For p = "MAXLEN","MINVAL","MAXVAL","SCALE" {
				Set v = $$$comMemberArrayGet(tTargetClass,$$$cCLASSproperty,tTargetProp,$$$cPROPparameter,p)
				Set:v'="" pParms(p) = v
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
		Set tType = ""
	}
	Quit tType
]]></Implementation>
</Method>

<Method name="%GetSQLFieldExpression">
<Description>
Convert a dot syntax reference to an SQL arrow syntax expression.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*tSC:%Status,pClass:%String,pPropExpr:%String,pAllowStreams:%Boolean=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tExpr = ""
	Set tType = pClass
	Set tRefType = ""
	For p = 1:1:$L(pPropExpr,".") {
		Set tProp = $P(pPropExpr,".",p)

		Set tField = ..%GetSQLColumnName(tType,tProp)
		If (tField="") {
			// test for transient properties (to give better error message)
			If $$$comMemberKeyGet(tType,$$$cCLASSproperty,tProp,$$$cPROPtransient) {
				Set tSC = $$$ERROR($$$GeneralError,"Transient property cannot be used as a data source unless it is SQL computed: " _ tType _ ":" _ tProp)
				Quit
			}
			Set tSC = $$$ERROR($$$GeneralError,"No SQL field found for property: " _ tType _ ":" _ tProp)
			Quit
		}
		Set tType = $$$comMemberKeyGet(tType,$$$cCLASSproperty,tProp,$$$cPROPtype)
		Set:tType="" tType = "%Library.String"

		Set tExpr = tExpr _ $S(tExpr="":"",tRefType="serial":"_",1:"->") _ tField
		Set tRefType = $$$getClassType($$$NormalizeClassname(tType))

		// do not allow streams as data source properties
		// BDB243: except for iKnow measures
		If (tRefType="stream") && 'pAllowStreams {
			Set tSC = $$$ERROR($$$GeneralError,"Stream property cannot be used as a data source: " _ tType _ ":" _ tProp)
			Quit
		}
	}
	Quit tExpr
]]></Implementation>
</Method>

<Method name="%MakeDescription">
<Description>
Return a description string for the given class member.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMemberType:%String,pName:%String,pSource:%String="",pNotes:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tDesc = pMemberType _ ": " _ pName
	Set:pSource'="" tDesc = tDesc _ "<br/>"_$C(13,10) _ $$$Text("Source: ","%DeepSee") _ pSource
	Set:pNotes'="" tDesc = tDesc _ "<br/>"_$C(13,10) _ pNotes
	Quit tDesc
]]></Implementation>
</Method>

<Method name="%MakePropStorageDef">
<Description><![CDATA[
Produce a storage definition for the <var>pPropName</var> that can be inserted into the class's storage definition.
The array <var>pKnownValues</var> contains the previously compiled storage data, and is used
as a working index to avoid collisions in the storage definition. The <var>pNewValues</var> array
will contain the storage data for all properties actually encountered while working through
this current definition.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pPropName:%String="",&pKnownValues,&pNewValues]]></FormalSpec>
<ReturnType>%Dictionary.StorageDataValueDefinition</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB961
	Set tValueDef = $$$NULLOREF
	Try {
		If (pPropName="") Quit
		
		Set tValueDef = ##class(%Dictionary.StorageDataValueDefinition).%New()
		Do tValueDef.ValueSet(pPropName)
		
		// Find the appropriate name for each fact number
		Set tNextAvailName = 0
		If $D(pKnownValues("value",pPropName),tKnownName) {
			Do tValueDef.NameSet(tKnownName)
			
			Set pNewValues("value",pPropName) = tKnownName
			Set pNewValues("name",tKnownName) = pPropName
		}
		Else {
			// Find the next available slot
			While $D(pKnownValues("name",$I(tNextName))) {}
			
			// Set the storage definition and the lookup indices
			Do tValueDef.NameSet(tNextName)
			Set pKnownValues("value",pPropName) = tNextName
			Set pKnownValues("name",tNextName) = pPropName
			
			Set pNewValues("value",pPropName) = tNextName
			Set pNewValues("name",tNextName) = pPropName
		}
	}
	Catch ex {
		Set tValueDef = $$$NULLOREF 
	}
	
	Quit tValueDef
]]></Implementation>
</Method>

<Method name="%AnalyzeStarProperty">
<Description>
For the given source class and reference to property within the source
class, find the type of the property; the aliased name for the property; the root property needed to
fetch complete details on the property.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSourceClass:%String,pSourceProperty:%String,*pType:%String,*pParms,pContext:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pType = ""
		Set pName = ""
		Kill pParms

		If (pSourceProperty = "") {
			Quit
		}

		// Analyze the type of the source property.
		// If source property is a reference, pull it apart and
		// analyze each piece.
		Set tClass = pSourceClass
		Set tName = ""
		If (pSourceProperty '= "") {
			For p = 1:1:$L(pSourceProperty,".") {
				Set tProp = $P(pSourceProperty,".",p)
				Set tType = ..%GetPropertyType(.tSC, .tParms, tClass,tProp,pContext _ " AnalyzeStarProperty")
				Quit:$$$ISERR(tSC)
				If (tType = "") Quit
				If ("datatype" = $$$getClassType($$$NormalizeClassname(tType))) {
					If (p < $L(pSourceProperty,".")) {
						// we cannot have references after a datatype!
						Set tSC = $$$ERROR($$$GeneralError,"Invalid property reference: " _ pSourceProperty)
					}
					Merge pParms = tParms
					Quit
				}
				Set tClass = tType
			}
			Quit:$$$ISERR(tSC)
		}

		Set tName = "" 
		For j=$L(pSourceProperty,"."):-1:1 {
			Set tName = tName _ $S(tName="":"",1:"Via")_ $P(pSourceProperty,".",j)
		}

		Set pType = tType
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%DenormalizeType">
<Description>
Convert a class name of the form %Library.xxx to %xxx.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pType:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$S($E(pType,1,9)="%Library.":"%"_$P(pType,".",2,999),1:pType)
]]></Implementation>
</Method>

<Method name="%IsString">
<Description>
Test to determine if the current type is a string or is a custom datatype
with %String as a superclass</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pType:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB491
	Set tIsString = 0
	Try {
		If (pType="%String")||(pType="%Library.String") {
			Set tIsString = 1
			Quit
		}
		
		s tTypeDef = ##class(%Dictionary.CompiledClass).%OpenId(pType)
		If (tTypeDef.Super["%String")||(tTypeDef.Super["%Library.String") {
			Set tIsString = 1
			Quit
		}
		Else {
			// Parse the list of superclasses and see if there any %String subclasses
			Set tSuperList = tTypeDef.Super
			For c=1:1:$L(tSuperList,",") {
				Set tSuperType = $P(tSuperList,",",c)
				If ($E(tSuperType)'="%") {
					Set tIsString = ..%IsString(tSuperType)
				}
				
				If (tIsString) Quit
			}
		}
	}
	Catch ex {
		Set tIsString = ex.AsStatus()
	}
	Quit tIsString
]]></Implementation>
</Method>

<Method name="%MakeSQLCompute">
<Description>
Given a classname, method name, base expression, and optional list
of options, return a value that can be used as an SQL computed field
expression. Match the options with arguments in the functions formal spec.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCode,pClass:%String,pMethod:%String,pBase:%String,&pOptions]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pCode = ""
	Set tSC = $$$OK
	Try {
		// test for expression methods
		If ("expression" = $$$comMemberKeyGet(pClass,$$$cCLASSmethod,pMethod,$$$cMETHcodemode)) {
			Set tExpr = ""
			For n = 1:1:$$$defMemberKeyGet(pClass,$$$cCLASSmethod,pMethod,$$$cMETHimplementation) {
				Set tExpr = tExpr _ $$$defMemberArrayGet(pClass,$$$cCLASSmethod,pMethod,$$$cMETHimplementation,n)
			}
			// replace formal arguments withing expression
			// using the method du fromage
			Set tSpec = $$$comMemberKeyGet(pClass,$$$cCLASSmethod,pMethod,$$$cMETHformalspecparsed)
			For n=1:1:$LL(tSpec) {
				Set tArgName = $LG($LG(tSpec,n),1)
				Set tArgValue = ""
				If (n = 1) {
					Set tExpr = $Replace(tExpr,tArgName,"{"_pBase_"}")
				}
				Else {
					If $D(pOptions($$$UPPER(tArgName))) {
						Set tArgValue = pOptions($$$UPPER(tArgName))
						Set tExpr = $Replace(tExpr,tArgName,$$$quote(tArgValue))
					}
				}
			}

			Set pCode = tExpr
		}
		Else {
			// If options are available, match them with formal spec
			Set tArgList = ""
			If ($D(pOptions)) {
				Set tArgCount = 0
				// get formal spec for function: skip first argument
				Set tSpec = $$$comMemberKeyGet(pClass,$$$cCLASSmethod,pMethod,$$$cMETHformalspecparsed)
				For n=2:1:$LL(tSpec) {
					Set tArgName = $LG($LG(tSpec,n),1)
					Set tArgValue = ""
					If $D(pOptions($$$UPPER(tArgName))) {
						Set tArgCount = tArgCount + 1
						Set tArgValue = pOptions($$$UPPER(tArgName))
					}
					Set tArgList = tArgList _ "," _ $$$quote(tArgValue)
				}
				If (tArgCount = 0) {
					Set tArgList = ""
				}
			}

			Set pCode = "##class("_pClass_")."_pMethod _ "({" _ pBase _ "}"
			Set pCode = pCode _ tArgList _")"
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ParseTimeFunction">
<Description>
Take a time function specification ("Function(p=1)") and find
from it the function name and list of options with their values.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSpec:%String,*pFuncName:%String,*pOptions:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pOptions
		Set pFuncName = ""
		Set tState = 0
		Set tDone = 0
		Set p = 1
		Set tToken = ""

		While (p <= $L(pSpec)) {
			Set ch = $E(pSpec,p)

			If (tState = 0) { // func name
				If (ch = "(") {
					Set pFuncName = $ZSTRIP(tToken,"<>W")
					If (pFuncName="") {
						Set tSC = $$$ERROR($$$GeneralError,"Missing function name in function specification: " _ pSpec)
						Quit
					}
					Set tToken = ""
					Set tState = 1
				}
				Else {
					Set tToken = tToken_ch
				}
			}
			ElseIf (tState = 1) { // (
				If (ch = ")") {
					Set tSC = $$$ERROR($$$GeneralError,"Missing option or option value in function specification: " _ pSpec)
					Quit
				}
				ElseIf (ch = "=") {
					Set tArg = $ZSTRIP(tToken,"<>W")
					If (tArg="") {
						Set tSC = $$$ERROR($$$GeneralError,"Missing option name in function specification: " _ pSpec)
						Quit
					}
					Set tToken = ""
					Set tState = 2
				}
				Else {
					Set tToken = tToken_ch
				}
			}
			ElseIf (tState = 2) { // (aaa=
				If ((ch = ")")||(ch = ",")) {
					Set tValue = $ZSTRIP(tToken,"<>W")
					If (tValue="") {
						Set tSC = $$$ERROR($$$GeneralError,"Missing option value in function specification: " _ pSpec)
						Quit
					}
					ElseIf ('$IsValidNum(tValue)) {
						Set tSC = $$$ERROR($$$GeneralError,"Invalid option value in function specification: " _ tValue)
						Quit
					}
					Set pOptions($$$UPPER(tArg)) = tValue
					Set tToken = ""
					Set tState = $CASE(ch,",":1,:5)
				}
				ElseIf (ch = """") {
					If (tToken'="") {
						// error
						Set tSC = $$$ERROR($$$GeneralError,"Unexpected "" in function specification: " _ pSpec)
						Quit
					}
					Set tState = 3
				}
				Else {
					Set tToken = tToken_ch
				}
			}
			ElseIf (tState = 3) { // ( (aaa="
				If (ch = """") {
					// test for ""
					If ($E(pSpec,p+1)="""") {
						Set tToken = tToken_ch
						Set p = p + 1
					}
					Else {
						Set tValue = $ZSTRIP(tToken,"<>W")
						Set pOptions($$$UPPER(tArg)) = tValue
						Set tToken = ""
						Set tState = 4
					}
				}
				Else {
					Set tToken = tToken_ch
				}
			}
			ElseIf (tState = 4) { // ( (aaa="" | aaa=22
				If (ch = ")") {
					Set tState = 5
				}
				ElseIf (ch = ",") {
					Set tState = 1
				}
				Else {
					Set tSC = $$$ERROR($$$GeneralError,"Unexpected character in function specification: " _ ch)
					Quit
				}
			}
			ElseIf (tState = 5) {
				Set tSC = $$$ERROR($$$GeneralError,"Unexpected characters after ')' in function specification: " _ pSpec)
				Quit
			}
			Set p = p + 1
		}

		If $$$ISERR(tSC) Quit


		If (tState = 0) {
			Set pFuncName = $ZSTRIP(tToken,"<>W")
		}
		ElseIf (tState '= 5) {
			Set tSC = $$$ERROR($$$GeneralError,"Missing ) in function specification: " _ pSpec)
			Quit
		}

		If '$ZName(pFuncName) {
			Set tSC = $$$ERROR($$$GeneralError,"Invalid function name in function specification: " _ pFuncName)
			Quit
		}
		Set o = $O(pOptions(""))
		While (o'="") {
			If '$ZName(o) {
				Set tSC = $$$ERROR($$$GeneralError,"Invalid option name in function specification: " _ o)
				Quit
			}
			Set o = $O(pOptions(o))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ParseExpression">
<Description><![CDATA[
Take a ObjectScript expression and find all the occurences of
<pVarName>.Property, replace them and return a list of property references.
An expression can also contain a reference to a class method
of the cube class using the syntax %cube.Method. This is replaced later.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCode:%String,*pResult:%String,*pPropList:%String,pVarName:%String="%source"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pPropList
		Set pResult = ""
		Set tLast = 1
		Set tPattern = pVarName_"."
		Set tSourceLen = $L(tPattern)
		Set p = $Find(pCode,tPattern)
		While (p > 0) {
			Set pResult = pResult _ $E(pCode,tLast,p-tSourceLen-1)
			Set tToken = ""
			// find end of property reference
			Set c = p
			While (1) {
				Set ch = $E(pCode,c)
				If ((ch'=".")&&(ch'="%")&&((ch="")||('$ZName("A"_ch)))) {
					Quit
				}
				Set tToken = tToken_ch 
				Set c = c + 1
			} 
			If (tToken '= "") {
				Set pPropList(tToken) = ""
				Set pResult = pResult _ pVarName _ "("""_tToken_""")"
			}
			Set tLast = p + $L(tToken)
			Set p = $Find(pCode,tPattern,p)
		}
		Set pResult = pResult _ $E(pCode,tLast,*)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetSQLTableName">
<Description><![CDATA[
Returns the SQL table name for class <var>pClass</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tTable = ##class(%DeepSee.Utils).%GetSQLTableName(pClass,0)		// DTB786 - Call without verification since the oddCOM global is being built!
	// do we need delimited ids?
	// we have to check schema and table name separately
	Set tSchema = $P(tTable,".",1)
	Set tTable = $P(tTable,".",2)
	If ('$System.SQL.IsValidRegularIdentifier(tSchema)) {
		Set tSchema = $$$quote(tSchema)
	}
	If ('$System.SQL.IsValidRegularIdentifier(tTable)) {
		Set tTable = $$$quote(tTable)
	}
	Quit tSchema _ "." _ tTable
]]></Implementation>
</Method>

<Method name="%GetSQLColumnName">
<Description><![CDATA[
Returns the SQL name of property <var>pProp</var> for class <var>pClass</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String,pProp:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// n.b., names are already quoted at this point if needed.
	Set tName = ##class(%DeepSee.Utils).%GetSQLColumnName(pClass,pProp)
	Quit tName
]]></Implementation>
</Method>

<Method name="%CompareMetaData">
<Description><![CDATA[
Compare the meta data for the given cube with a prior definition.<br/>
Results are returned in <var>pResults</var>.]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,*pResults</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pResults
		Set tCube = $$$UPPER(pCube)

		// bucket size affect cache
		Set pResults("bucketSize") = $G($$$DeepSeeMetaGLVN("cubes",tCube,"bucketSize"))=$G($$$DeepSeeMetaGLVN("prior",tCube,"bucketSize"))

		// other cube meta data
		Set pResults("cube") = 1
		If ($G($$$DeepSeeMetaGLVN("cubes",tCube,"defdim"))'=$G($$$DeepSeeMetaGLVN("prior",tCube,"defdim"))) {
			Set pResults("cube") = 0
		}
		If ($G($$$DeepSeeMetaGLVN("cubes",tCube,"precompute"))'=$G($$$DeepSeeMetaGLVN("prior",tCube,"precompute"))) {
			Set pResults("cube") = 0
		}
		If ($G($$$DeepSeeMetaGLVN("cubes",tCube,"caption"))'=$G($$$DeepSeeMetaGLVN("prior",tCube,"caption"))) {
			Set pResults("cube") = 0
		}
		If ($G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceClass"))'=$G($$$DeepSeeMetaGLVN("prior",tCube,"sourceClass"))) {
			Set pResults("cube") = 0
		}
		If ($G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceType"))'=$G($$$DeepSeeMetaGLVN("prior",tCube,"sourceType"))) {
			Set pResults("cube") = 0
		}

		// dimensions
		Set tDimEqual = 1
		Set tCurrDNO = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",""))
		Set tPriorDNO = $O($$$DeepSeeMetaGLVN("prior",tCube,"mbr#",""))
		While ((tDimEqual = 1) && ((tCurrDNO'="")||(tPriorDNO'=""))) {
			Set tCurrHNO = $S(tCurrDNO="":"",1:$O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tCurrDNO,"")))
			Set tPriorHNO = $S(tPriorDNO="":"",1:$O($$$DeepSeeMetaGLVN("prior",tCube,"mbr#",tPriorDNO,"")))
			While ((tDimEqual = 1) && ((tCurrHNO'="")||(tPriorHNO'=""))) {
				Set tCurrLNO = $S(tCurrHNO="":"",1:$O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tCurrDNO,tCurrHNO,""),1,cnode))
				Set tPriorLNO = $S(tPriorHNO="":"",1:$O($$$DeepSeeMetaGLVN("prior",tCube,"mbr#",tPriorDNO,tPriorHNO,""),1,pnode))
				While ((tDimEqual = 1) && ((tCurrLNO'="")||(tPriorLNO'=""))) {
					If ($G(cnode) '= $G(pnode)) {
						Set tDimEqual = 0
					}
					Set:((tCurrDNO'="")&&(tCurrHNO'="")) tCurrLNO = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tCurrDNO,tCurrHNO,tCurrLNO),1,cnode)
					Set:((tPriorDNO'="")&&(tPriorHNO'="")) tPriorLNO = $O($$$DeepSeeMetaGLVN("prior",tCube,"mbr#",tPriorDNO,tPriorHNO,tPriorLNO),1,pnode)
				}
				Set:(tCurrDNO'="") tCurrHNO = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tCurrDNO,tCurrHNO))
				Set:(tPriorDNO'="") tPriorHNO = $O($$$DeepSeeMetaGLVN("prior",tCube,"mbr#",tPriorDNO,tPriorHNO))
			}
			Set tCurrDNO = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tCurrDNO))
			Set tPriorDNO = $O($$$DeepSeeMetaGLVN("prior",tCube,"mbr#",tPriorDNO))
		}

		// facts
		Set tFactEqual = 1
		Set tFactReason = ""
		Set tCurrFact = $O($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",""),1,cfno)
		Set tPriorFact = $O($$$DeepSeeMetaGLVN("prior",tCube,"fact","prop",""),1,pfno)
		While (tFactEqual && ((tCurrFact'="")||(tPriorFact'=""))) {
			Set tFactReason = tCurrFact_"/"_tPriorFact
			If ((tCurrFact'=tPriorFact)||($G(cfno)'=$G(pfno))) {
				Set tFactEqual = 0
			}
			Else {
				// test next level subscripts	
				Set kc = $S(tCurrFact="":"",1:$O($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tCurrFact,""),1,cval))
				Set kp = $S(tPriorFact="":"",1:$O($$$DeepSeeMetaGLVN("prior",tCube,"fact","prop",tPriorFact,""),1,pval))
				While (tFactEqual && ((kc'="")||(kp'=""))) {
					If ((kc'=kp)||($G(cval)'=$G(pval))) {
						Set tFactEqual = 0
					}
					Else {
						// parameters
						Set kc2 = $S(kc="":"",1:$O($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tCurrFact,kc,""),1,cval2))
						Set kp2 = $S(kp="":"",1:$O($$$DeepSeeMetaGLVN("prior",tCube,"fact","prop",tPriorFact,kp,""),1,pval2))
						While (tFactEqual && ((kc2'="")||(kp2'=""))) {
							If ((kc2'=kp2)||($G(cval2)'=$G(pval2))) {
								Set tFactEqual = 0
							}
							Set:(tCurrFact'="")&&(kc'="") kc2 = $O($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tCurrFact,kc,kc2),1,cval2)
							Set:(tPriorFact'="")&&(kp'="") kp2 = $O($$$DeepSeeMetaGLVN("prior",tCube,"fact","prop",tPriorFact,kp,kp2),1,pval2)
						}
					}
					Set:(tCurrFact'="") kc = $O($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tCurrFact,kc),1,cval)
					Set:(tPriorFact'="") kp = $O($$$DeepSeeMetaGLVN("prior",tCube,"fact","prop",tPriorFact,kp),1,pval)
				}
			}
			// next
			Set tCurrFact = $O($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tCurrFact),1,cfno)
			Set tPriorFact = $O($$$DeepSeeMetaGLVN("prior",tCube,"fact","prop",tPriorFact),1,pfno)
		}
		Set:tFactEqual tFactReason = ""

		Set pResults("facts") = tFactEqual 
		Set pResults("dims") = tDimEqual 
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ProcessSubjectArea">
<Description><![CDATA[
Build the meta data for the given subject area model.
pCaptions(dname,hname,lname) = displayName<br/>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCubeClass:%String,pSubject:%DeepSee.Model.SubjectArea.subjectArea,&pCaptions:%String,pJoinList:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tBaseCube = $$$UPPER(pSubject.baseCube)
		Set tCube = $$$UPPER(pSubject.name) // cube for subject area

		// first merge over all meta data for base, then we will prune
		Kill $$$DeepSeeMetaGLVN("cubes",tCube)
		Merge $$$DeepSeeMetaGLVN("cubes",tCube) = $$$DeepSeeMetaGLVN("cubes",tBaseCube)

		// fix class name
		Set $$$DeepSeeMetaGLVN("cubes",tCube) = pCubeClass

		// we don't need "star" info
		Kill $$$DeepSeeMetaGLVN("cubes",tCube,"star")

		// add baseCube to meta data
		Set $$$DeepSeeMetaGLVN("cubes",tCube,"baseCube") = tBaseCube

		// if this is a compound cube; merge in elements from other base cubes
		If (pJoinList'="") {
			// merge cube elements
			For p = 2:1:$L(pJoinList,",") {
				Set tJoinCube = $$$UPPER($P(pJoinList,",",p))

				// dimensions
				Set tDim = $O($$$DeepSeeMetaGLVN("cubes",tJoinCube,"mbrs",""))
				While (tDim'="") {
					Set tHier = $O($$$DeepSeeMetaGLVN("cubes",tJoinCube,"mbrs",tDim,""))
					While (tHier'="") {
						If $D($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier)) {
							// make sure this dimension is "shared"
							If ('$D($$$DeepSeeMetaGLVN("cubes",tJoinCube,"sharesFrom",tBaseCube,tDim))&&
								'$D($$$DeepSeeMetaGLVN("cubes",tBaseCube,"sharesFrom",tJoinCube,tDim))) {
								If ((tDim'="%SEARCH")&&(tDim'="MEASURES")) {
									Set tSC = $$$ERROR($$$GeneralError,"Dimensions with same name must be shared: " _ tDim)
									Quit
								}
							}
						    If $$$ISERR(tSC) Quit
						}
						Else {
							// additional dimension from 2nd cube
							// add to compound cube
							// add a fake dim,hier number
							Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim))
							Set tHierInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier))
							If (tDimInfo="") {
								Set tNewDimNo = 1+$O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",""),-1)
								Set tNewHierNo = 1
							}
							Else {
								Set tNewDimNo = +$LG(tDimInfo,1)
								If (tHierInfo="") {
									Set tNewHierNo = 1+$O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tNewDimNo,""),-1)
								}
								Else {
									Set tNewHierNo = +$LG(tHierInfo,2)
								}
							}
							Set $$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier) = $LB(tNewDimNo,tNewHierNo,0)

							// get original element info and modify
							Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tJoinCube,"mbrs",tDim,tHier))
							Set tOrigInfo = $G($$$DeepSeeMetaGLVN("cubes",tJoinCube,"mbr#",+$LG(tInfo,1),+$LG(tInfo,2),+$LG(tInfo,3)))
						
							// remove fact name
							Set $List(tOrigInfo,5) = ""
							
							If $LG(tOrigInfo,1) = "m" {
								// PFS019 - Add source cube info to measure node's list item #14
								Set $List(tOrigInfo,14) = tJoinCube
							}
							Set $$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tNewDimNo,tNewHierNo,0) = tOrigInfo
						}
						Set tHier = $O($$$DeepSeeMetaGLVN("cubes",tJoinCube,"mbrs",tDim,tHier))
					}
				    If $$$ISERR(tSC) Quit
					Set tDim = $O($$$DeepSeeMetaGLVN("cubes",tJoinCube,"mbrs",tDim))
				}
			}
		    If $$$ISERR(tSC) Quit

			// process connectsBy
			If (pSubject.connectsBy'="") {
				For n = 1:1:$L(pSubject.connectsBy,"],[") {
					Set tSpec = $P(pSubject.connectsBy,"],[",n)
					If (tSpec'="") {
						Set:$E(tSpec)'="[" tSpec="["_tSpec
						Set:$E(tSpec,*)'="]" tSpec=tSpec_"]"
						Set $$$DeepSeeMetaGLVN("cubes",tCube,"connectsBy",$$$UPPER(tSpec)) = ""
					}
				}
			}

		} // joinList
	    If $$$ISERR(tSC) Quit

		// cube overrides

		// DTB082
		Set $$$DeepSeeMetaGLVN("cubes",tCube,"disableListingGroups") = pSubject.disableListingGroups

		#; listings
		For n=1:1:pSubject.listings.Count() {
			Set tListing = pSubject.listings.GetAt(n)
			If ('tListing.disabled) {
				Set $$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing.name,"fieldList") = tListing.fieldList
				Set:tListing.formatList'="" $$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing.name,"formatList") = tListing.formatList
				If (tListing.hidden) {
					// hidden listing does not exist in subjectArea
					Kill $$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing.name)
				}
				Else {
					Set:tListing.orderBy'="" $$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing.name,"orderBy") = tListing.orderBy
					Set:tListing.sql'="" $$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing.name,"sql") = tListing.sql
					Set:tListing.sourceClass'="" $$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing.name,"sourceClass") = tListing.sourceClass
					Set:(tListing.listingType'="")&&(tListing.listingType'="table") $$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing.name,"listingType") = tListing.listingType
					Set:tListing.resource'="" $$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing.name,"resource") = tListing.resource
				}
			}
		}

		// override of default listing
		If (pSubject.defaultListing'="") {
			If $D($$$DeepSeeMetaGLVN("cubes",tCube,"listing",pSubject.defaultListing)) {
				Set tDefaultListing = pSubject.defaultListing
				Set $$$DeepSeeMetaGLVN("cubes",tCube,"defaultListing") = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tDefaultListing,"fieldList"))
				Set $$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingOrder") = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tDefaultListing,"orderBy"))
				Set $$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingSQL") = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tDefaultListing,"sql"))
				Set $$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingSourceClass") = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tDefaultListing,"sourceClass"))
				Set $$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingFormat") = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tDefaultListing,"formatList"))
				Set $$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingResource") = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tDefaultListing,"resource"))
			}
		}

		// filtering (what if cube defines a filter!)
		Set:pSubject.filterSpec'="" $$$DeepSeeMetaGLVN("cubes",tCube,"filterSpec") = pSubject.filterSpec

		Set:pSubject.resource'="" $$$DeepSeeMetaGLVN("cubes",tCube,"resource") = pSubject.resource

		// dimension overrides
		For d=1:1:pSubject.dimensions.Count() {
			Set tDim = pSubject.dimensions.GetAt(d)
			If (tDim.disabled) {
				// disabled means: ignore this definition
				Continue
			}
			Set tDimBase = $$$UPPER(tDim.name)
			If ('$D($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase))) {
				Write !,$$$Text("Dimension not found in base cube, skipped","%DeepSee"),": ",tDim.name
				Continue
			}
			If (tDim.hidden) {
				// mark dimension as hidden
				Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase))
				Set dno = $LG(tInfo,1)
				Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",dno,0,0),17) = 1
			}

			// all level
			If ((tDim.allCaption = "")&&(tDim.allDisplayName '= "")) {
				Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase))
				Set tInfoD = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),0,0))
				Set tOldAllCaption = $LG(tInfoD,4)
				Set pCaptions($$$UPPER(tDim.name),$$$UPPER(tOldAllCaption)) = $LB(tOldAllCaption,tDim.allDisplayName)
			}
			ElseIf (tDim.allCaption '= "") {
				Set pCaptions($$$UPPER(tDim.name),$$$UPPER(tDim.allCaption)) = $LB(tDim.allCaption,tDim.allDisplayName)

				// change ALL caption
				Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase))
				Set tInfoD = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),0,0))
				Set tOldAllCaption = $$$UPPER($LG(tInfoD,4))
				// replace in dimension node
				Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),0,0),4) = tDim.allCaption

				// replace in hierarchy nodes: all node should be level 1, if present
				Set hno = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),""))
				While (hno '= "") {
					Set tInfoH = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),hno,1))
					If ($LG(tInfoH,1)="all") {
						Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),hno,1),4) = tDim.allCaption
					}
					Set hno = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),hno))
				}

				// now fix mbr nodes
				Set hk = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,""))
				While (hk'="") {
					If (hk = tOldAllCaption) {
						Set $$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,$$$UPPER(tDim.allCaption)) = $$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,hk)
						Kill $$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,hk)
					}
					// look one level down
					Set lk = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,hk,""))
					While (lk'="") {
						If (lk = tOldAllCaption) {
							Set $$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,hk,$$$UPPER(tDim.allCaption)) = $$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,hk,lk)
							Kill $$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,hk,lk)
						}
						Set lk = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,hk,lk))
					}
					Set hk = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,hk))
				}
			}
			
			// name changes
			If (tDim.displayName '= "") {
				Set pCaptions($$$UPPER(tDim.name)) = $LB(tDim.name,tDim.displayName)
			}

			// other attributes
			For h=1:1:tDim.hierarchies.Count() {
				Set tHier = tDim.hierarchies.GetAt(h)
				If (tHier.disabled) {
					Continue
				}
				If (tHier.displayName '= "") {
					Set pCaptions($$$UPPER(tDim.name),$$$UPPER(tHier.name)) = $LB(tHier.name,tHier.displayName)
				}

				// JMD1441
				// hide all levels of hidden hierarchy
				// (including the 0 level)
				If (tHier.hidden) {
					Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,$$$UPPER(tHier.name)))
					Set tLevelNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),$LG(tInfo,2),""))
					While (tLevelNo'="") {
						Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),$LG(tInfo,2),tLevelNo),17) = 1
						Set tLevelNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),$LG(tInfo,2),tLevelNo))
					}
				}

				For l=1:1:tHier.levels.Count() {
					Set tLevel = tHier.levels.GetAt(l)
					If (tLevel.disabled) {
						Continue
					}

					If (tLevel.displayName '= "") {
						Set pCaptions($$$UPPER(tDim.name),$$$UPPER(tHier.name),$$$UPPER(tLevel.name)) = $LB(tLevel.name,tLevel.displayName)
					}
					// find actual member #s
					Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase,$$$UPPER(tHier.name),$$$UPPER(tLevel.name)))
					If (tLevel.sort'="") {
						Set tLS = $Case(tLevel.sort,"asc":"asc","desc":"desc","desc numeric":"desc#","asc numeric":"asc#",:"")
						Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),$LG(tInfo,2),$LG(tInfo,3)),10) = tLS
					}
					If (tLevel.hidden) {
						// mark level as hidden
						Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),$LG(tInfo,2),$LG(tInfo,3)),17) = 1
					}
				}
			}
			
			// JMD1441 if all hierarchies are hidden, hide the dimension
			Set tAllHidden = 1
			Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDimBase))

			Set tHierNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),0))
			While (tHierNo'="") {
				Set tHierHidden = +$LG($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),tHierNo,0),17)
				If ('tHierHidden) {
					// check if *all* the levels are hidden
					Set tLevelsH = 1
					Set tLevelNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),tHierNo,1))
					While (tLevelNo'="") {
						Set tLevelHidden = +$LG($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),tHierNo,tLevelNo),17)
						If ('tLevelHidden) {
							Set tLevelsH = 0
							Quit
						}
						Set tLevelNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),tHierNo,tLevelNo))
					}
					If (tLevelsH) {
						Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),tHierNo,0),17) = 1
						Set tHierHidden = 1
					}
				}

				If ('tHierHidden) {
					Set tAllHidden = 0
					Quit
				}
				Set tHierNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),tHierNo))
			}

			// mark dimension hidden
			If (tAllHidden) {
				Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",$LG(tInfo,1),0,0),17) = 1
			}
		}

		// measure overrides
		For m=1:1:pSubject.measures.Count() {
			Set tMsr = pSubject.measures.GetAt(m)
			If (tMsr.disabled) {
				Continue
			}
			Set tMsrBase = $$$UPPER(tMsr.name)
			If ('$D($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs","MEASURES",tMsrBase))) {
				Write !,$$$Text("Measure not found in base cube, skipped","%DeepSee"),": ",tMsr.name
				Continue
			}
			If (tMsr.hidden) {
				Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs","MEASURES",tMsrBase))
				Set mno = $LG(tInfo,2)

				// mark node
				Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",0,mno,0),1) = "-m"

				// remove reference to measure
				Kill $$$DeepSeeMetaGLVN("cubes",tCube,"mbrs","MEASURES",tMsrBase)
				Continue
			}
			// name changes
			If (tMsr.displayName '= "") {
				Set pCaptions("MEASURES",$$$UPPER(tMsr.name)) = $LB(tMsr.name,tMsr.displayName)
			}
			// JMD1189 formatString
			If (tMsr.formatString'="") {
				Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs","MEASURES",tMsrBase))
				Set mno = $LG(tInfo,2)
				Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",0,mno,0),12) = tMsr.formatString
			}
		}

		// relationship overrides
		For r=1:1:pSubject.relationships.Count() {
			Set tRel = pSubject.relationships.GetAt(r)
			If (tRel.disabled) {
				Continue
			}
			Set tRelBase = $$$UPPER(tRel.name)
			If ('$D($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tRelBase))) {
				Write !,$$$Text("Relationship not found in base cube, skipped","%DeepSee"),": ",tRel.name
				Continue
			}
			If (tRel.hidden) {
				// mark (relation) dimension as hidden
				Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tRelBase))
				Set dno = $LG(tInfo,1)
				Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",dno,0,0),17) = 1
			}
			// name changes
			If (tRel.displayName '= "") {
				Set pCaptions(tRelBase) = $LB(tRel.name,tRel.displayName)
			}
		}
		// calculated members
		For m=1:1:pSubject.calculatedMembers.Count() {
			Set tMbr = pSubject.calculatedMembers.GetAt(m)
			If (tMbr.disabled) {
				Continue
			}
			
			// JMD911: If we are not overriding an existing calc mbr, enter info for it!
			If ('$D($$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs",$$$UPPER(tMbr.dimension),$$$UPPER(tMbr.name)))) {
				Set $$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs",$$$UPPER(tMbr.dimension),$$$UPPER(tMbr.name)) = $LB(tMbr.dimension,tMbr.name,tMbr.valueExpression,tMbr.formatString,tMbr.hidden,tMbr.listingFilter)
			}
			Else {
				If (tMbr.valueExpression'="") {
					Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs",$$$UPPER(tMbr.dimension),$$$UPPER(tMbr.name)),3) = tMbr.valueExpression
				}
				If (tMbr.formatString'="") {
					Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs",$$$UPPER(tMbr.dimension),$$$UPPER(tMbr.name)),4) = tMbr.formatString
				}
				// hide/show from Analyzer
				Set $List($$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs",$$$UPPER(tMbr.dimension),$$$UPPER(tMbr.name)),5) = tMbr.hidden

			}
			If (tMbr.displayName'="") {
				Set pCaptions($$$UPPER(tMbr.dimension)) = $LB(tMbr.dimension,tMbr.dimension)
				Set pCaptions($$$UPPER(tMbr.dimension),$$$UPPER(tMbr.name)) = $LB(tMbr.name,tMbr.displayName)
			}
		}

		// named sets
		For m=1:1:pSubject.namedSets.Count() {
			Set tMbr = pSubject.namedSets.GetAt(m)
			If (tMbr.disabled) {
				Continue
			}
			If (tMbr.hidden) {
				Kill $$$DeepSeeMetaGLVN("cubes",tCube,"namedSets",$$$UPPER(tMbr.name))
			}
			Else {
				Set $$$DeepSeeMetaGLVN("cubes",tCube,"namedSets",$$$UPPER(tMbr.name)) = $LB(tMbr.name,tMbr.setExpression)

				// use special %%NAMEDSETS dimension name
				Set pCaptions("%%NAMEDSETS",$$$UPPER(tMbr.name)) = $LB(tMbr.name,tMbr.displayName)
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%CreateCursorName">
<Description>
Create a unique cursor name to avoid SQL problems!</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPrefix:%String,pClassName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pClassName = $TR(pClassName,".","z")
	Set tPostFix = $S($L(pClassName)>20:$ZCRC(pClassName,7),1:pClassName)
	Quit pPrefix_tPostFix
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.SubjectArea">
<Description><![CDATA[
This class is used to define DeepSee Subject Areas.<br/>
Each subclass of this class defines an
active Subject Area. A Subject Area is analogous to an
SQL view; it is based on an actual DeepSee Cube data model 
and can serve as the target of queries as if it were an
actual cube model.<br/>
A Subject Area cannot define additional dimensions or measures
but it can define:<br/>
<ul>
<li>What dimensions and measures can be used in queries.</li>
<li>What permissions are needed to query a cube</li>
<li>How the data within a cube should be filtered.</li>
<li>The default listing for this subject area.</li>
</ul>]]></Description>
<CompileAfter>%DeepSee.Model.SubjectArea.subjectArea,%DeepSee.Generator</CompileAfter>
<IncludeCode>%occUtility,%DeepSee</IncludeCode>
<IncludeGenerator>%occUtility,%DeepSee</IncludeGenerator>
<Super>%RegisteredObject,%XML.Adaptor</Super>
<System>4</System>
<TimeCreated>60835,71423.817858</TimeCreated>

<Projection name="SubjectAreaProjection">
<Description>
This projection is used to keep track of when Subject areas are
compiled or deleted.</Description>
<Type>%DeepSee.SubjectAreaProjection</Type>
<Internal>1</Internal>
</Projection>

<XData name="SubjectArea">
<Description>
This XData definition defines the SubjectArea.</Description>
<XMLNamespace>http://www.intersystems.com/deepsee/subjectarea</XMLNamespace>
</XData>

<Method name="%Generate">
<Description>
Process the model for this Subject Area and generate meta data.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine(" Quit $$$OK")
	Set tSC = $$$OK
	Try {
		// DTB949 - The previous Subject Area and Base Cube name (if they exist) are kept 
		// in case the compile fails and information needs to be recorded
		Set tOldCubeName = $G(^||%Cls(%compiledclass.Name,"cube"))
		Set tOldBaseCube = $G(^||%Cls(%compiledclass.Name,"baseCube"))

		Kill ^||%Cls(%compiledclass.Name)
		Set:(tOldCubeName'="") ^||%Cls(%compiledclass.Name,"oldCubeName") = tOldCubeName		// DTB949
		Set:(tOldBaseCube'="") ^||%Cls(%compiledclass.Name,"oldBaseCube") = tOldBaseCube		// DTB949
		If (%class.Abstract || (%class.Name = "%DeepSee.SubjectArea")) {
			Quit
		}

		// JMD1348 prevent incremental compile
#ifdef cCLASSdisableincremental
	$$$comClassKeySet(%class.Name,$$$cCLASSdisableincremental,1)
#endif
		Set tDisplay=$$$qualifierGetValue(%qstruct,"displaylog")		// DTB466 - Track whether or not to display messages

		#; find XDATA block named SubjectArea
		Set tIndex = %compiledclass.XDatas.FindObjectId(%class.Name_"||SubjectArea")

		If (tIndex '= "") {
			#; get XDATA as stream
			Set tStream = %compiledclass.XDatas.GetAt(tIndex).Data
			Do tStream.Rewind()

			If (tStream.Size > 0) {

				#; render the stream into cube meta-data object (with children)
				Set tReader = ##class(%XML.Reader).%New()

				Set tSC = tReader.OpenStream(tStream)
				If $$$ISERR(tSC) Quit

				Do tReader.Correlate("subjectArea","%DeepSee.Model.SubjectArea.subjectArea")

				#; there should only be one subject area defined
				Do tReader.Next(.tSubject,.tSC)
				If $$$ISERR(tSC) Quit
				If '$IsObject(tSubject) {
					Set tSC = $$$ERROR($$$GeneralError,"No <subjectArea> element defined in SubjectArea block.")
					Quit
				}

				#; is subject area disabled?
				If (tSubject.disabled) {
					Write !,$$$FormatText($$$Text("Subject Area '%1' is disabled","%DeepSee"),tSubject.name)
					Quit
				}

				#; is this cube name already used?
				Set tCubeName = tSubject.name
				Set tRegClass = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName)))
				If ((tRegClass'="") && (tRegClass '= %class.Name)) {
					Set tSC = $$$ERROR($$$GeneralError,"Cube or SubjectArea with given name already exists: " _ tCubeName)
					Quit
				}

				#; validate subject area
				Set tSC = tSubject.%Validate()
				If $$$ISERR(tSC) Quit

				Set tJoinList = ""
				Set tBaseCubeList = tSubject.baseCube
				
				// +DTB372 - Translate all base cubes to their currently active version
				For c=1:1:$L(tBaseCubeList,",") {
					Set tVersionBaseCube = $P(tBaseCubeList,",",c)
					Set tVersionedCubeName = ##class(%DeepSee.CubeVersion.Utils).%GetVersionedCubeName(tVersionBaseCube)
					// Report versions of cubes being used
					If ($L(tBaseCubeList,",")>1)&&##class(%DeepSee.CubeVersion.Utils).%IsVersion(tVersionedCubeName) {
						Set tSC=$$$ERROR($$$GeneralError,"Compound cubes do not support versioned base cubes:"_tVersionedCubeName)
						$$$ThrowStatus(tSC)
					}
					Else {
						// Inform the caller that a versioned cube is the base cube
						Write:tDisplay !,$$$FormatText($$$Text("Subject area is based on versioned cube %1","%DeepSee"),tVersionedCubeName)		// DTB466 - Write is conditional on compiler flag
						Set $P(tBaseCubeList,",",c) = tVersionedCubeName
					}
				}
				// -DTB372
				
				
				#; base cube can contain a list of cube names!
				#; the first is the primary base; the rest are joined into the primary
				For p=1:1:$L(tBaseCubeList,",") {
					Set tBaseCube = $P(tBaseCubeList,",",p)
					Set tBaseClass = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tBaseCube)))
					If (tBaseClass = "") {
						Set tSC = $$$ERROR($$$GeneralError,"Base cube does not exist: " _ tBaseCube)
						Quit
					}
					If (p=1) {
						Set tPrimaryBaseCube = tBaseCube
						Set tPrimaryBaseClass = tBaseClass
					}
					Else {
						Set tJoinList = tBaseCubeList
					}
				}
				If $$$ISERR(tSC) Quit

				#; get cube name of subject area
				Set ^||%Cls(%compiledclass.Name,"cubeName") = tCubeName
				Set ^||%Cls(%compiledclass.Name,"baseCube") = $G(tPrimaryBaseCube)
				Set ^||%Cls(%compiledclass.Name,"baseClass") = $G(tPrimaryBaseClass)
				Set ^||%Cls(%compiledclass.Name,"cubeCaption") = tSubject.caption
				Set ^||%Cls(%compiledclass.Name,"countCaption") = tSubject.countMeasureCaption
				Set ^||%Cls(%compiledclass.Name,"countName") = tSubject.countMeasureName
				Set:tJoinList'="" ^||%Cls(%compiledclass.Name,"joinList") = tJoinList

				// reset so rest of logic will work
				Set tSubject.baseCube = $G(tPrimaryBaseCube)

				Set tSC = ##class(%DeepSee.Generator).%ProcessSubjectArea(%class.Name,tSubject,.tCaptions,tJoinList)
				If $$$ISERR(tSC) Quit

				Merge ^||%Cls(%compiledclass.Name,"captions") = tCaptions

				#; does this subjectArea support drill through
				Set tHasListing = ''$D($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing"))
				Set ^||%Cls(%compiledclass.Name,"drillThrough") = tHasListing
			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"No SubjectArea definition in subject area class: " _ %class.Name)
				Quit
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	// DTB949 - If there was an error, communicate it to the projection for recording in the metadata
	Set:$$$ISERR(tSC) ^||%Cls(%compiledclass.Name,"error") = tSC

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCubeName">
<Description>
Return the logical name of the MDX cube defined by this subject area.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine(" Quit "_$$$quote($G(^||%Cls(%compiledclass.Name,"cubeName"))))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetFactCount">
<Description>
Return number of facts in the base cube's fact table.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	// dispatch to base class
	Set tBaseClass = $G(^||%Cls(%compiledclass.Name,"baseClass"))
	If (tBaseClass '= "") {
		Do %code.WriteLine(" Quit ##class("_tBaseClass_").%GetFactCount()")
	}
	Else {
		Do %code.WriteLine(" Quit """"")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnExecuteListing">
<Description><![CDATA[
Notification that a listing (drillthrough) query is about to be executed.<br/>
This is called immediately before a listing query is executed.
This is useful for cases where additional setup work is required before
a listing query can run.<br/>
<var>pSQL</var> is the listing query that will be executed.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pSQL:%String</FormalSpec>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// default: dispatch to base class
	Set tBaseClass = $G(^||%Cls(%compiledclass.Name,"baseClass"))
	If (tBaseClass '= "") {
		Do %code.WriteLine(" Quit ##class("_tBaseClass_").%OnExecuteListing(pSQL)")
	}
	Else {
		Do %code.WriteLine(" Quit $$$OK")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetFactClass">
<Description>
Return name of the fact class used by the base cube.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// dispatch to base class
	Set tBaseClass = $G(^||%Cls(%compiledclass.Name,"baseClass"))
	If (tBaseClass '= "") {
		Do %code.WriteLine(" Quit ##class("_tBaseClass_").%GetFactClass()")
	}
	Else {
		Do %code.WriteLine(" Quit """"")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetCubeCaption">
<Description>
Return the caption of the subject area defined by this class.
If not defined, the subject area name is returned.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tCaption = $G(^||%Cls(%compiledclass.Name,"cubeCaption"))
	If (tCaption = "") {
		Set tCaption = $G(^||%Cls(%compiledclass.Name,"cubeName"))
	}

	Set tLocalize = 0
	Set DOMAIN = $G(%parameter("DOMAIN"))
	If (%class.System > 0) {
		Set tLocalize = (DOMAIN '= "")
	}
	Else {
		Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
	}
	If (tLocalize) {
		Do %code.WriteLine(" Quit $$$Text("_$$$quote(tCaption)_","_$$$quote(DOMAIN)_")")
	}
	Else {
		Do %code.WriteLine(" Quit "_$$$quote(tCaption))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetMemberCaption">
<Description>
For a given dimenions, hierarchy, and level return its localized caption.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pDimName:%String,pHierName:%String="",pLevelName:%String="",pPropName:%String=""</FormalSpec>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Do %code.WriteLine(" Set tCaption = """"")
		If (%class.Abstract || (%class.Name = "%DeepSee.SubjectArea")) {
			Quit
		}

		Do %code.WriteLine(" Set pDimName = $$$UPPER(pDimName)")
		Do %code.WriteLine(" Set pHierName = $$$UPPER(pHierName)")
		Do %code.WriteLine(" Set pLevelName = $$$UPPER(pLevelName)")
		Do %code.WriteLine(" Set pPropName = $$$UPPER(pPropName)")

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Merge tCaptions = ^||%Cls(%compiledclass.Name,"captions")

		Set tDimTest = "If"
		Set tDimName = $O(tCaptions(""))
		While (tDimName '= "") {
			Do %code.WriteLine(" "_tDimTest_" (pDimName="_$$$quote($$$UPPER(tDimName))_") {")
			Set tDimTest = "ElseIf"

			Do %code.Write("  If ((pHierName="""")&&(pLevelName="""")) {")

			If ($LG($G(tCaptions(tDimName)),2)'="") {
				If (tLocalize) {
					Do %code.WriteLine(" Quit $$$Text("_$$$quote($LG($G(tCaptions(tDimName)),2))_","_$$$quote(DOMAIN)_") }")
				}
				Else {
					Do %code.WriteLine(" Quit "_$$$quote($LG($G(tCaptions(tDimName)),2))_" }")
				}
			}
			Else {
				If ($LG($G(tCaptions(tDimName)),1)'="") {
					Do %code.WriteLine(" Quit "_$$$quote($LG($G(tCaptions(tDimName)),1)))
				}
				Do %code.WriteLine(" }")
			}
			
			Set tHierName = $O(tCaptions(tDimName,""))
			While (tHierName '= "") {
				Do %code.WriteLine("  ElseIf (pHierName="_$$$quote($$$UPPER(tHierName))_") {")

				Do %code.Write("   If (pLevelName="""") {")

				If ($LG($G(tCaptions(tDimName,tHierName)),2)'="") {
					If (tLocalize) {
						Do %code.WriteLine(" Quit $$$Text("_$$$quote($LG($G(tCaptions(tDimName,tHierName)),2))_","_$$$quote(DOMAIN)_")"_" }")
					}
					Else {
						Do %code.WriteLine(" Quit "_$$$quote($LG($G(tCaptions(tDimName,tHierName)),2))_" }")
					}
				}
				Else {
					If ($LG($G(tCaptions(tDimName,tHierName)),1)'="") {
						Do %code.WriteLine(" Quit "_$$$quote($LG($G(tCaptions(tDimName,tHierName)),1)))
					}
					Do %code.WriteLine(" }")
				}

				Set tLevelName = $O(tCaptions(tDimName,tHierName,""))
				While (tLevelName '= "") {
					Set tPropName = $O(tCaptions(tDimName,tHierName,tLevelName,""))
					Set tHasProps = (tPropName '= "")

					Do %code.WriteLine("   ElseIf (pLevelName="_$$$quote($$$UPPER(tLevelName))_") {")
					Do:tHasProps %code.WriteLine("    If (pPropName="""") {")
					If ($LG($G(tCaptions(tDimName,tHierName,tLevelName)),2)'="") {
						If (tLocalize) {
							Do %code.WriteLine("     Quit $$$Text("_$$$quote($LG($G(tCaptions(tDimName,tHierName,tLevelName)),2))_","_$$$quote(DOMAIN)_")")
						}
						Else {
							Do %code.WriteLine("     Quit "_$$$quote($LG($G(tCaptions(tDimName,tHierName,tLevelName)),2)))
						}
					}
					Else {
						If ($LG($G(tCaptions(tDimName,tHierName,tLevelName)),1)'="") {
							Do %code.WriteLine("     Quit "_$$$quote($LG($G(tCaptions(tDimName,tHierName,tLevelName)),1)))
						}
						Do %code.WriteLine(" }")
					}
					Do %code.WriteLine("    }")

					While (tPropName '= "") {
						Do %code.WriteLine("    ElseIf (pPropName="_$$$quote($$$UPPER(tPropName))_") {")
						If ($LG($G(tCaptions(tDimName,tHierName,tLevelName,tPropName)),2)'="") {
							If (tLocalize) {
								Do %code.WriteLine("     Quit $$$Text("_$$$quote($LG($G(tCaptions(tDimName,tHierName,tLevelName,tPropName)),2))_","_$$$quote(DOMAIN)_")")
							}
							Else {
								Do %code.WriteLine("     Quit "_$$$quote($LG($G(tCaptions(tDimName,tHierName,tLevelName,tPropName)),2)))
							}
						}
						Else {
							If ($LG($G(tCaptions(tDimName,tHierName,tLevelName,tPropName)),2)'="") {
								Do %code.WriteLine("     Quit "_$$$quote($LG($G(tCaptions(tDimName,tHierName,tLevelName,tPropName)),1)))
							}
							Do %code.WriteLine(" }")
						}
						Do %code.WriteLine("    }")
						Set tPropName = $O(tCaptions(tDimName,tHierName,tLevelName,tPropName))
					}
					Do:tHasProps %code.WriteLine("   }")

					Set tLevelName = $O(tCaptions(tDimName,tHierName,tLevelName))
				}
				Do %code.WriteLine("  }")
				Set tHierName = $O(tCaptions(tDimName,tHierName))
			}
			Do %code.WriteLine(" }")
			Set tDimName = $O(tCaptions(tDimName))
		}

		// dispatch to base class
		Set tBaseClass = ^||%Cls(%compiledclass.Name,"baseClass")
		If (tBaseClass '= "") {
			Do %code.WriteLine(" Set tCaption = ##class("_tBaseClass_").%GetMemberCaption(pDimName,pHierName,pLevelName,pPropName)")
		}

		// for compound cube, try the other base classes as well
		Set tJoinList = $G(^||%Cls(%compiledclass.Name,"joinList"))
		For p=2:1:$L(tJoinList,",") {
			Set tBaseCube = $P(tJoinList,",",p)
			Set tBaseClass = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tBaseCube)))
			If (tBaseClass '= "") {
				Do %code.WriteLine(" Set:tCaption="""" tCaption = ##class("_tBaseClass_").%GetMemberCaption(pDimName,pHierName,pLevelName,pPropName)")
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Do %code.WriteLine(" Quit tCaption")
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetMemberDescription">
<Description>
For a given dimenions, hierarchy, and level return its localized caption.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pDimName:%String,pHierName:%String="",pLevelName:%String="",pPropName:%String=""</FormalSpec>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// JSL4475 add this method
	Set tSC = $$$OK
	Try {
		Do %code.WriteLine(" Set tDescription = """"")
		If (%class.Abstract || (%class.Name = "%DeepSee.SubjectArea")) {
			Quit
		}

		Do %code.WriteLine(" Set pDimName = $$$UPPER(pDimName)")
		Do %code.WriteLine(" Set pHierName = $$$UPPER(pHierName)")
		Do %code.WriteLine(" Set pLevelName = $$$UPPER(pLevelName)")
		Do %code.WriteLine(" Set pPropName = $$$UPPER(pPropName)")

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Merge tDescriptions = ^||%Cls(%compiledclass.Name,"descriptions")

		Set tDimTest = "If"
		Set tDimName = $O(tDescriptions(""))
		While (tDimName '= "") {
			Do %code.WriteLine(" "_tDimTest_" (pDimName="_$$$quote($$$UPPER(tDimName))_") {")
			Set tDimTest = "ElseIf"

			Do %code.Write("  If ((pHierName="""")&&(pLevelName="""")) {")

			If ($LG($G(tDescriptions(tDimName)),1)'="") {
				If (tLocalize) {
					Do %code.WriteLine(" Quit $$$Text("_$$$quote($LG($G(tDescriptions(tDimName)),1))_","_$$$quote(DOMAIN)_") }")
				}
				Else {
					Do %code.WriteLine(" Quit "_$$$quote($LG($G(tDescriptions(tDimName)),1))_" }")
				}
			}
			Else {
				If ($LG($G(tDescriptions(tDimName)),1)'="") {
					Do %code.WriteLine(" Quit "_$$$quote($LG($G(tDescriptions(tDimName)),1)))
				}
				Do %code.WriteLine(" }")
			}
			
			Set tHierName = $O(tDescriptions(tDimName,""))
			While (tHierName '= "") {
				Do %code.WriteLine("  ElseIf (pHierName="_$$$quote($$$UPPER(tHierName))_") {")

				Do %code.Write("   If (pLevelName="""") {")

				If ($LG($G(tDescriptions(tDimName,tHierName)),1)'="") {
					If (tLocalize) {
						Do %code.WriteLine(" Quit $$$Text("_$$$quote($LG($G(tDescriptions(tDimName,tHierName)),1))_","_$$$quote(DOMAIN)_")"_" }")
					}
					Else {
						Do %code.WriteLine(" Quit "_$$$quote($LG($G(tDescriptions(tDimName,tHierName)),1))_" }")
					}
				}
				Else {
					If ($LG($G(tDescriptions(tDimName,tHierName)),1)'="") {
						Do %code.WriteLine(" Quit "_$$$quote($LG($G(tDescriptions(tDimName,tHierName)),1)))
					}
					Do %code.WriteLine(" }")
				}

				Set tLevelName = $O(tDescriptions(tDimName,tHierName,""))
				While (tLevelName '= "") {
					Set tPropName = $O(tDescriptions(tDimName,tHierName,tLevelName,""))
					Set tHasProps = (tPropName '= "")

					Do %code.WriteLine("   ElseIf (pLevelName="_$$$quote($$$UPPER(tLevelName))_") {")
					Do:tHasProps %code.WriteLine("    If (pPropName="""") {")
					If ($LG($G(tDescriptions(tDimName,tHierName,tLevelName)),1)'="") {
						If (tLocalize) {
							Do %code.WriteLine("     Quit $$$Text("_$$$quote($LG($G(tDescriptions(tDimName,tHierName,tLevelName)),1))_","_$$$quote(DOMAIN)_")")
						}
						Else {
							Do %code.WriteLine("     Quit "_$$$quote($LG($G(tDescriptions(tDimName,tHierName,tLevelName)),1)))
						}
					}
					Else {
						If ($LG($G(tDescriptions(tDimName,tHierName,tLevelName)),1)'="") {
							Do %code.WriteLine("     Quit "_$$$quote($LG($G(tDescriptions(tDimName,tHierName,tLevelName)),1)))
						}
						Do %code.WriteLine(" }")
					}
					Do %code.WriteLine("    }")

					While (tPropName '= "") {
						Do %code.WriteLine("    ElseIf (pPropName="_$$$quote($$$UPPER(tPropName))_") {")
						If ($LG($G(tDescriptions(tDimName,tHierName,tLevelName,tPropName)),1)'="") {
							If (tLocalize) {
								Do %code.WriteLine("     Quit $$$Text("_$$$quote($LG($G(tDescriptions(tDimName,tHierName,tLevelName,tPropName)),1))_","_$$$quote(DOMAIN)_")")
							}
							Else {
								Do %code.WriteLine("     Quit "_$$$quote($LG($G(tDescriptions(tDimName,tHierName,tLevelName,tPropName)),1)))
							}
						}
						Else {
							If ($LG($G(tDescriptions(tDimName,tHierName,tLevelName,tPropName)),1)'="") {
								Do %code.WriteLine("     Quit "_$$$quote($LG($G(tDescriptions(tDimName,tHierName,tLevelName,tPropName)),1)))
							}
							Do %code.WriteLine(" }")
						}
						Do %code.WriteLine("    }")
						Set tPropName = $O(tDescriptions(tDimName,tHierName,tLevelName,tPropName))
					}
					Do:tHasProps %code.WriteLine("   }")

					Set tLevelName = $O(tDescriptions(tDimName,tHierName,tLevelName))
				}
				Do %code.WriteLine("  }")
				Set tHierName = $O(tDescriptions(tDimName,tHierName))
			}
			Do %code.WriteLine(" }")
			Set tDimName = $O(tDescriptions(tDimName))
		}

		// dispatch to base class
		Set tBaseClass = ^||%Cls(%compiledclass.Name,"baseClass")
		If (tBaseClass '= "") {
			Do %code.WriteLine(" Set tDescription = ##class("_tBaseClass_").%GetMemberDescription(pDimName,pHierName,pLevelName,pPropName)")
		}

		// for compound cube, try the other base classes as well
		Set tJoinList = $G(^||%Cls(%compiledclass.Name,"joinList"))
		For p=2:1:$L(tJoinList,",") {
			Set tBaseCube = $P(tJoinList,",",p)
			Set tBaseClass = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tBaseCube)))
			If (tBaseClass '= "") {
				Do %code.WriteLine(" Set:tDescription="""" tDescription = ##class("_tBaseClass_").%GetMemberDescription(pDimName,pHierName,pLevelName,pPropName)")
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Do %code.WriteLine(" Quit tDescription")
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetFilterSpec">
<Description>
Return the filter spec for this subject area.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tCube = $$$UPPER(..%GetCubeName())
	Set tFilter = $G($$$DeepSeeMetaGLVN("cubes",tCube,"filterSpec"))
	Set tFilter = ..%OnGetFilterSpec(tFilter)
	Quit tFilter
]]></Implementation>
</Method>

<Method name="%OnGetFilterSpec">
<Description>
This callback gives a SubjectArea a chance to programmatically define its filter spec.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFilterSpec:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit pFilterSpec
]]></Implementation>
</Method>

<Method name="%GetDefaultListing">
<Description>
Return the name of the default listing for this SubjectArea, if any.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// JMD1061
	// first try callback
	Do %code.WriteLine(" Set tListing = ..%OnGetDefaultListing()")

	// now dispatch to base cube
	Set tBaseClass = $G(^||%Cls(%compiledclass.Name,"baseClass"))
	If (tBaseClass '= "") {
		Do %code.WriteLine(" Set:tListing="""" tListing = ##class("_tBaseClass_").%GetDefaultListing()")
	}
	Do %code.WriteLine(" Quit tListing")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnGetDefaultListing">
<Description>
This callback gives a SubjectArea a chance to programmatically return the name 
of the listing to use as its default listing.
This must be the name of a defined listing within the SubjectArea.
Return "" to use the pre-defined default listing.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<Method name="%CanDrillThrough">
<Description>
Test if this cube supports drill through (listing) queries.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// see if any listings are available to the current user
	Set tSC = ##class(%DeepSee.Utils).%GetCubeListings(..%GetCubeName(),.tListings)
	Quit $S($D(tListings):1,1:0)
]]></Implementation>
</Method>

<Method name="%IsAbstract">
<Description>
Test whether this subject area is abstract or not.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If (%class.Abstract) {
		Do %code.WriteLine(" Quit 1")
	}
	Else {
		Do %code.WriteLine(" Quit 0")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%IsCompound">
<Description>
Test whether this subject area is compound or not.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pJoinList:%String</FormalSpec>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tCompound =	($G(^||%Cls(%compiledclass.Name,"joinList"))'="")
	If (tCompound) {
		Do %code.WriteLine(" Set pJoinList = "_$$$quote(^||%Cls(%compiledclass.Name,"joinList")))
		Do %code.WriteLine(" Quit 1")
	}
	Else {
		Do %code.WriteLine(" Set pJoinList = """"")
		Do %code.WriteLine(" Quit 0")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetCountCaption">
<Description>
Return the (localized) caption for the %COUNT measure used by this cube.
Returns "" if this has not been overridden by the cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (%class.Abstract || (%class.Name = "%DeepSee.SubjectArea")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tName = ^||%Cls(%compiledclass.Name,"countCaption")
		If (tName="") {
			Set tBaseClass = ^||%Cls(%compiledclass.Name,"baseClass")
			Do %code.WriteLine(" Quit ##class("_tBaseClass_").%GetCountCaption()")
			Quit
		}
		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		If (tLocalize) {
			Do %code.WriteLine(" Quit $$$Text("_$$$quote(tName)_","_$$$quote(DOMAIN)_")")
		}
		Else {
			Do %code.WriteLine(" Quit "_$$$quote(tName))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCountName">
<Description>
Return the logical name for the %COUNT measure used by this cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (%class.Abstract || (%class.Name = "%DeepSee.SubjectArea")) {
			Do %code.WriteLine(" Quit ""%COUNT""")
			Quit
		}

		Set tName = ^||%Cls(%compiledclass.Name,"countName")
		If (tName="") {
			Set tBaseClass = ^||%Cls(%compiledclass.Name,"baseClass")
			Do %code.WriteLine(" Quit ##class("_tBaseClass_").%GetCountName()")
			Quit
		}
		Do %code.WriteLine(" Quit "_$$$quote(tName))
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetActionList">
<Description>
Return list of possible actions for this Subject Area.
This simply dispatches to the base cube's method.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&pActions:%List]]></FormalSpec>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// dispatch to base class
	Set tBaseClass = $G(^||%Cls(%compiledclass.Name,"baseClass"))
	If (tBaseClass '= "") {
		Do %code.WriteLine(" Quit ##class("_tBaseClass_").%GetActionList(.pActions)")
	}
	Else {
		Do %code.WriteLine(" Quit $$$OK")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetListingCaption">
<Description>
Return the (localized) caption for a given listing within this cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pListing:%String</FormalSpec>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))

		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition") || (tCubeName="")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Do %code.WriteLine(" Set pListing = $$$UPPER(pListing)")

		Set n = 0
		Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",""))
		While (k'="") {
			Set n = n + 1
			Set tName = $$$UPPER(k)
			Set tCaption = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",k,"displayName"))
			Set:tCaption="" tCaption = k
			Set tIf = $S(n>1:"ElseIf",1:"If")
			Do %code.WriteLine(" "_tIf_" ("_$$$quote(tName)_"=pListing) {")
			If (tLocalize) {
				Do %code.WriteLine("  Quit $$$Text("_$$$quote(tCaption)_","_$$$quote(DOMAIN)_")")
			}
			Else {
				Do %code.WriteLine("  Quit "_$$$quote(tCaption))
			}
			Do %code.WriteLine(" }")
			Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",k))
		}
		Do %code.WriteLine(" Quit """"")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetListingDescription">
<Description>
Return the (localized) description for a given listing within this cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pListing:%String</FormalSpec>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// Method added by JSL4477
	Set tSC = $$$OK
	Try {
		Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))

		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition") || (tCubeName="")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Do %code.WriteLine(" Set pListing = $$$UPPER(pListing)")

		Set n = 0
		Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",""))
		While (k'="") {
			Set n = n + 1
			Set tName = $$$UPPER(k)
			Set tDescription = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",k,"displayName"))
			;Set:tDescription="" tDescription = k
			Set tIf = $S(n>1:"ElseIf",1:"If")
			Do %code.WriteLine(" "_tIf_" ("_$$$quote(tName)_"=pListing) {")
			If (tLocalize) {
				Do %code.WriteLine("  Quit $$$Text("_$$$quote(tDescription)_","_$$$quote(DOMAIN)_")")
			}
			Else {
				Do %code.WriteLine("  Quit "_$$$quote(tDescription))
			}
			Do %code.WriteLine(" }")
			Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listing",k))
		}
		Do %code.WriteLine(" Quit """"")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetListingFieldCaption">
<Description>
Return the (localized) caption for a given listing field within this cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pField:%String</FormalSpec>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))

		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition") || (tCubeName="")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Do %code.WriteLine(" Set pField = $$$UPPER(pField)")

		Set n = 0
		Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",""))
		While (k'="") {
			Set n = n + 1
			Set tName = $$$UPPER(k)
			Set tCaption = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",k,"displayName"))
			Set:tCaption="" tCaption = k
			Set tIf = $S(n>1:"ElseIf",1:"If")
			Do %code.WriteLine(" "_tIf_" ("_$$$quote(tName)_"=pField) {")
			If (tLocalize) {
				Do %code.WriteLine("  Quit $$$Text("_$$$quote(tCaption)_","_$$$quote(DOMAIN)_")")
			}
			Else {
				Do %code.WriteLine("  Quit "_$$$quote(tCaption))
			}
			Do %code.WriteLine(" }")
			Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",k))
		}
		Do %code.WriteLine(" Quit """"")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetListingFieldDescription">
<Description>
Return the (localized) description for a given listing field within this cube.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pField:%String</FormalSpec>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// JSL4477 - added method
	Set tSC = $$$OK
	Try {
		Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))

		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition") || (tCubeName="")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Do %code.WriteLine(" Set pField = $$$UPPER(pField)")

		Set n = 0
		Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",""))
		While (k'="") {
			Set n = n + 1
			Set tName = $$$UPPER(k)
			Set tDescription = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",k,"description"))
			Set:tDescription="" tDescription = k
			Set tIf = $S(n>1:"ElseIf",1:"If")
			Do %code.WriteLine(" "_tIf_" ("_$$$quote(tName)_"=pField) {")
			If (tLocalize) {
				Do %code.WriteLine("  Quit $$$Text("_$$$quote(tDescription)_","_$$$quote(DOMAIN)_")")
			}
			Else {
				Do %code.WriteLine("  Quit "_$$$quote(tDescription))
			}
			Do %code.WriteLine(" }")
			Set k = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"listingFields",k))
		}
		Do %code.WriteLine(" Quit """"")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetLevelMemberCaption">
<Description>
For a pre-defined member within a given level in this cube, return its (localized) caption (display name).</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pDimNo:%Integer,pHierNo:%Integer,pLevelNo:%Integer,pName:%String</FormalSpec>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// JMD1010
		Set tCubeName = $G(^||%Cls(%compiledclass.Name,"cubeName"))

		If (%class.Abstract || (%class.Name = "%DeepSee.CubeDefinition") || (tCubeName="")) {
			Do %code.WriteLine(" Quit """"")
			Quit
		}

		Set tLocalize = 0
		Set DOMAIN = $G(%parameter("DOMAIN"))
		If (%class.System > 0) {
			Set tLocalize = (DOMAIN '= "")
		}
		Else {
			Set tLocalize = (DOMAIN '= "") && (DOMAIN '= "%DeepSee")
		}

		Do %code.WriteLine(" Set pName = $$$UPPER(pName)")

		Set tCaseCount = 0
		Set dno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",""))
		While (dno'="") {
			Set hno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,""))
			While (hno'="") {
				Set lno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,""))
				While (lno'="") {
					If $D($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno,"mbr")) {
						Set tCaseCount = tCaseCount + 1
						Do %code.WriteLine(" "_$S(tCaseCount>1:"Else",1:"")_"If ((pDimNo="_dno_")&&(pHierNo="_hno_")&&(pLevelNo="_lno_")) {")

						Set mc = 0
						Set m = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno,"mbr",""))
						While (m'="") {
							Set mc = mc + 1
							Set tName = $LG($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno,"mbr",m)),1)
							Set tCaption = $LG($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno,"mbr",m)),3)
							Do %code.Write("  "_$S(mc>1:"Else",1:"")_"If (pName="_$$$quote($$$UPPER(tName))_") {")
							If (tLocalize && (tCaption'="")) {
								Do %code.Write(" Quit $$$Text("_$$$quote(tCaption)_","_$$$quote(DOMAIN)_")")
							}
							Else {
								Set:tCaption="" tCaption = tName
								Do %code.Write(" Quit "_$$$quote(tCaption))
							}
							Do %code.WriteLine("  }")
							Set m = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno,"mbr",m))
						}

						Do %code.WriteLine(" }")
					}
					Set lno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno,lno))
				}
				Set hno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno,hno))
			}
			Set dno = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tCubeName),"mbr#",dno))
		}
		Do %code.WriteLine(" Quit """"")
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OnGetComputedMembers">
<Description><![CDATA[
This callback gives a Cube a chance to programmatically provide a set of
members for a computed dimension.<br/>
This simply dispatches to the base cube's method.]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[pDimName:%String,pHierName:%String,pLevelName:%String,&pMemberList,pRollupKey:%String="",&pRange:%String=""]]></FormalSpec>
<GenerateAfter>%Generate</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// dispatch to base class
	Set tBaseClass = $G(^||%Cls(%compiledclass.Name,"baseClass"))
	If (tBaseClass '= "") {
		Do %code.WriteLine(" Quit ##class("_tBaseClass_").%OnGetComputedMembers(pDimName,pHierName,pLevelName,.pMemberList,pRollupKey,.pRange)")
	}
	Else {
		Do %code.WriteLine(" Quit $$$OK")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^DeepSee.SubjectArea("data")</DataLocation>
<DefaultData>SubjectAreaDefaultData</DefaultData>
<IdLocation>^DeepSee.SubjectArea("data")</IdLocation>
<IndexLocation>^DeepSee.SubjectArea("index")</IndexLocation>
<StreamLocation>^DeepSee.SubjectArea("stream")</StreamLocation>
<Data name="SubjectAreaDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>name</Value>
</Value>
<Value name="3">
<Value>baseCube</Value>
</Value>
<Value name="4">
<Value>caption</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.SubjectAreaProjection">
<Description><![CDATA[
Projection class used by the <class>%DeepSee.SubjectArea</class> class.
This class takes care of any work that needs to happen when
a subject area is created (compiled) or deleted.
This class should be consider INTERNAL.]]></Description>
<IncludeCode>%DeepSee</IncludeCode>
<Super>%Projection.AbstractProjection</Super>
<System>3</System>
<TimeCreated>60165,76060.833051</TimeCreated>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClassName:%String,&parameters:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	Set tSC=$$$OK
	Try {
		If ($$$comClassDefined(pClassName)) {
			Set tAbstract = +$$$comClassKeyGet(pClassName,$$$cCLASSabstract)
			If ('tAbstract && (pClassName'="%DeepSee.SubjectArea")) {
				Set tCubeName = $zobjclassmethod(pClassName,"%GetCubeName")
				If (tCubeName="")&&$D(^||%Cls(pClassName,"oldCubeName"),tOldCubeName) {
					// DTB949 - Try to preserve the old cube name if the %GetCubeName method didn't compile
					// or could not return a value for any reason
 					Set tCubeName = tOldCubeName
				}
				Set tCubeNameU = $$$UPPER(tCubeName)

				#; Add this cube to the (local) index of Cubes
				If (tCubeNameU '= "") {
					If $D(^||%Cls(pClassName,"error"),tCompileError) {
						// DTB949 - Log a compile error in the metadata
						Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"compileError") = tCompileError
						If ($G(^||%Cls(pClassName,"oldBaseCube"))'="") {
							Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU,"baseCube") = $G(^||%Cls(pClassName,"oldBaseCube"))
						}
					}
					
					Set $$$DeepSeeMetaGLVN("cubes",tCubeNameU) = pClassName
					Set $$$DeepSeeMetaGLVN("classes",pClassName) = tCubeName
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClassName:%String,&parameters:%String,recompile:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	Set tSC=$$$OK
	Try {
		If ($$$comClassDefined(pClassName)) {
			Set tAbstract = +$$$comClassKeyGet(pClassName,$$$cCLASSabstract)
			If ('tAbstract && (pClassName'="%DeepSee.SubjectArea")) {
				#; Remove this subject area from the list of Cubes
				Set tCubeName = $G($$$DeepSeeMetaGLVN("classes",pClassName))
				Set tCubeNameU = $$$UPPER(tCubeName)

				#; make sure we are the right subject area
				If ((tCubeNameU'="")&&(pClassName = $G($$$DeepSeeMetaGLVN("cubes",tCubeNameU)))) {
					If recompile {
						Set ^||%Cls(pClassName,"cube") = tCubeName		// DTB949
						Set ^||%Cls(pClassName,"baseCube") = $G($$$DeepSeeMetaGLVN("cubes",tCubeNameU,"baseCube"))
					}
					Kill $$$DeepSeeMetaGLVN("classes",pClassName)
					Kill:tCubeName'="" $$$DeepSeeMetaGLVN("cubes",tCubeNameU)
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.UI.Architect">
<Description>
DeepSee Architect page.</Description>
<Super>%DeepSee.UI.standardPage,%CSP.Portal.SourceControl.Base</Super>
<System>4</System>
<TimeCreated>61333,44070.180139</TimeCreated>

<Parameter name="PAGENAME">
<Description>
Displayed name of this page.</Description>
<Default>Architect</Default>
</Parameter>

<Parameter name="DEFAULTVIEWMODE">
<Description>
If this page has multiple views, this is its initial display mode.</Description>
<Default>cube</Default>
</Parameter>

<Parameter name="DOCBOOKID">
<Default>D2MODEL_intro_architect</Default>
</Parameter>

<Property name="cubeFullName">
<Description>
Name of Cube (with extension).</Description>
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENURL" value="CUBE"/>
</Property>

<Property name="cubeName">
<Description>
Name of Cube being viewed.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="compileErrorOnLoad">
<Description>
This will be true if the cube being loaded logged an error on the last compile.</Description>
<Type>%ZEN.Datatype.boolean</Type>
</Property>

<Property name="inheritsFrom">
<Description>
Name of the inherited cube, if it exists.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="cubeClass">
<Description>
Class name of Cube being viewed.
This is determined from the cube name.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="cubeDescription">
<Description>
Description of Cube being viewed.
This is determined from the cube name.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="cubeDomain">
<Description>
Domain of Cube being viewed.
This is handled seperately from json.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="cubeDependsOn">
<Description>
DependsOn for cube class. If provided, this is used as the DependsOn value
of the generated cube. If not, the sourceClass for the cube is used.
This is handled seperately from json.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="dataSource">
<Description>
Data source. This is a copy of the value in the cube model.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="currItem">
<Description>
ID (index number, 0-based) of current selected item.</Description>
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>-1</InitialExpression>
</Property>

<Property name="currItemType">
<Description>
Type of the current selected item.</Description>
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="%model">
<Description>
Local copy of cube model object.</Description>
<Type>%DeepSee.Model.cube</Type>
</Property>

<Property name="readOnly">
<Description>
If true, user cannot modify the current cube definition.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="canWrite">
<Description>
If true, user can modify (non-read-only) cube definitions,
otherwise they can only view.</Description>
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="lblExpression">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$TextHTML("(expression)")</InitialExpression>
</Property>

<Property name="lblDataLevel">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$TextHTML("Level (type=data)")</InitialExpression>
</Property>

<Property name="lblTimeLevel">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$TextHTML("Level (type=time)")</InitialExpression>
</Property>

<Property name="lblAgeLevel">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$TextHTML("Level (type=age)")</InitialExpression>
</Property>

<Property name="hlpRemove">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$Text("Remove this item")</InitialExpression>
</Property>

<Property name="hlpMoveUp">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$Text("Move this item up")</InitialExpression>
</Property>

<Property name="hlpMoveDown">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$Text("Move this item down")</InitialExpression>
</Property>

<Property name="hlpShowHide">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$Text("Hide or show the properties box")</InitialExpression>
</Property>

<Property name="msgCubeInherited">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$Text("This cube inherits items from the %1 cube")</InitialExpression>
</Property>

<Property name="msgItemInherited">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$Text("This item has been inherited from the %1 cube")</InitialExpression>
</Property>

<Property name="msgItemOverride">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$Text("This is an override of an inherited cube item")</InitialExpression>
</Property>

<Property name="msgInvalid">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$TextHTML("Please click [Open] to select a model definition.")</InitialExpression>
</Property>

<Property name="msgOpenModel">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$Text("Please open a model definition first.")</InitialExpression>
</Property>

<Property name="hlpDropTooltip">
<Type>%ZEN.Datatype.caption</Type>
<InitialExpression>$$$Text("Create new %1")</InitialExpression>
</Property>

<Property name="settingsExpanded">
<Description>
If true, the settings area (property sheet) is visible.</Description>
<Type>%Boolean</Type>
<Internal>1</Internal>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="expandAll">
<Description>
Whether to expand all elements under each type. When user clicks Collapse All then this is set to 0. At end of renderTable it is set to 2.</Description>
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="DocumaticPage">
<Type>%String</Type>
</Property>

<Property name="timeFunctions">
<Type>%ZEN.Datatype.string</Type>
</Property>

<XData name="CSS3Style">
<Description>
This Style block contains page-specific CSS style definitions.</Description>
<Data><![CDATA[
<style type="text/css">

.zenLabel {
	color: rgb(67,67,67);
	font-size: 10pt;
}
.zenLabelDisabled {
	font-size: 10pt;
}

.zenHint {
	color: rgb(67,67,67);
	font-size: 8pt;
}

.dynaTreeNode {
	white-space: nowrap;
	font-size: 10pt;
}

.dynaTreeItem {
	color: rgb(71,72,67);
}

.detailLabel {
	font-weight: bold;
	color: rgb(71,72,67);
	font-size: 10pt;
}

#editorPane {
	position: relative;
}

#modelTableHeader {
	height: 40px;
	top: 0px;
	background: #F0F0F0;
	overflow: hidden;
}

#modelTableBody {
	top: 40px;
	height: 200px;
	border: 1px solid gray;
	overflow: auto;
	background: white;
}

#dataSource {
	background: white;
	width: 200px;
	overflow: auto;
	border-top: 1px solid gray;
	border-bottom: 1px solid gray;
}

#propertyPane {
	position: relative;
	background: rgb(156,154,141);
	height: 449px;
	width: 350px;
	border-right: 1px solid black;
	border-bottom: 1px solid black;
	display: none;
}

/* styles for tabs */
#tabDetails,#tabTools {
	overflow: auto;
	padding-left: 3px;
	color: #404040;
}

td.tabGroupButtonOff:hover {
	color: #FFEEAA;
}

.tabGroupBody {
	background: #E0E0D0;
	width: 399px;
	min-height: 300px;
}

td.tabGroupButtonOn {
	height: 30px;
	color: #404040;
	background: #E0E0D0;
	font-size: 10pt;
background: -moz-linear-gradient(top, #F8F8FF, #E0E0D0);
background: -webkit-gradient(linear, left top, left bottom, color-stop(0.0,#F8F8FF), color-stop(1.0,#E0E0D0));
	background: linear-gradient(top, #F8F8FF, #E0E0D0);
	border-top-left-radius: 4px;
	border-top-right-radius: 4px;
}

/* @doc="Individual tab bar button in Off state." */
td.tabGroupButtonOff,
td.tabGroupButtonDisabled {
	height: 30px;
	color: #404040;
	background: #C0C0C0;
	font-size: 10pt;
	background-image: none;
	background-repeat: repeat-x;
}
td.tabGroupButtonOff:hover {
	background: #C0C0C0;
}

td.tabGroupButtonDisabled {
	color: gray;
}

td.tabGroupButtonOff {
background: -moz-linear-gradient(top, #B0B0B0, #D0D0D0);
background: -webkit-gradient(linear, left top, left bottom, color-stop(0.0,#B0B0B0), color-stop(1.0,#D0D0D0));
	background: linear-gradient(top, #B0B0B0, #D0D0D0);
	border-top-left-radius: 4px;
	border-top-right-radius: 4px;
}

td.tabGroupButtonDisabled {
background: -moz-linear-gradient(top, #B0B0B0, #D0D0D0);
background: -webkit-gradient(linear, left top, left bottom, color-stop(0.0,#B0B0B0), color-stop(1.0,#D0D0D0));
	background: linear-gradient(top, #B0B0B0, #D0D0D0);
	border-top-left-radius: 4px;
	border-top-right-radius: 4px;
}

.tabGroupGap {
	width: 0px;
}

#propertyTitle {
	height: 40px;
	width: 40px;
}

#spanArrow {
	padding-left: 10px;
	color: white;
	font-size: 20pt;
	text-shadow: black 1px 1px 1px;
}

#propertyCommands {
	color: white;
}

table.modelTable {
	background: white;
	width: 100%;
	font-size: 10pt;
}

table.modelTable td {
	padding: 2px;
	border-bottom: 1px solid rgb(241,240,231);
}

.modelError {
	color: #404040;
	font-size: 24px;
	padding: 10px;
	background: lightgray;
}

span.selector {
	visibility: hidden;
}

.modelRowCubeSelected span.selector,
.modelRowDimensionSelected span.selector,
.modelRowHierarchySelected span.selector,
.modelRowLevelSelected span.selector,
.modelRowMeasureSelected span.selector {
	visibility: visible;
}

.modelRowCube {
	color: rgb(67,67,67);
	font-size: 1.2em;
	font-weight: bold;
	background: #D0D0FF;
}
.modelRowCubeSelected {
	font-size: 1.2em;
	font-weight: bold;
	color: white;
	background: rgb(53,107,141);
}

.modelRowDimension {
	color: rgb(67,67,67);
	font-weight: bold;
	background: #F0F0FF;
}
.modelRowDimensionSelected {
	font-weight: bold;
	color: white;
	background: rgb(53,107,141);
}

.modelRowHierarchy {
	font-weight: bold;
	color: rgb(67,67,67);
}
.modelRowHierarchySelected {
	font-weight: bold;
	color: white;
	background: rgb(53,107,141);
}

.modelRowLevel {
	color: rgb(67,67,67);
}

.modelRowLevelSelected {
	color: white;
	background: rgb(53,107,141);
}

.modelRowMeasure {
	color: rgb(67,67,67);
}
.modelRowMeasureSelected {
	color: white;
	background: rgb(53,107,141);
}

.modelRowProperty {
	color: rgb(67,67,67);
}
.modelRowPropertySelected {
	color: white;
	background: rgb(53,107,141);
}
.coverPaneActive {
	position:absolute;
	left:0px;
	right:0px;
	top:0px;
	bottom:0px;
	opacity:.2;
	background:grey;
	display:block;
}
.coverPaneInactive {
	position:absolute;
	left:0px;
	right:0px;
	top:0px;
	display:block;
}

.hdrLink {
	font-size: 10pt;
	font-weight: normal;
	color: #3b84bc;
	text-decoration: none;
	padding-left: 6px;
	padding-right: 6px;
}

.hdrLinkDisabled {
	font-size: 10pt;
	font-weight: normal;
	color: gray;
	text-decoration: none;
	padding-left: 6px;
	padding-right: 6px;
}

.hdrLink:hover {
	color: #98923a;
}

</style>
]]></Data>
</XData>

<XData name="Style">
<Description>
This Style block contains page-specific CSS style definitions.</Description>
<Data><![CDATA[
<style type="text/css">

.zenLabel {
	color: rgb(67,67,67);
	font-size: 10pt;
}
.zenLabelDisabled {
	font-size: 10pt;
}

.zenHint {
	color: rgb(67,67,67);
	font-size: 8pt;
}

.dynaTreeNode {
	white-space: nowrap;
	font-size: 10pt;
}

.dynaTreeItem {
	color: rgb(71,72,67);
}

.detailLabel {
	font-weight: bold;
	color: rgb(71,72,67);
	font-size: 10pt;
}

#editorPane {
	position: relative;
}

#modelTableHeader {
	height: 40px;
	top: 0px;
	background: #F0F0F0;
	overflow: hidden;
}

#modelTableBody {
	top: 40px;
	height: 200px;
	border: 1px solid gray;
	overflow: auto;
	background: white;
}

#dataSource {
	background: white;
	width: 200px;
	overflow: auto;
	border-top: 1px solid gray;
	border-bottom: 1px solid gray;
}

#propertyPane {
	position: relative;
	background: rgb(156,154,141);
	height: 449px;
	width: 350px;
	border-right: 1px solid black;
	border-bottom: 1px solid black;
	display: none;
}

/* styles for tabs */
#tabDetails,#tabTools {
	overflow: auto;
	padding-left: 3px;
	color: #404040;
}

td.tabGroupButtonOff:hover {
	color: #FFEEAA;
}

.tabGroupBody {
	background: #E0E0D0;
	width: 399px;
	min-height: 300px;
}

td.tabGroupButtonOn {
	height: 30px;
	color: #404040;
	background: #E0E0D0;
	font-size: 10pt;
}

td.tabGroupButtonOn:not([ie]) {
	background: -moz-linear-gradient(top, #F8F8FF, #E0E0D0);
	-moz-border-radius-topleft:4px;
	-moz-border-radius-topright:4px;

	background: -webkit-gradient(linear, left top, left bottom, color-stop(0.0,#F8F8FF), color-stop(1.0,#E0E0D0));
	border-top-left-radius: 4px;
	border-top-right-radius: 4px;
}

/* @doc="Individual tab bar button in Off state." */
td.tabGroupButtonOff,
td.tabGroupButtonDisabled {
	height: 30px;
	color: #404040;
	background: #C0C0C0;
	font-size: 10pt;
	background-image: none;
	background-repeat: repeat-x;
}
td.tabGroupButtonOff:hover {
	background: #C0C0C0;
}

td.tabGroupButtonDisabled {
	color: gray;
}

td.tabGroupButtonOff:not([ie]) {
	background: -moz-linear-gradient(top, #B0B0B0, #D0D0D0);
	-moz-border-radius-topleft:4px;
	-moz-border-radius-topright:4px;

	background: -webkit-gradient(linear, left top, left bottom, color-stop(0.0,#B0B0B0), color-stop(1.0,#D0D0D0));
	border-top-left-radius: 4px;
	border-top-right-radius: 4px;
}

td.tabGroupButtonDisabled:not([ie]) {
	background: -moz-linear-gradient(top, #B0B0B0, #D0D0D0);
	-moz-border-radius-topleft:4px;
	-moz-border-radius-topright:4px;

	background: -webkit-gradient(linear, left top, left bottom, color-stop(0.0,#B0B0B0), color-stop(1.0,#D0D0D0));
	border-top-left-radius: 4px;
	border-top-right-radius: 4px;
}

.tabGroupGap {
	width: 0px;
}

#propertyTitle {
	height: 40px;
	width: 40px;
}

#spanArrow {
	padding-left: 10px;
	color: white;
	font-size: 20pt;
	text-shadow: black 1px 1px 1px;
}

#propertyCommands {
	color: white;
}

table.modelTable {
	background: white;
	width: 100%;
	font-size: 10pt;
}

table.modelTable td {
	padding: 2px;
	border-bottom: 1px solid rgb(241,240,231);
}

.modelError {
	color: #404040;
	font-size: 24px;
	padding: 10px;
	background: lightgray;
}

span.selector {
	visibility: hidden;
}

.modelRowCubeSelected span.selector,
.modelRowDimensionSelected span.selector,
.modelRowHierarchySelected span.selector,
.modelRowLevelSelected span.selector,
.modelRowMeasureSelected span.selector {
	visibility: visible;
}

.modelRowCube {
	color: rgb(67,67,67);
	font-size: 1.2em;
	font-weight: bold;
	background: #D0D0FF;
}
.modelRowCubeSelected {
	font-size: 1.2em;
	font-weight: bold;
	color: white;
	background: rgb(53,107,141);
}

.modelRowDimension {
	color: rgb(67,67,67);
	font-weight: bold;
	background: #F0F0FF;
}
.modelRowDimensionSelected {
	font-weight: bold;
	color: white;
	background: rgb(53,107,141); 
	/* #FFEEAA; */
}

.modelRowHierarchy {
	font-weight: bold;
	color: rgb(67,67,67);
}
.modelRowHierarchySelected {
	font-weight: bold;
	color: white;
	background: rgb(53,107,141);
}

.modelRowLevel {
	color: rgb(67,67,67);
}
.modelRowLevelSelected {
	color: white;
	background: rgb(53,107,141);
}

.modelRowMeasure {
	color: rgb(67,67,67);
}
.modelRowMeasureSelected {
	color: white;
	background: rgb(53,107,141);
}

.modelRowProperty {
	color: rgb(67,67,67);
}
.modelRowPropertySelected {
	color: white;
	background: rgb(53,107,141);
}
.coverPaneActive {
	position:absolute;
	left:0px;
	right:0px;
	top:0px;
	bottom:0px;
	opacity:.2;
	background:grey;
	display:block;
}
.coverPaneInactive {
	position:absolute;
	left:0px;
	right:0px;
	top:0px;
	display:block;
}

.hdrLink {
	font-size: 10pt;
	font-weight: normal;
	color: #3b84bc;
	text-decoration: none;
	padding-left: 6px;
	padding-right: 6px;
}

.hdrLinkDisabled {
	font-size: 10pt;
	font-weight: normal;
	color: gray;
	text-decoration: none;
	padding-left: 6px;
	padding-right: 6px;
}

.hdrLink:hover {
	color: #98923a;
}

/* WAL176 */
.hzResizeBar {
	position:absolute;
	top:0px;
	bottom:0px;
	width:10px;
	cursor:ew-resize;
	z-index:-1;
}
/* WAL176 */

</style>
]]></Data>
</XData>

<XData name="contentPane">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane xmlns="http://www.intersystems.com/zen">

<!-- Get Cube Definition in JSON format -->
<jsonProvider id="cube"
	OnGetTargetObject="GetCubeDefinition"
	OnSubmitContent="SubmitCube"
/>
<!-- DTB156 - Inherited Cube Definition in JSON format. There is no submit for this cube! -->
<jsonProvider id="inheritedCube"
	OnGetTargetObject="GetInheritedCubeDefinition"
>
<parameter id="parmInheritsFrom" paramName="inheritsFrom" value="#(%page.inheritsFrom)#"/>
</jsonProvider>

<hgroup id="mainGroup" cellVAlign="top">
<vgroup id="editorPane">
<html id="modelTableHeader" OnDrawContent="DrawTableHeader"></html>
<hgroup cellVAlign="top">
<dynaTree id="dataSource" 
 imageContracted="images/arrow1R.gif"
 imageExpanded="images/arrow1D.gif"
 imageNode=""
	showLines="false" showFolders="false" dragEnabled="true" 
	OnGetTreeInfo="GetDataSourceInfo">
<parameter id="sourceP1" paramName="dataSource" value="#(%page.dataSource)#" />
</dynaTree>
<html id="modelTableBody" dropEnabled="true" ondrop="return zenPage.tableDropHandler(dragData);"></html>
</hgroup>
</vgroup>
<vgroup id="propertyPane">
<html id="propertyTitle"><span id="spanArrow" title="#(%page.hlpShowHide)#" onclick="zenPage.toggleSettings();" onmouseover="this.style.color='#FFEEAA';this.style.cursor='pointer'" onmouseout="this.style.color='';this.style.cursor='';">&#187;</span></html>
<tabGroup id="propertyTabs" showTabBar="true">
<tab id="tabDetails" caption="Details">
<vgroup id="msgCubeInherited" hidden="true">
<spacer height="15"/>
<label id="msgCubeInheritedText" value="#(%page.msgCubeInherited)#" controlClass="detailLabel" width="95%"/>
<spacer height="5"/>
</vgroup>
<vgroup id="msgItemInherited" hidden="true">
<spacer height="15"/>
<label id="msgItemInheritedText" value="#(%page.msgItemInherited)#" controlClass="detailLabel" width="95%"/>
<spacer height="5"/>
<hgroup id="btnOverride" hidden="true">
<spacer width="15"/>
<button caption="Customize" onclick="zenPage.overrideInheritedItem();"/>
</hgroup>
<spacer height="15"/>
</vgroup>
<vgroup id="msgOverride" hidden="true">
<spacer height="15"/>
<label value="#(%page.msgItemOverride)#" controlClass="detailLabel" width="95%"/>
<spacer height="5"/>
</vgroup>
<vgroup id="tabDetailContent">
<spacer height="5"/>
<vgroup id="defaultDetails" label="Select an item to view details"/>
<vgroup id="cubeDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label label="Cube" labelClass="detailLabel"/>
<checkbox id="detailCubeDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
<checkbox id="detailCubeFactNums" label="Selective Build Enabled" disabled="true"/>
</hgroup>
<text id="detailCubeName" label="Cube Name" size="44" onchange="zenPage.applyDetails();"/>
<text id="detailCubeDisplayName" label="Display name" size="44" onchange="zenPage.applyDetails();"/>
<hgroup label="Description" cellVAlign="top">
<text id="detailCubeDescription" size="44" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailCubeDescription" hidden="true" cols="32" rows="4" onchange="zenPage.applyDescription('detailCubeDescription');"/>
<image src="deepsee/ds2_page_44.png" width="16" height="16" onclick="zenPage.editDescription('detailCubeDescription');"/>
</hgroup>
<hgroup>
<text id="detailCubeCaption" label="Caption" size="19" onchange="zenPage.applyDetails();"/>
<text id="detailCubeDomain" label="Domain" size="19" onchange="zenPage.applyDomain(zenThis.getValue());"/>
<!--<text id="detailCubeBucketSize" label="Bucket size" size="10" onchange="zenPage.applyDetails();"/>-->
</hgroup>
<text id="detailCubeSource" label="Source class" size="44" disabled="true"/>
<hgroup cellVAlign="bottom" cellStyle="padding-right:4px;">
<text id="detailCubeNullReplacement" label="Null replacement string" dropEnabled="true" size="19" onchange="zenPage.applyDetails();"/>
</hgroup>

<select id="detailCubeDefaultListing" label="Default listing" value="" originalValue="" onchange="zenPage.applyDetails();"/>

<hgroup hidden="true">
<select id="detailCubeDefaultMeasure" label="Default measure" value="" originalValue="" onchange="zenPage.applyDetails();"/>
<text id="detailCubeDefaultMember" label="Default member" dropEnabled="true" size="19" onchange="zenPage.applyDetails();"/>
</hgroup>
<hgroup cellVAlign="bottom">
<text id="detailCubeOwner" label="Owner" size="19" onchange="zenPage.applyDetails();"/>
<text id="detailCubeResource" label="Resource" size="19" onchange="zenPage.applyDetails();"/>
<image id="btndetailCubeResource" src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('CubeResource');"/>
</hgroup>
<hgroup>
<text id="detailCubeCountMeasureName" label="Count measure name" dropEnabled="true" size="19" onchange="zenPage.applyDetails();"/>
<text id="detailCubeCountMeasureCaption" label="Count measure caption" dropEnabled="true" size="19" onchange="zenPage.applyDetails();"/>
</hgroup>
<hgroup cellVAlign="bottom">
<text id="detailCubeBuildOrder" label="Initial build order" size="19" onchange="zenPage.applyDetails();"/>
<text id="detailCubeBuildRestriction" label="Build restriction" size="19" onchange="zenPage.applyDetails();"/>
<image id="btndetailBuildRestriction" src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('BuildRestriction');"/>
</hgroup>
<!--<text id="detailCubeDomain" label="Localization domain" size="19" onchange="zenPage.applyDetails();"/>-->
<text id="detailCubeClass" label="Class name" size="44" disabled="true" value="#(%page.cubeClass)#"/>
<text id="detailCubeDependsOn" label="Depends On" hint="Option list of classes that this cube depends on" size="44" onchange="zenPage.applyDependsOn(zenThis.getValue());"/>
<checkbox id="detailCubeSqlRestrict" label="Allow SQL Restrict" onchange="zenPage.applyDetails();"/>
<textarea label="Additional Description" id="areadetailAdditionalDescriptionCube" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
</vgroup>
<!-- End of Cube Details -->

<vgroup id="measureDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label label="Measure" labelClass="detailLabel"/>
<checkbox id="detailMeasureDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
<checkbox id="detailMeasureHidden" label="Hidden" onchange="zenPage.applyDetails();"/>
<checkbox id="detailMeasureSearchable" label="Searchable" onchange="zenPage.applyDetails();"/>
</hgroup>
<text id="detailMeasureName" label="Name" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<text id="detailMeasureDisplayName" label="Display name" size="44" onchange="zenPage.applyDetails();"/>
<hgroup label="Description" cellVAlign="top">
<text id="detailMeasureDescription" size="44" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailMeasureDescription" hidden="true" cols="32" rows="4" onchange="zenPage.applyDescription('detailMeasureDescription');"/>
<image src="deepsee/ds2_page_44.png" width="16" height="16" onclick="zenPage.editDescription('detailMeasureDescription');"/>
</hgroup>
<label label="Source Values" labelClass="detailLabel" />
<hgroup label="Property" cellVAlign="top">
<radioButton id="detailMeasureSourcePropertyRB" name="detailMeasureSourceRB" optionValue="property" onclick="zenPage.toggleSource('Measure','Source');"/>
<text id="detailMeasureSource" size="40" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('MeasureSource');"/>
</hgroup>
<hgroup label="Expression" cellVAlign="top">
<radioButton id="detailMeasureSourceExpressionRB" name="detailMeasureSourceRB" optionValue="expression" onclick="zenPage.toggleSource('Measure','Expression');"/>
<text id="detailMeasureExpression" size="40" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('MeasureExpression');"/>
</hgroup>
<form enclosingStyle="background:lightgray;">
<select id="detailMeasureAgg" label="Aggregate" valueList="COUNT,SUM,AVG,MIN,MAX" required="true" showEmpty="false" onchange="zenPage.applyDetails();"/>
<hgroup cellVAlign="top" cellStyle="padding-right:4px;">
<select id="detailMeasureType" label="Type" hint="Leave blank for default" valueList="" required="false" showEmpty="true" onchange="zenPage.changeType(zenThis);zenPage.applyDetails();"/>
<text id="detailMeasureScale" label="Precision" size="20" onchange="zenPage.applyDetails();" hidden="true"/>
<select id="detailMeasureiKnowSource" label="iKnow Source" valueList="string,stream,file,domain" displayList="string,stream,file,domain" showEmpty="false" onchange="zenPage.changeType(zenThis);" hidden="true"/>
<image id="detailMeasureiKnowDictionaries" label="Dictionaries" src="deepsee/dictionary_24.png" title="Click to maintain optional iKnow dictionaries for use in matching."
onclick="zenPage.editItem('iKnowDictionaries');"/>
<hidden id="detailMeasureiKnowDictionaryValue"/>
</hgroup>
<hgroup cellVAlign="bottom" cellStyle="padding-right:4px;">
<text id="detailMeasureFormatString" label="Format string" size="42" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<image id="btndetailMeasureFormatString" src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('FormatString');"/>
</hgroup>
</form>
<text id="detailMeasureFactName" label="Field name in fact table" size="20" onchange="zenPage.applyDetails();"/>
<form label="Measure-Specific Listings" labelClass="detailLabel" enclosingStyle="background:lightgray;">
<select id="measureBasedListingComparison" label="Operator" valueList=",=,&lt;&gt;,&lt;,&gt;,&lt;=,&gt;=,MIN,MAX" required="true" showEmpty="false" onchange="zenPage.applyDetails();"/>
<textarea label="Value" id="areadetailMeasureBasedListing" hidden="false" cols="10" rows="1" onchange="zenPage.applyDetails();"/>
</form>
<textarea label="Additional Description" id="areadetailAdditionalDescriptionMeasure" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
</vgroup>
<!-- End of Measure Details -->
<label id="lblComputed" hidden="true" label="To modify a computed dimension, edit the cube definition class with Studio."/>
<vgroup id="dimensionDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label label="Dimension" labelClass="detailLabel"/>
<checkbox id="detailDimensionDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
<checkbox id="detailDimensionHidden" label="Hidden" hidden="true" onchange="zenPage.applyDetails();"/>
</hgroup>
<text id="detailDimensionName" label="Name" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<text id="detailDimensionDisplayName" label="Display name" size="44" onchange="zenPage.applyDetails();"/>
<hgroup label="Description" cellVAlign="top">
<text id="detailDimensionDescription" size="44" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailDimensionDescription" hidden="true" cols="32" rows="4" onchange="zenPage.applyDescription('detailDimensionDescription');"/>
<image src="deepsee/ds2_page_44.png" width="16" height="16" onclick="zenPage.editDescription('detailDimensionDescription');"/>
</hgroup>
<vgroup id="idDimension">
<hgroup cellStyle="padding-right:2px;">
<select id="detailDimensionType" label="Dimension type" valueList="data,time,age,iKnow" required="true" showEmpty="false" onchange="zenPage.changeType(zenThis);zenPage.applyDetails();"/>
<select id="detailDimensionCalendar" label="Calendar"  valueList="gregorian,partial,hijriTabular,hijriObserved" displayList="gregorian,partial,hijri (tabular),hijri (observed)" required="true" showEmpty="false" onchange="zenPage.applyDetails();" value="gregorian"/>
<select id="detailDimensioniKnowType" label="iKnow type" valueList="entity,dictionary" displayList="entity,dictionary" required="true" showEmpty="false" onchange="zenPage.applyDetails();"/>
<select id="detailDimensioniKnowMeasure" label="iKnow measure" valueList="" title="iKnow measure is required for iKnow type" required="true" showEmpty="false" onchange="zenPage.applyDetails();"/>
</hgroup>
<vgroup id="idDetailDimensionSource">
<label label="Source Values" labelClass="detailLabel" />
<hgroup cellVAlign="top">
<radioButton id="detailDimensionSourcePropertyRB" name="detailDimensionSourceRB" optionValue="property" onclick="zenPage.toggleSource('Dimension','Source');"/>
<label label="Property" />
</hgroup>
<hgroup cellVAlign="top">
<text id="detailDimensionSource" size="44" dropEnabled="true" ondrop="zenThis.setValue(dragData.value)" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('DimensionSource');"/>
</hgroup>
<hgroup cellVAlign="top">
<radioButton id="detailDimensionSourceExpressionRB" name="detailDimensionSourceRB" optionValue="expression" onclick="zenPage.toggleSource('Dimension','Expression');"/>
<label label="Expression" />
</hgroup>
<hgroup cellVAlign="top">
<text id="detailDimensionExpression" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('DimensionExpression');"/>
</hgroup>
</vgroup>
<vgroup cellStyle="padding:4px;" label="All Level" labelClass="detailLabel">
<checkbox id="detailDimensionHasAll" caption="Enable the All level for this dimension" captionClass="zenLabel" value="1" onchange="zenPage.changeType(zenThis);zenPage.applyDetails();"/>
<text id="detailDimensionAllCaption" label="Caption for All member" size="44" onchange="zenPage.applyDetails();"/>
<text id="detailDimensionAllDisplayName" label="Display name for All member" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
</vgroup>
</vgroup>
<vgroup id="idDimensionSharesFrom" hidden="true">
<label id="detailDimensionSharesFromCube" label="Shares from Cube"/>
</vgroup>
<textarea label="Additional Description" id="areadetailAdditionalDescriptionDimension" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
</vgroup>
<!-- End of Dimension Details -->

<vgroup id="hierarchyDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label label="Hierarchy" labelClass="detailLabel"/>
<checkbox id="detailHierarchyDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
</hgroup>
<text id="detailHierarchyName" label="Name" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<text id="detailHierarchyDisplayName" label="Display name" size="20" onchange="zenPage.applyDetails();"/>
<textarea id="detailHierarchyDescription" label="Description" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailAdditionalDescriptionHierarchy" label="Additional Description" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
</vgroup>
<!-- End of Hierarchy Details -->

<vgroup id="levelDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label id="lblLevel" controlClass="detailLabel" value="Data Level"/>
<checkbox id="detailLevelDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
</hgroup>
<text id="detailLevelName" label="Name" size="44"  dropEnabled="true" onchange="zenPage.applyDetails();"/>
<text id="detailLevelDisplayName" label="Display name" size="44" onchange="zenPage.applyDetails();"/>
<hgroup label="Description" cellVAlign="top">
<text id="detailLevelDescription" size="44" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailLevelDescription" hidden="true" cols="32" rows="2" onchange="zenPage.applyDescription('detailLevelDescription');"/>
<image src="deepsee/ds2_page_44.png" width="16" height="16" onclick="zenPage.editDescription('detailLevelDescription');"/>
</hgroup>
<label label="Source Values" labelClass="detailLabel" />
<vgroup id="idDetailLevelSource">
<hgroup cellVAlign="top">
<radioButton id="detailLevelSourcePropertyRB" name="detailLevelSourceRB" optionValue="property" onclick="zenPage.toggleSource('Level','Source');"/>
<label label="Property" />
</hgroup>
<hgroup cellVAlign="top">
<text id="detailLevelSource" size="44" dropEnabled="true" ondrop="zenThis.setValue(dragData.value)" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('LevelSource');"/>
</hgroup>
<hgroup cellVAlign="top">
<radioButton id="detailLevelSourceExpressionRB" name="detailLevelSourceRB" optionValue="expression" onclick="zenPage.toggleSource('Level','Expression');"/>
<label label="Expression" />
</hgroup>
<hgroup cellVAlign="top">
<text id="detailLevelExpression" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('LevelExpression');"/>
</hgroup>
</vgroup>
<form id="frmHowtotransform" label="How to Transform the Source Values" labelClass="detailLabel" enclosingStyle="background:lightgray;">
<text id="detailLevelNullReplacement" label="Null replacement string" dropEnabled="true" size="20" onchange="zenPage.applyDetails();"/>

<hgroup cellVAlign="bottom">
<text id="detailLevelRangeExpression" label="Range expression" size="44" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('RangeExpression');"/>
</hgroup>
<checkbox id="detailLevelUseDisplayValue" caption="Use value in DISPLAYLIST" captionClass="zenLabel" onchange="zenPage.applyDetails();"/>

</form>
<hgroup id="idLevelTimeFunction" cellStyle="padding-right:4px;">
<select id="detailLevelTimeFunction" label="Extract value with function"
valueList="MinuteNumber,HourNumber,DayMonthYear,DayNumber,WeekNumber,MonthNumber,WeekYear,MonthYear,QuarterNumber,QuarterYear,Year,Decade" onchange="zenPage.changeType(zenThis);zenPage.applyDetails();"/>
</hgroup>
<hgroup id="idLevelTimeFormat" cellStyle="padding-right:4px;">
<text id="detailLevelTimeFormat" label="Time Format" onchange="zenPage.applyDetails();"/>
</hgroup>
<select id="detailLevelTimeFunctionAge" label="Extract value with function" hidden="true"
valueList="Days,Months,Years" onchange="zenPage.changeType(zenThis);zenPage.applyDetails();"/>
<hgroup id="idDataFunction" cellStyle="padding-right:4px;" valign="top">
<select id="detailLevelList" label="Source value list type" displayList="Not a list,$List structure,Comma delimited,Other delimited" valueList="false,true,comma,other" showEmpty="false" onchange="zenPage.changeType(zenThis);"/>
<text id="detailLevelListDelimiter" label="List delimiter" size="2" onblur="zenPage.applyDetails();"/>
</hgroup>
<select id="detailLevelSort" label="Sort option" valueList="asc,desc,asc numeric,desc numeric" showEmpty="true" onchange="zenPage.applyDetails();"/>
<text id="detailLevelFactName" label="Field name in fact table" size="20" onchange="zenPage.applyDetails();"/>
<hgroup id="idLevelDependsOn" cellVAlign="top">
<textarea id="areadetailLevelDependsOn" label="Depends on" cols="34" rows="6" onchange="zenPage.applyDetails();"/>
<vgroup>
<image src="/csp/broker/images/spacer.gif" width="16" height="16"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('LevelDependsOn');"/>
</vgroup>
</hgroup>
<textarea id="areadetailAdditionalDescriptionLevel" label="Additional Description" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
</vgroup>
<!-- End of Level Details -->

<vgroup id="propertyDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label label="Property" labelClass="detailLabel"/>
<checkbox id="detailPropertyDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
<checkbox id="detailPropertyHidden" label="Hidden" onchange="zenPage.applyDetails();"/>
</hgroup>
<text id="detailPropertyName" label="Name" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<text id="detailPropertyDisplayName" label="Display name" size="44" onchange="zenPage.applyDetails();"/>
<hgroup label="Description" cellVAlign="top">
<text id="detailPropertyDescription" size="44" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailPropertyDescription" hidden="true" cols="32" rows="4" onchange="zenPage.applyDescription('detailPropertyDescription');"/>
<image src="deepsee/ds2_page_44.png" width="16" height="16" onclick="zenPage.editDescription('detailPropertyDescription');"/>
</hgroup>
<label label="Source Values" labelClass="detailLabel" />
<hgroup label="Property" cellVAlign="top">
<radioButton id="detailPropertySourcePropertyRB" name="detailPropertySourceRB" optionValue="property" onclick="zenPage.toggleSource('Property','Source');"/>
<text id="detailPropertySource" size="44" dropEnabled="true" ondrop="zenThis.setValue(dragData.value)" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('PropertySource');"/>
</hgroup>
<vgroup cellStyle="padding-left:20px;">
<hgroup>
<checkbox id="detailPropertyUseDisplayValue" onchange="zenPage.applyDetails();"/>
<label label="Use value in DISPLAYLIST"/>
</hgroup>
<hgroup>
<checkbox id="detailPropertyIsReference" onchange="zenPage.applyDetails();"/>
<label label="Get value at runtime"/>
</hgroup>
</vgroup>
<hgroup label="Expression" cellVAlign="top">
<radioButton id="detailPropertySourceExpressionRB" name="detailPropertySourceRB" optionValue="expression" onclick="zenPage.toggleSource('Property','Expression');"/>
<text id="detailPropertyExpression" size="44" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('PropertyExpression');"/>
</hgroup>
<label label="Effect of Properties on Level Members" labelClass="detailLabel"/>
<vgroup>
<hgroup>
<checkbox id="detailPropertyIsName" onchange="zenPage.applyDetails();"/>
<label label="Use as member names"/>
</hgroup>
<hgroup labelPosition="left" >
<select id="detailPropertySort" label="Sort members by property value" valueList="asc,desc,asc numeric,desc numeric" showEmpty="true" onchange="zenPage.applyDetails();"/>
</hgroup>
</vgroup>
<hgroup cellStyle="padding-right:4px;">
</hgroup>
<text id="detailPropertyFactName" label="Field name in level table" size="20" onchange="zenPage.applyDetails();"/>
<textarea label="Additional Description" id="areadetailAdditionalDescriptionProperty" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
</vgroup>
<!-- End of Property Details -->

<vgroup id="listingDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label label="Listing" labelClass="detailLabel"/>
<checkbox id="detailListingDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
</hgroup>
<text id="detailListingName" label="Name" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<text id="detailListingDisplayName" label="Display name" size="44" onchange="zenPage.applyDetails();"/>
<hgroup label="Description" cellVAlign="top">
<text id="detailListingDescription" size="44" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailListingDescription" hidden="true" cols="32" rows="4" onchange="zenPage.applyDescription('detailListingDescription');"/>
<image src="deepsee/ds2_page_44.png" width="16" height="16" onclick="zenPage.editDescription('detailListingDescription');"/>
</hgroup>
<select id="detailListingType" label="Listing type" valueList="table,map" required="true" showEmpty="false" onchange="zenPage.applyDetails();"/>
<hgroup cellVAlign="bottom">
<text id="detailListingResource" label="Resource" size="44" onchange="zenPage.applyDetails();"/>
<image id="btndetailListingResource" src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('ListingResource');"/>
</hgroup>
<hgroup id="idListingFieldList" cellVAlign="top">
<textarea id="areadetailListingFieldList" label="Field list" cols="32" rows="6" onchange="zenPage.applyDetails();"/>
<vgroup>
<image src="/csp/broker/images/spacer.gif" width="16" height="16"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('ListingFieldList');"/>
</vgroup>
</hgroup>
<hgroup id="idListingOrderBy" cellVAlign="top">
<textarea id="areadetailListingOrderBy" label="Order by" cols="32" rows="2" onchange="zenPage.applyDetails();"/>
<vgroup>
<image src="/csp/broker/images/spacer.gif" width="16" height="16"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('ListingOrderBy');"/>
</vgroup>
</hgroup>
<combobox id="detailListingSourceClass" label="Data connector" editable="true" valueList="" onchange="zenPage.applyDetails();" unrestricted="true"/>
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<checkbox id="detailListingUseSQL" label="Custom SQL query" onchange="zenPage.changeUseSQL();"/>
</hgroup>
<hgroup id="idListingSQL" cellVAlign="top" hidden="true">
<textarea id="areadetailListingSQL" label="SQL Query" cols="32" rows="6" onchange="zenPage.applyDetails();"/>
<vgroup>
<image src="/csp/broker/images/spacer.gif" width="16" height="16"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('ListingSQL');"/>
</vgroup>
</hgroup>
<textarea label="Additional Description" id="areadetailAdditionalDescriptionListing" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
</vgroup>
<!-- End of Listing Details -->
<!-- JSL4434 add listingField -->
<vgroup id="listingFieldDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label label="Listing Field" labelClass="detailLabel"/>
<checkbox id="detailListingFieldDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
</hgroup>
<text id="detailListingFieldName" label="Name" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<text id="detailListingFieldDisplayName" label="Display name" size="44" onchange="zenPage.applyDetails();"/>
<hgroup label="Description" cellVAlign="top">
<text id="detailListingFieldDescription" size="44" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailListingFieldDescription" hidden="true" cols="32" rows="4" onchange="zenPage.applyDescription('detailListingFieldDescription');"/>
<image src="deepsee/ds2_page_44.png" width="16" height="16" onclick="zenPage.editDescription('detailListingFieldDescription');"/>
</hgroup>
<hgroup id="areadetailListingFieldExpression" cellVAlign="top">
<text id="detailListingFieldExpression" label="Field Expression" size="44" ondrop="zenPage.dropDetailListingFieldExpression(dragData)" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<vgroup>
<image src="/csp/broker/images/spacer.gif" width="16" height="16"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('ListingField');"/>
</vgroup>
</hgroup>
<hgroup cellVAlign="bottom">
<text id="detailListingFieldResource" label="Resource" size="44" onchange="zenPage.applyDetails();"/>
<image id="btndetailListingFieldResource" src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('ListingFieldResource');"/>
</hgroup>

</vgroup>
<!-- End of ListingField Details -->


<vgroup id="calculatedMemberDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label label="Calculated Member" labelClass="detailLabel"/>
<checkbox id="detailCalMemberDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
<checkbox id="detailCalMemberHidden" label="Hidden" hidden="true" onchange="zenPage.applyDetails();"/>
</hgroup>
<text id="detailCalMemberName" label="Name" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<text id="detailCalMemberDisplayName" label="Display name" size="44" onchange="zenPage.applyDetails();"/>
<hgroup label="Description" cellVAlign="top">
<text id="detailCalMemberDescription" size="44" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailCalMemberDescription" hidden="true" cols="32" rows="4" onchange="zenPage.applyDescription('detailCalMemberDescription');"/>
<image src="deepsee/ds2_page_44.png" width="16" height="16" onclick="zenPage.editDescription('detailCalMemberDescription');"/>
</hgroup>
<selector id="detailCalMemberDimension" label="Dimension" size="41" onchange="zenPage.applyDetails();"/>
<hgroup cellVAlign="bottom" cellStyle="padding-right:4px;">
<text id="detailCalMemberFormatString" label="Format string" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('CalMemberFormatString');"/>
</hgroup>
<!--<text id="detailCalMemberUnits" label="Units" size="20" onchange="zenPage.applyDetails();" hidden="true"/>-->
<hgroup cellVAlign="top" cellStyle="padding-right:4px;">
<textarea id="areadetailCalMemberValueExpression" label="Value expression" cols="32" rows="6" onchange="zenPage.applyDetails();"/>
<vgroup>
<image src="/csp/broker/images/spacer.gif" width="16" height="16"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('CalMemberValueExpression');"/>
</vgroup>
</hgroup>
<hgroup cellVAlign="top" cellStyle="padding-right:4px;">
<textarea label="Listing Filter" id="areadetailCalcMemberListingFilter" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
<vgroup id="areadetailCalcMemberListingFilterMagnifyingGlass">
<image src="/csp/broker/images/spacer.gif" width="16" height="16"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('listingFilterExpression');"/>
</vgroup>
</hgroup>
<textarea label="Additional Description" id="areadetailAdditionalDescriptionCalculatedMember" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
</vgroup>
<!-- End of calculatedMembers Details -->

<vgroup id="namedSetDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label label="Named Sets" labelClass="detailLabel"/>
<checkbox id="detailNamedSetDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
</hgroup>
<text id="detailNamedSetName" label="Name" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<text id="detailNamedSetDisplayName" label="Display name" size="44" onchange="zenPage.applyDetails();"/>
<hgroup label="Description" cellVAlign="top">
<text id="detailNamedSetDescription" size="44" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailNamedSetDescription" hidden="true" cols="32" rows="4" onchange="zenPage.applyDescription('detailNamedSetDescription');"/>
<image src="deepsee/ds2_page_44.png" width="16" height="16" onclick="zenPage.editDescription('detailNamedSetDescription');"/>
</hgroup>
<hgroup cellVAlign="top" cellStyle="padding-right:4px;">
<textarea id="areadetailNamedSetSetExpression" label="Set expression" cols="32" rows="6" onchange="zenPage.applyDetails();"/>
<vgroup>
<image src="/csp/broker/images/spacer.gif" width="16" height="16"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('SetExpression');"/>
</vgroup>
</hgroup>
<textarea label="Additional Description" id="areadetailAdditionalDescriptionNamedSet" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
</vgroup>
<!-- End of namedSets Details -->

<vgroup id="relationshipDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label label="Relationship" labelClass="detailLabel"/>
<checkbox id="detailRelationshipDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
</hgroup>
<text id="detailRelationshipName" label="Name" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<text id="detailRelationshipDisplayName" label="Display name" size="44" onchange="zenPage.applyDetails();"/>
<hgroup label="Description" cellVAlign="top">
<text id="detailRelationshipDescription" size="44" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailRelationshipDescription" hidden="true" cols="32" rows="4" onchange="zenPage.applyDescription('detailRelationshipDescription');"/>
<image src="deepsee/ds2_page_44.png" width="16" height="16" onclick="zenPage.editDescription('detailRelationshipDescription');"/>
</hgroup>
<vgroup id="idDetailRelationshipSource">
<label label="Source Values" labelClass="detailLabel" />
<hgroup cellVAlign="top">
<radioButton id="detailRelationshipSourcePropertyRB" name="detailRelationshipSourceRB" optionValue="property" onclick="zenPage.toggleSource('Relationship','Source');"/>
<label label="Property" />
</hgroup>
<hgroup cellVAlign="top">
<text id="detailRelationshipSource" size="44" dropEnabled="true" ondrop="zenThis.setValue(dragData.value)" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('RelationshipSource');"/>
</hgroup>
<hgroup cellVAlign="top">
<radioButton id="detailRelationshipSourceExpressionRB" name="detailRelationshipSourceRB" optionValue="expression" onclick="zenPage.toggleSource('Relationship','Expression');"/>
<label label="Expression" />
</hgroup>
<hgroup cellVAlign="top">
<text id="detailRelationshipExpression" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('RelationshipExpression');"/>
</hgroup>
</vgroup>
<form label="How to Transform the Source Values" labelClass="detailLabel" enclosingStyle="background:lightgray;">
<text id="detailRelationshipNullReplacement" label="Null replacement string" dropEnabled="true" size="20" onchange="zenPage.applyDetails();"/>
</form>
<select id="detailRelationshipCardinality" label="Cardinality" valueList="one,many" displayList="One,Many" showEmpty="false" onchange="zenPage.applyDetails();"/>
<text id="detailRelationshipInverse" label="Inverse" size="44" onchange="zenPage.applyDetails();"/>
<select id="detailRelationshipRelatedCube" label="Related cube" showEmpty="false" onchange="zenPage.applyDetails();"/>
<text id="detailRelationshipFactName" label="Field name in fact table" size="20" onchange="zenPage.applyDetails();"/>
<textarea label="Additional Description" id="areadetailAdditionalDescriptionRelationship" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
</vgroup>
<!-- End of relationship Details -->

<vgroup id="expressionDetails" hidden="true" cellStyle="padding:3px;" labelPosition="top">
<hgroup labelPosition="left" cellStyle="padding-right:10px;">
<label label="Expression" labelClass="detailLabel"/>
<checkbox id="detailExpressionDisabled" label="Disabled" onchange="zenPage.applyDetails();"/>
</hgroup>
<text id="detailExpressionName" label="Name" size="44" dropEnabled="true" onchange="zenPage.applyDetails();"/>
<hgroup label="Description" cellVAlign="top">
<text id="detailExpressionDescription" size="44" onchange="zenPage.applyDetails();"/>
<textarea id="areadetailExpressionDescription" hidden="true" cols="32" rows="4" onchange="zenPage.applyDescription('detailExpressionDescription');"/>
<image src="deepsee/ds2_page_44.png" width="16" height="16" onclick="zenPage.editDescription('detailExpressionDescription');"/>
</hgroup>
<vgroup id="idDetailExpressionSource">
<label label="Source Expression" labelClass="detailLabel" />
<hgroup cellVAlign="top">
<textarea id="areadetailExpressionExpression" cols="32" rows="6" onchange="zenPage.applyDetails();"/>
<image src="deepsee/ds2_magnify_44.png" width="16" height="16" onclick="zenPage.editItem('ExpressionExpression');"/>
</hgroup>
</vgroup>
<textarea label="Additional Description" id="areadetailAdditionalDescriptionExpression" hidden="false" cols="32" rows="4" onchange="zenPage.applyDetails();"/>
</vgroup>
<!-- End of expression Details -->

</vgroup>
</tab>
<tab caption="Tools" id="tabTools" labelPosition="left" title="Various tools for working with Analytics data models">
<vgroup cellStyle="padding-left:3px;">
<label label="Various tools for working with Analytics data models"/>

<hgroup cellStyle="padding: 10px;" cellVAlign="top">
<image src="portal/comparison_chart_48.gif"/>
<vgroup>
<button caption="Analyzer" controlClass="commandButton" title="Use the Analyzer to view this cube." onclick="zenPage.toolAnalyzer();"/>
<label label="Use the Analyzer to view this cube."/>
</vgroup>
</hgroup>

<hgroup cellStyle="padding: 10px;" cellVAlign="top">
<image src="portal/sql_query_48.gif"/>
<vgroup>
<button caption="Query Tool" controlClass="commandButton" title="Use the Query Tool to run queries against this cube." onclick="zenPage.toolQuery();"/>
<label label="Use the Query Tool to run queries against this cube."/>
</vgroup>
</hgroup>

</vgroup>
</tab>
</tabGroup>
</vgroup>
</hgroup>
<timer id="commandBtnTimer" ontimeout="zenPage.commandBtnTimeout();" timeout="500"/>
</pane>
]]></Data>
</XData>

<Method name="%OnGetTitle">
<Description>
Get the (localized) title string for the page.
This should be implemented in a subclass.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If (..cubeName="") {
		Quit ..%OnGetPageName()
	}
	Quit ..cubeName
]]></Implementation>
</Method>

<Method name="%OnGetPageName">
<Description>
Get the (localized) name of the page.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $$$Text("Architect","%DeepSee")
]]></Implementation>
</Method>

<Method name="%OnGetProductName">
<Description>
Get the product name for the page.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit "Analytics"
]]></Implementation>
</Method>

<Method name="OnGetRibbonInfo">
<Description>
Get information to display in the ribbon bar.</Description>
<FormalSpec>*pDisplay:%Boolean,*pViewIcons:%List,*pSortOptions:%List,*pSearchBox:%Boolean,*pRibbonTitle:%String,*pCommands:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pDisplay = 1
	Set pSearchBox = 0
	Set pRibbonTitle = $$$Text("Architect")

	//Set pViewIcons(1) = $LB("cubes",$$$Text("Show related cubes"),"portal/view_cubes.png")
	Set pViewIcons(2) = $LB("cube",$$$Text("Show cube definition"),"portal/view_cube.png")
	//Set pViewIcons(3) = $LB("table",$$$Text("Show fact table definition"),"portal/view_facts.png")

	// commands
	// $LB(id,caption,help,onclick)
	// DTB390 - Hide buttons that the user does not have privilege to use
	Set:..canEdit pCommands($I(pCommands)) = $LB("cmdNew",$$$Text("New"),$$$Text("Create a new model"),"zenPage.newCube();")
	Set pCommands($I(pCommands)) = $LB("cmdOpen",$$$Text("Open"),$$$Text("Open a model"),"zenPage.changeSubjectArea();")
	Set:..canEdit pCommands($I(pCommands)) = $LB("cmdSave",$$$Text("Save"),$$$Text("Save this model"),"zenPage.save();")
	Set pCommands($I(pCommands)) = $LB("cmdCompile",$$$Text("Compile"),$$$Text("Compile this model"),"zenPage.compile();")
	Set pCommands($I(pCommands)) = $LB("cmdBuild",$$$Text("Build"),$$$Text("Rebuild data for this model"),"zenPage.buildCube();")
	Set pCommands($I(pCommands)) = $LB("cmdDoc",$$$Text("Documentation"),$$$Text("Open Documatic for this model"),"zenPage.doDocument();")

	Quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawTableHeader">
<Description>
Draw the contents of the Table Header (the region between the diagram and the table).</Description>
<FormalSpec>pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//Set msgChange = $$$Text("Change")
	//Set hlpChange = $$$Text("Change the data source for this model")
	Set msgNew = $$$Text("New")
	Set hlpNew = $$$Text("Add a new cube")
	Set msgAdd = $$$Text("Add Element")
	Set hlpAdd = $$$Text("Add an element to this model")
	Set msgUndo = $$$Text("Undo")
	Set hlpUndo = $$$Text("Undo the last change to this model")
	Set msgExpand = $$$Text("Expand All")
	Set hlpExpand = $$$Text("Expand all elements")
	Set msgCollapse = $$$Text("Collapse All")
	Set hlpCollapse = $$$Text("Collapse all elements")
	Set msgReorder = $$$Text("Reorder")
	Set hlpReorder = $$$Text("Reorder Dimensions or Measures")
	Set msgView = $$$Text("View")
	Set hlpView = $$$Text("View cube details")

	&html<<div style="position:relative;">>
	&html<<div style="position:absolute;top:16px;left:20px;font-weight:bold;color:#404040;">#($$$Text("Source Class"))#</div>>
	///&nbsp;<a class="hdrLink" href="#" title="#(hlpChange)#" onclick="zenPage.changeDataSource();return false;">#(msgChange)#</a>
	///</div>> 
	&html<<div style="position:absolute;top:16px;left:200px;font-weight:bold;color:#404040;">#($$$Text("Model Elements"))#
	&nbsp;<a class="hdrLink" href="#" title="#(hlpAdd)#" onclick="zenPage.addItem();return false;">#(msgAdd)#</a>
	&nbsp;&nbsp;<a id="cmdUndo" class="hdrLinkDisabled" disabled="true" href="#" title="#(hlpUndo)#" onclick="zenPage.undo();return false;">#(msgUndo)#</a>
	&nbsp;&nbsp;<a class="hdrLink" href="#" title="#(hlpExpand)#" onclick="zenPage.toggleExpand(1);return false;">#(msgExpand)#</a>
	&nbsp;&nbsp;<a class="hdrLink" href="#" title="#(hlpCollapse)#" onclick="zenPage.toggleExpand(0);return false;">#(msgCollapse)#</a>
	&nbsp;&nbsp;<a class="hdrLink" href="#" title="#(hlpReorder)#" onclick="zenPage.reorder();return false;">#(msgReorder)#</a>
	</div>>

	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetDataSourceInfo">
<Description>
Provide contents of the data source tree.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pRoot:%String,*pTree,&pParms]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tDataSource = $G(pParms("dataSource"))
	If (tDataSource '= "") {
		Set tSC = ##class(%DeepSee.Utils).%GetDataSourceTree(tDataSource,.pTree,,,,pRoot)
		If $$$ISERR(tSC) Quit tSC
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnDrawRibbon">
<Description>
Draw additional stuff in the ribbon bar</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (%page.cubeName'="")&&(%page.canWrite) Quit ..%DrawSourceControlCommands()		// DTB646 - Check privileges for source control button display
	Quit 1
]]></Implementation>
</Method>

<Method name="changeSubjectArea">
<Description>
Launch the cube finder dialog.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	zenLaunchPopupWindow('_DeepSee.UI.Dialog.finderDialog.cls?MODE=models','SubjectArea','status,scrollbars,resizable=yes,width=800,height=600');
]]></Implementation>
</Method>

<Method name="changeType">
<Description>
This function takes care of certain fields when their values are changed.</Description>
<FormalSpec>idfield</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var idname = idfield.getProperty("id");
	switch(idname) {
	case 'detailMeasureType':
		var measureType = zen("detailMeasureType").getValue();
		zen("detailMeasureScale").setHidden(measureType!="number");
		zen("detailMeasureiKnowSource").setHidden(measureType!="iKnow");
		zen("detailMeasureiKnowDictionaries").setHidden(measureType!="iKnow");
		zen('detailMeasureFormatString').setDisabled(measureType=="iKnow");
		zen('detailMeasureAgg').setDisabled(measureType=="iKnow");		
		if (measureType=="iKnow"&&zen("detailMeasureiKnowSource").getValue()=="") {
			zen("detailMeasureiKnowSource").setValue('string');	
		}
		var currentAggFunc = zen('detailMeasureAgg').getValue();
		if ((new Array('iKnow','text','string','boolean')).indexOf(measureType)>=0) {
			zen('detailMeasureAgg').setValue('COUNT');
		} else if (((measureType=='date') || (measureType=='age')) && (currentAggFunc!='MAX') && (currentAggFunc!='MIN') && (currentAggFunc!='AVG')) {
			zen('detailMeasureAgg').setValue('AVG');
		}
		break;
	case 'detailDimensionType':
		var dimType = zen("detailDimensionType").getValue();
		if (dimType == 'data' || dimType == 'iKnow') { 
			zen('idDetailDimensionSource').setHidden(true);
		}
		else {
			zen('idDetailDimensionSource').setHidden(false);
		}
		zen('detailDimensionCalendar').setHidden('time'!=dimType);		// DTB181 - Only expose for time dimensions
		zen('detailDimensioniKnowType').setHidden(dimType!="iKnow");
		zen('detailDimensioniKnowMeasure').setHidden(dimType!="iKnow");
		if (dimType == "iKnow") {
			var iKnowMeasures = this.getiKnowMeasures();
			zen('detailDimensioniKnowMeasure').setProperty("valueList",iKnowMeasures);
			var currentIKnowMeasure = zen('detailDimensioniKnowMeasure').getValue();
			zen('detailDimensioniKnowMeasure').setValue((currentIKnowMeasure!='') ? currentIKnowMeasure : iKnowMeasures.split(',')[0]);
			var currentIKnowType = zen('detailDimensioniKnowType').getValue();
			zen('detailDimensioniKnowType').setValue((currentIKnowType!='') ? currentIKnowType : 'entity');
		}
		break;
	case 'detailDimensionHasAll':
		var hasAll = zen("detailDimensionHasAll").getValue();
		zen("detailDimensionAllCaption").setDisabled(hasAll!=1);
		zen("detailDimensionAllDisplayName").setDisabled(hasAll!=1);
		break;
	case 'detailLevelList':
		// listType value = false,true,comma,other
		var listType = zen("detailLevelList").getValue();
		var delimiter = zen("detailLevelListDelimiter");
		if (listType == "comma") delimiter.setValue(",");
		if ((listType != "comma")&&(listType != "other")) delimiter.setValue("");
		delimiter.setDisabled(listType!='other');
		// PFS041 - If other is selected, focus on delimiter input, else apply changes
		if (listType=='other') {
			zenPage.getComponentById('detailLevelListDelimiter').focus();
		} else {
			zenPage.applyDetails();
		}
		break;
	case 'detailLevelTimeFunction':
		zen("frmHowtotransform").setHidden(zen("detailLevelTimeFunction").getValue()!="");
		break;
	case 'detailLevelTimeFunctionAge':
		zen("frmHowtotransform").setHidden(zen("detailLevelTimeFunctionAge").getValue()!="");
		break;
	case 'detailMeasureiKnowSource':
		if (idfield.getValue() == "domain") {
			var ok = confirm($$$Text("You are changing iKnow source to 'domain' which is an advanced iKnow setting. Are you sure you want to do this?"));
			if (ok) {
				zen("detailMeasureiKnowDictionaries").setHidden(true);
			} else {
				// reset value back to 'string'
				zen("detailMeasureiKnowSource").setValue('string');
			}
		} else {
			zen("detailMeasureiKnowDictionaries").setHidden(false);
		}
		zenPage.applyDetails();
		break;
	}
]]></Implementation>
</Method>

<Method name="changeUseSQL">
<Description>
User checked/unchecked the Use SQL field</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var usesql = zen("detailListingUseSQL").getValue();
	zen("idListingSQL").setHidden(!usesql);
	zen("idListingFieldList").setHidden(usesql);
	zen("idListingOrderBy").setHidden(usesql);
	zen("detailListingSourceClass").setHidden(usesql);
]]></Implementation>
</Method>

<Method name="onlayoutHandler">
<Description>
Adjust sizes of components on the page.</Description>
<FormalSpec>load</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	try {
		this.updateTable();
		this.adjustSizes();
		
		if (load) {
			// reset scrolling !!!
			var tableBodyDiv = zen('modelTableBody').getEnclosingDiv();
			tableBodyDiv.scrollTop = 0;
			tableBodyDiv.scrollLeft = 0;
			
			//YSD2397 - temp out until default Measure/Listing issue is resolved
			var cube  = zenPage.getComponentById('cube').content
			if (cube) {
				this.selectItem('cube',0);
				//this.applyDetails();		// DTB918
			}
		}
	}
	catch(ex) {
		zenExceptionHandler(ex,arguments,'Error in onlayoutHandler');
	}
]]></Implementation>
</Method>

<Method name="adjustSizes">
<Description>
Adjust sizes of components on the page.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	try {
		var propDiv = zen('propertyPane').getEnclosingDiv();
		var editDiv = zen('editorPane').getEnclosingDiv();
		var tableHdrDiv = zen('modelTableHeader').getEnclosingDiv();
		var tableBodyDiv = zen('modelTableBody').getEnclosingDiv();
		var sourceDiv = zen('dataSource').getEnclosingDiv();
		var proptitleDiv = zen('propertyTitle').getEnclosingDiv();
		var proptabsDiv = zen('propertyTabs').getEnclosingDiv();

		propDiv.style.display = 'block';

		// find size of window
		var winHeight = zenGetWindowHeight();
		var winWidth = zenGetWindowWidth();

		var propWidth = 40;
		if (this.settingsExpanded) {
			propWidth = (winWidth<900) ? 300 : 400;		// DTB731 - Provide a little more space for the Details pane
		}
		propDiv.style.width = propWidth + 'px';

		var th = this.getTitleAreaHeight();
		var hgt = winHeight - th - 25;
		var editorHgt = hgt - 1;
		var editorWid = winWidth - propDiv.offsetWidth - 25;
		hgt = (hgt < 1 ? 1 : hgt);
		editDiv.style.width = editorWid + 'px';
		editDiv.style.height = editorHgt + 'px';
		tableHdrDiv.style.width = editorWid + 'px';
		tableBodyDiv.style.width = editorWid - sourceDiv.offsetWidth + 'px';
		tableBodyDiv.style.height = editorHgt - tableHdrDiv.offsetHeight + 'px';
		sourceDiv.style.height = editorHgt - tableHdrDiv.offsetHeight + 'px';

		propDiv.style.height = hgt - 1 + 'px';

		if (this.settingsExpanded) {
			var tabBodyHgt = (hgt - proptitleDiv.offsetHeight - 30);
			tabBodyHgt = (tabBodyHgt < 1 ? 1 : tabBodyHgt);
			zen('propertyTabs').setBodySize(tabBodyHgt,propDiv.offsetWidth- 2);
			zen('propertyTabs').setHidden(false);
		}
		else {
			zen('propertyTabs').setHidden(true);
		}
		
		// + WAL177
		var bar = document.getElementById('resize');
		if (bar) {
			bar.style.position = "absolute";
			bar.style.left = parseInt(sourceDiv.style.width)-5+'px';
			bar.style.top= '0px';
			bar.style.width = '10px';
			bar.style.height = parseInt(sourceDiv.style.height)+'px';
			bar.style.cursor = "ew-resize";
			bar.style.zIndex = "100";
			this.handle = [];
			var o = {};
			o.div = bar;
			o.col = sourceDiv;
			o.pos = 0;
		    ZLM.registerDragItem(o.div,this);
			this.handle[0] = o;
		}
		// - WAL177
	}
	catch(ex) {
		zenExceptionHandler(ex,arguments,'Error in adjustSizes');
	}
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// + WAL177

]]></Content>
</UDLText>

<Method name="startDrag">
<Description>
Callback to initiate window resize event</Description>
<FormalSpec>engine,wrapper</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var idx = 0;
	while (this.handle[idx] && this.handle[idx].div!=wrapper.node) idx++;

	this.barInMotion = this.handle[idx];
	this.startingX = this.barInMotion.div.offsetLeft;
	this.startingW = this.barInMotion.col.offsetWidth;

	if (idx==0) this.minX = 10;
	else this.minX = this.handle[idx-1].div.offsetLeft+10;
	if (idx==this.handle.length-1) this.maxX = this.handle[idx].div.parentNode.offsetWidth-20;
	else this.maxX = this.handle[idx+1].div.offsetLeft-10;
]]></Implementation>
</Method>

<Method name="endDrag">
<Description>
Callback to wrap up window resize event </Description>
<FormalSpec>engine,wrapper</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	zenPage.adjustSizes();
]]></Implementation>
</Method>

<Method name="constrainDragX">
<Description>
Callback to limit horizontal resizing</Description>
<FormalSpec>engine,wrapper,intendedX</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var newX = intendedX;
	if (newX<this.minX) newX = this.minX;
	if (newX>this.maxX) newX = this.maxX;
	
	var newDelta = newX - this.startingX;
	this.barInMotion.col.style.width = (this.startingW+newDelta)+"px";
	zenPage.adjustSizes();
	return(newX);
]]></Implementation>
</Method>

<Method name="constrainDragY">
<Description>
Callback to limit vertical resizing</Description>
<FormalSpec>engine,wrapper,intendedY</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return(0);
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// - WAL177

]]></Content>
</UDLText>

<Method name="updateTable">
<Description>
Update the contents of the model table.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.renderTable();
	if ((''!==this.currItem)&&(''!==this.currItemType)) {
		// DTB190 - Re-select the item
		this.selectItem(this.currItemType,this.currItem,true);
	}
]]></Implementation>
</Method>

<Method name="renderTable">
<Description>
Update the contents of the model table.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var table = zen('modelTableBody');
	var html = new Array();
	var cube = this.getCubeObject();
	var inheritedCube = this.getInheritedCubeObject();		// DTB156
	var source,type;

	// maps row number in the table back to an item in the model
	this._rowIndex = new Array();
	// DTB156 - maintains a record of which displayed items are inherited
	this._inheritedIndex = new Array();
	
	// n.b., we add a _parent and _index decoration to each element in the tree as we render
	if (null == cube) {
		html[html.length] = '<div class="modelError">' + this.msgInvalid + '</div>';
	}
	else {
		// we also add an array to track if disclosures are open or closed
		if (null == cube._contracted) {
			cube._contracted = new Object();
		}
		
		// WAL177
		html[html.length] = '<div id="resize" class="hzResizeBar" onmousedown="ZLM.drag(this,event);">';
		html[html.length] = '</div>';

		// create table displaying cube model.
		html[html.length] = '<table class="modelTable" border="0" cellspacing="0">';
		var indentDim = '<img height="1px" width="16px" src="images/spacer.gif"/>';
		var indentMea = '<img height="1px" width="32px" src="images/spacer.gif"/>';
		var indentHier = '<img height="1px" width="48px" src="images/spacer.gif"/>';
		var indentLevel = '<img height="1px" width="62px" src="images/spacer.gif"/>';
		var indentProperty = '<img height="1px" width="78px" src="images/spacer.gif"/>';
		var disc = '';
		var remove = '';
		var enabler = '';
		var style = '';
		var measureList = '';
		var listingList = '';
		// cube
		source = cube.sourceClass;

		type = 'cube';
		this._rowIndex[this._rowIndex.length] = cube;
		html[html.length] = '<tr class="modelRowCube" id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'cube\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
		html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
		html[html.length] = '<td>' + zenEscapeXML(cube.name) + '</td>';
		html[html.length] = '<td>' + $$$Text("Element Type") + '&nbsp;</td>';
		html[html.length] = '<td>' + $$$Text("Details") + '&nbsp;</td>';
		html[html.length] = '<td>' + enabler + '&nbsp;</td>';
		html[html.length] = '<td>' + remove + '&nbsp;</td>';
		html[html.length] = '</tr>';

		// measures
		type = '';
		this._rowIndex[this._rowIndex.length] = 'measures';
		var closed = this.isClosed(cube,'measures');
		disc = '<img width="16px" src="' + (!closed ? 'images/arrow1D.gif' : 'images/arrow1R.gif') + '" onclick="zenPage.toggleDisclosure(\'measures\');"/>';

		html[html.length] = '<tr class="modelRowDimension" id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'measures\','+(this._rowIndex.length-1)+');" onmouseover="zenPage.rowMouseOver(\'measure\',this);" onmouseout="zenPage.rowMouseOut(this);">';
		html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
		html[html.length] = '<td>' + disc + $$$Text('Measures') + '</td>';
		html[html.length] = '<td>' + type + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;' + '</td>';
		html[html.length] = '<td>' + enabler + '&nbsp;</td>';
		html[html.length] = '<td>' + remove + '&nbsp;</td>';
		html[html.length] = '</tr>';
		if (!closed) {
			this.renderCubeItems(cube,'measure',html);
			if (inheritedCube) {
				// DTB156 - Add inherited measures
				this.renderCubeItems(inheritedCube,'measure',html);
			}
		}
		
		// dimensions
		this._rowIndex[this._rowIndex.length] = 'dimensions';
		closed = this.isClosed(cube,'dimensions');
		disc = '<img width="16px" src="' + (!closed ? 'images/arrow1D.gif' : 'images/arrow1R.gif') + '" onclick="zenPage.toggleDisclosure(\'dimensions\');" onmouseover="zenPage.rowMouseOver(\'dimension\',this);" onmouseout="zenPage.rowMouseOut(this);"/>';

		html[html.length] = '<tr class="modelRowDimension" id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'dimensions\','+(this._rowIndex.length-1)+');" onmouseover="zenPage.rowMouseOver(\'dimension\',this);" onmouseout="zenPage.rowMouseOut(this);">';
		html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
		html[html.length] = '<td >' + disc + $$$Text('Dimensions') + '</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '</tr>';
		if (!closed) {
			this.renderCubeItems(cube,'dimension',html);
			if (inheritedCube) {
				// DTB156 - Add inherited dimensions
				this.renderCubeItems(inheritedCube,'dimension',html);
			}
	  	}
	  	
	  	// listings
		this._rowIndex[this._rowIndex.length] = 'listings';
		var closed = this.isClosed(cube,'listings');
		disc = '<img width="16px" src="' + (!closed ? 'images/arrow1D.gif' : 'images/arrow1R.gif') + '" onclick="zenPage.toggleDisclosure(\'listings\');"/>';
		html[html.length] = '<tr class="modelRowDimension" id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'listings\','+(this._rowIndex.length-1)+');" onmouseover="zenPage.rowMouseOver(\'listing\',this);" onmouseout="zenPage.rowMouseOut(this);">';
		html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
		html[html.length] = '<td>' + disc + $$$Text('Listings') + '</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '</tr>';	
		if (!closed) {
			this.renderCubeItems(cube,'listing',html);
			if (inheritedCube) {
				// DTB156 - Add inherited listings
				this.renderCubeItems(inheritedCube,'listing',html);
			}
		}
		
	  	// listing fields JSL4434
		this._rowIndex[this._rowIndex.length] = 'listingFields';		// DTB156 - plural reference to listingFields at top level
		var closed = this.isClosed(cube,'listingFields');
		disc = '<img width="16px" src="' + (!closed ? 'images/arrow1D.gif' : 'images/arrow1R.gif') + '" onclick="zenPage.toggleDisclosure(\'listingFields\');"/>';
		html[html.length] = '<tr class="modelRowDimension" id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'listingFields\','+(this._rowIndex.length-1)+');" onmouseover="zenPage.rowMouseOver(\'listingField\',this);" onmouseout="zenPage.rowMouseOut(this);">';
		html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
		html[html.length] = '<td>' + disc + $$$Text('Listing Fields') + '</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '</tr>';	
		if (!closed) {
			this.renderCubeItems(cube,'listingField',html);
			if (inheritedCube) {
				// DTB156 - Add inherited listingFields
				this.renderCubeItems(inheritedCube,'listingField',html);
			}
		}
		
	  	// calculated members
		this._rowIndex[this._rowIndex.length] = 'calculatedMembers';
		closed = this.isClosed(cube,'calculatedMembers');
		disc = '<img width="16px" src="' + (!closed ? 'images/arrow1D.gif' : 'images/arrow1R.gif') + '" onclick="zenPage.toggleDisclosure(\'calculatedMembers\');"/>';

		html[html.length] = '<tr class="modelRowDimension" id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'calculatedMembers\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
		html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
		html[html.length] = '<td>' + disc + $$$Text('Calculated Members') + '</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '</tr>';	
		if (!closed) {
			this.renderCubeItems(cube,'calculatedMember',html);
			if (inheritedCube) {
				// DTB156 - Add inherited calcMembers
				this.renderCubeItems(inheritedCube,'calculatedMember',html);
			}
		}	
		
	  	// namedSets
		this._rowIndex[this._rowIndex.length] = 'namedSets';
		closed = this.isClosed(cube,'namedSets');
		disc = '<img width="16px" src="' + (!closed ? 'images/arrow1D.gif' : 'images/arrow1R.gif') + '" onclick="zenPage.toggleDisclosure(\'namedSets\');"/>';

		html[html.length] = '<tr class="modelRowDimension" id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'namedSets\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
		html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
		html[html.length] = '<td>' + disc + $$$Text('Named Sets') + '</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '</tr>';	
		if (!closed) {
			this.renderCubeItems(cube,'namedSet',html);
			if (inheritedCube) {
				// DTB156 - Add inherited named sets
				this.renderCubeItems(inheritedCube,'namedSet',html);
			}
		}

	  	// relationships
		this._rowIndex[this._rowIndex.length] = 'relationships';
		closed = this.isClosed(cube,'relationships');
		disc = '<img width="16px" src="' + (!closed ? 'images/arrow1D.gif' : 'images/arrow1R.gif') + '" onclick="zenPage.toggleDisclosure(\'relationships\');"/>';

		html[html.length] = '<tr class="modelRowDimension" id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'relationships\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
		html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
		html[html.length] = '<td>' + disc + $$$Text('Relationships') + '</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '</tr>';
		if (!closed) {
			this.renderCubeItems(cube,'relationship',html);
			if (inheritedCube) {
				// DTB156 - Add inherited relationships
				this.renderCubeItems(inheritedCube,'relationship',html);
			}
		}
		
		// +DTB390
		// expressions
		this._rowIndex[this._rowIndex.length] = 'expressions';
		closed = this.isClosed(cube,'expressions');
		disc = '<img width="16px" src="' + (!closed ? 'images/arrow1D.gif' : 'images/arrow1R.gif') + '" onclick="zenPage.toggleDisclosure(\'expressions\');"/>';

		html[html.length] = '<tr class="modelRowDimension" id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'expressions\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
		html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
		html[html.length] = '<td>' + disc + $$$Text('Expressions') + '</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '<td>' + '&nbsp;</td>';
		html[html.length] = '</tr>';
		if (!closed) {
			this.renderCubeItems(cube,'expression',html);
			if (inheritedCube) {
				this.renderCubeItems(inheritedCube,'expression',html);
			}
		}		
		// -DTB390
		
		html[html.length] = '</table>'; 
	}
	table.setContent(html.join(''));
	this.expandAll = 2;
]]></Implementation>
</Method>

<Method name="renderCubeItems">
<Description>
Render the actual items in a given group type in the table. This does not draw the 
title bars.</Description>
<FormalSpec>cube,itemGroupType,html</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB156
	var table = zen('modelTableBody');
	var source,type;
	var inherited = (zenPage.inheritsFrom.toUpperCase()==cube.name.toUpperCase());		// DTB172 - Cube names are not case-sensitive

	if (true) {
		// we also add an array to track if disclosures are open or closed
		if (null == cube._contracted) {
			cube._contracted = new Object();
		}

		var indentDim = '<img height="1px" width="16px" src="images/spacer.gif"/>';
		var indentMea = '<img height="1px" width="32px" src="images/spacer.gif"/>';
		var indentHier = '<img height="1px" width="48px" src="images/spacer.gif"/>';
		var indentLevel = '<img height="1px" width="62px" src="images/spacer.gif"/>';
		var indentProperty = '<img height="1px" width="78px" src="images/spacer.gif"/>';
		var disc = '';
		var remove = '';
		var enabler = '';
		var style = '';
		var measureList = '';
		var listingList = '';
		
		// DTB156 - Coordinated styling for inherited items 
		var inheritedBackground = ''; 
		var inheritedFontStyle = 'font-style:italic';
		
		if (inherited) {
			style = 'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';		// DTB156
		}

		switch (itemGroupType) {
			// measures
			case 'measure':
				for (var m = 0; m < cube.measures.length; m++) {
					var msr = cube.measures[m];
					if ((inherited)&&(this.findRowForItemName(msr.name,itemGroupType)>-1)) {
						// DTB156 - This has been overriden in the local definition
						continue;
					}
					msr._parent = cube;
					msr._index = m;
					this._inheritedIndex[this._rowIndex.length] = inherited;
					this._rowIndex[this._rowIndex.length] = msr;
					
					var type = msr.type + " " + $$$Text("measure");
					var details = (msr.type == 'string' || msr.type == 'text' || msr.type == 'iKnow') ? '' : msr.aggregate;
					var source = (msr.sourceExpression!='') ? this.lblExpression : msr.sourceProperty;
					
					// DTB156 - adjust behavior based on local or inherited definition
					if (inherited) {
						remove = '';
						style = (msr.disabled) ?
										'style="background:#C0C0C0;'+inheritedFontStyle+';"' :
										'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';
					}
					else {
						remove = '<img width="16px" src="' + 'deepsee/close_a_16.png' + '" title="' + this.hlpRemove + '" onclick="zenPage.removeItem(\'measure\','+(this._rowIndex.length-1)+','+m+');" />';
						style = (msr.disabled) ? 'style="background:#C0C0C0;"' : '';
					}
					
					html[html.length] = '<tr class="modelRowMeasure" '+style+' id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'measure\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
					html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
					html[html.length] = '<td>' + indentMea + zenEscapeXML(msr.name) + '</td>';
					html[html.length] = '<td>' + type + '&nbsp;</td>';
					html[html.length] = '<td>' + details + ' ' + source + '&nbsp;</td>';
					html[html.length] = '<td>' + remove + '&nbsp;</td>';	
					html[html.length] = '<td>' + '&nbsp;</td>';
					html[html.length] = '</tr>';
					
					if (msr.disabled == 0) {
						if (measureList != "") measureList = measureList + ",";
						measureList = measureList + msr.name;
					}
				}
				if (!inherited) {		// DTB156
					zen("detailCubeDefaultMeasure").setProperty("valueList",measureList);
				}
			break;

			// dimensions
			case 'dimension':
				for (var d = 0; d < cube.dimensions.length; d++) {
					var dim = cube.dimensions[d];
					if ((inherited)&&(this.findRowForItemName(dim.name,itemGroupType)>-1)) {
						// DTB156 - This has been overriden in the local definition
						continue;
					}
					
					if ((('time'==dim.type)||('age'==dim.type))&&(''==dim.calendar)) {
						// DTB190 - Assign the gregorian calendar to the serialized time dimension
						dim.calendar = 'gregorian';
					}
					
					dim._parent = cube;
					dim._index = d;
					this._inheritedIndex[this._rowIndex.length] = inherited;
					this._rowIndex[this._rowIndex.length] = dim;
					
					var source = dim.sourceProperty;
					var type = dim.type + " " + $$$Text("dimension");
					if (dim.sharesFrom != "") {
						type = $$$Text("Shared dimension");
						source = dim.sharesFrom;
					}
					var isTime = ('time' == dim.type);
					var closed = cube._contracted['dim'+d];
					disc = '<img width="16px" src="' + (!closed ? 'images/arrow1D.gif' : 'images/arrow1R.gif') + '" onclick="zenPage.toggleDisclosure(\'dim'+d+'\');"/>';

					// DTB156 - adjust behavior based on local or inherited definition
					if (inherited) {
						remove = '';
						style = (dim.disabled) ?
										'style="background:#C0C0C0;'+inheritedFontStyle+';"' :
										'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';
					}
					else {
						remove = '<img width="16px" src="' + 'deepsee/close_a_16.png' + '" title="' + this.hlpRemove + '" onclick="zenPage.removeItem(\'dimension\','+(this._rowIndex.length-1)+','+d+');" />';
						style = (dim.disabled) ? 'style="background:#C0C0C0;"' : '';
					}
					
					html[html.length] = '<tr class="modelRowDimension" '+style+' id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'dimension\','+(this._rowIndex.length-1)+');" onmouseover="zenPage.rowMouseOver(\'hierarchy\',this);" onmouseout="zenPage.rowMouseOut(this);">';
					html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
					html[html.length] = '<td>' + indentDim + disc + zenEscapeXML(dim.name) + '</td>';
					html[html.length] = '<td>' + type + '&nbsp;</td>';
					html[html.length] = '<td>' + source + '&nbsp;</td>';
					html[html.length] = '<td>' + remove + '&nbsp;</td>';
					html[html.length] = '<td>' + '&nbsp;</td>';
					html[html.length] = '</tr>';

					if (!closed) {
						for (var h = 0; h < dim.hierarchies.length; h++) {
							var hier = dim.hierarchies[h];
							hier._parent = dim;
							hier._index = h;
							hier._dimtype = dim.type;
							hier._calendar = (('time'==dim.type)||('age'==dim.type)) ? dim.calendar : ''; 		// DTB180
							this._inheritedIndex[this._rowIndex.length] = inherited;
							this._rowIndex[this._rowIndex.length] = hier;
							type = 'hierarchy';
							
							// DTB156 - adjust behavior based on local or inherited definition
							if (inherited) {
								remove = '';
								style = (dim.disabled||hier.disabled) ? 
											'style="background:#C0C0C0;'+inheritedFontStyle+';"' :
											'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';
							}
							else {
								remove = '<img width="16px" src="' + 'deepsee/close_a_16.png' + '" title="' + this.hlpRemove + '" onclick="zenPage.removeItem(\'hierarchy\','+(this._rowIndex.length-1)+','+d+','+h+');" />';
								style = (dim.disabled||hier.disabled) ? 'style="background:#C0C0C0;"' : '';
							}
							
							html[html.length] = '<tr class="modelRowHierarchy" '+style+' id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'hierarchy\','+(this._rowIndex.length-1)+');" onmouseover="zenPage.rowMouseOver(\'level\',this);" onmouseout="zenPage.rowMouseOut(this);">';
							html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
							html[html.length] = '<td>' + indentHier + zenEscapeXML(hier.name) + '</td>';
							html[html.length] = '<td>' + type + '&nbsp;</td>';
							html[html.length] = '<td>' + '&nbsp;' + '</td>';
							html[html.length] = '<td>' + remove + '&nbsp;</td>';
							html[html.length] = '<td>' + '&nbsp;</td>';
							html[html.length] = '</tr>';
							var hierLen = hier.levels.length;
							var levelnum = 0
							for (var l = 0; l < hierLen; l++) {
								var level = hier.levels[l];
								level._dimtype = dim.type;
								level._calendar = (('time'==dim.type)||('age'==dim.type)) ? dim.calendar : '';		// DTB180
								level._parent = hier;
								level._index = l;
								levelnum++;
								this._inheritedIndex[this._rowIndex.length] = inherited;
								this._rowIndex[this._rowIndex.length] = level;
								type = 'level';
								source = (level.sourceExpression!='') ? this.lblExpression : level.sourceProperty;
								if (isTime) {
									source = level.timeFunction;
								}
								
								// DTB156 - adjust behavior based on local or inherited definition
								if (inherited) {
									remove = '';
									moveup = '';
									movedn = '';
									style = (dim.disabled||hier.disabled||level.disabled) ? 
											'style="background:#C0C0C0;'+inheritedFontStyle+';"' :
											'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';
								}
								else {
									remove = '<img width="16px" src="' + 'deepsee/close_a_16.png' + '" title="' + this.hlpRemove + '" onclick="zenPage.removeItem(\'level\','+(this._rowIndex.length-1)+','+d+','+h+','+l+');" />';
									if (hierLen > 1) {
										moveup = '<img width="16px" src="' + 'deepsee/up_16.png' + '" title="' + this.hlpMoveUp + '" onclick="zenPage.moveItemUp(\'level\','+(this._rowIndex.length-1)+','+d+','+h+','+l+');" />';
										movedn = '<img width="16px" src="' + 'deepsee/down_16.png' + '" title="' + this.hlpMoveDown + '" onclick="zenPage.moveItemDown(\'level\','+(this._rowIndex.length-1)+','+d+','+h+','+l+');" />';
									} else {
										moveup = '';
										movedn = '';
									}
									style = (dim.disabled||hier.disabled||level.disabled) ? 'style="background:#C0C0C0;"' : '';
								}
								
								html[html.length] = '<tr class="modelRowLevel" '+style+' id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'level\','+(this._rowIndex.length-1)+');" onmouseover="zenPage.rowMouseOver(\'property\',this);" onmouseout="zenPage.rowMouseOut(this);">';
								html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
								html[html.length] = '<td>' + indentLevel + zenEscapeXML(level.name) + '</td>';
								html[html.length] = '<td>' + type + '&nbsp;'+levelnum + '&nbsp;</td>';
								html[html.length] = '<td>' + source + '&nbsp;</td>';
								html[html.length] = '<td>' + remove + '&nbsp;</td>';
								html[html.length] = '<td>' + moveup + '&nbsp;' + movedn + '</td>';
								html[html.length] = '</tr>';

								var propLen = level.properties.length;
								for (var p = 0; p < propLen; p++) {
									var prop = level.properties[p];
									prop._parent = level;
									prop._index = p;
									this._inheritedIndex[this._rowIndex.length] = inherited;		// DTB156
									this._rowIndex[this._rowIndex.length] = prop;
									type = 'property';
									source = (prop.sourceExpression!='') ? this.lblExpression : prop.sourceProperty;
									
									if (inherited) {
										// DTB156 - adjust behavior based on local or inherited definition
										remove = '';
										moveup = '';
										movedn = '';
										style = (dim.disabled||hier.disabled||level.disabled||prop.disabled) ? 
											'style="background:#C0C0C0;'+inheritedFontStyle+';"' :
											'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';
									}
									else {
										remove = '<img width="16px" src="' + 'deepsee/close_a_16.png' + '" title="' + this.hlpRemove + '" onclick="zenPage.removeItem(\'property\','+(this._rowIndex.length-1)+','+d+','+h+','+l+','+p+');" />';
										if (propLen > 1) {
											moveup = '<img width="16px" src="' + 'deepsee/up_16.png' + '" title="' + this.hlpMoveUp + '" onclick="zenPage.moveItemUp(\'property\','+(this._rowIndex.length-1)+','+d+','+h+','+l+','+p+');" />';
											movedn = '<img width="16px" src="' + 'deepsee/down_16.png' + '" title="' + this.hlpMoveDown + '" onclick="zenPage.moveItemDown(\'property\','+(this._rowIndex.length-1)+','+d+','+h+','+l+','+p+');" />';
										} else {
											moveup = '';
											movedn = '';
										}
										style = (dim.disabled||hier.disabled||level.disabled||prop.disabled) ? 'style="background:#C0C0C0;"' : '';
									}

									html[html.length] = '<tr class="modelRowProperty" '+style+' id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'property\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
									html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
									html[html.length] = '<td>' + indentProperty + zenEscapeXML(prop.name) + '</td>';
									html[html.length] = '<td>' + type + '&nbsp;</td>';
									html[html.length] = '<td>' + source + '&nbsp;</td>';
									html[html.length] = '<td>' + remove + '&nbsp;</td>';
									html[html.length] = '<td>' + moveup + '&nbsp;' + movedn + '</td>';
									html[html.length] = '</tr>';
								}
							}
						}
					}
				}
				break;
		  	
		  	// listings
			case 'listing':
				if (inherited) {
					// DTB190 - Inherited is rendered second. Pick up the previously accumulated listings
					listingList = zen('detailCubeDefaultListing').getProperty('valueList');
				}

				for (var d = 0; d < cube.listings.length; d++) {
					var list = cube.listings[d];
					if ((inherited)&&(this.findRowForItemName(list.name,itemGroupType)>-1)) {
						// DTB156 - This has been overriden in the local definition
						continue;
					}
					list._parent = cube;
					list._index = d;
					this._inheritedIndex[this._rowIndex.length] = inherited;		// DTB156
					this._rowIndex[this._rowIndex.length] = list;
					type = 'listing';
					var isdefault = '';
					if (list.name == cube.defaultListing) isdefault = "&nbsp;("+$$$Text("default")+")";
					
					if (inherited) {
						// DTB156 - adjust behavior based on local or inherited definition
						remove = '';
						style = (list.disabled) ?
										'style="background:#C0C0C0;'+inheritedFontStyle+';"' :
										'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';
					}
					else {
						remove = '<img width="16px" src="' + 'deepsee/close_a_16.png' + '" title="' + this.hlpRemove + '" onclick="zenPage.removeItem(\'listing\','+(this._rowIndex.length-1)+','+d+');" />';
						style = (list.disabled) ? 'style="background:#C0C0C0;"' : '';
					}
					
					// show sql if it's defined. ow show fieldList.
					var fieldList = (list.sql != "") ? list.sql : list.fieldList;
					if (fieldList.length > 40) fieldList = fieldList.substring(0,40) + "...";
					html[html.length] = '<tr class="modelRowMeasure" '+style+' id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'listing\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
					html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
					html[html.length] = '<td>' + indentMea + zenEscapeXML(list.name) + '</td>';
					html[html.length] = '<td>' + type + isdefault + '&nbsp;</td>';
					html[html.length] = '<td>' + zenEscapeXML(fieldList) + '&nbsp;</td>';
					html[html.length] = '<td>' + remove + '&nbsp;</td>';
					html[html.length] = '<td>' + '&nbsp;</td>';
					html[html.length] = '</tr>';
					if (list.disabled == 0) {
						if (listingList != "") listingList = listingList + ",";
						listingList = listingList + list.name;
					}
				}
				zen('detailCubeDefaultListing').setProperty('valueList',listingList);
				break;
			
		  	// listing fields JSL4434
			case 'listingField':
				for (var d = 0; d < cube.listingFields.length; d++) {
					var field = cube.listingFields[d];
					//console.log('name=' + field.name + ' itemGroupType=' + itemGroupType + ' row return: ' + this.findRowForItemName(field.name,itemGroupType));
					if ((inherited)&&(this.findRowForItemName(field.name,itemGroupType)>-1)) {
						// DTB156 - This has been overriden in the local definition
						continue;
					}
					field._parent = cube;
					field._index = d;
					this._inheritedIndex[this._rowIndex.length] = inherited;		// DTB156
					this._rowIndex[this._rowIndex.length] = field;
					type = 'listingField';
					var isdefault = '';
					
					if (inherited) {
						// DTB156 - adjust behavior based on local or inherited definition
						remove = '';
						style = (field.disabled) ?
										'style="background:#C0C0C0;'+inheritedFontStyle+';"' :
										'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';
					}
					else {
						remove = '<img width="16px" src="' + 'deepsee/close_a_16.png' + '" title="' + this.hlpRemove + '" onclick="zenPage.removeItem(\'listingField\','+(this._rowIndex.length-1)+','+d+');" />';
						style = (field.disabled) ? 'style="background:#C0C0C0;"' : '';
					}
					
					var fieldExpression = field.fieldExpression;
					if (fieldExpression.length > 40) fieldExpression = fieldExpression.substring(0,40) + "...";
			
					html[html.length] = '<tr class="modelRowMeasure" '+style+' id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'listingField\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
					html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
					html[html.length] = '<td>' + indentMea + zenEscapeXML(field.name) + '</td>';
					html[html.length] = '<td>' + type + isdefault + '&nbsp;</td>';
					html[html.length] = '<td>' + zenEscapeXML(fieldExpression) + '&nbsp;</td>';
					html[html.length] = '<td>' + remove + '&nbsp;</td>';
					html[html.length] = '<td>' + '&nbsp;</td>';
					html[html.length] = '</tr>';
				}
				break;
			
		  	// calculated members
			case 'calculatedMember':
				for (var d = 0; d < cube.calculatedMembers.length; d++) {
					var member = cube.calculatedMembers[d];
					if ((inherited)&&(this.findRowForItemName(member.name,itemGroupType)>-1)) {
						// DTB156 - This has been overriden in the local definition
						continue;
					}
					member._parent = cube;
					member._index = d;
					this._inheritedIndex[this._rowIndex.length] = inherited;		// DTB156
					this._rowIndex[this._rowIndex.length] = member;
					type = 'calculatedMember';
					
					if (inherited) {
						// DTB156 - adjust behavior based on local or inherited definition
						remove = '';
						style = (member.disabled) ?
										'style="background:#C0C0C0;'+inheritedFontStyle+';"' :
										'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';
					}
					else {
						remove = '<img width="16px" src="' + 'deepsee/close_a_16.png' + '" title="' + this.hlpRemove + '" onclick="zenPage.removeItem(\'calculatedMember\','+(this._rowIndex.length-1)+','+d+');" />';
						style = (member.disabled) ? 'style="background:#C0C0C0;"' : '';
					}
					
					html[html.length] = '<tr class="modelRowMeasure" '+style+' id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'calculatedMember\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
					html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
					html[html.length] = '<td>' + indentMea + zenEscapeXML(member.name) + '</td>';
					html[html.length] = '<td>' + type + '&nbsp;</td>';
					html[html.length] = '<td>' + member.dimension + '&nbsp;</td>';
					html[html.length] = '<td>' + remove + '&nbsp;</td>';
					html[html.length] = '<td>' + '&nbsp;</td>';
					html[html.length] = '</tr>';
				}
				break;
				
		  	// namedSets	
			case 'namedSet':
				for (var d = 0; d < cube.namedSets.length; d++) {
					var member = cube.namedSets[d];
					if ((inherited)&&(this.findRowForItemName(member.name,itemGroupType)>-1)) {
						// DTB156 - This has been overriden in the local definition
						continue;
					}
					member._parent = cube;
					member._index = d;
					this._inheritedIndex[this._rowIndex.length] = inherited;
					this._rowIndex[this._rowIndex.length] = member;
					type = 'namedSet';
					var setExpression = member.setExpression;
					if (setExpression.length > 40) setExpression = setExpression.substring(0,40) + "...";
					
					if (inherited) {
						// DTB156 - adjust behavior based on local or inherited definition
						remove = '';
						style = (member.disabled) ?
										'style="background:#C0C0C0;'+inheritedFontStyle+';"' :
										'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';
					}
					else {
						remove = '<img width="16px" src="' + 'deepsee/close_a_16.png' + '" title="' + this.hlpRemove + '" onclick="zenPage.removeItem(\'namedSet\','+(this._rowIndex.length-1)+','+d+');" />';
						style = (member.disabled) ? 'style="background:#C0C0C0;"' : '';
					}
					
					html[html.length] = '<tr class="modelRowMeasure" '+style+' id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'namedSet\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
					html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
					html[html.length] = '<td>' + indentMea + zenEscapeXML(member.name) + '</td>';
					html[html.length] = '<td>' + type + '&nbsp;</td>';
					html[html.length] = '<td>' + zenEscapeXML(setExpression) + '&nbsp;</td>';
					html[html.length] = '<td>' + remove + '&nbsp;</td>';
					html[html.length] = '<td>' + '&nbsp;</td>';
					html[html.length] = '</tr>';
				}
				break;

		  	// relationships
			case 'relationship':
				for (var d = 0; d < cube.relationships.length; d++) {
					var member = cube.relationships[d];
					if ((inherited)&&(this.findRowForItemName(member.name,itemGroupType)>-1)) {
						// DTB156 - This has been overriden in the local definition
						continue;
					}
					member._parent = cube;
					member._index = d;
					this._inheritedIndex[this._rowIndex.length] = inherited;		// DTB156
					this._rowIndex[this._rowIndex.length] = member;
					type = 'relationship';
					var sourceExpression = member.sourceExpression;
					if (sourceExpression.length > 40) sourceExpression = sourceExpression.substring(0,40) + "...";				
					
					if (inherited) {
						// DTB156 - adjust behavior based on local or inherited definition
						remove = '';
						style = (member.disabled) ?
										'style="background:#C0C0C0;'+inheritedFontStyle+';"' :
										'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';
					}
					else {
						remove = '<img width="16px" src="' + 'deepsee/close_a_16.png' + '" title="' + this.hlpRemove + '" onclick="zenPage.removeItem(\'relationship\','+(this._rowIndex.length-1)+','+d+');" />';
						style = (member.disabled) ? 'style="background:#C0C0C0;"' : '';
					}
					
					html[html.length] = '<tr class="modelRowMeasure" '+style+' id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'relationship\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
					html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
					html[html.length] = '<td>' + indentMea + zenEscapeXML(member.name) + '</td>';
					html[html.length] = '<td>' + type + '&nbsp;</td>';
					html[html.length] = '<td>' + zenEscapeXML(sourceExpression) + '&nbsp;</td>';
					html[html.length] = '<td>' + remove + '&nbsp;</td>';
					html[html.length] = '<td>' + '&nbsp;</td>';
					html[html.length] = '</tr>';
				}
				break;
			// expressions
			case 'expression':
				// Case added by DTB390
				for (var d = 0; d < cube.expressions.length; d++) {
					var member = cube.expressions[d];
					if ((inherited)&&(this.findRowForItemName(member.name,itemGroupType)>-1)) {
						continue;
					}
					member._parent = cube;
					member._index = d;
					this._inheritedIndex[this._rowIndex.length] = inherited;
					this._rowIndex[this._rowIndex.length] = member;
					type = 'expression';
					var sourceExpression = member.sourceExpression;
					if (sourceExpression.length > 40) sourceExpression = sourceExpression.substring(0,40) + "...";				
					
					if (inherited) {
						remove = '';
						style = (member.disabled) ?
										'style="background:#C0C0C0;'+inheritedFontStyle+';"' :
										'style="background:'+inheritedBackground+';'+inheritedFontStyle+';"';
					}
					else {
						remove = '<img width="16px" src="' + 'deepsee/close_a_16.png' + '" title="' + this.hlpRemove + '" onclick="zenPage.removeItem(\'expression\','+(this._rowIndex.length-1)+','+d+');" />';
						style = (member.disabled) ? 'style="background:#C0C0C0;"' : '';
					}
					
					html[html.length] = '<tr class="modelRowMeasure" '+style+' id="row_'+(this._rowIndex.length-1)+'" onclick="zenPage.rowClick(\'expression\','+(this._rowIndex.length-1)+');" onmouseover="this.style.color=\'orange\';" onmouseout="this.style.color=\'\';">';
					html[html.length] = '<td width="10">' + '<span class="selector">&raquo;</span>' + '</td>';
					html[html.length] = '<td>' + indentMea + zenEscapeXML(member.name) + '</td>';
					html[html.length] = '<td>' + type + '&nbsp;</td>';
					html[html.length] = '<td>' + zenEscapeXML(sourceExpression) + '&nbsp;</td>';
					html[html.length] = '<td>' + remove + '&nbsp;</td>';
					html[html.length] = '<td>' + '&nbsp;</td>';
					html[html.length] = '</tr>';
				}
				break;
				
			default:
				alert('Unknown type in renderCubeItems');
		}		
	}
]]></Implementation>
</Method>

<Method name="isClosed">
<FormalSpec>cube,item</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var closed = cube._contracted[item];
	if (this.expandAll == 0) {
		closed = true;
		cube._contracted[item]=true;
	} 
	if (this.expandAll == 1){
		closed = false;
		cube._contracted[item]=false;			
	}
	return closed
]]></Implementation>
</Method>

<Method name="toggleExpand">
<Description>
user clicked Expand All (flag=1) or Collapsed All (flag=0). </Description>
<FormalSpec>flag</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.expandAll = flag;
	this.updateTable();
]]></Implementation>
</Method>

<Method name="findRowForItem">
<Description>
Find the row number in the table for the given model item.
This must be called after the table has been rendered.</Description>
<FormalSpec>item</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var row = -1;
	if (this._rowIndex) {
		for (var r = 0; r < this._rowIndex.length; r++) {
			if (this._rowIndex[r] === item) {
				row = r;
				break;
			}
		}
	}
	return row;
]]></Implementation>
</Method>

<Method name="findRowForItemName">
<Description><![CDATA[
Find the row number in the table for the given model item name.
If <var>itemGroup</var> is defined, return the first occurence of 
<var>name</var> within the particular group of model items.
This must be called after the table has been rendered.]]></Description>
<FormalSpec>name,itemGroup</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB156
	var row = -1;
	var itemType = '';
	if (this._rowIndex) {
		for (var r = 0; r < this._rowIndex.length; r++) {
			if (this._rowIndex[r].name == name) {
				if ((!itemGroup)||(this._rowIndex[r]._class.split('.')[2] == itemGroup)) {
					// Return the first occurence of the name if itemGroup is not defined
					row = r;
					break;
				}
			}
		}
	}
	return row;
]]></Implementation>
</Method>

<Method name="%OnAfterCreatePage">
<Description>
This class method callback is called just before the server-side page 
object is created.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tSC = ##super()
		If $$$ISERR(tSC) Quit

		// check privileges
		Do CheckArchitectUseAccess^%qdsUtils()
		$$$dsTrackFeature("Architect")		// DTB393

		Set tWrite = $$CheckArchitectWriteAccess^%qdsUtils()
		If ('tWrite) {
			Set ..canWrite = 0
			#; Disable the property details pane 
			Set ..%GetComponentById("tabDetails").disabled = 1
		}
		Set ..readOnly = 0	

		If (..cubeFullName = "") {
			Set ..cubeFullName = $G(^DeepSee.LastCube($UserName))
		}

		// Strip off extension from name
		Set tExt = $P(..cubeFullName,".",$L(..cubeFullName,"."))
		If ((tExt = "cube")||(tExt = "subjectArea")) {
			Set tName = $P(..cubeFullName,".",1,$L(..cubeFullName,".")-1)
			Set ..cubeName = tName
		}
		Else {
			Set tExt = "cube"
			Set ..cubeName = ..cubeFullName
		}

		If (tExt = "subjectArea") {
			#; check if baseCube is compound. If it is, then do not open.
			If ##class(%DeepSee.UI.Dialog.finderDialog).IsCompound(..cubeFullName) '= "" {
				Set ..cubeFullName = ""
			}
			#; show other architect
			Set %response.Redirect = "_DeepSee.UI.ArchitectSA.zen?CUBE="_$ZCVT(..cubeFullName,"O","URL")
			Quit
		}

		If ('##class(%DeepSee.Utils).%CubeExists(..cubeName, .tSC)) {
			Set ..cubeName = ""
			Set ..dataSource = ""
			Set ..%model = ""
			// JMD1202: do not give error
			Set tSC = $$$OK
			Quit
		}

		Set ^DeepSee.LastCube($UserName) = ..cubeName_".cube"
		If ($G(%request.Data("home",1))'="") {
			Set %response.Context("home") = %request.Data("home",1)
		}

		// get class name for cube
		Set ..cubeClass = ##class(%DeepSee.Utils).%GetCubeClass(..cubeName)
		Set ..cubeDescription = ##class(%DeepSee.Utils).%GetCubeDescription(..cubeName)

		Set ..%model = ##class(%DeepSee.Utils).%GetModel(..cubeName, .tSC)
		If $IsObject(..%model) {
			Set ..cubeName = ..%model.name // Get actual name
			Set ..dataSource = ..%model.sourceClass
			Set ..inheritsFrom = ..%model.inheritsFrom		// DTB156

			// test for write access
			If ((..%model.resource'="")&&'$System.Security.Check(..%model.resource,"WRITE")) {
				Set ..readOnly = 1
			}		
			Set ..%GetComponentById("detailCalMemberDimension").context = "%DeepSee.Component.ContextSearch/Dimensions?subject="_..cubeName
		}
		Else {
			Set ..dataSource = ""
		}		
		Set ..%GetComponentById("detailListingSourceClass").valueList = ..LoadListingSource()
		Set pdef = ##class(%Dictionary.CompiledProperty).%OpenId("%DeepSee.Model.measure||aggregate")
		Set VALUELIST = pdef.Parameters.GetAt("VALUELIST")
		Set ..%GetComponentById("detailMeasureAgg").valueList = $P(VALUELIST,",",2,"999")
		Set pdef = ##class(%Dictionary.CompiledProperty).%OpenId("%DeepSee.Model.measure||type")		
		Set VALUELIST = pdef.Parameters.GetAt("VALUELIST")
		Set ..%GetComponentById("detailMeasureType").valueList = $P(VALUELIST,",",2,"999")
		Set ..cubeDomain = $$$comMemberKeyGet(..cubeClass,$$$cCLASSparameter,"DOMAIN",$$$cPARAMdefault)
		Set ..%GetComponentById("detailCubeDomain").value = ..cubeDomain
		
		// +DTB180 - Collect timefunctions for all calendars once and store in a JSON string
		Set ..timeFunctions = """gregorian"":""" _ ..GetTimeLevelClasses("%DeepSee.Time.AbstractLevel","gregorian") _ """"
		Set ..timeFunctions = ..timeFunctions _ ",""partial"":""" _ ..GetTimeLevelClasses("%DeepSee.Time.AbstractLevel","partial") _ """"		// DTB685 - Add partial dates
		Set ..timeFunctions = ..timeFunctions _ ",""hijriTabular"":""" _ ..GetTimeLevelClasses("%DeepSee.Time.AbstractLevel","hijriTabular") _ """"
		Set ..timeFunctions = ..timeFunctions _ ",""hijriObserved"":""" _ ..GetTimeLevelClasses("%DeepSee.Time.AbstractLevel","hijriObserved") _ """"		// DTB182 - Add hijriObserved
		Set ..timeFunctions = "{" _ ..timeFunctions _ "}"
		// -DTB180
		
		// +DTB321 - Use recursive node processing to capture all cubes in folders
		Set tSC = ##class(%DeepSee.Utils).%GetCubeListArray(.tParms,.pMetaData,.pData,"cubes")
		If $$$ISERR(tSC) Quit
		Set tSC = ##class(%DeepSee.Utils).%ProcessCubeListArrayNode(.pData,,.tCubeList)
		If $$$ISERR(tSC) Quit
		Set ..%GetComponentById("detailRelationshipRelatedCube").valueList = tCubeList
		// -DTB321
		
		#; JMD761
		Set tDependsOn = $$$comClassKeyGet(..cubeClass,$$$cCLASSdependson)
		Set ..cubeDependsOn = tDependsOn
		Set ..%GetComponentById("detailCubeDependsOn").value = ..cubeDependsOn

		#; If we are in a version that ResourceList does not exist (such as 2010.2) then hide the Resource image
		If $System.Version.GetMajor() < 2011 {
			Set ..%GetComponentById("btndetailCubeResource").hidden = 1
			Set ..%GetComponentById("btndetailListingResource").hidden = 1
		}
		Set ..DocumaticPage = ..Link("/csp/documatic/%25CSP.Documatic.cls",,1)_"CLASSNAME="_..EscapeURL(..cubeClass)_"&LIBRARY="_..EscapeURL($namespace)
		
		// +DTB730 - Set the tooltip for this checkBox here so it can support line breaks
		Set tSourceTable = ##class(%DeepSee.Utils).%GetSQLTableName(##class(%DeepSee.Utils).%GetSourceClass(..cubeName))
		Set ..%GetComponentById("detailCubeSqlRestrict").title = "Allow use of the special %SQLRESTRICT dimension where users can specify either:" _ $C(10) _
													"SQL SELECT query that returns one column of IDs that represent IDs of the source class." _ $C(10) _
													"SQL WHERE clause that will be added to query 'SELECT %ID from " _ tSourceTable _ "'." _ $C(10,10) _
													"The MDX result will be restricted to the facts built from the specified source IDs, then additional MDX filters will be applied."
		// -DTB730
		
		// DTB949 - Communicate to the client that the current definition failed to compile
		Set ..compileErrorOnLoad = $D($$$DeepSeeMetaGLVN("cubes",$$$UPPER(..cubeName),"compileError"))
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="LoadListingSource">
<Description>
Return Data Connector list</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set valueList = ""	
	// setup Data Connector list for Listings
	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tSC = tRS.Execute("%DeepSee.DataConnector")
	
	While tRS.Next() {
		Set tClass = tRS.GetData(1)
		Set tS = $zobjclassmethod(tClass,"%GetParameter","SUPPORTSIDLIST")
		If tS = 1 Set valueList = valueList _ $S(valueList'="":",",1:"") _ tClass
	}
	Quit valueList
]]></Implementation>
</Method>

<Method name="GetCubeDefinition">
<Description>
Get Cube definition for JSON provider.</Description>
<FormalSpec><![CDATA[&pParms,*pObject:%RegisteredObject]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If $IsObject(..%model) {
		Set pObject = ..%model
	}
	ElseIf (..cubeName'="") {
		Set pObject = ##class(%DeepSee.Utils).%GetModel(..cubeName, .tSC)
		If $$$ISOK(tSC) && $IsObject(pObject) {
			If ..IsSourceControlReadOnly(..GetInternalName()) {
				Set pObject.ReadOnly = 2
			}
		}
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="GetInheritedCubeDefinition">
<Description>
Get the inherited Cube definition for JSON provider.</Description>
<FormalSpec><![CDATA[&pParms,*pObject:%RegisteredObject]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB156
	Set pObject = $$$NULLOREF
	Set tSC = $$$OK
	Set tCubeName = pParms("inheritsFrom")
	
	If (tCubeName'="") {
		Set pObject = ##class(%DeepSee.Utils).%GetModel(tCubeName, .tSC)
		Set tSC = pObject.%ResolveInheritance()		// If this inherits something else, collapse all into a single inherited representation.
		If $$$ISERR(tSC) Quit
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="getTimeFunctionsForCalendar">
<Description>
Report the supported functions for a given calendar.</Description>
<FormalSpec>calendar</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB180
	var functionCalendars = ZLM.jsonParse(zenPage.timeFunctions);
	var functionList = '';
	if (calendar) {
		functionList = functionCalendars[calendar];
	}

	return functionList;
]]></Implementation>
</Method>

<Method name="GetTimeLevelClasses">
<Description>
Produces a list of Time level class delimited by commas.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSubClass,pCalendar="gregorian"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set VALUELIST = ""
	Set tCompare = $$$UPPER($P(pSubClass,".",1,2))
	Set tLen = $L(tCompare)
	// Find all subclasses of Time Level class
	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tSC = tRS.Execute(pSubClass)
	Quit:$$$ISERR(tSC) VALUELIST
	While (tRS.Next(.tSC)) {
		Quit:$$$ISERR(tSC)
		Set tName = $G(tRS.Data("Name"))
		Set tShortName = $P(tName,".",$L(tName,"."))
		// In order to display, check that a time funciton
		// - Is a member of the %DeepSee.Time package (ie: display system functions only)
		// - Uses the appropriate calendar
		If ($E($$$UPPER(tName),1,tLen) = tCompare) && ($Parameter(tName,"CALENDAR")=pCalendar)  {
			Set VALUELIST = VALUELIST_$S(VALUELIST'="":",",1:"")_tShortName
		}
	}
	Quit VALUELIST
]]></Implementation>
</Method>

<Method name="getCubeObject">
<Description>
Return the cube definition object.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var json = this.getComponentById('cube');
	var cube = json.getContentObject();
	return cube;
]]></Implementation>
</Method>

<Method name="getInheritedCubeObject">
<Description>
Return the cube definition object for the inherited cube.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB156
	var json = this.getComponentById('inheritedCube');
	var cube = json.getContentObject();
	return cube;
]]></Implementation>
</Method>

<Method name="getSelectedItem">
<Description>
Return the current selected item.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var item = null;
	if (this.currItem == -1) {
		this.currItem = 0;	
	}	
	if (this._rowIndex) {
		item = this._rowIndex[this.currItem];
	} 
	return item;
]]></Implementation>
</Method>

<Method name="getiKnowMeasures">
<Description>
Return a list of iKnow measures</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var cube = this.getCubeObject();
	var measures = "";
	for (var m = 0; m < cube.measures.length; m++) {
		if (cube.measures[m].type == "iKnow") {
			if (measures != "") measures += ","
			measures += cube.measures[m].name;	
		}
	}
	return measures;
]]></Implementation>
</Method>

<Method name="cancelDetailForm">
<Description>
Cancel changes from detail form.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// reselect item
	this.selectItem(this.currItemType,this.currItem,true);
]]></Implementation>
</Method>

<Method name="setViewModeHandler">
<Description>
Do the actual work of updating the view to match the current view mode.</Description>
<FormalSpec>mode</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	this.adjustSizes();
]]></Implementation>
</Method>

<Method name="changeDataSource">
<Description>
Launch the data source dialog.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (!this.canUserModify()) {
		return;
	}
	zenLaunchPopupWindow('_DeepSee.UI.Dialog.finderDialog.cls?MODE=sourceclasses','DataSource','status,scrollbars,resizable=yes,width=800,height=600');
]]></Implementation>
</Method>

<Method name="onPopupAction">
<Description>
This client event is fired when the a popup page launched from this page fires an action.</Description>
<FormalSpec>popupName,action,value</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (action != 'ok') return false;
	switch(popupName) {
	case 'SubjectArea':
		// pull extension off of name
		var isCube = true;
		var name = '';
		var s = value.toString().split('.');
		if ('cube' == s[s.length-1]) {
			s.length = s.length-1;
			name = s.join('.');
			isCube = true;
		}
		else if ('subjectArea' == s[s.length-1]) {
			s.length = s.length-1;
			name = s.join('.');
			isCube = false;
		}
		if (!isCube) {
			try {
				self.document.location = zenLink('_DeepSee.UI.ArchitectSA.zen?CUBE=' + encodeURIComponent(value));
			}
			catch(ex) {
			}
		}
		else if (name != this.cubeName) {
			try {
				self.document.location = zenLink('_DeepSee.UI.Architect.zen?CUBE=' + encodeURIComponent(value));
			}
			catch(ex) {
			}
		}
		break;
	case 'DataSource':
		if (value != '') {
			// pull extension off of name
			var s = value.toString().split('.');
			if ('cls' == s[s.length-1]) {
				s.length = s.length-1;
				zenPage.setDataSource(s.join('.'));
			}
		}
		break;
	case 'CubeAdd':
		if (value != this.cubeName) {
			try {
				self.document.location = zenLink('_DeepSee.UI.Architect.zen?CUBE=' + encodeURIComponent(value));
			}
			catch(ex) {
			}
		}
		break;	
	case 'CubeSave':
		setTimeout("zenPage.saveCube()",200);
		break;
	case 'CubeCompile':
		break;
	case 'CubeBuild':
		break;
	case 'CubeAddItem':
		if ('' != value) {
			this.addNewItemToModel(value);
		}
		break;
	case 'sourceClass':
		var classname = value.substring(0,value.indexOf('.cls'));
		zen('detailCubeSource').setValue(classname);
		zenPage.applyDetails();
		break;		
	case 'RangeExpression':
		zen('detailLevelRangeExpression').setValue(value);
		zenPage.applyDetails();
		break;	
	case 'FormatString':
		zen('detailMeasureFormatString').setValue(value);
		zenPage.applyDetails();
		break;
	case 'CalMemberFormatString':		// DTB654
		zen('detailCalMemberFormatString').setValue(value)
		zenPage.applyDetails();
		break;
	case 'switchNamespace':
		var homeurl = zenLink("/csp/sys/%25CSP.Portal.Home.zen");
		var url = zenPage.GetNewURL(value,"_DeepSee.UI.Architect.zen");
		if (url == "" || value == "%SYS") url = homeurl;
		try {
			self.document.location = url;
		}
		catch(ex) {
		}
		break;		
	case 'MeasureSource':
		zen('detailMeasureSource').setValue(value);
		zenPage.applyDetails();
		break;
	case 'MeasureExpression':
		zen('detailMeasureExpression').setValue(value);
		zenPage.applyDetails();
		break;
	case 'DimensionSource':
		zen('detailDimensionSource').setValue(value);
		zenPage.applyDetails();
		break;
	case 'DimensionExpression':
		zen('detailDimensionExpression').setValue(value);
		zenPage.applyDetails();
		break;
	case 'LevelSource':
		zen('detailLevelSource').setValue(value);
		zenPage.applyDetails();
		break;
	case 'LevelExpression':
		zen('detailLevelExpression').setValue(value);
		zenPage.applyDetails();
		break;
	case 'LevelDependsOn':
		zen('areadetailLevelDependsOn').setValue(value);
		zenPage.applyDetails();
		break;
	case 'PropertySource':
		zen('detailPropertySource').setValue(value);
		zenPage.applyDetails();
		break;
	case 'PropertyExpression':
		zen('detailPropertyExpression').setValue(value);
		zenPage.applyDetails();
		break;
	case 'RelationshipSource':
		zen('detailRelationshipSource').setValue(value);
		zenPage.applyDetails();
		break;
	case 'RelationshipExpression':
		zen('detailRelationshipExpression').setValue(value);
		zenPage.applyDetails();
		break;
	case 'ListingFieldList':
		zen('areadetailListingFieldList').setValue(value);
		zenPage.applyDetails();
		break;
	case 'ListingSQL':
		zen('areadetailListingSQL').setValue(value);
		zenPage.applyDetails();
		break;
	case 'ListingOrderBy':
		zen('areadetailListingOrderBy').setValue(value);
		zenPage.applyDetails();
		break;
	case 'ListingField': // JSL4436
		zen('detailListingFieldExpression').setValue(value);
		zenPage.applyDetails();
		break;
	case 'ListingFieldResource': // JSL4436		
		zen('detailListingFieldResource').setValue(value);
		zenPage.applyDetails();
		break;
	case 'CalMemberValueExpression':
		zen('areadetailCalMemberValueExpression').setValue(value);
		zenPage.applyDetails();
		break;
	// + WAL190 (2)
	case 'listingFilterExpression':
		zen('areadetailCalcMemberListingFilter').setValue(value);
		zenPage.applyDetails();
		break;
	// - WAL190 (2)
	case 'CubeResource':
		zen('detailCubeResource').setValue(value);
		zenPage.applyDetails();
		break;
	case 'BuildRestriction':
		zen('detailCubeBuildRestriction').setValue(value);
		zenPage.applyDetails();
		break;
	case 'ListingResource':
		zen('detailListingResource').setValue(value);
		zenPage.applyDetails();
		break;	
	case 'iKnowDictionaries':
		zen('detailMeasureiKnowDictionaryValue').setValue(value);
		var tDictLabel = $$$Text("Dictionaries") + " (0)";
		if (value != "") {
			var tDict = value.split(",");
			if (tDict.length > 0) tDictLabel = $$$Text("Dictionaries") + " (" + tDict.length + ")";
		}	
		zen("detailMeasureiKnowDictionaries").setProperty("label",tDictLabel);
		zenPage.applyDetails();
		break;
	case 'SetExpression':
		zen('areadetailNamedSetSetExpression').setValue(value);
		zenPage.applyDetails();
		break;	
	case 'ExpressionExpression':
		// Case added by DTB390
		zen('areadetailExpressionExpression').setValue(value);
		zenPage.applyDetails();
		break;
	case 'ReorderItems':
		var dataCube = value;
		var cube = this.getCubeObject();
		cube.dimensions = dataCube.dimensions;
		cube.measures = dataCube.measures;
		this.addUndoAction();
		this.updateTable();
	}
]]></Implementation>
</Method>

<Method name="saveCube">
<Description>
Do save now. This method is called from compile also.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	
	this.assignFactNumbers();		// DTB918 - Make sure all fact numbers are assigned
	
	var ok = this.saveDocument();
	if (ok) {
		this.clearUndoBuffer();
		/* saveDocument() may return a new object so we need to reload table object here*/	
		this.updateTable();
		this.selectItem(this.currItemType,this.currItem,true);		
	}
]]></Implementation>
</Method>

<Method name="setDataSource">
<Description>
Set the dataSource for the current cube.</Description>
<FormalSpec>cls</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (cls != this.dataSource) {
		this.addUndoAction();
		this.dataSource = cls;
		var cube = this.getCubeObject();
		if (cube) {
			// set type !!!
			cube.sourceClass = this.dataSource;
		}

		zen('dataSource').refreshContents();
		zen('detailCubeSource').setValue(cls);
	}
]]></Implementation>
</Method>

<Method name="newCube">
<Description>
Invoke dialog to add a new cube.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// check if there is unsaved changes
	var undo = self.document.getElementById('cmdUndo');
	
	if (undo.disabled == false) {
		var ok = confirm($$$Text("Changes have not been saved for the current cube. Discard changes?"));
		if (ok == false) {
			return false;	
		}
	}
	var parms = {
			MODE:'cube',
			CUBE:this.cubeName,
			CLASS:this.cubeClass
			};

	zenLaunchPopupWindow('_DeepSee.UI.Dialog.CubeAdd.cls','SubjectArea','status,scrollbars,resizable=yes,width=700,height=650',parms);
]]></Implementation>
</Method>

<Method name="viewCube">
<Description>
Open CubeView page to view all details (if user has not modified anything).</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var cube = this.getCubeObject();	
	if (null == cube) {
		alert(this.msgOpenModel);
		return;	
	}

	if (!this.canUndo()) {
		var urlPage = "_DeepSee.UI.CubeView.zen?CUBE=" + cspEncodeUTF8(this.cubeName);
		document.location = urlPage;

	}
]]></Implementation>
</Method>

<Method name="doDocument">
<Description>
Open Documatic page to view all details (if user has not modified anything).</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var cube = this.getCubeObject();	
	if (null == cube) {
		alert(this.msgOpenModel);
		return;	
	}

	if (this.canUndo()) {
		alert($$$Text("There are unsaved changes. Documentation will show Compiled class information only."));
	}
	var winWidth = zenGetWindowWidth();
	var winHeight = zenGetWindowHeight();
	var top = winHeight * 0.1;
	var left = winWidth * 0.1;
	var features = 'top='+top+',left='+left+',width='+winWidth+',height='+winHeight+',status,scrollbars,resizable=yes,location=1,toolbar=1,menubar=1';
	var popup = window.open(this.DocumaticPage,'DeepSeeDocument',features);
	popup.focus();
]]></Implementation>
</Method>

<Method name="addItem">
<Description>
Invoke dialog to add a new item to the model.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (!this.canUserModify()) {
		return;
	}
	var cube = this.getCubeObject();
	if (null == cube) {
		alert(this.msgOpenModel);
		return;	
	}
	// show add item dialog
	var selectedItem = this.getSelectedItem();
	var selectedClass;
	if (selectedItem._class) {
		selectedClass = selectedItem._class;
	} else {
		if ('measures' == selectedItem) selectedClass = '%DeepSee.Model.measure';
		// if user clicked 'Dimensions' then Add, we do not want to enable hierarchy therefore we send ''
		if ('dimensions' == selectedItem) selectedClass = '';
		if ('listings' == selectedItem) selectedClass = '%DeepSee.Model.listing';
		if ('listingField' == selectedItem) selectedClass = '%DeepSee.Model.listingField'; // JSL4434
		if ('calculatedMembers' == selectedItem) selectedClass = '%DeepSee.Model.calculatedMember';
		if ('namedSets' == selectedItem) selectedClass = '%DeepSee.Model.namedSets';
		if ('relationships' == selectedItem) selectedClass = '%DeepSee.Model.relationship';
	}
	this._newItemCounter = this._newItemCounter ? this._newItemCounter : 1;
	var parms = {
			MODE:'savecube',
			CUBE:this.cubeName,
			CLASS:this.cubeClass,
			SELECTEDCLASS:selectedClass,
			NEWITEMCOUNTER:this._newItemCounter
			};

	zenLaunchPopupWindow('_DeepSee.UI.Dialog.CubeAddItem.cls','CubeAddItem','status,scrollbars,resizable=yes,width=700,height=600',parms);
]]></Implementation>
</Method>

<Method name="addNewItemToModel">
<Description>
Add a new item to the model and select it.</Description>
<FormalSpec>typenewname</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (!this.canUserModify()) {
		return;
	}
	var cube = this.getCubeObject();
	
	//this._newItemCounter = this._newItemCounter ? this._newItemCounter : 1;
	var newItem = null;
	var newType = '';
	this._newItemCounter++;

	// find current selection
	// if it is the correct type, we add new item after it or as a child as appropriate
	var selectedItem = this.getSelectedItem();
	var newnames = typenewname.split("^");
	var type = newnames[0];
	var newname = newnames[1];
	switch(type) {
	case 'measure':
		var newMsr = this.createMeasure(newname,'','number');	
		this.addUndoAction();
		//if (!selectedItem._class || '%DeepSee.Model.measure' != selectedItem._class || null == selectedItem._index) {
			// add to end
			cube.measures[cube.measures.length] = newMsr;
		//}
		//else {
			// insert
		//	cube.measures.splice(selectedItem._index,0,newMsr);
		//}
		newItem = newMsr;
		newType = 'measure';
		break;
	case 'dataDimension':
		var newDim = this.createDim(newname,'data',newname,'')
		this.addUndoAction();
		
		// add initial hierarchy
		var newHier = this.createHier('H1');		
		newDim.hierarchies[0] = newHier;
		
		// add inital level
		var newLevel = this.createLevel('New_Level1','');
		newHier.levels[0] = newLevel;
		
		// add at end
		cube.dimensions[cube.dimensions.length] = newDim;

		newItem = newDim;
		newType = 'dimension';
		break;
	case 'timeDimension':
		var newDim = this.createDim(newname,'time','','')
		this.addUndoAction();
	
		// add initial hierarchy
		var newHier = this.createHier('H1');		
		newDim.hierarchies[0] = newHier;
		
		// add inital level
		var newLevel = this.createLevel('New_Level1','');
		newHier.levels[0] = newLevel;
		
		newDim.hierarchies[0] = newHier;

		// add at end
		cube.dimensions[cube.dimensions.length] = newDim;

		newItem = newDim;
		newType = 'dimension';
		break;
	case 'ageDimension':
		var newDim = this.createDim(newname,'age',newname,'');
		this.addUndoAction();
		
		// add initial hierarchy
		var newHier = this.createHier('H1');		
		newDim.hierarchies[0] = newHier;
		
		// add inital level
		var newLevel = this.createLevel('New_Level1','');
		newHier.levels[0] = newLevel;

		// add at end
		cube.dimensions[cube.dimensions.length] = newDim;

		newItem = newDim;
		newType = 'dimension';
		break;
	case 'iKnowDimension':
		var newDim = this.createDim(newname,'iKnow',newname,'');
		this.addUndoAction();
		
		// add initial hierarchy
		var newHier = this.createHier('H1');		
		newDim.hierarchies[0] = newHier;
		
		// add inital level
		var newLevel = this.createLevel('New_Level1','');
		newHier.levels[0] = newLevel;

		// add at end
		cube.dimensions[cube.dimensions.length] = newDim;

		newItem = newDim;
		newType = 'dimension';
		break;
	case 'sharedDimension':
		var newDim = this.createDim(newname,'data',newname,'');
		newDim.sharesFrom = newnames[2];
		this.addUndoAction();
		
		// add at end
		cube.dimensions[cube.dimensions.length] = newDim;

		newItem = newDim;
		newType = 'dimension';
		break;			
	case 'hierarchy':
		if (!selectedItem._class || ('%DeepSee.Model.dimension' != selectedItem._class &&'%DeepSee.Model.hierarchy' != selectedItem._class)) {
			alert($$$Text('Please select a dimension or hierarchy'));
			return;
		}
		this.addUndoAction();

		var newHier = this.createHier(newname);
		// add inital level
		var newLevel = this.createLevel('New_Level1','');
		newHier.levels[0] = newLevel;

		if ('%DeepSee.Model.hierarchy' != selectedItem._class || null == selectedItem._index) {
			// add to end
			selectedItem.hierarchies[selectedItem.hierarchies.length] = newHier;
		}
		else {
			// insert
			selectedItem._parent.hierarchies.splice(selectedItem._index,0,newHier);
		}
		newItem = newHier;
		newType = 'hierarchy';
		break;
	case 'level':
		if (!selectedItem._class || ('%DeepSee.Model.hierarchy' != selectedItem._class &&'%DeepSee.Model.level' != selectedItem._class)) {
			alert($$$Text('Please select a hierarchy or level'));
			return;
		}
		this.addUndoAction();

		var newLevel = this.createLevel(newname,'');

		if ('%DeepSee.Model.level' != selectedItem._class || null == selectedItem._index) {
			// add to end
			selectedItem.levels[selectedItem.levels.length] = newLevel;
		}
		else {
			// insert
			selectedItem._parent.levels.splice(selectedItem._index,0,newLevel);
		}
		newItem = newLevel;
		newType = 'level';
		break;
	case 'property':
		if (!selectedItem._class || ('%DeepSee.Model.level' != selectedItem._class&&'%DeepSee.Model.property' != selectedItem._class)) {
			alert($$$Text('Please select a level or property'));
			return;
		}
		this.addUndoAction();

		// add a new property to the level
		var newProp = this.createProp(newname,'');

		if ('%DeepSee.Model.property' != selectedItem._class || null == selectedItem._index) {
			// add to end
			selectedItem.properties[selectedItem.properties.length] = newProp;
		}
		else {
			// insert
			selectedItem._parent.properties.splice(selectedItem._index,0,newProp);
		}
		newItem = newProp;
		newType = 'property';
		break;
	case 'listing':
		var newList = this.createListing(newname,'');
		
		this.addUndoAction();

		//YSD2514 always add to the end
		//if (!selectedItem._class || '%DeepSee.Model.listing' != selectedItem._class || null == selectedItem._index) {
			// add to end
			cube.listings[cube.listings.length] = newList;
		//}
		//else {
			// insert
		//	cube.listings.splice(selectedItem._index,0,newList);
		//}
		newItem = newList;
		newType = 'listing';
		break;
	case 'listingField': // JSL4434
		var newField = this.createListingField(newname,'');
		
		this.addUndoAction();
		newItem = newField;
		newType = 'listingField';
		cube.listingFields[cube.listingFields.length] = newField;
		break;
	case 'memberMeasure': case 'memberDimension':
		var newMember = new Object();
		newMember._class = '%DeepSee.Model.calculatedMember';
		newMember.name = newname;
		newMember.description = '';
		newMember.additionalDescription = '';		// DTB391
		newMember.displayName = '';
		newMember.disabled = 0;
		if (type == 'memberMeasure') newMember.dimension = 'Measures';
		else newMember.dimension = 'memberDimension';
		newMember.formatString = '';
		newMember.units = '';
		newMember.valueExpression = '';
		// + WAL190 (2)
		newMember.listingFilter = '';
		newMember.additionalDescription = '';
		// - WAL190 (2)
		
		this.addUndoAction();

		if (!selectedItem._class || '%DeepSee.Model.calculatedMember' != selectedItem._class || null == selectedItem._index) {
			// add to end
			cube.calculatedMembers[cube.calculatedMembers.length] = newMember;
		}
		else {
			// insert
			cube.calculatedMembers.splice(selectedItem._index,0,newMember);
		}
		newItem = newMember;
		newType = 'calculatedMember';
		break;	
	case 'namedSet':
		var newMember = new Object();
		newMember._class = '%DeepSee.Model.namedSet';
		newMember.name = newname;
		newMember.description = '';
		newMember.additionalDescription = '';		// DTB391
		newMember.displayName = '';
		newMember.disabled = 0;
		newMember.setExpression = '';
		
		this.addUndoAction();

		if (!selectedItem._class || '%DeepSee.Model.namedSet' != selectedItem._class || null == selectedItem._index) {
			// add to end
			cube.namedSets[cube.namedSets.length] = newMember;
		}
		else {
			// insert
			cube.namedSets.splice(selectedItem._index,0,newMember);
		}
		newItem = newMember;
		newType = 'namedSet';
		break;				
	case 'relationship':
		var newRelationship = this.createRelationship(newname);
		cube.relationships[cube.relationships.length] = newRelationship;
		this.addUndoAction();
		newItem = newRelationship;
		newType = 'relationship';
		break;
	case 'expression':
	// Case added by DTB390
		var newExpression = new Object();
		newExpression._class = '%DeepSee.Model.expression';
		newExpression.name = newname;
		newExpression.description = '';
		newExpression.additionalDescription = '';		// DTB391
		newExpression.disabled = 0;
		newExpression.sourceExpression = '';
		cube.expressions[cube.expressions.length] = newExpression;
		
		this.addUndoAction();

		newItem = newExpression;
		newType = 'expression';
		break;
	default:
		alert('addNewItem: unknown type: ' + type);
		return;
	}

	if (newItem && '' != newType) {
		this.updateTable();
		this.selectNewItem(newItem,newType);
	}
]]></Implementation>
</Method>

<Method name="addInheritedItemToModel">
<Description>
Add a new item to the model and select it. Designed for adding an overriden item from 
an inherited cube</Description>
<FormalSpec>type,inheritedItem</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB156
	if (!this.canUserModify()) {
		return;
	}
	var cube = this.getCubeObject();
	this._newItemCounter++;

	// Add the inheritedItem to appropriate group in the local cube model. 
	switch(type) {
	case 'measure':		
		this.addUndoAction();
		cube.measures[cube.measures.length] = inheritedItem;
		break;
	case 'dimension':
		this.addUndoAction();
		cube.dimensions[cube.dimensions.length] = inheritedItem;
		break;		
	case 'hierarchy':
		// Cannot override an orphaned hierarchy
		inheritedItem = null;
		break;
	case 'level':
		// Cannot override an orphaned level
		inheritedItem = null;
		break;
	case 'property':
		// Cannot override an orphaned property
		inheritedItem = null;
		break;
	case 'listing':
		this.addUndoAction();
		cube.listings[cube.listings.length] = inheritedItem;
		break;
	case 'listingField':
		this.addUndoAction();
		cube.listingFields[cube.listingFields.length] = inheritedItem;
		break;
	case 'calculatedMember':
		this.addUndoAction();
		cube.calculatedMembers[cube.calculatedMembers.length] = inheritedItem;
		break;	
	case 'namedSet':
		this.addUndoAction();
		cube.namedSets[cube.namedSets.length] = inheritedItem;
		break;				
	case 'relationship':
		this.addUndoAction();
		cube.relationships[cube.relationships.length] = inheritedItem;
		break;
	default:
		alert('addInheritedItemToModel: unknown type: ' + type);
		return;
	}

	if (inheritedItem && '' != type) {
		this.updateTable();
		this.selectNewItem(inheritedItem,type);
	}
]]></Implementation>
</Method>

<Method name="createMeasure">
<Description>
Create a new measure. 'type' passed in is 'number', 'date', 'boolean' or 'string'</Description>
<FormalSpec>newname,newsource,type</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var newMsr = new Object();
	newMsr._class = '%DeepSee.Model.measure';
	newMsr.name = newname;
	newMsr.description = '';
	newMsr.additionalDescription = '';		// DTB391
	newMsr.sourceProperty = newsource;
	newMsr.sourceExpression = '';
	newMsr.aggregate = (type=='number') ? 'SUM' : ((type=='date') ? 'AVG' : 'COUNT');
	newMsr.hidden = 0;
	newMsr.scale = '';
	newMsr.type = type;
	newMsr.factName = '';
	newMsr.displayName = '';
	newMsr.disabled = 0;
	newMsr.units = '';
	newMsr.formatString = '';
	newMsr.iKnowSource = '';
	newMsr.iKnowDictionaries = '';
	newMsr.isModified = true;		// DTB918
	// + WAL190 (2)
	newMsr.additionalDescription = '';
	newMsr.listingFilterValue = ''; // WAL222
	// - WAL190 (2)
	return newMsr
]]></Implementation>
</Method>

<Method name="createDim">
<Description><![CDATA[
Create new dimension. If drag & drop, sourceprop passed in will not be null.]]></Description>
<FormalSpec>newname,dimtype,sourceprop,caption</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var newDim = new Object();
	newDim._class = '%DeepSee.Model.dimension';
	newDim.name = newname;
	newDim.description = '';
	newDim.additionalDescription = '';		// DTB391
	newDim.sourceProperty = (dimtype!='time') ? '' : sourceprop;
	newDim.sourceExpression = '';		
	newDim.type = dimtype;
	newDim.hasAll = 0;
	newDim.allCaption = 'All' + ' ' + newname;;
	newDim.allDisplayName = newname;
	newDim.disabled = 0;
	newDim.displayName = caption;
	newDim.hierarchies = new Array();
	if (dimtype=='iKnow') {
		var iKnowMeasures = this.getiKnowMeasures();
		newDim.iKnowMeasure = iKnowMeasures.split(',')[0];
		newDim.iKnowType = 'entity';
	}
	else if (dimtype=='time') {
		// DTB237 - Always default to gregorian calendar in new dimensions
		newDim.calendar = 'gregorian';
	}

	newDim.sharesFrom = '';
	return newDim
]]></Implementation>
</Method>

<Method name="createHier">
<Description>
Create new hierarchy.</Description>
<FormalSpec>newname</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// add a new hierarchy to the dimension
	var newHier = new Object();
	newHier._class = '%DeepSee.Model.hierarchy';
	newHier.name = newname; 
	newHier.description = '';
	newHier.additionalDescription = '';		// DTB391
	newHier.disabled = 0;
	newHier.displayName = '';
	newHier.levels = new Array();
	return newHier;
]]></Implementation>
</Method>

<Method name="createLevel">
<Description><![CDATA[
Create new level If drag & drop, newsource passed in will not be null.]]></Description>
<FormalSpec>newname,newsource</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// add a new level to the hierarchy
	var newLevel = new Object();
	newLevel._class = '%DeepSee.Model.level';
	newLevel.name = newname;
	newLevel.description = '';
	newLevel.additionalDescription = '';		// DTB391
	newLevel.sourceProperty = newsource;
	newLevel.sourceExpression = '';
	newLevel.timeFunction = '';
	newLevel.timeFormat = '';		// DTB340
	newLevel.list = false;
	newLevel.listDelimiter = '';
	newLevel.nullReplacement = null;
	newLevel.rangeExpression = '';
	newLevel.useDisplayValue = 1;
	newLevel.factName = '';
	newLevel.disabled = 0;
	newLevel.displayName = '';	
	newLevel.properties = new Array();
	newLevel.sort = '';
	newLevel.dependsOn = '';
	newLevel.isModified = true;		// DTB918
	// + WAL190 (2)
	newLevel.additionalDescription = '';
	// - WAL190 (2)
	return newLevel;
]]></Implementation>
</Method>

<Method name="createProp">
<Description><![CDATA[
Create new property. If drag & drop, newsource passed in will not be null.]]></Description>
<FormalSpec>newname,newsource</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// add a new property to the level
	var newProp = new Object();
	newProp._class = '%DeepSee.Model.property';
	newProp.name = newname;
	newProp.description = '';
	newProp.additionalDescription = '';		// DTB391
	newProp.sourceProperty = newsource;
	newProp.sourceExpression = '';
	newProp.factName = '';
	newProp.sort = '';
	newProp.isName = 0;
	newProp.isReference = 0;
	newProp.hidden = 0;
	newProp.disabled = 0;
	newProp.displayName = '';
	return newProp;
]]></Implementation>
</Method>

<Method name="createListing">
<Description><![CDATA[
Create new listing object. If drag & drop, fieldName passed in will not be null.]]></Description>
<FormalSpec>newname,fieldName</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var newList = new Object();
	newList._class = '%DeepSee.Model.listing';
	newList.name = newname;
	newList.description = '';
	newList.additionalDescription = '';		// DTB391
	newList.displayName = '';
	newList.disabled = 0;
	newList.fieldList = fieldName;
	newList.listingType = 'table';
	newList.orderBy = '';
	newList.resource = '';
	newList.sourceClass = '';
	newList.sql = '';
	return newList;
]]></Implementation>
</Method>

<Method name="createListingField">
<Description><![CDATA[
Create new listing object. If drag & drop, fieldExpression passed in will not be null.]]></Description>
<FormalSpec>newname,fieldExpression</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var newList = new Object();
	newList._class = '%DeepSee.Model.listingField';
	newList.name = newname;
	newList.description = '';
	newList.additionalDescription = '';		// DTB391
	newList.displayName = '';
	newList.disabled = 0;
	fieldExpression = this.transformToSQLExpression(fieldExpression); // JSL4436, only non-null when drag and drop from source tree
	newList.fieldExpression = fieldExpression;
	newList.resource = '';
	return newList;
]]></Implementation>
</Method>

<Method name="createRelationship">
<Description>
Create new relationship object.</Description>
<FormalSpec>newname</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var newRelationship = new Object();
	newRelationship._class = '%DeepSee.Model.relationship';
	newRelationship.name = newname;
	newRelationship.description = '';
	newRelationship.additionalDescription = '';		// DTB391
	newRelationship.displayName = '';
	newRelationship.disabled = 0;
	newRelationship.cardinality = '';
	newRelationship.factName = '';
	newRelationship.inverse = '';
	newRelationship.linkClass = '';
	newRelationship.linkProperty = '';
	newRelationship.nullReplacement = null;
	newRelationship.relatedCube = '';
	newRelationship.sourceExpression = '';
	newRelationship.sourceProperty = '';
	newRelationship.isModified = true;		// DTB918
	return newRelationship;
]]></Implementation>
</Method>

<Method name="browseClass">
<Description>
Invoke class finder dialog. popupName="sourceclasses" or "cubes"</Description>
<FormalSpec>popupName</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var mode = (popupName == "sourceClass") ? "sourceclasses" : "cubes";
	zenLaunchPopupWindow('_DeepSee.UI.Dialog.finderDialog.cls?MODE='+mode,popupName,'resizable,width=900,height=500');
]]></Implementation>
</Method>

<Method name="editItem">
<Description>
Invoke dialog to edit certain items: RangeExpression, FormatString, SourceProperty, SourceExpression, CubeResource, ListingResource, ListingField.</Description>
<FormalSpec>what</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// PFS101 - Do not allow edit dialog if item is disabled
	// DTB755 - Test for existence of the component before checking disabled
	if (zen('detail'+what) && zen('detail'+what).getProperty('disabled')) {
		return;
	}
	var selectedItem = this.getSelectedItem();
	var uiclass = "_DeepSee.UI.Dialog.GetList.cls";
	var spec = "status,scrollbars,resizable=yes,width=640,height=680";
	switch(what) {
	case 'FormatString':
		var value = zen("detailMeasureFormatString").getValue();
		var element = zen('detailMeasureName').getValue();
		uiclass = "_DeepSee.UI.Dialog." + what + ".cls";
		break;
	case 'CalMemberFormatString':		// DTB654
		var value = zen("detailCalMemberFormatString").getValue();
		var element = zen('detailCalMemberName').getValue();
		uiclass = "_DeepSee.UI.Dialog.FormatString.cls";
		break;
	case 'RangeExpression':
		var value = zen("detailLevelRangeExpression").getValue();
		var element = zen('detailLevelName').getValue();
		uiclass = "_DeepSee.UI.Dialog." + what + ".cls";
		break;				
	case 'MeasureSource':
		var value = zen("detailMeasureSource").getValue();
		var element = zen('detailMeasureName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.GetProperties.cls";
		break;			
	case 'MeasureExpression':
		var value = zen("detailMeasureExpression").getValue();
		var element = zen('detailMeasureName').getValue();
		break;		
	case 'DimensionSource':
		var value = zen("detailDimensionSource").getValue();
		var element = zen('detailDimensionName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.GetProperties.cls";
		break;			
	case 'DimensionExpression':
		var value = zen("detailDimensionExpression").getValue();
		var element = zen('detailDimensionName').getValue();		
		break;
	case 'LevelSource':
		var value = zen("detailLevelSource").getValue();
		var element = zen('detailLevelName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.GetProperties.cls";
		break;			
	case 'LevelExpression':
		var value = zen("detailLevelExpression").getValue();
		var element = zen('detailLevelName').getValue();
		break;
	case 'LevelDependsOn':
		var value = zen("areadetailLevelDependsOn").getValue();
		var element = zen('detailLevelName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.FieldList.cls";
		spec = "status,scrollbars,resizable=yes,width=800,height=680";
		break;	
	case 'PropertySource':
		var value = zen("detailPropertySource").getValue();
		var element = zen('detailPropertyName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.GetProperties.cls";
		break;		
	case 'PropertyExpression':
		var value = zen("detailPropertyExpression").getValue();
		var element = zen('detailPropertyName').getValue();
		break;
	case 'ListingFieldList':
		var value = zen("areadetailListingFieldList").getValue();
		var element = zen('detailListingName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.FieldList.cls";
		break;		
	case 'ListingSQL':
		var value = zen("areadetailListingSQL").getValue();
		var element = zen('detailListingName').getValue();
		break;		
	case 'ListingOrderBy':
		var value = zen("areadetailListingOrderBy").getValue();
		var element = zen('detailListingName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.FieldList.cls";
		break;		
	case 'ListingField': // JSL4436
		var value = zen("detailListingFieldExpression").getValue();
		var element = zen("detailListingFieldName").getValue();
		var uiclass = "_DeepSee.UI.Dialog.GetProperties.cls";
		break;			
	case 'ListingFieldResource':
		var value = zen("detailListingFieldExpression").getValue();
		var element = zen("detailListingFieldName").getValue();
		var uiclass = "_DeepSee.UI.Dialog.GetResource.cls";
		break;		// DTB244
	case 'CalMemberValueExpression':
		var value = zen("areadetailCalMemberValueExpression").getValue();
		var element = zen('detailCalMemberName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.ExpressionBuilder.cls"; // WAL126 -- use expression builder
		break;
	// + WAL190 (2)
	case 'listingFilterExpression':
		var value = zen('areadetailCalcMemberListingFilter').getValue();
		var element = zen('detailCalMemberName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.ExpressionBuilder.cls";
		break;
	// - WAL190
	case 'CubeResource':
		var value = zen('detailCubeResource').getValue();
		var element = zen("detailCubeName").getValue();
		var uiclass = "_DeepSee.UI.Dialog.GetResource.cls";
		break;
	case 'BuildRestriction':
		var value = zen('detailCubeBuildRestriction').getValue();
		var element = zen("detailCubeName").getValue();
		break;
	case 'ListingResource':
		var value = zen("detailListingName").getValue();
		var element = zen('detailListingName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.GetResource.cls";
		break;	
	case 'SetExpression':
		var value = zen("areadetailNamedSetSetExpression").getValue();
		var element = zen('detailNamedSetName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.ExpressionBuilder.cls"; // WAL126 -- use expression builder
		break;
	case 'RelationshipSource':
		var value = zen("detailRelationshipSource").getValue();
		var element = zen('detailRelationshipName').getValue();
		var uiclass = "_DeepSee.UI.Dialog.GetProperties.cls";
		break;			
	case 'RelationshipExpression':
		var value = zen("detailRelationshipExpression").getValue();
		var element = zen('detailRelationshipName').getValue();		
		break;
	case 'iKnowDictionaries':
		var value = zen('detailMeasureiKnowDictionaryValue').getValue();
		var element = zen('detailMeasureName').getValue()
		var uiclass = "_DeepSee.UI.Dialog.GetDictionaryList.cls";
	case 'ExpressionExpression':
		// Case added by DTB390
		var value = zen("areadetailExpressionExpression").getValue();
		var element = zen('detailExpressionName').getValue()
		break;
	}

	var parms = {
			CUBE:this.cubeName,
			ELEMENT:element,
			DATASOURCE:this.dataSource,
			SELECTEDCLASS:selectedItem._class,
			VALUE:value,
			WHAT:what
			};
	zenLaunchPopupWindow(uiclass,what,spec,parms);
]]></Implementation>
</Method>

<Method name="toggleSource">
<FormalSpec>element,type</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var prop = zen('detail'+element+'Source');
	var expr = zen('detail'+element+'Expression');
	if (type=='Source') {
		prop.setProperty('disabled',false);
		expr.setValue('');
		expr.setProperty('disabled',true);
	} else {
		expr.setProperty('disabled',false);
		prop.setValue('');
		prop.setProperty('disabled',true);
	}
]]></Implementation>
</Method>

<Method name="editDescription">
<Description>
Toggle to show/hide Description textarea; set what's in text into textarea.</Description>
<FormalSpec>what</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var value = zen(what).getValue();
	var id = "area"+what;
	zen(id).setValue(value);
	zen(id).setHidden(!zen(id).getProperty("hidden"));
	zen(what).setHidden(!zen(what).getProperty("hidden"));
]]></Implementation>
</Method>

<Method name="applyDescription">
<Description>
Set textarea description back into the text description field.</Description>
<FormalSpec>what</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var id = "area"+what;
	var value = zen(id).getValue();
	zen(what).setValue(value);
	this.applyDetails();
]]></Implementation>
</Method>

<Method name="reorder">
<Description>
Invoke dialog to reorder certain elements of the model.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (!this.canUserModify()) {
		return;
	}
	var cube = this.getCubeObject();
	if (null == cube) {
		alert(this.msgOpenModel);
		return;	
	}

	 // Save a copy for export to child window
	this.exportCube = cube;
	var parms = {
			CUBENAME:this.cubeName,
			FETCHCUBE:"fetchCube" // pass the child window (page2) the name of a function to call
	};

	zenLaunchPopupWindow('_DeepSee.UI.Dialog.ReorderItems.cls','ReorderItems','status,scrollbars,resizable=yes,width=680,height=620',parms);
]]></Implementation>
</Method>

<Method name="fetchCube">
<Description>
This method is called from child pages (reorder) to get a live javaScript object of the cube</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return(this.exportCube);
]]></Implementation>
</Method>

<Method name="selectNewItem">
<Description>
Helper method: select an item, make sure it is visible
and give focus to the details panel.</Description>
<FormalSpec>newItem,newType</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var row = this.findRowForItem(newItem);
	// select the new item
	this.selectItem(newType,row,true);

	// make sure the new item is visible
	var body = self.document.getElementById('modelTableBody');
	var tr = self.document.getElementById('row_' + row);
	if (tr && body) {
		zenScrollIntoView(body,tr);
	}

	var giveFocusTo = '';
	switch(newType) {
	case 'measure':
		giveFocusTo = 'detailMeasureName';
		break;
	case 'dimension':
		giveFocusTo = 'detailDimensionName';
		break;
	case 'hierarchy':
		giveFocusTo = 'detailHierarchyName';
		break;
	case 'level':
		giveFocusTo = 'detailLevelName';
		break;
	case 'property':
		giveFocusTo = 'detailPropertyName';
		break;
	}
	
	if ('' != giveFocusTo) {
		var ctrl = zen(giveFocusTo);
		ctrl.focus();
		ctrl.select();
	}
]]></Implementation>
</Method>

<Method name="rowClick">
<Description>
User click on a row in the table.</Description>
<FormalSpec>type,row</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	this.selectItem(type,row);
]]></Implementation>
</Method>

<Method name="selectItem">
<Description>
Select a row in the table.</Description>
<FormalSpec>type,row,force</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// console.log('type='+this._rowIndex[row].type+' classType='+this._rowIndex[row]._class.split('.')[2]+' name='+this._rowIndex[row].name+" row="+row+' isInherited='+this._inheritedIndex[row]); //DTB156
	force = ('undefined' == typeof force) ? false : force;
	tab = zen('tabDetails');
	if (this.currItem != row || force) {
		// unhilite
		if (this.currItem >= 0 && this.currItemType != '') {
			var trow = self.document.getElementById('row_' + this.currItem);
			if (trow) {
				trow.className = this.getCSSForType(this.currItemType);
			}
		}

		this.currItem = row;
		this.currItemType = type;

		// hilite
		var trow = self.document.getElementById('row_' + this.currItem);
		if (trow) {
			trow.className = this.getCSSForType(this.currItemType) + 'Selected';
		}

		/// don't do anything if it's at the top level
		if (('measures' == type)||('dimensions' == type)||('listings' == type)||('listingFields'==type)||('calculatedMembers' == type)||('namedSets' == type)||('relationships' == type)) {
			type = '';
		}
		// set contents of detail form
		var item = this._rowIndex[row];	
		var isInherited = this._inheritedIndex[row];				// DTB156
		var isOverride = this.itemIsOverride(item);					// DTB156
		
		if(type.length>0 && item.length>0 && item!=type) {
			type = '';
		}

		// make appropriate group in details panel visible
		zen('defaultDetails').setHidden(type != '');
		zen('cubeDetails').setHidden(type != 'cube');
		zen('dimensionDetails').setHidden(type != 'dimension');
		zen('hierarchyDetails').setHidden(type != 'hierarchy');
		zen('levelDetails').setHidden(type != 'level');
		zen('listingDetails').setHidden(type != 'listing');
		zen('listingFieldDetails').setHidden(type != 'listingField'); // JSL4434
		zen('propertyDetails').setHidden(type != 'property');
		zen('measureDetails').setHidden(type != 'measure');
		zen('calculatedMemberDetails').setHidden(type != 'calculatedMember');
		zen('namedSetDetails').setHidden(type != 'namedSet');
		zen('relationshipDetails').setHidden(type != 'relationship');
		zen('expressionDetails').setHidden(type != 'expression');			// DTB390
	
		if (item) {
			zen('lblComputed').setHidden(!((item.type == "computed")||(item._dimtype == "computed")));
			switch(type) {
			case 'cube':
				zen('areadetailAdditionalDescriptionCube').setValue(item.additionalDescription);  // WAL172
				zen('detailCubeName').setValue(item.name);
				zen('detailCubeOwner').setValue(item.owner);
				zen('detailCubeResource').setValue(item.resource);
				zen('detailCubeCaption').setValue(item.caption);
				zen('detailCubeDescription').setValue(item.description);
				if (''==this.inheritsFrom) {		// DTB156
					zen('detailCubeSource').setValue(item.sourceClass);
				}
				zen('detailCubeNullReplacement').setValue(item.nullReplacement);
				zen('detailCubeCountMeasureName').setValue(item.countMeasureName);
				zen('detailCubeCountMeasureCaption').setValue(item.countMeasureCaption);
				zen('detailCubeDisplayName').setValue(item.displayName);
				//zen('detailCubeBucketSize').setValue(item.bucketSize);
				zen('detailCubeDisabled').setValue(item.disabled);
				zen('detailCubeFactNums').setValue(item.namedFactNums);		// DTB859 - Make a control for this
				zen('detailCubeDefaultMeasure').setValue(item.defaultMeasure);
				zen('detailCubeDefaultListing').setValue(item.defaultListing);
				zen('detailCubeDefaultMember').setValue(item.defaultMember);
				zen('detailCubeBuildOrder').setValue(item.initialBuildOrder);
				zen('detailCubeBuildRestriction').setValue(item.buildRestriction);
				zen('detailCubeSqlRestrict').setValue(item.enableSqlRestrict);		// DTB730
				break;
			case 'measure':
				zen('areadetailAdditionalDescriptionMeasure').setValue(item.additionalDescription); // WAL172
				zen('areadetailMeasureBasedListing').setValue(item.listingFilterValue); // WAL190 // WAL222
				zen('measureBasedListingComparison').setValue(item.listingFilterOperator); // WAL190
				zen('detailMeasureName').setValue(item.name);
				zen('detailMeasureName').setDisabled(isOverride);		// DTB190
				zen('detailMeasureDescription').setValue(item.description);
				zen('areadetailMeasureDescription').setValue(item.description);
				var agg = item.aggregate;
				// if type is boolean/text/string and aggregate is null then default to COUNT
				if ('' == agg && (item.type == "boolean"||item.type == "text"||item.type == "string")) agg = 'COUNT';
				agg = ('' == agg) ? 'SUM' : agg;
				zen('detailMeasureAgg').setValue(agg);
				zen('detailMeasureType').setValue(item.type);

				var sp = item.sourceProperty;
				var se = item.sourceExpression;
				if ('' != se) {
					sp = '';
					zen('detailMeasureSourceExpressionRB').setValue('expression');
					this.toggleSource('Measure','Expression');
				}
				else {
					zen('detailMeasureSourcePropertyRB').setValue('property');
					this.toggleSource('Measure','Source');
				}
				zen('detailMeasureSource').setValue(sp);
				zen('detailMeasureExpression').setValue(se);
				zen('detailMeasureHidden').setValue(item.hidden);
				zen('detailMeasureScale').setValue(item.scale);
				zen("detailMeasureScale").setHidden(item.type!="number");
				zen('detailMeasureDisplayName').setValue(item.displayName);
				// if type is iKnow, disable Aggregate and Format string, show iKnow source
				zen('detailMeasureiKnowSource').setValue(item.iKnowSource);
				zen("detailMeasureiKnowSource").setHidden(item.type!="iKnow");
				zen("detailMeasureiKnowDictionaryValue").setValue(item.iKnowDictionaries);
				var hideDict = true;
				if (item.type=="iKnow"&&item.iKnowSource!="domain") hideDict = false;
				zen("detailMeasureiKnowDictionaries").setHidden(hideDict);
				var tDictLabel = $$$Text("Dictionaries") + " (0)";
				if (item.iKnowDictionaries != "") {
					var tDict = item.iKnowDictionaries.split(",");
					if (tDict.length > 0) tDictLabel = $$$Text("Dictionaries") + " (" + tDict.length + ")";
				}	
				zen("detailMeasureiKnowDictionaries").setProperty("label",tDictLabel);
				zen('detailMeasureFormatString').setValue(item.formatString);
				// allow to alter disabled status only if not ReadOnly!
				if (this.canWrite && !this.readOnly) {
					zen('detailMeasureFormatString').setDisabled(item.type=="iKnow");
					zen('detailMeasureAgg').setDisabled(item.type=="iKnow");
				}
				zen('detailMeasureDisabled').setValue(item.disabled);
				zen('detailMeasureDisabled').setHidden(isOverride);		// DTB173 - Hide Disabled for overrides
				zen('detailMeasureFactName').setValue(item.factName);
				zen('detailMeasureSearchable').setValue(item.searchable);
				break;
			case 'dimension':
				zen('areadetailAdditionalDescriptionDimension').setValue(item.additionalDescription); // WAL172
			    if (item.type == "computed") {
				    zen('dimensionDetails').setHidden(true);
				    break;
			    }
				zen('detailDimensionName').setValue(item.name);
				zen('detailDimensionName').setDisabled(isOverride);		// DTB190
				zen('detailDimensionDescription').setValue(item.description);
				zen('areadetailDimensionDescription').setValue(item.description);
				var sp = item.sourceProperty;
				var se = item.sourceExpression;
				var dSource = zen('detailDimensionSourceExpressionRB');
				if ('' != se) {
					sp = '';
					dSource.setValue('expression');
					this.toggleSource('Dimension','Expression');
				}
				else {
					dSource.setValue('property');
					this.toggleSource('Dimension','Source');
				}
				if (item.type == 'data' || item.type == 'iKnow') zen('idDetailDimensionSource').setHidden(true);
				else zen('idDetailDimensionSource').setHidden(false);
				zen('detailDimensionSource').setValue(sp);
				zen('detailDimensionExpression').setValue(se);
				zen('detailDimensionHidden').setValue(item.hidden);		// DTB156
				zen('detailDimensionHidden').setHidden(!isOverride);	// DTB156
				zen('detailDimensionType').setValue(item.type);
				zen('detailDimensionHasAll').setValue(item.hasAll);
				zen('detailDimensionAllCaption').setValue(item.allCaption);
				zen('detailDimensionAllDisplayName').setValue(item.allDisplayName);
				zen('detailDimensionDisabled').setValue(item.disabled);
				zen('detailDimensionDisabled').setHidden(isOverride);		// DTB173 - Hide Disabled for overrides
				zen('detailDimensionDisplayName').setValue(item.displayName);
				if (this.canWrite && !this.readOnly) {
					zen("detailDimensionAllCaption").setDisabled(item.hasAll!=1);
					zen("detailDimensionAllDisplayName").setDisabled(item.hasAll!=1);
				}
				zen('detailDimensioniKnowType').setHidden(item.type!="iKnow");
				zen('detailDimensioniKnowMeasure').setHidden(item.type!="iKnow");
				if ('time'==item.type) {
					// DTB181 - Initialize to gregorian if this is not already set
					zen('detailDimensionCalendar').setValue((item.calendar!='') ? item.calendar : 'gregorian');
				}
				else {		
				}
				zen('detailDimensionCalendar').setHidden('time'!=item.type);		// DTB181 - Only expose for time dimensions
				if (item.type == "iKnow") {
					zen('detailDimensioniKnowType').setValue((item.iKnowType!='') ? item.iKnowType : 'entity');
					var iKnowMeasures = this.getiKnowMeasures();
					zen('detailDimensioniKnowMeasure').setProperty("valueList",iKnowMeasures);
					zen('detailDimensioniKnowMeasure').setValue((item.iKnowMeasure!='') ? item.iKnowMeasure : iKnowMeasures.split(',')[0]);
				}
				zen('idDimension').setHidden(item.sharesFrom!="");
				zen('idDimensionSharesFrom').setHidden(item.sharesFrom=="");
				zen('detailDimensionSharesFromCube').setValue(item.sharesFrom);
				break;
			case 'hierarchy':
				zen('areadetailAdditionalDescriptionHierarchy').setValue(item.additionalDescription); // WAL172
				// DTB190 - Hide details for all computed dimension elements
				if (item._dimtype == "computed") {
				    zen('hierarchyDetails').setHidden(true);
				    break;
			    }
			
				zen('detailHierarchyName').setValue(item.name);
				zen('detailHierarchyDescription').setValue(item.description);
				zen('detailHierarchyDisabled').setValue(item.disabled);
				zen('detailHierarchyDisplayName').setValue(item.displayName);
				break;
			case 'level':
				zen('areadetailAdditionalDescriptionLevel').setValue(item.additionalDescription); // WAL172
				// DTB190 - Hide details for all computed dimension elements
				if (item._dimtype == "computed") {
				    zen('levelDetails').setHidden(true);
				    break;
			    }
			
				if (item._dimtype == "time") zen('lblLevel').setValue(this.lblTimeLevel);
				else if (item._dimtype == "age") zen('lblLevel').setValue(this.lblAgeLevel);
				else zen('lblLevel').setValue(this.lblDataLevel);
				///Extract value with function is shown only for time and age levels (p78905)
				zen('idLevelTimeFunction').setHidden(item._dimtype=="data");
				zen('idLevelTimeFormat').setHidden(item._dimtype=="data");			// DTB340
				zen('detailLevelTimeFunction').setProperty('valueList',zenPage.getTimeFunctionsForCalendar(item._calendar));		// DTB180 - Set the timeFunction list
				zen('detailLevelTimeFormat').setValue(item.timeFormat);				// DTB340
				if (this.canWrite && !this.readOnly) {
					// disable Source Values box if it is not "data dimension", but display the value if exists.
					zen('idDetailLevelSource').setProperty('disabled',item._dimtype!="data");
					var detailLevelListDelimiter = zen('detailLevelListDelimiter');
					detailLevelListDelimiter.setDisabled(item.detailLevelList!=1);
				}
				zen('detailLevelList').setValue(item.list);
				if (item.listDelimiter != "") {
					var choice = "other";
					if (item.listDelimiter == ",") choice = "comma";
					zen('detailLevelList').setValue(choice);
					zen('detailLevelList').setProperty("originalValue",choice);
					if (this.canWrite && !this.readOnly) {
						detailLevelListDelimiter.setDisabled(item.listDelimiter==",");
					}
				} 
				detailLevelListDelimiter.setValue(item.listDelimiter);
				// PFS101 - Put this block of code after enable/disable for non-data dimensions
				zen('detailLevelName').setValue(item.name);
				zen('detailLevelDescription').setValue(item.description);
				zen('areadetailLevelDescription').setValue(item.description);
				var sp = item.sourceProperty;
				var se = item.sourceExpression;
				var dSource = zen('detailLevelSourceExpressionRB');
				if (item._dimtype=="data") {
					if ('' != se) {
						sp = '';
						dSource.setValue('expression');
						this.toggleSource('Level','Expression');
					}
					else {
						dSource.setValue('property');
						this.toggleSource('Level','Source');
					}
				}
				zen('detailLevelSource').setValue(sp);
				zen('detailLevelExpression').setValue(se);
				zen('detailLevelNullReplacement').setValue(item.nullReplacement);
				zen('detailLevelUseDisplayValue').setValue(item.useDisplayValue);
				zen('detailLevelDisabled').setValue(item.disabled);
				zen('detailLevelDisplayName').setValue(item.displayName);
				zen("detailLevelRangeExpression").setValue(item.rangeExpression);
				zen('detailLevelSort').setValue(item.sort);
				//use frmHowtotransform now zen('idNotTimeFunction').setHidden(item.timeFunction!="");
				zen('detailLevelFactName').setValue(item.factName);
				zen('detailLevelFactName').setHidden(false);
				if (item._dimtype == "data") {
					zen('idDataFunction').setHidden(false);
					zen('frmHowtotransform').setHidden(false);
				} else {
					zen('frmHowtotransform').setHidden(true);
					zen('idDataFunction').setHidden(true);
					if (item._dimtype == "time") {
						zen('idLevelTimeFunction').setHidden(false);
						zen('idLevelTimeFormat').setHidden(false);					// DTB340
						zen('detailLevelTimeFunction').setValue(item.timeFunction);
						zen('detailLevelTimeFormat').setValue(item.timeFormat);		// DTB340
						zen('detailLevelTimeFunctionAge').setHidden(true);
					} else {
						/// dimtype = "age"
						zen('idLevelTimeFunction').setHidden(true);
						zen('idLevelTimeFormat').setHidden(true);					// DTB340
						zen('detailLevelTimeFunctionAge').setHidden(false);
						zen('detailLevelTimeFunctionAge').setValue(item.timeFunction);
					}
				}
				zen('detailLevelSort').setHidden(item._dimtype=="age");
				if (this.canWrite && !this.readOnly) {
					var iknowflag = (item._dimtype=="iKnow");
					zen('detailLevelSort').setDisabled(iknowflag);
					zen('detailLevelTimeFunctionAge').setDisabled(iknowflag);
					zen('detailLevelFactName').setDisabled(iknowflag);
				}
				zen('areadetailLevelDependsOn').setValue(item.dependsOn);	
				break;
			case 'property':
				zen('areadetailAdditionalDescriptionProperty').setValue(item.additionalDescription); // WAL172
				zen('detailPropertyName').setValue(item.name);
				zen('detailPropertyDescription').setValue(item.description);
				zen('areadetailPropertyDescription').setValue(item.description);
				var sp = item.sourceProperty;
				var se = item.sourceExpression;
				if ('' != se) {
					sp = '';
					zen('detailPropertySourceExpressionRB').setValue('expression');
					this.toggleSource('Property','Expression');
				}
				else {
					zen('detailPropertySourcePropertyRB').setValue('property');
					this.toggleSource('Property','Source');
				}
				zen('detailPropertySource').setValue(sp);
				zen('detailPropertyExpression').setValue(se);
				zen('detailPropertySort').setValue(item.sort);
				zen('detailPropertyIsName').setValue(item.isName);
				zen('detailPropertyIsReference').setValue(item.isReference);
				zen('detailPropertyHidden').setValue(item.hidden);
				zen('detailPropertyDisabled').setValue(item.disabled);
				zen('detailPropertyDisplayName').setValue(item.displayName);
				zen('detailPropertyUseDisplayValue').setValue(item.useDisplayValue);
				zen('detailPropertyFactName').setValue(item.factName);
				break;
			case 'listing':
				zen('areadetailAdditionalDescriptionListing').setValue(item.additionalDescription); // WAL172
				zen('detailListingName').setValue(item.name);
				zen('detailListingName').setDisabled(isOverride);		// DTB190
				zen('detailListingDescription').setValue(item.description);
				zen('areadetailListingDescription').setValue(item.description);
				zen('detailListingDisabled').setValue(item.disabled);
				zen('detailListingDisabled').setHidden(isOverride);		// DTB173 - Hide Disabled for overrides
				zen('detailListingDisplayName').setValue(item.displayName);
				zen('areadetailListingFieldList').setValue(item.fieldList);
				zen('detailListingType').setValue(item.listingType);
				zen('areadetailListingOrderBy').setValue(item.orderBy);
				zen('detailListingResource').setValue(item.resource);
				zen('detailListingSourceClass').setValue(item.sourceClass);
				zen('areadetailListingSQL').setValue(item.sql);
				var useSQL = (item.sql.length > 0);
				zen('detailListingUseSQL').setValue(useSQL);
				this.changeUseSQL();
				break;
			case 'listingField': // JSL4434
				zen('detailListingFieldName').setValue(item.name);
				zen('detailListingFieldName').setDisabled(isOverride);		// DTB190
				zen('detailListingFieldDescription').setValue(item.description);
				zen('areadetailListingFieldDescription').setValue(item.description);
				zen('detailListingFieldDisabled').setValue(item.disabled);
				zen('detailListingFieldDisabled').setHidden(isOverride);		// DTB173 - Hide Disabled for overrides
				zen('detailListingFieldDisplayName').setValue(item.displayName);
				zen('detailListingFieldExpression').setValue(item.fieldExpression);
				zen('detailListingFieldResource').setValue(item.resource);
				break;
			case 'calculatedMember':
				zen('areadetailAdditionalDescriptionCalculatedMember').setValue(item.additionalDescription); // WAL172
				zen('areadetailCalcMemberListingFilter').setValue(item.listingFilter);	// WAL190
				zen('detailCalMemberName').setValue(item.name);
				zen('detailCalMemberName').setDisabled(isOverride);		// DTB190
				zen('detailCalMemberDescription').setValue(item.description);
				zen('detailCalMemberHidden').setValue(item.hidden);		// DTB156
				zen('detailCalMemberHidden').setHidden(!isOverride);	// DTB156
				zen('areadetailCalMemberDescription').setValue(item.description);
				zen('detailCalMemberDisabled').setValue(item.disabled);
				zen('detailCalMemberDisabled').setHidden(isOverride);		// DTB173 - Hide Disabled for overrides
				zen('detailCalMemberDisplayName').setValue(item.displayName);
				zen('detailCalMemberDimension').setValue(item.dimension);
				zen('detailCalMemberFormatString').setValue(item.formatString);
				//zen('detailCalMemberUnits').setValue(item.units);
				zen('areadetailCalMemberValueExpression').setValue(item.valueExpression);
				if (this.canWrite && !this.readOnly) {
					if (item.dimension == "Measures") zen('detailCalMemberDimension').setDisabled(true);
					else zen('detailCalMemberDimension').setDisabled(false);
				}
				// + WAL233
				if (item.dimension=='Measures') {
					zen('areadetailCalcMemberListingFilter').setHidden(false);
					zen('areadetailCalcMemberListingFilterMagnifyingGlass').setHidden(false);
				}
				else {
					zen('areadetailCalcMemberListingFilter').setHidden(true);
					zen('areadetailCalcMemberListingFilterMagnifyingGlass').setHidden(true);
				}
				// - WAL233
				break;
			case 'namedSet':
				zen('areadetailAdditionalDescriptionNamedSet').setValue(item.additionalDescription); // WAL172
				zen('detailNamedSetName').setValue(item.name);
				zen('detailNamedSetName').setDisabled(isOverride);		// DTB190
				zen('detailNamedSetDescription').setValue(item.description);
				zen('areadetailNamedSetDescription').setValue(item.description);
				zen('detailNamedSetDisabled').setValue(item.disabled);
				zen('detailNamedSetDisabled').setHidden(isOverride);		// DTB173 - Hide Disabled for overrides
				zen('detailNamedSetDisplayName').setValue(item.displayName);
				zen('areadetailNamedSetSetExpression').setValue(item.setExpression);
				break;				
			case 'relationship':
				zen('areadetailAdditionalDescriptionRelationship').setValue(item.additionalDescription); // WAL172
				zen('detailRelationshipName').setValue(item.name);
				zen('detailRelationshipName').setDisabled(isOverride);		// DTB190
				zen('detailRelationshipDescription').setValue(item.description);
				zen('areadetailRelationshipDescription').setValue(item.description);
				zen('detailRelationshipDisabled').setValue(item.disabled);
				zen('detailRelationshipDisabled').setHidden(isOverride);		// DTB173 - Hide Disabled for overrides
				zen('detailRelationshipNullReplacement').setValue(item.nullReplacement);
				zen('detailRelationshipDisplayName').setValue(item.displayName);
				zen('detailRelationshipCardinality').setValue(item.cardinality);
				zen('detailRelationshipInverse').setValue(item.inverse);
				zen('detailRelationshipRelatedCube').setValue(item.relatedCube);
				zen('detailRelationshipFactName').setValue(item.factName);
				var sp = item.sourceProperty;
				var se = item.sourceExpression;
				var dSource = zen('detailRelationshipSourceExpressionRB');
				if ('' != se) {
					sp = '';
					dSource.setValue('expression');
					this.toggleSource('Relationship','Expression');
				}
				else {
					dSource.setValue('property');
					this.toggleSource('Relationship','Source');
				}
				zen('detailRelationshipSource').setValue(sp);
				zen('detailRelationshipExpression').setValue(se);

				/*newRelationship.factName = '';
				newRelationship.linkClass = '';
				newRelationship.linkProperty = '';
				*/
				break;
			case 'expression':
				// Case added by DTB390
				zen('detailExpressionName').setValue(item.name);
				zen('detailExpressionName').setDisabled(isOverride);
				zen('detailExpressionDisabled').setValue(item.disabled);
				zen('areadetailExpressionExpression').setValue(item.sourceExpression);
				zen('detailExpressionDescription').setValue(item.description);
				zen('areadetailExpressionDescription').setValue(item.description);
				zen('areadetailAdditionalDescriptionExpression').setValue(item.additionalDescription);
				break;	
			}
		}
	}
	
	// +DTB156 - Adjust the details tab environment according to inheritance behavior
	var classType = (item&&item._class) ? item._class.split('.')[2] : null;

	// +DTB190 - Set message for cube inheritance
	if (('cube'==classType)&&(item.inheritsFrom)) {
		zen('msgCubeInherited').setProperty('hidden',false)
		zen('msgCubeInheritedText').setValue(zenPage.msgCubeInherited.replace(/%1/,zenPage.inheritsFrom));
	}
	else {
		zen('msgCubeInherited').setProperty('hidden',true)
	}

	if (isInherited) {
		zen('msgItemInherited').setProperty('hidden',false);
		zen('msgItemInheritedText').setValue(zenPage.msgItemInherited.replace(/%1/,zenPage.inheritsFrom));
	}
	else {
		zen('msgItemInherited').setProperty('hidden',true);
	}
	// -DTB190
	
	zen('msgOverride').setProperty('hidden',!isOverride);
	if (classType&&(('hierarchy'!=classType)&&('level'!=classType)&&('property'!=classType))) {
		if (('dimension'==classType)&&('computed'==item.type)) {
			zen('btnOverride').setProperty('hidden',true);
		}
		else {
			zen('btnOverride').setProperty('hidden',!isInherited);
		}
	}
	else {
		zen('btnOverride').setProperty('hidden',true);
	}
	zenPage.setDetailContentDisabled(this._inheritedIndex[row])		
	// -DTB156
]]></Implementation>
</Method>

<Method name="getCSSForType">
<Description>
Find the css class for the given row type.</Description>
<FormalSpec>type</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	switch(type) {
	case 'cube':
		return 'modelRowCube';
	case 'measures':
		return 'modelRowDimension';
	case 'measure':
		return 'modelRowMeasure';
	case 'dimensions':
		return 'modelRowDimension';	
	case 'dimension':
		return 'modelRowDimension';		// DTB190 - Use dimension styling for individual dimensions
	case 'hierarchy':
		return 'modelRowHierarchy';
	case 'level':
		return 'modelRowLevel';
	case 'property':
		return 'modelRowProperty';
	case 'listings':
		return 'modelRowDimension';
	case 'listing':
		return 'modelRowMeasure';
	case 'listingFields':
		return 'modelRowDimension'; 	// DTB156 - fix selection formatting for listingFields title bar
	case 'listingField':
		return 'modelRowMeasure'; 		// DTB156 - fix selection formatting for listingField
	case 'calculatedMembers':
		return 'modelRowDimension';
	case 'calculatedMember':
		return 'modelRowMeasure';
	case 'namedSets':
		return 'modelRowDimension';
	case 'namedSet':
		return 'modelRowMeasure';
	case 'relationships':
		return 'modelRowDimension';
	case 'relationship':
		return 'modelRowMeasure';
	case 'expressions':					// DTB390
		return 'modelRowDimension';
	case 'expression':					// DTB390
		return 'modelRowMeasure';

	default:
		alert('Unknown type (css)' + type);
		break;
	}
	return '';
]]></Implementation>
</Method>

<Method name="applyDetails">
<Description>
Apply changes from detail form.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var item = this._rowIndex[this.currItem];
	if (item) {
		this.addUndoAction();
		
		switch(this.currItemType) {
		case 'cube':
			item.additionalDescription = zen('areadetailAdditionalDescriptionCube').getValue(); // WAL172
			item.name = zen('detailCubeName').getValue();
			item.owner = zen('detailCubeOwner').getValue();
			item.resource = zen('detailCubeResource').getValue();
			item.caption = zen('detailCubeCaption').getValue();
			item.description = zen('detailCubeDescription').getValue();
			if (''==this.inheritsFrom) {			// DTB156
				item.sourceClass = zen('detailCubeSource').getValue();
				if (item.sourceClass != this.dataSource) {
					this.dataSource = item.sourceClass;
					zen('dataSource').refreshContents();
				}
			}
			item.nullReplacement = zen('detailCubeNullReplacement').getValue();
			item.countMeasureName = zen('detailCubeCountMeasureName').getValue();
			item.countMeasureCaption = zen('detailCubeCountMeasureCaption').getValue();
			item.defaultMeasure = zen('detailCubeDefaultMeasure').getValue();
			item.defaultListing = zen('detailCubeDefaultListing').getValue();
			item.defaultMember = zen('detailCubeDefaultMember').getValue();
			item.disabled = zen('detailCubeDisabled').getValue();
			item.namedFactNums = zen('detailCubeFactNums').getValue();		// DTB859 - Make a control for this
			//item.bucketSize = zen('detailCubeBucketSize').getValue();
			item.displayName = zen('detailCubeDisplayName').getValue();
			item.initialBuildOrder = zen('detailCubeBuildOrder').getValue();
			item.buildRestriction = zen('detailCubeBuildRestriction').getValue();
			item.enableSqlRestrict = zen('detailCubeSqlRestrict').getValue();		// DTB730
			break;
		case 'measure':
			if (this.checkItemModified(item,this.currItemType)) {
				// DTB918 - Mark this item as modified
				item.isModified = true;
				item.factNumber = '';
			}
			item.additionalDescription = zen('areadetailAdditionalDescriptionMeasure').getValue(); // WAL172
			item.listingFilterValue = zen('areadetailMeasureBasedListing').getValue(); // WAL190
			item.listingFilterOperator = zen('measureBasedListingComparison').getValue(); // WAL190
			if (item.listingFilterOperator!='') { zen('detailMeasureSearchable').setValue(true); } // WAL190 (2)
			item.name = zen('detailMeasureName').getValue();
			// + WAL062
			if (zen('detailMeasureSourceExpressionRB').getValue() == 'expression') {
				item.sourceExpression = zen('detailMeasureExpression').getValue();
				item.sourceProperty = '';
			}
			else {
				item.sourceProperty = zen('detailMeasureSource').getValue();
				item.sourceExpression = '';
			}
			// - WAL062
			item.description = zen('detailMeasureDescription').getValue();
			item.aggregate = zen('detailMeasureAgg').getValue();
			item.hidden = zen('detailMeasureHidden').getValue();
			item.scale = zen('detailMeasureScale').getValue();
			item.type = zen('detailMeasureType').getValue();
			item.factName = zen('detailMeasureFactName').getValue();
			item.disabled = zen('detailMeasureDisabled').getValue();
			item.displayName = zen('detailMeasureDisplayName').getValue();
			item.iKnowSource = zen('detailMeasureiKnowSource').getValue();
			item.iKnowDictionaries = zen('detailMeasureiKnowDictionaryValue').getValue();
			item.formatString = zen('detailMeasureFormatString').getValue();
			item.searchable = zen('detailMeasureSearchable').getValue();
			if (item.aggregate != "COUNT" && (item.type=="boolean"||item.type=="text"||item.type=="string")) {
				 if (confirm($$$Text("For a Boolean/String/Text measure, the Aggregate function must be COUNT. Change the Aggregate function now?"))) {
					 zen('detailMeasureAgg').setValue("COUNT");
					 item.aggregate = "COUNT";
				 } 
			}
			if ((item.aggregate!="AVG")&&(item.aggregate!="MAX")&&(item.aggregate!="MIN")
					 && (item.type=="age"||item.type=="date")) {
				if (confirm($$$Text("For a date/age measure, the Aggregate function must be AVG, MAX or MIN. Change the Aggregate function now?"))) {
					 zen('detailMeasureAgg').setValue("AVG");
					 item.aggregate = "AVG";
				 } 
			}
			break;
		case 'dimension':
			item.additionalDescription = zen('areadetailAdditionalDescriptionDimension').getValue(); // WAL172
			item.name = zen('detailDimensionName').getValue();
			item.sourceProperty = zen('detailDimensionSource').getValue();
			item.sourceExpression = zen('detailDimensionExpression').getValue();
			item.hidden = zen('detailDimensionHidden').getValue();				// DTB156
			item.description = zen('detailDimensionDescription').getValue();
			item.type = zen('detailDimensionType').getValue();
			item.hasAll = zen('detailDimensionHasAll').getValue();
			item.allCaption = zen('detailDimensionAllCaption').getValue();
			item.allDisplayName = zen('detailDimensionAllDisplayName').getValue();
			item.disabled = zen('detailDimensionDisabled').getValue();
			item.displayName = zen('detailDimensionDisplayName').getValue();
			item.iKnowMeasure = zen('detailDimensioniKnowMeasure').getValue();
			item.iKnowType = zen('detailDimensioniKnowType').getValue();
			item.calendar = zen('detailDimensionCalendar').getValue();		// DTB179
			break;
		case 'hierarchy':
			item.additionalDescription = zen('areadetailAdditionalDescriptionHierarchy').getValue(); // WAL172
			item.name = zen('detailHierarchyName').getValue();
			item.description = zen('detailHierarchyDescription').getValue();
			item.disabled = zen('detailHierarchyDisabled').getValue();
			item.displayName = zen('detailHierarchyDisplayName').getValue();
			break;
		case 'level':
			if (this.checkItemModified(item,this.currItemType)) {
				// DTB918 - Mark this item as modified
				item.isModified = true;
				item.factNumber = '';
			}
			item.additionalDescription = zen('areadetailAdditionalDescriptionLevel').getValue(); // WAL172
			item.name = zen('detailLevelName').getValue();
			// + WAL062
			if (zen('detailLevelSourceExpressionRB').getValue() == 'expression') {
				item.sourceExpression = zen('detailLevelExpression').getValue();
				item.sourceProperty = '';
			}
			else {
				item.sourceProperty = zen('detailLevelSource').getValue();
				item.sourceExpression = '';
			}
			// - WAL062
			item.description = zen('detailLevelDescription').getValue();
			var list = zen('detailLevelList').getValue();
			// list displayList= "Not a list,$List,Comman,Other"
			// list valueList  = "false,true,comma,other"
			item.list = true;
			item.listDelimiter = zen('detailLevelListDelimiter').getValue();			
			if (list == "false") {
				item.list = false;
				item.listDelimiter = "";
			} 
			if (item._dimtype == "time") {
				item.timeFunction = zen('detailLevelTimeFunction').getValue();
				item.timeFormat = zen('detailLevelTimeFormat').getValue();		// DTB340
			}
			if (item._dimtype == "age") item.timeFunction = zen('detailLevelTimeFunctionAge').getValue();
			item.nullReplacement = zen('detailLevelNullReplacement').getValue();
			item.useDisplayValue = zen('detailLevelUseDisplayValue').getValue();
			item.rangeExpression = zen('detailLevelRangeExpression').getValue();
			item.factName = zen('detailLevelFactName').getValue();
			item.disabled = zen('detailLevelDisabled').getValue();
			item.displayName = zen('detailLevelDisplayName').getValue();
			item.sort = zen('detailLevelSort').getValue();
			item.dependsOn = zen('areadetailLevelDependsOn').getValue();
			break;
		case 'property':
			item.additionalDescription = zen('areadetailAdditionalDescriptionProperty').getValue(); // WAL172
			item.name = zen('detailPropertyName').getValue();
			// + WAL062
			if (zen('detailPropertySourceExpressionRB').getValue() == 'expression') {
				item.sourceExpression = zen('detailPropertyExpression').getValue();
				item.sourceProperty = '';
			}
			else {
				item.sourceProperty = zen('detailPropertySource').getValue();
				item.sourceExpression = '';
			}
			// - WAL062		
			item.description = zen('detailPropertyDescription').getValue();
			item.useDisplayValue = zen('detailPropertyUseDisplayValue').getValue();
			item.sort = zen('detailPropertySort').getValue();
			item.isName = zen('detailPropertyIsName').getValue();
			item.isReference = zen('detailPropertyIsReference').getValue();
			item.hidden = zen('detailPropertyHidden').getValue();
			item.disabled = zen('detailPropertyDisabled').getValue();
			item.displayName = zen('detailPropertyDisplayName').getValue();
			item.factName = zen('detailPropertyFactName').getValue();
			break;
		case 'listing':
			item.additionalDescription = zen('areadetailAdditionalDescriptionListing').getValue(); // WAL172
			item.name = zen('detailListingName').getValue();
			item.description = zen('detailListingDescription').getValue();
			item.disabled = zen('detailListingDisabled').getValue();
			item.displayName = zen('detailListingDisplayName').getValue();
			item.fieldList = zen('areadetailListingFieldList').getValue();
			item.listingType = zen('detailListingType').getValue();
			item.orderBy = zen('areadetailListingOrderBy').getValue();
			item.resource = zen('detailListingResource').getValue();
			item.sql = zen('areadetailListingSQL').getValue();
			item.sourceClass = zen('detailListingSourceClass').getValue();
			break;
		case 'listingField': // JSL4434
			item.name = zen('detailListingFieldName').getValue();
			item.fieldExpression = zen('detailListingFieldExpression').getValue(); // JSL4436
			item.description = zen('detailListingFieldDescription').getValue();
			item.disabled = zen('detailListingFieldDisabled').getValue();
			item.displayName = zen('detailListingFieldDisplayName').getValue();
			item.resource = zen('detailListingFieldResource').getValue();
			break;
		case 'calculatedMember':
			item.additionalDescription = zen('areadetailAdditionalDescriptionCalculatedMember').getValue(); // WAL172
			item.listingFilter = zen('areadetailCalcMemberListingFilter').getValue(); // WAL190
			item.name = zen('detailCalMemberName').getValue();
			item.description = zen('detailCalMemberDescription').getValue();
			item.disabled = zen('detailCalMemberDisabled').getValue();
			item.displayName = zen('detailCalMemberDisplayName').getValue();
			item.dimension = zen('detailCalMemberDimension').getValue();
			item.formatString = zen('detailCalMemberFormatString').getValue();
			item.hidden = zen('detailCalMemberHidden').getValue();				// DTB156
			item.valueExpression = zen('areadetailCalMemberValueExpression').getValue();
			break;
		case 'namedSet':
			item.additionalDescription = zen('areadetailAdditionalDescriptionNamedSet').getValue(); // WAL172
			item.name = zen('detailNamedSetName').getValue();
			item.description = zen('detailNamedSetDescription').getValue();
			item.disabled = zen('detailNamedSetDisabled').getValue();
			item.displayName = zen('detailNamedSetDisplayName').getValue();
			item.setExpression = zen('areadetailNamedSetSetExpression').getValue();
			break;
		case 'relationship':
			if (this.checkItemModified(item,this.currItemType)) {
				// DTB918 - Mark this item as modified
				item.isModified = true;
				item.factNumber = '';
			}
			item.additionalDescription = zen('areadetailAdditionalDescriptionRelationship').getValue(); // WAL172
			item.name = zen('detailRelationshipName').getValue();
			item.description = zen('detailRelationshipDescription').getValue();
			item.disabled = zen('detailRelationshipDisabled').getValue();
			item.displayName = zen('detailRelationshipDisplayName').getValue();
			item.nullReplacement = zen('detailRelationshipNullReplacement').getValue();
			item.cardinality = zen('detailRelationshipCardinality').getValue();
			item.inverse = zen('detailRelationshipInverse').getValue();
			item.relatedCube = zen('detailRelationshipRelatedCube').getValue();		
			item.factName = zen('detailRelationshipFactName').getValue();
			// + WAL062
			if (zen('detailRelationshipSourceExpressionRB').getValue() == 'expression') {
				item.sourceExpression = zen('detailRelationshipExpression').getValue();
				item.sourceProperty = '';
			}
			else {
				item.sourceProperty = zen('detailRelationshipSource').getValue();
				item.sourceExpression = '';
			}
			// - WAL062
			break;
		case 'expression':
				// Case added by DTB390
				item.name = zen('detailExpressionName').getValue();
				item.description = zen('detailExpressionDescription').getValue();
				item.disabled = zen('detailExpressionDisabled').getValue();
				item.sourceExpression = zen('areadetailExpressionExpression').getValue();
				item.additionalDescription = zen('areadetailAdditionalDescriptionExpression').getValue();
			break;

		}

		this.updateTable();
		// !!! this.setModified(true);
	}
]]></Implementation>
</Method>

<Method name="applyDependsOn">
<Description>
user modified DependsOn. Since it is not part of json, handle it seperately.</Description>
<FormalSpec>value</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.addUndoAction();
	this.cubeDependsOn = value;
]]></Implementation>
</Method>

<Method name="applyDomain">
<Description>
user modified Domain. Since it is not part of json, handle it seperately.</Description>
<FormalSpec>value</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.addUndoAction();
	this.cubeDomain = value;
]]></Implementation>
</Method>

<Method name="enableItem">
<Description>
Enable/disable a row in the table.</Description>
<FormalSpec>row,flag</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var item = this._rowIndex[this.currItem];
	if (item) {
		item.disabled = !flag;
		this.updateTable();
		this.selectItem(this.currItemType,this.currItem,true);
	}
	return true;
]]></Implementation>
</Method>

<Method name="moveItemUp">
<FormalSpec>type,row,index,hier,level,prop</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var item = this._rowIndex[row];
	var last = "";
	if (item) {
		row--;
		if (row > 0) {
			var cube = this.getCubeObject();
			switch(type) {
			case 'level':
				if (cube.dimensions[index].hierarchies[hier].levels[level-1]) {
					this.addUndoAction();
					last = cube.dimensions[index].hierarchies[hier].levels[level-1];
					cube.dimensions[index].hierarchies[hier].levels[level-1] = cube.dimensions[index].hierarchies[hier].levels[level];
					cube.dimensions[index].hierarchies[hier].levels[level] = last;
				}
			break;
			case 'property':
				if (cube.dimensions[index].hierarchies[hier].levels[level].properties[prop-1]) {
					this.addUndoAction();
					last = cube.dimensions[index].hierarchies[hier].levels[level].properties[prop-1];
					cube.dimensions[index].hierarchies[hier].levels[level].properties[prop-1] = cube.dimensions[index].hierarchies[hier].levels[level].properties[prop];
					cube.dimensions[index].hierarchies[hier].levels[level].properties[prop] = last;
				}
			break;
			}
			if (last != "") {	
				this.updateTable();
			}
		}
	}
]]></Implementation>
</Method>

<Method name="moveItemDown">
<FormalSpec>type,row,index,hier,level,prop</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var item = this._rowIndex[row];
	var last = "";
	if (item) {
		row++;
		if (row > 0) {
			var cube = this.getCubeObject();
			switch(type) {
			case 'level':
				if (cube.dimensions[index].hierarchies[hier].levels[level+1]) {
					this.addUndoAction();
					last = cube.dimensions[index].hierarchies[hier].levels[level+1];
					cube.dimensions[index].hierarchies[hier].levels[level+1] = cube.dimensions[index].hierarchies[hier].levels[level];
					cube.dimensions[index].hierarchies[hier].levels[level] = last;
				}
			break;
			case 'property':
				if (cube.dimensions[index].hierarchies[hier].levels[level].properties[prop+1]) {
					this.addUndoAction();
					last = cube.dimensions[index].hierarchies[hier].levels[level].properties[prop+1];
					cube.dimensions[index].hierarchies[hier].levels[level].properties[prop+1] = cube.dimensions[index].hierarchies[hier].levels[level].properties[prop];
					cube.dimensions[index].hierarchies[hier].levels[level].properties[prop] = last;
				}
			break;
			}
			if (last != "") {	
				this.updateTable();
			}
		}
	}
]]></Implementation>
</Method>

<Method name="removeItem">
<Description>
Remove a row from the table.</Description>
<FormalSpec>type,row,index,hier,level,prop</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var item = this._rowIndex[row];
	if (item) {
		var cube = this.getCubeObject();
		
		var ok = confirm($$$Text('Do you wish to delete this item?')+'\n' + type + ": " + item.name);
		if (!ok) {
			return;
		}
		this.addUndoAction();

		switch(type) {
		case 'measure':
			cube.measures.splice(index,1);
			break;
		case 'dimension':
			cube.dimensions.splice(index,1);
			break;
		case 'hierarchy':
			cube.dimensions[index].hierarchies.splice(hier,1);
			break;
		case 'level':
			cube.dimensions[index].hierarchies[hier].levels.splice(level,1);
			break;
		case 'property':
			cube.dimensions[index].hierarchies[hier].levels[level].properties.splice(prop,1);
			break;
		case 'listing':
			cube.listings.splice(index,1);
			break;
		case 'listingField':
			cube.listingFields.splice(index,1); // JSL4434
			break;
		case 'calculatedMember':
			cube.calculatedMembers.splice(index,1);
			break;			
		case 'namedSet':
			cube.namedSets.splice(index,1);
			break;			
		case 'relationship':
			cube.relationships.splice(index,1);
			break;			
		case 'expression':
			cube.expressions.splice(index,1);		// DTB390
			break;
		}
		
		// +DTB460 - If the last item is being removed, reset the currItem before refreshing the table
		var isLastItem = ((row+1)==this._rowIndex.length);
		if (isLastItem) {
			this.currItem = -1;
			this.currItemType = '';
		}
		// -DTB460

		this.updateTable();

		// reset currItem
		this.currItem = -1;
		this.currItemType = '';
		this.selectItem(this.currItemType,this.currItem,true);
	}
	return true;
]]></Implementation>
</Method>

<Method name="canUndo">
<Description>
Return true if it is possible to undo an action</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return this._undoBuffer && (this._undoIndex > 0);
]]></Implementation>
</Method>

<Method name="undo">
<Description>
Undo the most recent change.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (this.canUndo()) {
		var cube = this.getCubeObject();
		this._undoIndex--;
		var oldcube = this._undoBuffer[this._undoIndex];
		var json = this.getComponentById('cube');
		json.setContentObject(oldcube);
		this.updateTable();
		
		if (cube.sourceClass != oldcube.sourceClass) {
			this.dataSource = oldcube.sourceClass;
			zen('dataSource').refreshContents();
		}
		this.selectItem(this.currItemType,this.currItem,true);

		if (this._undoIndex == 0) {
			this.changeUndoState(true);
		}
	}
]]></Implementation>
</Method>

<Method name="clearUndoBuffer">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	delete this._undoBuffer;
	delete this._undoIndex;

	this.changeUndoState(true);
]]></Implementation>
</Method>

<Method name="changeUndoState">
<Description>
Change Undo button state and View button state (opposite of Undo button)</Description>
<FormalSpec>undostate</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// change undo button state
	var undo = self.document.getElementById('cmdUndo');
	undo.disabled = undostate;
	undo.className = (undostate == true) ? 'hdrLinkDisabled' : 'hdrLink';
	this.setModified(!undostate);
]]></Implementation>
</Method>

<Method name="addUndoAction">
<Description>
Remember the current state in the undo buffer.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (null == this._undoBuffer) {
		this._undoBuffer = new Array();
		this._undoIndex = 0;
	}

	// remember copy of entire cube as state
	var cube = this.getCubeObject();
	var oldcube = this.cloneObject(cube);
	this._undoBuffer[this._undoIndex] = oldcube;
	this._undoIndex++;

	this.changeUndoState(false);
]]></Implementation>
</Method>

<Method name="cloneObject">
<Description>
Create a clone of the given object.</Description>
<FormalSpec>obj,clone</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var clone = clone ? clone : new Object();
	for (var i in obj) {
		if ((i == '_parent')||(i == '_index')) {
			// skip back pointers
		}
		else if (null == obj[i]) {
			clone[i] = null;
		}
		else if (typeof obj[i] === 'object') {
			clone[i] = (obj[i].constructor === Array) ? new Array(): new Object();
			this.cloneObject(obj[i],clone[i]);
		}
		else {
			clone[i] = obj[i];
		}
	}
	return clone;
]]></Implementation>
</Method>

<Method name="toggleDisclosure">
<Description>
User click on disclosure icon in table.</Description>
<FormalSpec>key</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var cube = this.getCubeObject();
	if (cube && cube._contracted) {
		cube._contracted[key] = !cube._contracted[key];
		this.updateTable();
	}
]]></Implementation>
</Method>

<Method name="tableDropHandler">
<Description>
Drop handler for model table.</Description>
<FormalSpec>dragData</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var tgtId = ZLM.getDragInnerDestination().id;
	var cube = this.getCubeObject();
	
	if ('' == tgtId) {
		tgtId = ZLM.getDragInnerDestination().parentNode.id;
	}
	var row = -1;
	var tgtType;
	var newItem = null;
	var newType = '';

	if (''!=tgtId) {
		if (tgtId.indexOf('row_')!=-1) {
			
			tgtType = 'row';
			row = tgtId.split('_')[1];
		}
	}
	var item = this._rowIndex[row];

	if (null == cube._contracted) {
		cube._contracted = new Object();
	}
	if (item) {
		this.addUndoAction();
		var folderClosed = false;
		var type = item._class;
		if ('measures' == item) {
			// act like a measure
			type = '%DeepSee.Model.measure';
			folderClosed = cube._contracted['measures'];
		}
		if ('dimensions' == item) {
			// act like a dimension
			type = '%DeepSee.Model.dimension';
			folderClosed = cube._contracted['dimensions'];
		}
		if ('listings' == item) {
			type = '%DeepSee.Model.listing';
			folderClosed = cube._contracted['listings'];			
		}
		if ('listingFields' == item) { 		// DTB156 - plural reference to listingFields folder
			type = '%DeepSee.Model.listingField';
			folderClosed = cube._contracted['listingFields'];
		}
		var isconfirmed = 1;
		
		// DTB779 - Set current item to the drop zone
		this.currItem = row;
		this.currItemType = type.split('.')[type.split('.').length-1];
		
		switch(type) {
		case '%DeepSee.Model.cube':
		case '%DeepSee.Model.dimension':
			// add a new dimension to the cube IF user dropped it onto "Dimensions".
			// if user dropped onto an existing dimension, then create H1 and new level with the property name.
			// !!! find type of source property
			var newDName = this.getDimName(cube,dragData.text);
			var proxy = this.GetPropInfo(cube.sourceClass,dragData.value);
			var createType = "data";
			if (proxy.IsDate==1) createType = "time";
			var newDim = this.createDim(newDName,createType,dragData.value,proxy.Caption);
			// add initial hierarchy
			var newHName = this.getHierName(item,"H");
			var newHier = this.createHier(newHName);
			newDim.hierarchies[0] = newHier;	
			// add initial level
			var newLName = this.getLevName(item,dragData.text);
			var newSource = (createType!='time') ? dragData.value : '';
			var newLevel = this.createLevel(newLName,newSource);
			newHier.levels[0] = newLevel;

			if ('%DeepSee.Model.cube' == type) {
				// add to end
				item.dimensions[item.dimensions.length] = newDim;
				newItem = newDim;
				newType = 'dimension';
			}
			else if ('dimensions' == item) {
				cube.dimensions[cube.dimensions.length] = newDim;
				newItem = newDim;
				newType = 'dimension';
			}
			else if (null != item._index) {
				// insert
				//item._parent.dimensions.splice(item._index,0,newDim);
				// create H1 under current dimensions
				item.hierarchies[item.hierarchies.length] = newHier;
				newItem = item;
				newType = 'hierarchy';
			}
			break;
		case '%DeepSee.Model.measure':
			if ('measures' != item) {
				isconfirmed = false;
				break;	
			}
			// add a new measure
			var proxy = this.GetPropInfo(cube.sourceClass,dragData.value);
			var newType = (proxy.IsNumeric == 1) ? 'number' : ((proxy.IsDate == 1) ? 'date' : ((proxy.IsBoolean == 1) ? 'boolean' : 'string'));
			if (newType == 'string') {
				isconfirmed = confirm($$$Text("Most measures are numeric. Are you sure you want to create this nonnumeric measure?"));
				if (!isconfirmed) break;
			}
			var newMName = this.getMeaName(cube,dragData.text);
			var newMsr = this.createMeasure(newMName,dragData.value,newType);

			//now always add to the end 
			//if ('measures' == item) {
			cube.measures[cube.measures.length] = newMsr;
			//}
			//else if (null != item._index) {
			//	item._parent.measures.splice(item._index,0,newMsr);
			//}
			newItem = newMsr;
			newType = 'measure';
			break;
		case '%DeepSee.Model.hierarchy':
			// add a new level to this hierarchy
			var newLName = this.getLevName(item,dragData.text);
			var newSource = (item._dimtype!='time'&&item._dimtype!='age') ? dragData.value : '';
			var newLevel = this.createLevel(newLName,newSource);
			item.levels[item.levels.length] = newLevel;
			newItem = newLevel;
			newType = 'level';
			break;

		case '%DeepSee.Model.level':
			// add a new property to this level
			var newPName = this.getPropName(item,dragData.text);
			var newProp = this.createProp(newPName,dragData.value);
			item.properties[item.properties.length] = newProp;
			newItem = newProp;
			newType = 'property';
			break;

		case '%DeepSee.Model.listing':
			if ('listings' != item) {
				isconfirmed = false;
				break;	
			}
			var newLName = this.getListName();
			//Field List names needs to be SQL name
			var proxy = this.GetPropInfo(this.dataSource,dragData.value);
			newItem = this.createListing(newLName,proxy.SQLNames);
			newType = 'listing';
			cube.listings[cube.listings.length] = newItem;
			break;
		case '%DeepSee.Model.listingField': // JSL4434
			if ('listingFields' != item) {		// DTB156 - change to listingFields (plural)
				isconfirmed = false;
				break;	
			}
			var newLFName = this.getListingFieldName(cube, dragData.text); // JSL4438
			var proxy = this.GetPropInfo(this.dataSource,dragData.value);		// DTB895 - Call GetPropInfo to discover characteristics of the current property
			newItem = this.createListingField(newLFName,proxy.SQLNames); // JSL4436		// DTB895 - Use SQLNames as found in GetPropInfo
			newType = 'listingField';
			cube.listingFields[cube.listingFields.length] = newItem; // JSL4436
			break;
			
		default:
			return true;
		}
		if (!isconfirmed) return false;
		// if user dropped onto a closed folder, open it now.
		if (folderClosed == true) {
			this.toggleDisclosure(item);
		} else {
			this.updateTable();			
		}
		if (newItem && ('' != newType)) {
			this.selectNewItem(newItem,newType);
		}
	} else {
		// item is undefined
	}
	return true;
]]></Implementation>
</Method>

<Method name="getMeaName">
<Description>
Given the base name, return the new name with proper index number </Description>
<FormalSpec>item,name</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (item.measures) {
		var len = item.measures.length;
	} else {
		return name;	
	}
	var namelen = name.length;
	var newnamelen = 0;
	for (var i=0; i < len; i++) {
		var orig = item.measures[i].name;
		if (name == orig.substring(0,namelen)) newnamelen++;
	}
	if (newnamelen == 0) return name;
	return name+newnamelen;
]]></Implementation>
</Method>

<Method name="getDimName">
<Description>
Given the base name, return the new name with proper index number </Description>
<FormalSpec>item,name</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (item.dimensions) {
		var len = item.dimensions.length;
	} else {
		return name;	
	}
	var namelen = name.length;
	var newnamelen = 0;
	for (var i=0; i < len; i++) {
		var orig = item.dimensions[i].name;
		if (name == orig.substring(0,namelen)) newnamelen++;
	}
	if (newnamelen == 0) return name;
	return name+newnamelen;
]]></Implementation>
</Method>

<Method name="getHierName">
<Description>
Given the base name, return the new name with proper index number </Description>
<FormalSpec>item,name</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (item.hierarchies) {
		var len = item.hierarchies.length;
	} else {
		return name+"1";	
	}
	var namelen = name.length;
	var newnamelen = 1;
	for (var i=0; i < len; i++) {
		var orig = item.hierarchies[i].name;
		if (name == orig.substring(0,namelen)) newnamelen++;
	}
	return name+newnamelen;
]]></Implementation>
</Method>

<Method name="getLevName">
<Description>
Given the base name, return the new name with proper index number </Description>
<FormalSpec>item,name</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (item.levels) {
		var len = item.levels.length;
	} else {
		return name;	
	}
	var namelen = name.length;
	var newnamelen = 0;
	for (var i=0; i < len; i++) {
		var orig = item.levels[i].name;
		if (name == orig.substring(0,namelen)) newnamelen++;
	}
	if (newnamelen == 0) return name;
	return name+newnamelen;
]]></Implementation>
</Method>

<Method name="getPropName">
<Description>
Given the base name, return the new name with proper index number </Description>
<FormalSpec>item,name</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (item.properties) {
		var len = item.properties.length;
	} else {
		return name;	
	}
	var namelen = name.length;
	var newnamelen = 0;
	for (var i=0; i < len; i++) {
		var orig = item.properties[i].name;
		if (name == orig.substring(0,namelen)) newnamelen++;
	}
	if (newnamelen == 0) return name;
	return name+newnamelen;
]]></Implementation>
</Method>

<Method name="getListName">
<Description>
Return new list name. Starting "New_listing1".</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var listNumber = this._newItemCounter ? this._newItemCounter : 1;
	var listName = "New_listing"+listNumber;
	this._newItemCounter = ++listNumber;
	return listName;
]]></Implementation>
</Method>

<Method name="getListingFieldName">
<Description>
Return new list name. Starting "New_listing1".</Description>
<FormalSpec>cube,name</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
 // JSL4434
 	if (name == "") { // addElement/Item
		var listNumber = this._newItemCounter ? this._newItemCounter : 1;
		var listName = "New_listingField"+listNumber;
		this._newItemCounter = ++listNumber;
		return listName;
 	} else { // drag and drop JSL4438
		if (cube.listingFields) {
			var len = cube.listingFields.length;
		} else {
			return name;	
		}
		var namelen = name.length;
		var newnamelen = 0;
		for (var i=0; i < len; i++) {
			var orig = cube.listingFields[i].name;
			if (name == orig.substring(0,namelen)) newnamelen++;
		}
		if (newnamelen == 0) return name;
		return name+newnamelen;
	 		
	 }
]]></Implementation>
</Method>

<Method name="save">
<Description>
Save the cube.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (!this.canUserModify()) {
		return;
	}
	if(this.cubeName == "") {
		alert(this.msgOpenModel);
		return;
	}

	// show save dialog
	var cubeName = zen("detailCubeName").getValue();
	if (cubeName == '') cubeName = this.cubeName;
	var parms = {
			MODE:'savecube',
			CUBE:cubeName,
			CLASS:this.cubeClass,
			DESC:this.cubeDescription
			};

	zenLaunchPopupWindow('_DeepSee.UI.Dialog.CubeSave.cls','CubeSave','status,scrollbars,resizable=yes,width=700,height=600',parms);
]]></Implementation>
</Method>

<Method name="%GetLocatorLinks">
<Description><![CDATA[
Return the array of links to show in the locator bar.<br/>
pLink(n)=$LB(caption,link) ]]></Description>
<FormalSpec>*pLink</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..%GetRootLink(.pLink)
	Set tPageName = ..%OnGetPageName()
	Set pLink($I(pLink)) = $LB(tPageName,$ZCVT($className(),"O","URL")_".zen?CUBE="_$ZCVT(..cubeFullName,"O","URL"))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SubmitCube">
<Description>
Object submit handler JSON provider.
This is called when the client submits the Cube definition.</Description>
<FormalSpec><![CDATA[pCommand:%String,pProvider:%ZEN.Auxiliary.jsonProvider,pSubmitObject:%RegisteredObject,&pResponseObject:%RegisteredObject]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tClass = ..cubeClass
		Set tDesc = $TR(..cubeDescription,$C(13),"")
		Set tDomain = ..cubeDomain
		Set tReadOnly = 0

		If (pCommand '= "forcesave") && ##class(%Dictionary.ClassDefinition).%ExistsId(..cubeClass) {
			Set tSC = ..LoadClassDefinition(..cubeClass,.tModelDef,.tReadOnly,1)
			If $$$ISERR(tSC) Quit
			If $zdatetime(tModelDef.TimeChanged,3,,6) '= pSubmitObject.Timestamp {
				Set pProvider.error = "timestamp"
				Quit
			}
		}
		// Save the class cube definition
		// JMD761
		Set tDependsOn = ..cubeDependsOn
		Set tSC = ##class(%DeepSee.Utils).%SaveCubeDefinition(tClass,"",tDesc,pSubmitObject,tDomain,tDependsOn)
		
		If $$$ISERR(tSC) Quit
		// send up-to-date model back to client, this should include updated timestamp
		Set pResponseObject = pSubmitObject
		// correct the ReadOnly flag on the response object
		If ..IsSourceControlReadOnly(..GetInternalName()) {
			Set pResponseObject.ReadOnly = 2
		}
		Else {
			Set pResponseObject.ReadOnly = tReadOnly
		}

	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="setModified">
<Description>
Set the modified flag for the page.</Description>
<FormalSpec>flag</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method override added by DTB918 
	this.invokeSuper('setModified',arguments);
	
	// DTB918 - Block Build if a compile is required
	if (flag) {
		this.disableCommandButton('cmdBuild');	
	}
	else {
		this.enableCommandButton('cmdBuild');
	}
]]></Implementation>
</Method>

<Method name="commandBtnTimeout">
<Description>
Timeout for the timer managing the compile button</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB933
	zenPage.setCommandsFromBuildState();
	zen('commandBtnTimer').startTimer();
	
	return;
]]></Implementation>
</Method>

<Method name="setCommandsFromBuildState">
<Description>
This method is responsible for controlling the Compile button's availability
according to the build lock.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB933
	if (this.CheckBuildLock(zenPage.cubeName)) {
		zenPage.disableCommandButton('cmdCompile');
	}
	else {
		zenPage.enableCommandButton('cmdCompile');
	}

	return;
]]></Implementation>
</Method>

<Method name="CheckBuildLock">
<Description>
Check to see if the current cube has a build lock, indicating there is an update underway</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	// Method added by DTB933
	Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
	
	Set tIsLocked = 1
	Lock ^DeepSee.Build(tCubeIndex):0

	If $Test {
		Lock -^DeepSee.Build(tCubeIndex)
		Set tIsLocked = 0
	}

	Quit tIsLocked
]]></Implementation>
</Method>

<Method name="compile">
<Description>
Compile the cube.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (!this.canUserModify()) {
		return;
	}
	if(this.cubeName == "") {
		alert(this.msgOpenModel);
		return;
	}
	if (this.CheckBuildLock(zenPage.cubeName)) {		// DTB933 - Final check to account for possible race condition
		zenPage.disableCommandButton('cmdCompile');
		return;
	}
	
	var undo = self.document.getElementById('cmdUndo');
	if ((undo.disabled == false) || (this.pageModified)) {		// DTB918 - Auto-assign will modify without an undo buffer!
		// save before compile!
		this.saveCube();
	}	
	// show compile dialog
	var parms = {
			CUBE:this.cubeName,
			CLASS:this.cubeClass
			};

	zenLaunchPopupWindow('_DeepSee.UI.Dialog.CubeCompile.cls','CubeCompile','status,scrollbars,resizable=yes,width=610,height=700',parms);
]]></Implementation>
</Method>

<Method name="buildCube">
<Description>
Rebuild the cube.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (!this.canUserModify()) {
		return;
	}
	if(this.cubeName == "") {
		alert(this.msgOpenModel);
		return;
	}
	var cube = this.getCubeObject();
	var maxFacts = cube.maxFacts;
	var modSpecLists = {};
	zenPage.getModifiedFactList(modSpecLists);
	var factModJson = JSON.stringify(modSpecLists);		// DTB911

	// show build dialog
	var parms = {
			CUBE:this.cubeName,
			CLASS:this.cubeClass,
			maxFacts:maxFacts,
			MODIFIED:factModJson
			};

	zenLaunchPopupWindow('_DeepSee.UI.Dialog.CubeBuild.cls','CubeBuild','status,scrollbars,resizable=yes,width=700,height=600',parms);
]]></Implementation>
</Method>

<Method name="canUserModify">
<Description>
Test if the user has write privilege.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (!this.canWrite) {
		alert($$$Text('You are not authorized to modify or save cube definitions.'));
		return false;
	}
	if (this.readOnly) {
		alert($$$Text('This cube definition is read only.'));
		return false;
	}
	return true
]]></Implementation>
</Method>

<Method name="toggleSettings">
<Description>
Toggle display of settings (property tabs) box.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.settingsExpanded = !this.settingsExpanded;
	var span = self.document.getElementById('spanArrow');
	if (this.settingsExpanded) {
		span.innerHTML = '&#187;';
	}
	else {
		span.innerHTML = '&#171;';
	}
	this.adjustSizes();
]]></Implementation>
</Method>

<Method name="toolAnalyzer">
<Description>
Show analyzer in a new window.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var cube = this.cubeName;
	var win = window.open('_DeepSee.UI.Analyzer.zen?CUBE='+encodeURIComponent(cube),'Docbook');
	try {
		win.focus();
	}
	catch(ex) {
	}
]]></Implementation>
</Method>

<Method name="toolQuery">
<Description>
Show query tool in a new window.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var cube = this.cubeName;
	cube = (cube!='') ? cube + '.cube' : '';
	var win = window.open('_DeepSee.UI.MDXQuery.zen?SUBJECTAREA='+encodeURIComponent(cube),'Docbook');
	try {
		win.focus();
	}
	catch(ex) {
	}
]]></Implementation>
</Method>

<Method name="onloadHandler">
<Description>
Add check to ensure that we correctly load documents on the client when source control hooks are in use.
Also set up a timer to ensure we don't hit timeouts while editing documents in Studio, as well as
When in Studio mode, also detect whether we are running IE10, as we need to save documents differently if that
is the case.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.invokeSuper('onloadHandler',arguments);
	this.initializeSourceControl();
	if (!this.canWrite) {
		// DTB646 - User authorization lock on the Page
		this.disableCommandButton("cmdNew");		// DTB440 - Disable New button for readOnly users
		this.disableCommandButton("cmdSave");
		this.disableCommandButton("cmdCompile");
		this.disableCommandButton("cmdBuild");
	}
	
	if (this.readOnly) {
		// DTB646 - Source control lock on the document
		this.disableCommandButton("cmdSave");
		this.disableCommandButton("cmdCompile");
	}
	
	var coverPane = zenPage.getComponentById('detailCoverPane');
	if (!coverPane) {
		zenPage.addDetailCoverPane();
	}
	
	// +DTB156 - set dataSource if cube is inherited
	var cubeI = this.getInheritedCubeObject();
	
	if (cubeI) {
		this.dataSource = cubeI.sourceClass;
		zen('detailCubeSource').setValue(cubeI.sourceClass);
		zen('dataSource').refreshContents();
		
		// DTB935 - The inherited cube settings might prevent the possiblity of the namedFactNums
		// in the current cube.
		var blockNamedFactNums = (cubeI.abstract && !cubeI.namedFactNums);
	}
	// - DTB156
	
	// + DTB918 - Set all cubes as factNumsEnabled = true
	var cube  = zenPage.getComponentById('cube').content
	if ((cube) && (!cube.namedFactNums) && (!cube.abstract) && (!blockNamedFactNums)) {		// DTB935 - Test against abstract and inheritance settings
		cube.namedFactNums = true;
		zenPage.setModified(true);
	}
	// - DTB918
	
	if (zenPage.compileErrorOnLoad) {
		// DTB949 - Prevent launch of the Build dialog if the cube build will not complete
		// due to compile failure
		this.disableCommandButton('cmdBuild');
	}
]]></Implementation>
</Method>

<Method name="addDetailCoverPane">
<Description>
Adds a coverpane to the details tab in the DOM. This is used to disable the entire details section
while still being able to read the items.</Description>
<Internal>1</Internal>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB156
	var detailsContent = zen('tabDetailContent');
	var parentDiv = detailsContent.getEnclosingDiv();
	var newDiv = document.createElement('div');
	newDiv.setAttribute('id','detailCoverPane');
	newDiv.setAttribute('class','coverPaneInactive');
	
	parentDiv.style.position='relative';
	
	parentDiv.appendChild(newDiv);
]]></Implementation>
</Method>

<Method name="rowMouseOver">
<Description>
method for when user mouse over a row in the table</Description>
<FormalSpec>element,div</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var tooltip = this.hlpDropTooltip;
	div.style.color='orange';
	if (ZLM.dragActive == 1) {
		div.style.color='orange';
		div.style.cursor = 'pointer';
		div.title = tooltip.replace(/%1/,element);
	}
]]></Implementation>
</Method>

<Method name="rowMouseOut">
<Description>
method for when mouse out</Description>
<FormalSpec>div</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	div.style.color = '';
	div.title = '';
]]></Implementation>
</Method>

<Method name="GetPropInfo">
<Description><![CDATA[
This method returns the following values via proxy object:<br>
1) IsDate is set to 1 if the property type is a date format. Verified against the ODBC type.<br>
2) IsNumeric is set to 1 if the property type is any kind of numeric format. Verified against the ODBC type.<br>
3) Caption is the property's parameter CAPTION.</br>
4) SQLNames in the fashion of Prop1 -> Prop2 -> Prop3.</br>
5) IsBoolean is set to 1 if the property type is a boolean. Verified against the ODBC type.
]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>sourceClass,fullName</FormalSpec>
<ReturnType>%ZEN.proxyObject</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	Try {
		Set tProxy = ##class(%ZEN.proxyObject).%New()
		Set tProxy.IsDate = 0
		Set tProxy.IsNumeric = 0
		Set tProxy.IsBoolean = 0
		Set tProxy.Caption = ""
		Set tProxy.SQLNames = ""
		Set cnt = 1
		
		// +DTB160
		Set tIsConnector = ##class(%DeepSee.Utils).%IsDataConnector(sourceClass)
		If tIsConnector {
			// Collect information about the dataconnector definition
			Set tSC = $classMethod(sourceClass,"%GetPropertyInfo",.tList)
			Set tItem = $O(tList(""))
			While (tItem'="") {
				Set tConnectorProperties($LG(tList(tItem),1)) = $LG(tList(tItem),3)
				Set tItem = $O(tList(tItem))
			}
		}
		// -DTB160

		Set prop = $P(fullName,".",cnt)
		Set tLen = $L(fullName,".")
		While prop '= "" {
			// + WAL074 -- Use global lookup instead of %Dictionary.Class query so users don't need
			//             privileges on that table for Architect functionality
			Set tPropClass = $$$comMemberKeyGet(sourceClass,$$$cCLASSproperty,prop,$$$cPROPtype)
			If tIsConnector {
				// DTB160 - If the property is defined by a dataconnector, normalize its data type
				Set tType = $S($D(tConnectorProperties(prop)):tConnectorProperties(prop))
				If $E(tType,1)="%" {
					Set tType = $E(tType,2,*)
				}
				Set tType = $$$UPPER(tType)
			}
			Else {
				// Revert to previous
				Set tType = $$$comClassKeyGet(tPropClass,$$$cCLASSodbctype)
			}
			If tPropClass '[ "%Library",##class(%Dictionary.CompiledClass).%ExistsId(tPropClass) {
				Set sourceClass = tPropClass
			}
			// - WAL074
			Set tProxy.IsDate = $Case(tType,"DATE":1,"TIMESTAMP":1,:0)
			Set tProxy.IsNumeric = $Case(tType,"INTEGER":1,"NUMERIC":1,"DOUBLE":1,"BIGINT":1,"LONGVARBINARY":1,"SMALLINT":1,"TINYINT":1,"VARBINARY":1,:0)
			Set tProxy.IsBoolean = $case(tType,"BOOLEAN":1, "BIT":1, :0)
			Set tProxy.Caption = $$$comMemberArrayGet(sourceClass,$$$cCLASSproperty,prop,$$$cPROPparameter,"CAPTION")
			Set tSQL = ##class(%DeepSee.Utils).%GetSQLColumnName(sourceClass,prop)
			Set tProxy.SQLNames = tProxy.SQLNames _ $S(tSQL'="":tSQL,1:prop) _ $S(cnt<tLen:"->",1:"")
			Set cnt = cnt + 1
			Set prop = $P(fullName,".",cnt)
		}
	} 
	Catch(ex) {
		Set tProxy.IsDate = 0
		Set tProxy.Caption = ""
	}
	Quit tProxy
]]></Implementation>
</Method>

<Method name="GetInternalName">
<Description>
Return the internal name of the current document, including the three letter
extension in upper-case. For example, MyPackage.MyClass.CLS would be the internal name
for the class MyPackage.MyClass.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..cubeClass_".CLS"
]]></Implementation>
</Method>

<Method name="getCurrentName">
<Description>
Return the current name of the class/object being modified.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// fallback on class name if cube name is null or empty
 	if ((!this.cubeName) || (0 === this.cubeName.length))
 	{
 		return this.cubeClass;
 	}
	return this.cubeName;
]]></Implementation>
</Method>

<Method name="getPageTitle">
<Description>
Get the title string to add to the locator row.
This should be implemented in a subclass.</Description>
<Language>javascript</Language>
<ReturnType>%String</ReturnType>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return this.getCurrentName();
]]></Implementation>
</Method>

<Method name="getClientModel">
<Description>
Get the jsonProvider object on the client.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return zen('cube');
]]></Implementation>
</Method>

<Method name="onDocumentLoadComplete">
<Description>
Callback method invoked after we have successfully loaded the current document.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	this.updateDocumentState(true);
]]></Implementation>
</Method>

<Method name="%OnDrawHTMLHead">
<Description><![CDATA[
This callback is called at the end of the HTML HEAD section of the page.<br/>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ##super()
	If $$$ISERR(tSC) Quit tSC
	
	Set tSC = ..%DrawSourceControlHead()
	Quit tSC
]]></Implementation>
</Method>

<Method name="setReadOnly">
<Description>
method used by Source Control to set the value of the readOnly flag.</Description>
<FormalSpec>readOnly</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this.readOnly = !!readOnly;
	zen("tabDetails").setProperty('disabled',!!readOnly);
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// method to transform source property to sql expression

]]></Content>
</UDLText>

<Method name="transformToSQLExpression">
<FormalSpec>expr</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// current implementation is a hack, does not take care of delimited identifiers
	components = expr.split(".");
	return components.join("->")
]]></Implementation>
</Method>

<Method name="dropDetailListingFieldExpression">
<FormalSpec>dragData</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zen("detailListingFieldExpression").setValue(this.transformToSQLExpression(dragData.value));
	this.applyDetails();
]]></Implementation>
</Method>

<Method name="overrideInheritedItem">
<Description>
Called by the Override button to override an inherited item in the local cube definition.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB156
	var item = zenPage.getSelectedItem();
	var classType = item._class.split('.')[2]
	
	zenPage.addInheritedItemToModel(classType,item);
]]></Implementation>
</Method>

<Method name="setDetailContentDisabled">
<Description>
This prevents a user from making changes to the item details using the cover pane.</Description>
<FormalSpec>setDisabled</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB156
	var coverPane = document.getElementById('detailCoverPane');
	if (setDisabled) {
		//coverPane.style.bottom='0px';
		coverPane.setAttribute('class','coverPaneActive');
	}
	else {
		//coverPane.style.bottom='';
		coverPane.setAttribute('class','coverPaneInactive');
	}
]]></Implementation>
</Method>

<Method name="itemIsOverride">
<Description><![CDATA[
If it exists, search the inherited cube object for the same
logical definition as <var>item</var>.]]></Description>
<FormalSpec>item</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB156
	if (!item) {
		return false;
	}
	var isOverride = false;
	
	var inheritedCube = this.getInheritedCubeObject();
	var itemClass = (item._class) ? item._class : '';
	var itemType = '';
	var itemRow = -1;
	
	if (itemClass) {
		itemType = itemClass.split('.')[2] + 's';
		itemRow = this.findRowForItemName(item.name,itemClass.split('.')[2]);
	}
	
	if ((inheritedCube)&&(!this._inheritedIndex[itemRow])&&inheritedCube[itemType]) {
		for ( i = 0 ; i < inheritedCube[itemType].length ; i++ ) {
			if (item.name==inheritedCube[itemType][i].name) {
				isOverride = true;
				break;
			}
		}
	}
	
	return isOverride;
]]></Implementation>
</Method>

<Method name="chooseSCMenu">
<Description>
Handle a source control menu selection.</Description>
<FormalSpec>menuName,commandName,saveFlags</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method overidden by DTB646
	if ((typeof menuName == 'string') && (menuName.length != '') && (typeof commandName == 'string') && (commandName.length != '')) {
		if (this.pageModified && (typeof saveFlags == 'string')) {
			if ((saveFlags.charAt(0) == '1') || (saveFlags.charAt(2) == '1')) {
				this.saveDocument();
			}
		}
		this.invokeSourceControl(menuName+','+commandName);
	}
	
	zenPage.reloadPage();		// DTB646 - Reload the page to refresh state
]]></Implementation>
</Method>

<Method name="checkItemModified">
<Description>
Pass in an item and type and test if the settings substantial to data storage definition 
(eg: values, type, etc.) have changed.</Description>
<FormalSpec>item,type</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB918
	if (!item) return false;
	
	var isModified = false;
	var typeString = '';
	
	// Control settings are type-specific references
	if (!isModified) {
		switch (type) {
			case 'measure':
				typeString = 'Measure';
				if (	(item.type != zen('detailMeasureType').getValue()) 
					) {
					isModified = true;
				}
			break;
			case 'level':
				typeString = 'Level';
				if (	(item.dependsOn != zen('areadetailLevelDependsOn').getValue())
					) {
					isModified = true;	
				}
				
				if ((item._dimtype == 'time') &&
						( (item.timeFunction != zen('detailLevelTimeFunction').getValue()) ||
						(item.timeFormat != zen('detailLevelTimeFormat').getValue()) )
					) {
					isModified = true;	
				}
				if ((item._dimtype == 'age') && (item.timeFunction != zen('detailLevelTimeFunctionAge').getValue())) {
					isModified = true;
				}
			break;
			case 'relationship':
				typeString = 'Relationship';
				if (	(item.cardinality != zen('detailRelationshipCardinality').getValue()) ||
						(item.inverse != zen('detailRelationshipInverse').getValue()) ||
						(item.relatedCube != zen('detailRelationshipRelatedCube').getValue())
					) {
					isModified = true;	
				}
			break;
		}
	}
	
	if (	(item.sourceExpression != zen('detail'+typeString+'Expression').getValue()) ||
			(item.sourceProperty != zen('detail'+typeString+'Source').getValue())
		) {
		isModified = true;	
	}

	return isModified;
]]></Implementation>
</Method>

<Method name="assignFactNumbers">
<Description>
Examine the cube definition object. If the cube's namedFactNums property is set, automatically assign a factNumber to
any structural element that does not already have one defined.</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB910
	var cube = zenPage.getCubeObject();
	var isInherited = (''!==cube.inheritsFrom);		// DTB935
	
	if (cube && (cube.namedFactNums)) {
		// Create arrays to hold the reference locations of the items that need fact numbers set
		var definedFactNums = [1];		// The fact number "1" is always going to go to the %SEARCH virtual dimension
		var definedMsrNums = [];		// DTB918 - Previously generated ID numbers could be duplicated between Measures and Dimensions 
		var sourceIndex = {"dimensions":{},"measures":{},"relationships":{}};		// DTB918 - Remember the source for each fact number
		var missing = {"dimensions":[],"measures":[],"relationships":[]};
		
		// + DTB935 - Assemble the lookup indices for the cube, accounting for the inherited cube if applicable.
		// When complete:
		// - 'defined*' arrays will have the reserved fact numbers
		// - 'sourceIndex' will account for sources of all fact table columns that will be compiled
		// - the 'missing' index will point to any elements that need to be assigned a fact number prior to compile
		if (isInherited) {
			var iCube = zenPage.getInheritedCubeObject();
			zenPage.analyzeCubeModel(iCube, definedMsrNums, definedFactNums, sourceIndex, missing);
			// NB: 'missing' should be empty at this moment since the supercube should be compiled
		}
		zenPage.analyzeCubeModel(cube, definedMsrNums, definedFactNums, sourceIndex, missing);
		// - DTB935
		

		// Now assign factNumbers to any elements that have been recorded in 'missing'.
		var nextFact = 2;		// The fact number "1" is always going to go to the %SEARCH virtual dimension
		var nextMsr = 1;		// DTB918
		
		var currItem = null;
		for (m in missing.measures) {
			// DTB918 - Check the sourceIndex and assign the same fact number to same source and type
			currItem = cube.measures[missing.measures[m]];
			currSource = (currItem.sourceProperty ? currItem.sourceProperty : currItem.sourceExpression) +':'+ currItem.type;
			
			if (sourceIndex.measures[currSource]) {
				currItem.factNumber = sourceIndex.measures[currSource];
			}
			else {
				while (definedMsrNums.indexOf(nextMsr)>=0) {
					nextMsr++;
				}
				
				currItem.factNumber = nextMsr;
				definedMsrNums.push(nextMsr);
				if (!sourceIndex.measures[currSource]) {
					// DTB935 - Log this in the sourceIndex in case the same source is going
					// to be assigned to another element marked missing
					sourceIndex.measures[currSource] = nextMsr;
				}
			}
		}
		
		for (r in missing.relationships) {
			// DTB918 - Check the sourceIndex and assign the same fact number to same source
			currItem = cube.relationships[missing.relationships[r]];
			currSource = (currItem.sourceProperty ? currItem.sourceProperty : currItem.sourceExpression);
			
			if (sourceIndex.relationships[currSource]) {
				currItem.factNumber = sourceIndex.relationships[currSource];
			}
			else {
				while (definedFactNums.indexOf(nextFact)>=0) {
					nextFact++;
				}
				
				currItem.factNumber = nextFact;
				definedFactNums.push(nextFact);
				if (!sourceIndex.relationships[currSource]) {
					// DTB935 - Log this in the sourceIndex in case the same source is going
					// to be assigned to another element marked missing
					sourceIndex.relationships[currSource] = nextFact;
				}
			}
		}
		
		for (a in missing.dimensions) {
			// DTB918 - Check the sourceIndex and assign the same fact number to same source
			var addr = missing.dimensions[a];
			var dimension = cube.dimensions[addr[0]];		// DTB935 - Extract the dimension for later reference
			currItem = dimension.hierarchies[addr[1]].levels[addr[2]];
			
			currSource = zenPage.getLevelSourceForIndex(dimension,currItem);		// DTB937
			
			if (sourceIndex.dimensions[currSource]) {
				currItem.factNumber = sourceIndex.dimensions[currSource];
			}
			else {
				while (definedFactNums.indexOf(nextFact)>=0) {
					nextFact++;
				}
				
				currItem.factNumber = nextFact;
				definedFactNums.push(nextFact);
				if (!sourceIndex.dimensions[currSource]) {
					// DTB935 - Log this in the sourceIndex in case the same source is going
					// to be assigned to another element marked missing
					sourceIndex.dimensions[currSource] = nextFact;
				}
			}
		}
	}
]]></Implementation>
</Method>

<Method name="analyzeCubeModel">
<Description><![CDATA[
This will compare the current cube model with the compiled definition. It will return two arrays 
 <var>definedMsrNums</var>, <var>definedFactNums</var>
containing the known factNumbers that have been used in measures and levels/relationships, respectively.
For those items that have factNumbers assigned, the mapping between column sources and factNumbers 
is returned in <var>sourceIndex</var>. Anything that has been modified in the current session or did not 
previously have a compiled fact number will be returned in the <var>missing</var> index.<br><br>
If factNumbers of the model elements have not been explicitly set but have been previously assigned internally
via the compile, the factNumbers in the current cube model will be set to those numbers. 
In the case of inherited cubes, only the compiled factNumbers of the supercube will be held constant. ]]></Description>
<FormalSpec>cube,definedMsrNums,definedFactNums,sourceIndex,missing</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB935
	var currSource = '';
	var currFactNo = '';
	var isInherited = (''!=cube.inheritsFrom);
	
	// Initialize local versions of the input parameters if they are not supplied by the caller
	if (!definedFactNums) {
		var definedFactNums = [1];		// The fact number "1" is always going to go to the %SEARCH virtual dimension
	}
	if (!definedMsrNums) {
		var definedMsrNums = [];		// Previously generated ID numbers could be duplicated between Measures and Dimensions 
	}
	if (!sourceIndex) {
		var sourceIndex = {"dimensions":{},"measures":{},"relationships":{}};		// Remember the source for each fact number
	}
	if (!missing) {
		var missing = {"dimensions":[],"measures":[],"relationships":[]};
	}
	
	// Query the server for the relevant fact numbers that have previously been assigned in a compile.
	// When this cube inherits from another, use the compiled information from the supercube.
	if (isInherited) {
		var compiledFactNums = JSON.parse(zenPage.GetCompiledFactNumbers(cube.inheritsFrom));
	}
	else {
		var compiledFactNums = JSON.parse(zenPage.GetCompiledFactNumbers(cube.name));
	}

	// Examine current model measures
	var mName = '';
	for (m in cube.measures) {
		mName = '[MEASURES].[' + cube.measures[m].name + ']';
		currSource = (cube.measures[m].sourceProperty ? cube.measures[m].sourceProperty : cube.measures[m].sourceExpression) +':'+ cube.measures[m].type;		// DTB918
		
		if (!cube.measures[m].isModified) {
			// If the measure is not marked modified, check the actual factNumber setting
			if (cube.measures[m].factNumber) {
				// The model does have a number already assigned
				definedMsrNums.push(cube.measures[m].factNumber);
			}
			else if (compiledFactNums.measures[mName.toUpperCase()]) {
				// This should be the initial assignment case following upgrade.
				// The model doesn't declare the fact number but there is an assigned number in
				// the metadata. Preserve this number.
				currFactNo = compiledFactNums.measures[mName.toUpperCase()];
				// For measures the returned factNumber probably begins with 'M'. Remove it to
				// expose the raw integer.
				currFactNo = (currFactNo[0]=='M' ? currFactNo.slice(1,currFactNo.length) : currFactNo );
				cube.measures[m].factNumber = parseInt(currFactNo);
				definedMsrNums.push(cube.measures[m].factNumber);
			}
			else if (isInherited) {
				// Elements defined in cubes inheriting other definitions could have conflicting
				// fact numbers due to changes in a supercube. To be safe these will all be reset.
				missing.measures.push(m);
			}
		}
		else {
			// DTB959 - Multiple compiles without a build can mean the element is marked modified
			// and has a factNumber assigned. Only assign to the missing index if there is no
			// factNumber.
			if (cube.measures[m].factNumber) {
				// The model does have a number already assigned
				definedMsrNums.push(cube.measures[m].factNumber);
			}
			else {
				missing.measures.push(m);
			}
		}
		
		if ((cube.measures[m].factNumber) && (currSource)) {
			// Remember which source is used to produce this value
			sourceIndex.measures[currSource] = cube.measures[m].factNumber;
		}
	}

	// Examine current model relationships
	var rName = '';
	for (r in cube.relationships) {
		rName = '[' + cube.relationships[r].name + ']';
		currSource = (cube.relationships[r].sourceProperty ? cube.relationships[r].sourceProperty : cube.relationships[r].sourceExpression);		// DTB918
		
		if (!cube.relationships[r].isModified) {
			// If the relationship is not marked modified, check the actual factNumber setting
			if (cube.relationships[r].factNumber) {
				// The model does have a number assigned
				definedFactNums.push(cube.relationships[r].factNumber);
			}
			else if (compiledFactNums.relationships[rName.toUpperCase()]) {
				// This should be the initial assignment case following upgrade.
				// The model doesn't declare the fact number but there is an assigned number in
				// the metadata. Preserve this number.
				currFactNo = compiledFactNums.relationships[rName.toUpperCase()];
				cube.relationships[r].factNumber = parseInt(currFactNo);
				definedFactNums.push(cube.relationships[r].factNumber);
			}
			else if (isInherited) {
				// Elements defined in cubes inheriting other definitions could have conflicting
				// fact numbers due to changes in a supercube. To be safe these will all be reset.
				missing.relationships.push(r);
			}
		}
		else {
			// DTB959 - Multiple compiles without a build can mean the element is marked modified
			// and has a factNumber assigned. Only assign to the missing index if there is no
			// factNumber.
			if (cube.relationships[r].factNumber) {
				// The model does have a number assigned
				definedFactNums.push(cube.relationships[r].factNumber);
			}
			else {
				missing.relationships.push(r);
			}
		}
		
		if ((cube.relationships[r].factNumber) && (currSource)) {
			// Remember which source is used to produce this value
			sourceIndex.relationships[currSource] = cube.relationships[r].factNumber;
		}
	}

	// Examine current model dimensions and levels
	var dName = '';
	var hName = '';
	var lName = '';
	var spec = '';
	for (d in cube.dimensions) {
		dName = '[' + cube.dimensions[d].name + ']';
		var dimension = cube.dimensions[d];
		
		for (h in dimension.hierarchies) {
			hName = '[' + dimension.hierarchies[h].name + ']';
			
			for (l in dimension.hierarchies[h].levels) {
				var level = dimension.hierarchies[h].levels[l];
				lName = '[' + level.name + ']';
				spec = dName + '.' + hName + '.' + lName;
				
				currSource = zenPage.getLevelSourceForIndex(dimension,level);		// DTB937
				
				if (!level.isModified) {
					// If the level is not marked modified, check the actual factNumber setting
					if (level.factNumber) {
						// The model does have a number assigned
						definedFactNums.push(level.factNumber);
					}
					else if (compiledFactNums.dimensions[spec.toUpperCase()]) {
						// This should be the initial assignment case following upgrade.
						// The model doesn't declare the fact number but there is an assigned number in
						// the metadata. Preserve this number.
						currFactNo = compiledFactNums.dimensions[spec.toUpperCase()];
						level.factNumber = parseInt(currFactNo);
						definedFactNums.push(level.factNumber);
					}
					else if (isInherited) {
						// Elements defined in cubes inheriting other definitions could have conflicting
						// fact numbers due to changes in a supercube. To be safe these will all be reset.
						missing.dimensions.push([d,h,l]);
					}
				}
				else {
					// DTB959 - Multiple compiles without a build can mean the element is marked modified
					// and has a factNumber assigned. Only assign to the missing index if there is no
					// factNumber.
					if (level.factNumber) {
						// The model does have a number assigned
						definedFactNums.push(level.factNumber);
					}
					else {
						missing.dimensions.push([d,h,l]);
					}
				}
				
				if ((level.factNumber) && (currSource)) {
					// Remember which source is used to produce this value
					sourceIndex.dimensions[currSource] = level.factNumber;
				}
			}
		}
	}
]]></Implementation>
</Method>

<Method name="setFactsModified">
<Description><![CDATA[
Set or Clear all isModified flags in the cube definition according to <var>value</var>.]]></Description>
<FormalSpec>value</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB911
	var cube = zenPage.getCubeObject();
	
	if (cube.namedFactNums) {
		// Collect the named facts that are already present and note locations of any that are missing.
		// There should be no conflicts since that would have failed any previous compile.
		for (m in cube.measures) {
			cube.measures[m].isModified = value;
		}

		for (r in cube.relationships) {
			cube.relationships[r].isModified = value;
		}

		for (d in cube.dimensions) {
			for (h in cube.dimensions[d].hierarchies) {
				for (l in cube.dimensions[d].hierarchies[h].levels) {
					cube.dimensions[d].hierarchies[h].levels[l].isModified = value;
				}
			}
		}
	}
]]></Implementation>
</Method>

<Method name="getModifiedFactList">
<Description>
Fetch the list of dimensions, measures, and relationships that are known to have been modified 
since the last build.</Description>
<FormalSpec>specList</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB911
	var cube = zenPage.getCubeObject();
	if (!specList) {
		var specList = {};		// DTB911 - Initialize the specList
	}
	
	if (cube.namedFactNums) {
		// Create arrays to hold the reference locations of the items that need fact numbers set
		var definedFactNums = [1];		// The fact number "1" is always going to go to the %SEARCH virtual dimension
		var changedFactIndex = {"dimensions":[],"measures":[],"relationships":[]};
		
		// Collect the named facts that are already present and note locations of any that are missing.
		// There should be no conflicts since that would have failed any previous compile.
		var mName = '';
		specList.measures = [];
		for (m in cube.measures) {
			mName = cube.measures[m].name;
			if (cube.measures[m].isModified) {
				specList.measures.push('[MEASURES].[' + mName + ']');
				changedFactIndex.measures.push(m);
			}
		}

		var rName = '';
		specList.relationships = [];
		for (r in cube.relationships) {
			rName = cube.relationships[r].name;
			if (cube.relationships[r].isModified) {
				specList.relationships.push('[' + rName + ']');
				changedFactIndex.relationships.push(m);
			}
		}

		var dName = '';
		var hName = '';
		var lName = '';
		var level = {};
		specList.dimensions = [];
		for (d in cube.dimensions) {
			dName = '[' + cube.dimensions[d].name + ']';
			for (h in cube.dimensions[d].hierarchies) {
				hName = '[' + cube.dimensions[d].hierarchies[h].name + ']';
				for (l in cube.dimensions[d].hierarchies[h].levels) {
					level = cube.dimensions[d].hierarchies[h].levels[l];
					lName = '[' + level.name + ']';
					
					if (level.isModified) {
						specList.dimensions.push(dName + '.' + hName + '.' + lName);
						changedFactIndex.dimensions.push([d,h,l]);
					}
				}
			}
		}
	}
	
	return changedFactIndex;
]]></Implementation>
</Method>

<Method name="getLevelSourceForIndex">
<Description><![CDATA[
Given the objects representing a <var>dimension</var> and a <var>level</var>, produce
a string that can be used as an identifier in the sourceIndex when determining shared storage
for fact table columns.]]></Description>
<FormalSpec>dimension,level</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// Method added by DTB937
	// DTB961 - Protect all lookups from returning an undefined to better normalize the index
	if ('time'==dimension.type) {
		currSource = (dimension.sourceProperty ? dimension.sourceProperty : dimension.sourceExpression)
					+ ':'
					+ (level.timeFunction ? level.timeFunction : '')
					+ ':' 
					+ (level.timeOffset ? level.timeOffset : '');
	}
	else if ('age'==dimension.type) {
		currSource = (dimension.sourceProperty ? dimension.sourceProperty : dimension.sourceExpression) 
					+ ':'
					+ (level.timeFunction ? level.timeFunction : '');
	}
	else {
		currSource = (level.sourceProperty ? level.sourceProperty : level.sourceExpression) 
					+ ':'
					+ (level.rangeExpression ? level.rangeExpression : '');		
	}
	
	return currSource;
]]></Implementation>
</Method>

<Method name="GetCompiledFactNumbers">
<Description><![CDATA[
Return an index of the currently used fact numbers in the compiled metadata. This index is returned as a JSON object which takes the form:<br>
<example language=cos>
Set tCompiledFactNums = {
		"measures":{
		  "[MEASURES].[NAME]":"M1"
		},
		"dimensions":{
		  "[DIM].[HIER].[LEVEL]":"2"		
		},
		"relationships":{
		  "[RELNAME]":"3"
		}
	}
</example>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	// Method added by DTB918
	Set tCompiledFactNums = {
		"measures":{},
		"dimensions":{},
		"relationships":{}
		}
	
	Try {
		Set tSC = ##class(%DeepSee.Utils).%GetDimensionList(pCubeName,.tFullList,,,1)
		If $$$ISERR(tSC) Quit
		// Walk straight through the triple-subscript array since it will have everything in the same order as in the cube definition
		Set d = $O(tFullList(""))
		While (d'="") {
			Set h = $O(tFullList(d,""))
			While (h'="") {
				Set l = $O(tFullList(d,h,""),1,tFactInfo)
				While (l'="") {
					Set tTypeCode = $LG(tFactInfo,1)
					Set tSpec = ""
					Set tFactNo = $LG(tFactInfo,5)
					
					If (tFactNo'="") {
						If (tTypeCode="m") {
							Set tType = "measures"
							Set tSpec = "[" _ $LG(tFactInfo,2) _ "].[" _ $LG(tFactInfo,3) _ "]"
						}
						ElseIf (tTypeCode="l") {
							Set tType = "dimensions"
							Set tSpec = "[" _ $LG(tFactInfo,2) _ "].[" _ $LG(tFactInfo,3) _ "].[" _ $LG(tFactInfo,4) _ "]"
						}
						ElseIf (tTypeCode="r") {
							Set tType = "relationships"
							Set tSpec = "[" _ $LG(tFactInfo,2) _ "]"
						}
						Else {
							// If this cannot assign a filing position, skip to the next level
							Continue
						}

						Do tCompiledFactNums.%Get(tType).%Set($$$UPPER(tSpec),tFactNo)
					}
					
					Set l = $O(tFullList(d,h,l),1,tFactInfo)
				}
				
				Set h = $O(tFullList(d,h))
			}
			
			Set d = $O(tFullList(d))
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}

	Quit tCompiledFactNums.%ToJSON()
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.Utils">
<Description>
This class contains a number of DeepSee utility methods.</Description>
<IncludeCode>%sySite,%occUtility,%DeepSee</IncludeCode>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeCreated>61100,60588.221955</TimeCreated>

<Parameter name="DOMAIN">
<Default>%DeepSee</Default>
</Parameter>

<Method name="%Reset">
<Description><![CDATA[
Stops all DeepSee background agents, clears any pending tasks,
and clears the result cache for the current namespace.
If <var>pClearCells</var> is true, then the cell cache for the
current namespace is also cleared.<br/>
This method is provided as a convenience for developers for 
use on development or test systems. You should not use this method
on production systems as it will have immediate effect on the
performance of end user operations.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClearCells:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tSC = ##class(%DeepSee.WorkMgr).%KillAgents(1)		// DTB706 - This is now handled by the WorkMgr

	Kill $$$DeepSeeAxisGLVN
	Kill $$$DeepSeeResultsGLVN
	Kill $$$DeepSeeListingGLVN
	Kill $$$DeepSeeListingBitGLVN
	Kill $$$DeepSeeListingResultsGLVN		// DTB142 - Kill listing results as well
	Kill $$$DeepSeeJoinGLVN
	Kill $$$DeepSeeKPIGLVN
	Kill $$$DeepSeeQueryNonceGLVN		// DTB762
	Kill $$$DeepSeeParameterNonceGLVN		// DTB796
	If (pClearCells) {
		Kill $$$DeepSeeCellsGLVN
		Kill $$$DeepSeeBucketsGLVN
	}
	Set tSC = ..%KillLogFile()
	Quit tSC
]]></Implementation>
</Method>

<Method name="%TestForCancel">
<Description>
Test if the current query execution should be cancelled.
Not currently used.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFlag:%String=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Quit 0
	Set tCancel = 0
	If +$G(%dsPivotNonce) {
		// give other processes a chance!
		Hang 0.001
		If $D(^DeepSee.Cancel(%dsPivotNonce)) {
			Set tCancel = 1
		}
	}
	Quit tCancel
]]></Implementation>
</Method>

<Method name="%RunServerInitCode">
<Description><![CDATA[
Run the server init code.<br/>
This gives customer applications a chance to establish environmental settings.
This is called whenever a DeepSee session is created or when a background agent starts.<br/>
The server init code is a valid ObjectScript expression stored in the ^DeepSee.InitCode global.
Server init code should not write any output to the current device nor
should this code kill any % variables required by Zen or DeepSee.]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tInitCode = $G($$$DeepSeeInitCode)
		If (tInitCode'="") {
			X tInitCode
			Set tSC = ##class(%DeepSee.Utils).%WriteToLog("ServerInitCode",tInitCode)
		}
	}
	Catch(ex) {
		Set tSC = $$$ERROR($$$GeneralError,"Error in DeepSee ServerInit Code:" _ $ZE)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%RunServerAuditCode">
<Description><![CDATA[
Run the server audit code.<br/>
This gives customer applications a chance to audit viewing of DeepSee dashboard pages.
This is called whenever a DeepSee dashaboard is viewed in the user portal.<br/>
The server audit code is a valid ObjectScript expression stored in the ^DeepSee.AuditCode global.
Server audit code should not write any output to the current device nor
should this code kill any % variables required by Zen or DeepSee.<br/>
The variable, %dsDashboard, will contain the id (name) of the current dashboard item.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDashboardId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		New %dsDashboard
		Set %dsDashboard = pDashboardId
		Set tAuditCode = $G($$$DeepSeeAuditCode)
		If (tAuditCode'="") {
			X tAuditCode
			Set tSC = ##class(%DeepSee.Utils).%WriteToLog("ServerAuditCode",tAuditCode)
		}
	}
	Catch(ex) {
		Set tSC = $$$ERROR($$$GeneralError,"Error in DeepSee ServerAudit Code:" _ $ZE)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%IsCubeAvailable">
<Description>
Test if the given cube is available for querying.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pReason:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tAvailable = 1
	Set pReason = ""
	Try {
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		
		// test for permission
		Set tClassName = ..%GetCubeClass(pCubeName,.tSC)
		If (tClassName = "") {
			Set tAvailable = 0
			Set pReason = $$$FormatText($$$Text("Subject area '%1' does not exist or you do not have permission to view it.","%DeepSee"),pCubeName)
			Quit
		}
		
		If $D($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"compileError")) {
			// DTB949 - Return a specific message for compile failure. This will apply to both cubes
			// and subject areas since both are stored under the "cubes" subscript.
			Set tAvailable = 0
			Set pReason = $$$FormatText($$$Text("Subject area '%1' failed to compile and cannot be used.","%DeepSee"),pCubeName)
			Quit
		}
		
		// test for rebuild
		Lock +^DeepSee.Build(tCubeIndex,"QUERY"):0.1 Else  Set tAvailable = 0
		If ('tAvailable) {
			Set pReason = $$$FormatText($$$Text("Subject area '%1' is currently being rebuilt and is not available.","%DeepSee"),pCubeName)
			Quit
		}
		Lock -^DeepSee.Build(tCubeIndex,"QUERY")
	}
	Catch(ex) {
		Set tAvailable = 0
		Set pReason = $ZE
	}
	Quit tAvailable
]]></Implementation>
</Method>

<Method name="%BuildCube">
<Description><![CDATA[
Update <em>all</em> facts in the DeepSee cube <var>pCubeName</var> 
with data from the source table.<br/>
This will delete any information currently in the cube.<br><br>
<var>pAsync</var> controls whether DeepSee performs the build in multiple background processes.
If this argument is true, the system uses multiple processes and does not return until they are all complete.
If this argument is false, the system uses a single process and does not return until it is complete.<br>
If you have specified initialBuildOrder, the system will reset the value of pAsync to 0 and use a single process to build the cube. 
The presence of initialBuildOrder in the cube definition will override this setting and will force <var>pAsync</var>=0.
The parameter may be passed by reference to communicate to the caller whether or not this
override has taken place.<br/>
When a limit is imposed on background agents for a particular namespace using <method>%SetAgentCount</method>, only one build may be active
at a time in that namespace. This will not have any effect on behavior of builds in other namespaces.<br/>
If <var>pVerbose</var> is true, then status information is written to the console.<br/>
If <var>pIndexOnly</var> is true, only rebuild the fact table indices.<br/>
If <var>pMaxFacts</var> is non-zero, then only build this number of facts.<br/>
<var>pTracking</var> is an internal argument used when this method is run in the background and specifies that status information should be stored.<br/>
<var>pBuildStatistics</var> returns an array of information about the cube build. <br/>
The array has four subscripts. For example, if tStats is the argument used, as in: <br/>
do ##class(%DeepSee.Utils).%BuildCube("PATIENTS",1,,,,,.tStats) the array will look like the following: <br/>
		tStats("elapsedTime")=10.000643          <br/>
		tStats("errors")=1                       <br/>
		tStats("factCount")=5000                 <br/>
		tStats("missingReferences")=1            <br/>
<br/>
If the <var>pFactList</var> is supplied the build will only update the columns listed in that fact list. 
The list must consist of the specific fact names and can have either a comma-delimited or $LB format.
If this list is supplied, the specific facts being updated will be individually marked as unavailable for queries
and queries referencing dimensions based on those facts will throw an error on prepare.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCubeName:%String,pAsync:%Boolean=1,pVerbose:%Boolean=1,pIndexOnly:%Boolean=0,pMaxFacts:%Integer=0,pTracking:%Boolean=0,&pBuildStatistics:%String="",pFactList:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tIsLocked = 0
		Set tUpdateLimitedList = ($G(pFactList)'="")		// DTB906 - Use a compact variable to indicate selective fact updates
		Set tAgentCount = ##class(%DeepSee.Utils).%GetAgentCount("build")		// DTB929 (2)
		Set tCubeNameU = $$$UPPER(pCubeName)
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		Set tClassName = ..%GetCubeClass(pCubeName,.tSC)
		
		// +DTB130 - if a cube uses versions, build the pending version when called using the generic name. If a version
		// is specifically passed in via pCubeName, build it
		Set tPendingVersionNo = ##class(%DeepSee.CubeVersion.Utils).%GetPendingCubeVersion(pCubeName)
		If (tPendingVersionNo'="") {
			Set pCubeName = ##class(%DeepSee.CubeVersion.Utils).%GetVersionedCubeName(pCubeName,tPendingVersionNo)
		}
		Else {
			Set tCubeName = ##class(%DeepSee.CubeVersion.Utils).%GetVersionedCubeName(pCubeName)
			If ##class(%DeepSee.CubeVersion.Utils).%IsActiveVersion(tCubeName) {
				Set tSC = $$$ERROR($$$GeneralError,"Build cannot be called on an activated cube version: " _ tCubeName)
				Quit
			}
		}
		// -DTB130
		If $$$ISERR(tSC) Quit

		If ('..%IsBaseCube(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"Build cannot be called on a SubjectArea: " _ pCubeName)
			Quit
		}
		If (..%IsCubeAbstract(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"Build cannot be called on an abstract Cube: " _ pCubeName)
			Quit
		}
		
		If (tUpdateLimitedList)&&'$$$dsSupportsSelectedList(tCubeNameU) {
			// DTB891 - Consult the namedFactNums setting for this cube and quit with an error if it is not enabled
			Set tSC = $$$ERROR($$$GeneralError,"%BuildCube cannot be called using pFactList without enabling namedFactNums for this cube.")
			Quit
		}
		Else {
			// DTB891 - Convert to a list build format since it is more universally supported
			// DTB961 - Reinforce the list by including the cube in the call to normalize
			Set tFactList = ..%NormalizeFactList(pFactList,.tSC,tCubeIndex)
			If $$$ISERR(tSC) Quit
		}
		// DTB900 - Check the supplied fact list against the cube's fact table
		If '..%IsValidFactList(tCubeNameU,tFactList,.tSC,.tReason) {
			Set tSC = $$$ERROR($$$GeneralError,"Invalid fact list supplied to %BuildCube: List = '" _ $ListToString(tFactList,", ") _ "': Failures = '"_$ListToString(tReason,", ")_"'")		// DTB915 - Add reason to the error message
			Quit
		}
		If $$$ISERR(tSC) Quit

		Set tDSTIME = ""

		New %dsCubeName
		Set %dsCubeName = tCubeNameU

		// do not allow concurrent calls to BuildCube
		// also prevent queries while this cube is being built
		If tUpdateLimitedList {
			// DTB906 - If a selected fact list is in play, individually lock them
			Set tSC = ..%LockFactList(tCubeIndex,tFactList,.tIsLocked)
		}
		Else {
			Lock +^DeepSee.Build(tCubeIndex):1 Else  Set tSC = $$$ERROR($$$GeneralError,"Unable to obtain the lock needed to build cube: " _ pCubeName)
			Set tIsLocked = 1
		}
		If $$$ISERR(tSC) Quit
		
		// + DTB923 - If the agent count is limited, enforce single cube build behavior
		Set tIsAgentLocked = 0
		If +tAgentCount {
			// DTB929 (2)
			Set tAgentCountMax = ..%GetAgentCount("buildMax")
			If +tAgentCountMax && (tAgentCount > tAgentCountMax) {
				Set tAgentCount = tAgentCountMax
			}
			
			Write:pVerbose !,"Agent count is limited to " _tAgentCount _".",!
			Write:pVerbose "Requesting single cube build lock...",!
			Lock +^DeepSee.Build("LIMITAGENTS")
			Write:pVerbose "Proceeding with build of [",pCubeName,"]",!
			Set tIsAgentLocked = 1
		}
		// - DTB923
		
		If tUpdateLimitedList {
			// DTB908 - Mark the specific dimensions being built as enabled=0
			Set tSC = ..%MarkFactsEnabled(tCubeIndex,tFactList,0,1)
			If $$$ISERR(tSC) Quit
		}

		// track time spent in user expressions
		Kill ^IRIS.Temp.DeepSeeBuildStats($namespace,tCubeIndex)

		Set tFactClass = $zobjclassmethod(tClassName,"%GetFactClass")

		If (pTracking) {
			// WAL024
			Kill ^IRIS.Temp.CubeManagerUpdateTracking(+$J,##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCubeName))		// DTB130 - clean up according to the generic name
		}

		// run server init code
		Set tSC = ##class(%DeepSee.Utils).%RunServerInitCode()
		If $$$ISERR(tSC) Quit

		// clear update log
		Set tSC = $zobjclassmethod(tFactClass,"%KillLogFile")
		If $$$ISERR(tSC) Quit

		// reset build error list
		Kill $$$DeepSeeBuildErrorsGLVN(tCubeNameU)
		
		// +DTB531 - Purge listing globals. If the build is happening in the first hour of the day
		// the purge of listings will start with the day prior.
		Kill $$$DeepSeeListingBitGLVN(tCubeNameU)
		Set tListingPurgeDate = $S($P($H,",",2)<3600:$H-1,1:+$H)
		Set tSC = ..%PurgeListings(0,tListingPurgeDate)
		If $$$ISERR(tSC) Quit
		// -DTB531

		// get details on source class
		Set tSC = $zobjclassmethod(tClassName,"%GetSourceInfo",.tSourceInfo)
		If $$$ISERR(tSC) Quit

		Set tInitialBuildOrder = $G(tSourceInfo("initialBuildOrder"))
		Set tBuildRestriction = $G(tSourceInfo("buildRestriction"))
		Set tSourceIsBitFriendly = +$G(tSourceInfo("posint"))
		Set tMaxFacts = $G(tSourceInfo("maxFacts"))
		If (+pMaxFacts>0) {
			Set tMaxFacts = $S('tUpdateLimitedList:+pMaxFacts,1:0)		// DTB921 - Ignore maxfacts for Selective Build
		}
		
		// DTB320 - Force synchronous build if initial build order is defined to preserve the ordering
		If (tInitialBuildOrder'="")&&(pAsync) {
			Set pAsync=0
			Write:pVerbose !,"Initial Build Order defined: Switching to synchronous build.",!
		}

		// JMD1177: get the current dstime counter
		If ($G(tSourceInfo("dstime"))'="") {
			Set tSourceClassName = $G(tSourceInfo("sourceClass"))
			
			// DTB422 - Cube updates no longer care about the source's dsinterval setting, everything will get translated to an increment-style
			// update log. Increment the top counter of this log and push all IDs from the buffer before preceding.
			Set tSC = ..%ProcessUpdateBuffer(tSourceClassName)
			Set tDSTIME = $I($$$DeepSeeUpdateQueue)
			If $$$ISERR(tSC) Quit
			
		}

		// notify (for iKnow)
		// JMD953: make sure error is returned
		Set tSC = $classmethod(tFactClass,"%OnStartBatch",tCubeNameU,pVerbose)

		Write:pVerbose !,"Building cube [",pCubeName,"]",!

		If tUpdateLimitedList {
			// DTB891 - Do not remove the data for all facts. This needs to be cleared out column-wise.
			// Purge only the relevant indices that will be rebuilt. 
			Write:pVerbose "Deleting selected indices..."
			
			// DTB961 - Process the fact list to find the corresponding index list for calling %BuildIndices
			Set tSC = $classmethod(tFactClass,"%PurgeIndices",..%FindCubeIndexList(tCubeIndex,,tFactList))
			If $$$ISERR(tSC) Quit
			Write:pVerbose $C(13,27)_"[0J"
			Write:pVerbose "Selected indices deleted.",!
		}
		ElseIf ('pIndexOnly) {
			Do:pTracking UpdateTracking("delete",,0)
			Write:pVerbose "Deleting existing cube..."
			Set tSC = $classmethod(tClassName,"%KillFacts")
			If $$$ISERR(tSC) Quit
			Write:pVerbose $C(13,27)_"[0J"
			Write:pVerbose "Existing cube deleted.",!
			Do:pTracking UpdateTracking("delete",,100)
		}
		Else {
			Write:pVerbose "Deleting existing indices..."
			Set tSC = $classmethod(tFactClass,"%PurgeIndices")
			If $$$ISERR(tSC) Quit
			Write:pVerbose $C(13,27)_"[0J"
			Write:pVerbose "Existing indices deleted.",!
		}

		// clear precompute cache
		Set tStart = $ZH

		Set tPercentComplete = 0

		New %dsfactcount,%dserrors,%dserrcount		// DTB473
		Set %dsfactcount = 0
		Set %dserrcount = 0
		New %dsmaxfacts
		If (tMaxFacts>0) {
			Set %dsmaxfacts = tMaxFacts
		}

		New %dsMissingRef
		Set %dsMissingRef = 0

		If ('pAsync) {
			If ('pIndexOnly) {
				Set tSC = $classmethod(tClassName,"%BuildFactTable",pVerbose,tFactList)		// DTB891
				If $$$ISERR(tSC) Quit

				Write:pVerbose $C(13,27)_"[0J"
				Write:pVerbose "Fact table built:"
				Write:pVerbose ?25,$J($FN(+$G(%dsfactcount),",",0),10)_" fact(s) (1 core used)",!
				If (%dserrcount>0) {
					Write:pVerbose ?25,$J($FN(+$G(%dserrcount),",",0),10)_" error(s)",!
				} Else {
					Set tFacts = $FN(+$G(%dsfactcount),",",0)
				}
				If (%dsMissingRef>0) {
					Write:pVerbose ?25,$J($FN(+$G(%dsMissingRef),",",0),10)_" missing reference(s)",!
				}
			}

			Write:pVerbose "Building indices..."
			
			// DTB961 - Process the fact list to find the corresponding index list for calling %BuildIndices
			Set tSC = $classmethod(tFactClass,"%BuildIndices",..%FindCubeIndexList(tCubeIndex,,tFactList))
			If $$$ISERR(tSC) Quit
			
			Write:pVerbose $C(13,27)_"[0J"
			Write:pVerbose "Fact indices built: ",?25,$J($FN(tFacts,",",0),10)," fact(s) (1 worker used)",!
		}
		Else {
			// set agents equal to 1*cores ???
			Set tCPU = ##class(%SYSTEM.CPU).%New()
			Set:'+tAgentCount tAgentCount = tCPU.nCores		// DTB923 - Don't reset

			If ('pIndexOnly) {
				Do:pTracking UpdateTracking("facts",0,0)

				// if true, then use a temp file to build tables in parallel
				// that would not normally be done in parallel
				Set tUseTempFile = 1

				If ('tSourceIsBitFriendly || (tMaxFacts>0) ||( tInitialBuildOrder'="") || (tBuildRestriction'="") || (tFactList'="")) {		// DTB927 - Use temp file if there is a fact list
					If (tUseTempFile) {
						Set tTempFileKey = $I($$$DeepSeeTempSourceId)
						Set tSC = $zobjclassmethod(tFactClass,"%BuildTempFile",tTempFileKey,.tImplemented,pVerbose)
						If $$$ISERR(tSC) Quit
						If ('tImplemented) {
							Set tUseTempFile = 0
						}
					}

					If ('tUseTempFile) {
						// build fact table in one process
						Set tSC = $classmethod(tClassName,"%BuildFactTable",pVerbose,tFactList)		// DTB891 - Pass tFactList
						If $$$ISERR(tSC) Quit

						Write:pVerbose $C(13,27)_"[0J"
						Write:pVerbose "Fact table built:"
						Write:pVerbose ?25,$FN(+$G(%dsfactcount),",",0)_" fact(s)"
						If (%dserrcount>0) {
							Write:pVerbose ", ",$FN(+$G(%dserrcount),",",0)_" error(s)"
						} Else {
							Set tFacts = $FN(+$G(%dsfactcount),",",0)
						}
						Write:pVerbose " (1 core used)",!
					}
					Else {
						// JMD1203: invoke callback
						Set tSC = $classmethod(tClassName,"%OnBuildCube",tFactList)		// DTB891 - Pass pFactList as supplied by the user to the user callback
						If $$$ISERR(tSC) Quit

						// use temp file of source ids, to build in parallel
						// use background tasks
						// DTB704 - This is now handled by the %DeepSee.WorkMgr
						Set tSC = ##class(%DeepSee.WorkMgr).%CreateTaskGroup(.tGroupId,1,"UPDATEFACTSTEMP",1,.tWorkMgr)		// DTB923 - Request WorkMgr oref
						
						If $$$ISERR(tSC) {
							Do $System.Status.DisplayError(tSC)
							Quit
						}

						// use temp global to track progress
						// background tasks will update this
						Kill $$$DeepSeeTempUpdate($namespace,tGroupId)

						// update facts for each "chunk"
						Set tChunk = $O($$$DeepSeeTempSourceId(tTempFileKey,""))
						While (tChunk '= "") {
							// DTB704 - This is now handled by the %DeepSee.WorkMgr
							Set tSC = ##class(%DeepSee.WorkMgr).%QueueTask(tGroupId,"UPDATEFACTSTEMP",pCubeName,"",tTempFileKey,tChunk,,tFactList,,.tWorkMgr)		// DTB891 - Queue up the tFactList	// DTB923 - Include WorkMgr oref
							
							If $$$ISERR(tSC) $$$ThrowStatus(tSC)		// DTB
							Set tChunk = $O($$$DeepSeeTempSourceId(tTempFileKey,tChunk))
						}
						If $$$ISERR(tSC) Quit

						// now wait on tasks to complete
						If ('pVerbose && ('pTracking)) {
							// DTB704 - This is now handled by the %DeepSee.WorkMgr
							Set tSC = ##class(%DeepSee.WorkMgr).%WaitForTaskGroup(tGroupId,,,.tWorkMgr)		// DTB923 - Include WorkMgr oref
							If $$$ISERR(tSC) Quit
							
							// DTB794 - Set local variables in this case as well
							Set tFacts = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
							Set tErrors = +$G($$$DeepSeeBuildErrorsGLVN(tCubeNameU))
							Set tMissingRefs = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"missing"))
							Kill $$$DeepSeeTempUpdate($namespace,tGroupId)
						}
						Else {
							Set tTimeOut = 2
							Set tCompleted = 0
							Set tPct = 0
							While ('tCompleted) {
								Set tFacts = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
								Set tCount = +$G($$$DeepSeeTaskGroupGLVN(tGroupId,"count"))
								Set tComplete = +$G($$$DeepSeeTaskGroupGLVN(tGroupId,"complete"))
								Set:tCount>0 tPercentComplete = (tComplete/tCount)*100
								Write:pVerbose $C(13,27)_"[0J"_"Building fact table: ",?25,$J($FN(tFacts,",",0),10)," fact(s) updated.  "_$J($FN(+$G(tPercentComplete),",",0),3)_"% tasks complete"
								Do:pTracking UpdateTracking("facts",tFacts,tPercentComplete)
								// DTB704 - This is now handled by the %DeepSee.WorkMgr
								Set tSC = ##class(%DeepSee.WorkMgr).%WaitForTaskGroup(tGroupId,.tCompleted,tTimeOut,.tWorkMgr)		// DTB923 - Include WorkMgr oref
							
								If $$$ISERR(tSC) Quit
								Set tPct = tPct + 1
							}
							Set tFacts = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
							Set tErrors = +$G($$$DeepSeeBuildErrorsGLVN(tCubeNameU))
							Set tMissingRefs = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"missing"))		// DTB301
							
							// Statitics output printed to terminal
							Write:pVerbose $C(13,27)_"[0J"
							Write:pVerbose "Fact table built: ",?25,$J($FN(tFacts,",",0),10)," fact(s) ("_tAgentCount_" worker(s) used)",!
							Write:pVerbose&&(tErrors) "Errors: ",?25,$J($FN(tErrors,",",0),10)," error(s)",!
							If (tMissingRefs>0) {
								// DTB301 - Report missing references
								Write:pVerbose ?25,$J($FN(+$G(tMissingRefs),",",0),10)_" missing reference(s)",!
							}

							Kill $$$DeepSeeTempUpdate($namespace,tGroupId)
							Do:pTracking UpdateTracking("facts",tFacts,tPercentComplete)
						}
						// kill temp file
						Kill $$$DeepSeeTempSourceId(tTempFileKey)
					}
				}
				Else {
					// we can build the fact table in parallel
			
					// JMD1203: invoke callback
					Set tSC = $classmethod(tClassName,"%OnBuildCube")
					If $$$ISERR(tSC) Quit

					// find range of id values for source table
					Set tSC = $zobjclassmethod(tClassName,"%GetSourceIds",.tStartId,.tEndId)
					If $$$ISERR(tSC) Quit

					// use background tasks
					// DTB704 - This is now handled by the %DeepSee.WorkMgr
					Set tSC = ##class(%DeepSee.WorkMgr).%CreateTaskGroup(.tGroupId,1,"UPDATEFACTS",1,.tWorkMgr)		// DTB923 - Request WorkMgr oref
					
					If $$$ISERR(tSC) {
						Do $System.Status.DisplayError(tSC)
						Quit
					}

					// break range into bitmap chunk-size sub-ranges
					Set tItemCount = 0
					Set tStartChunk = (+tStartId\64000)+1
					Set tRangeStartId = ((tStartChunk-1)*64000)
					While (tRangeStartId <= tEndId) {
						Set tRangeEndId = tRangeStartId + 64000 - 1
						Set:(tRangeStartId<tStartId) tRangeStartId = tStartId
						Set:((tRangeEndId)>tEndId) tRangeEndId = tEndId 

						Set tItemCount = tItemCount + 1
						Set tWorkList(tItemCount) = $LB(tRangeStartId,tRangeEndId)
						Set tStartChunk = tStartChunk + 1
						Set tRangeStartId = ((tStartChunk-1)*64000)
					}

					// use temp global to track progress
					// background tasks will update this
					Kill $$$DeepSeeTempUpdate($namespace,tGroupId)

					// update facts for each item
					Set tItem = $O(tWorkList(""))
					While (tItem '= "") {
						Set tRangeStartId = $LG(tWorkList(tItem),1)
						Set tRangeEndId = $LG(tWorkList(tItem),2)
						// DTB704 - This is now handled by the %DeepSee.WorkMgr
						Set tSC = ##class(%DeepSee.WorkMgr).%QueueTask(tGroupId,"UPDATEFACTS",pCubeName,"",tRangeStartId,tRangeEndId,,tFactList,,.tWorkMgr)		// DTB891	// DTB923 - Include WorkMgr oref
						
						If $$$ISERR(tSC) $$$ThrowStatus(tSC)		// DTB
						Set tItem = $O(tWorkList(tItem))
					}
					If $$$ISERR(tSC) Quit

					// now wait on tasks to complete
					If ('pVerbose && ('pTracking)) {
						// DTB704 - This is now handled by the %DeepSee.WorkMgr
						Set tSC = ##class(%DeepSee.WorkMgr).%WaitForTaskGroup(tGroupId,,,.tWorkMgr)		// DTB923 - Include WorkMgr oref
						
						// DTB798 - Set local variables in this case as well
						Set tFacts = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
						Set tErrors = +$G($$$DeepSeeBuildErrorsGLVN(tCubeNameU))
						Set tMissingRefs = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"missing"))
						If $$$ISERR(tSC) Quit
					}
					Else {
						Set tTimeOut = 2
						Set tCompleted = 0
						Set tPct = 0
						While ('tCompleted) {
							Set tFacts = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
							Set tCount = +$G($$$DeepSeeTaskGroupGLVN(tGroupId,"count"))
							Set tComplete = +$G($$$DeepSeeTaskGroupGLVN(tGroupId,"complete"))
							Set:tCount>0 tPercentComplete = (tComplete/tCount)*100
							Write:pVerbose $C(13,27)_"[0J"_"Building fact table: ",?25,$J($FN(tFacts,",",0),10)," fact(s) updated.  "_$J($FN(+$G(tPercentComplete),",",0),3)_"% tasks complete"
							Do:pTracking UpdateTracking("facts",tFacts,tPercentComplete)
							// DTB704 - This is now handled by the %DeepSee.WorkMgr
							Set tSC = ##class(%DeepSee.WorkMgr).%WaitForTaskGroup(tGroupId,.tCompleted,tTimeOut,.tWorkMgr)		// DTB923 - Include WorkMgr oref
					
							If $$$ISERR(tSC) Quit
							Set tPct = tPct + 1
						}
						Set tFacts = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
						Write:pVerbose $C(13,27)_"[0J"
						Write:pVerbose "Fact table built: ",?25,$J($FN(tFacts,",",0),10)," fact(s) ("_tAgentCount_" worker(s) used)",!

						Set tErrors = +$G($$$DeepSeeBuildErrorsGLVN(tCubeNameU))
						Write:pVerbose&&(tErrors) "Errors: ",?25,$J($FN(tErrors,",",0),10)," error(s)",!
						
						// DTB301 - Report missing references
						Set tMissingRefs = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"missing"))
						If (tMissingRefs>0) {
							Write:pVerbose ?25,$J($FN(+$G(tMissingRefs),",",0),10)_" missing reference(s)",!
						}

						Kill $$$DeepSeeTempUpdate($namespace,tGroupId)
						Do:pTracking UpdateTracking("facts",tFacts,tPercentComplete)
					}
				}
			}

			If $$$ISERR(tSC) Quit

			Do:pTracking UpdateTracking("facts",$G(tFacts),100)

			// build indices
			Do:pTracking UpdateTracking("indices",0,0)
			Set tSC = $zobjclassmethod(tClassName,"%GetFactIdRange",.tStartFactId,.tEndFactId)
			If $$$ISERR(tSC) Quit

			// DTB704 - This is now handled by the %DeepSee.WorkMgr
			// DTB923 - Plan to reuse the current WorkMgr oref if it was previously created, else request a new one
			Set tSC = ##class(%DeepSee.WorkMgr).%CreateTaskGroup(.tGroupId,1,"BUILDINDICES",'$IsObject($G(tWorkMgr)),.tWorkMgr)
			
			If $$$ISERR(tSC) Quit

			// use temp global to track progress
			// background tasks will update this
			Kill $$$DeepSeeTempUpdate($namespace,tGroupId)

			// build indices
			Kill tWorkList

			If ((tStartFactId'="")&&(tEndFactId'="")) {
				Set tItemCount = 0
				Set tStartChunk = (+tStartFactId\64000)+1
				Set tRangeStartId = ((tStartChunk-1)*64000)
				While (tRangeStartId <= tEndFactId) {
					Set tRangeEndId = tRangeStartId + 64000 - 1
					Set:(tRangeStartId<tStartFactId) tRangeStartId = tStartFactId
					Set:((tRangeEndId)>tEndFactId) tRangeEndId = tEndFactId

					Set tItemCount = tItemCount + 1
					Set tWorkList(tItemCount) = $LB(tRangeStartId,tRangeEndId)
					Set tStartChunk = tStartChunk + 1
					Set tRangeStartId = ((tStartChunk-1)*64000)
				}
			}

			Set tItem = $O(tWorkList(""))
			While (tItem '= "") {
				Set tRangeStartId = $LG(tWorkList(tItem),1)
				Set tRangeEndId = $LG(tWorkList(tItem),2)
				// DTB704 - This is now handled by the %DeepSee.WorkMgr
				// DTB961 - Process the fact list to find the corresponding index list for ultimately calling %BuildIndices
				Set tSC = ##class(%DeepSee.WorkMgr).%QueueTask(tGroupId,"BUILDINDICES",pCubeName,"",tRangeStartId,tRangeEndId,,..%FindCubeIndexList(tCubeIndex,,tFactList),,.tWorkMgr)		// DTB923 - Include WorkMgr oref
				If $$$ISERR(tSC) $$$ThrowStatus(tSC)		// DTB
				
				Set tItem = $O(tWorkList(tItem))
			}
			If $$$ISERR(tSC) Quit

			// now wait on tasks to complete
			If ('pVerbose&&('pTracking)) {
				// DTB704 - This is now handled by the %DeepSee.WorkMgr
				Set tSC = ##class(%DeepSee.WorkMgr).%WaitForTaskGroup(tGroupId,,,.tWorkMgr)		// DTB923 - Include WorkMgr oref
				
				If $$$ISERR(tSC) Quit
			}
			Else {
				Set tTimeOut = 2
				Set tCompleted = 0
				Set tPct = 0
				While ('tCompleted) {
					Set tFacts = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
					Set tCount = +$G($$$DeepSeeTaskGroupGLVN(tGroupId,"count"))
					Set tComplete = +$G($$$DeepSeeTaskGroupGLVN(tGroupId,"complete"))
					Set:tCount>0 tPercentComplete = (tComplete/tCount)*100
					Write:pVerbose $C(13,27)_"[0J"_"Building indices... "_$J($FN(tFacts,",",0),10)_" fact(s) processed. "_$J($FN(+$G(tPercentComplete),",",0),3)_"% tasks complete"
					Do:pTracking UpdateTracking("indices",tFacts,tPercentComplete)
					
					// DTB704 - This is now handled by the %DeepSee.WorkMgr
					Set tSC = ##class(%DeepSee.WorkMgr).%WaitForTaskGroup(tGroupId,.tCompleted,tTimeOut,.tWorkMgr)		// DTB923 - Include WorkMgr oref
					
					If $$$ISERR(tSC) Quit
					Set tPct = tPct + 1
				}
				Set tFacts = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
				Write:pVerbose $C(13,27)_"[0J"
				Write:pVerbose "Fact indices built: ",?25,$J($FN(tFacts,",",0),10)," fact(s) ("_tAgentCount_" worker(s) used)",!
				Do:pTracking UpdateTracking("indices",tFacts,tPercentComplete)
				Kill $$$DeepSeeTempUpdate($namespace,tGroupId)
				If $$$ISERR(tSC) Quit
			}
			Do:pTracking UpdateTracking("indices",$G(tFacts),100)
		}

		// notify (for iKnow)
		If (pVerbose) {
			Write $C(13,27)_"[0J"
			Write "Processing iKnow Indices..."
		}
		
		// BDB324: track iKnow index build
		do ##class(%iKnow.DeepSee.CubeUtils).GetIKnowMeasures(pCubeName,.tIKMsrs)
		do:pTracking&&$d(tIKMsrs) UpdateTracking("iknow",0,0)
		
		// JMD953: make sure error is returned
		Set tSC = $classmethod(tFactClass,"%OnEndBatch",tCubeNameU,pVerbose)
		If $$$ISERR(tSC) Quit

		// BDB324: mark iKnow index build end
		do:pTracking&&$d(tIKMsrs) UpdateTracking("iknow",$g(tFacts),100)

		If (pVerbose) {
			Write $C(13,27)_"[0J"
			Write !
		}

		// update sync point (timestamp)
		// DTB422 - Store the update time in the update global
		// DTB899 - Do not update if pFactList is supplied. INSERTS were not processed in selective build
		If (tDSTIME'="")&&'tUpdateLimitedList { 
			Set tSC = ##class(%DeepSee.Utils).%SetCubeDSTime(tCubeNameU,tDSTIME)		// DTB838 - Use API
			If $$$ISERR(tSC) Quit
		}

		// update lastDataUpdate
		Set $$$DeepSeeUpdateQueue("cubes",tCubeNameU,"lastDataUpdate") = $ZTIMESTAMP		// DTB422

		Set tSC = ..%PrecomputeAggregates(pCubeName,pAsync,pVerbose,pTracking)
		If $$$ISERR(tSC) Quit

		If (pVerbose) {
			Write $C(13,27)_"[0J"
			Write "Complete",!
			Write "Elapsed time: ",?25,$J($FN($ZH-tStart,"",6),14),"s",!
			Write "Source expression time: ",?25,$J($FN(+$G(^IRIS.Temp.DeepSeeBuildStats($namespace,tCubeNameU,"expr")),"",6),14),"s",!
			
			If ($D(^IRIS.Temp.DeepSeeBuildStats($namespace,tCubeNameU,"iknow"))) {
				Write "iKnow processing time: ",?25,$J($FN(+$G(^IRIS.Temp.DeepSeeBuildStats($namespace,tCubeNameU,"iknow")),"",6),14),"s",!
			}
		}
		Set ^IRIS.Temp.DeepSeeBuildStats.prevBuildFinished($namespace, pCubeName) = $horolog
		
		Do:pTracking UpdateTracking("complete")
		
		// + WAL270 -- return array of build statistics
		//             some cases use the % variables, some don't -- safely check both
		// DTB423 - Remove formatting from statistics
		Set pBuildStatistics("factCount") = +$G(%dsfactcount)
		Set:$G(pBuildStatistics("factCount"))=0 pBuildStatistics("factCount") = +$G(tFacts)
		Set pBuildStatistics("errors") = +$G(%dserrors)
		Set:$G(pBuildStatistics("errors"))=0 pBuildStatistics("errors") = +$G(tErrors)
		Set pBuildStatistics("missingReferences") = +$G(%dsMissingRef)
		Set:$G(pBuildStatistics("missingReferences"))=0 pBuildStatistics("missingReferences") = +$G(tMissingRefs)
		Set pBuildStatistics("elapsedTime") = $ZH-$G(tStart)
		If ($G(tCubeNameU)'="") {
			// DTB432 - Add additional build statistics
			Set pBuildStatistics("expressionTime") = +$G(^IRIS.Temp.DeepSeeBuildStats($namespace,tCubeNameU,"expr"))
			Set pBuildStatistics("iKnowTime") = +$G(^IRIS.Temp.DeepSeeBuildStats($namespace,tCubeNameU,"iknow"))
		}
		// - WAL270

		If (pVerbose) {
			// check cardinality of dimensions
			Set tThreshold = 20000
			Set tSC = ..%GetDimensionTables(pCubeName,.tTables,1)
			If $$$ISERR(tSC) Quit
			Set k = $O(tTables(""))
			While (k'="") {
				If ($G(tTables(k)) > tThreshold) {
					Write "**Warning** dimension table '"_k_"' has a large number of members ("_tTables(k)_")",!
				}
				Set k = $O(tTables(k))
			}
		}
		
		// DTB908 - Mark the specific dimensions being built as enabled=1, inProgress=0 if this completes successfully
		// In the case of a complete build, mark them all
		Set tSC = ..%MarkFactsEnabled(tCubeIndex,tFactList)
		If $$$ISERR(tSC) Quit
 	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	
	// JMD1480
	If ($$$ISOK(tSC)&&(tCubeNameU'="")) {
		Set tErrors = +$G($$$DeepSeeBuildErrorsGLVN(tCubeNameU))
		If (tErrors) {
			// DTB426 - Return the number of build errors.
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText($$$Text("There were %1 errors while building cube %2. For more detailed information: Do ##class(%DeepSee.Utils).%PrintBuildErrors(""%2"").","%DeepSee"),tErrors,tCubeNameU))
		}
	}
	
	// DTB233 - Call %OnAfterBuildCube
	Set tCallBackSC = $$$OK
	If $G(tClassName)'="" {
		Set tErrors = +$G(tErrors)
		Set tCallBackSC = $classmethod(tClassName,"%OnAfterBuildCube",tSC,tErrors)
	}
	If $$$ISOK(tSC)&&$$$ISERR(tCallBackSC) {
		// If the user chose to return an error in an otherwise successful build, return it
		Set tSC = tCallBackSC
	}
	
	// Release the lock after the user callback is complete
	If (tIsLocked) {
		If tUpdateLimitedList {
			// DTB906 - Release all columns in the fact list
			// DTB961 - This return status is unnecessary and would overwrite any previous error
			Do ..%UnlockFactList(tCubeIndex,tFactList)
		}
		Else {
			Lock -^DeepSee.Build(tCubeIndex)
		}
	}
	// DTB923 - Release agent-limited build lock
	If +$G(tIsAgentLocked) {
		Lock -^DeepSee.Build("LIMITAGENTS")
		Set tIsAgentLocked = 0
	}
	
	If (pVerbose && $$$ISERR(tSC)) {
		Do $System.Status.DisplayError(tSC)
	}
	If pTracking,$$$ISERR(tSC) {
		Do $System.Status.DecomposeStatus(tSC,.errors)		// DTB426 - Don't reset the return status
		Set error = $O(errors(""))
		While error '= "" {
			Do UpdateTracking("error",,,errors(error))	
			Set error = $O(errors(error))	
		}
	}

	Quit tSC
UpdateTracking(phase,count,pct,errors)
	Set tStep = $Case(phase,"delete":1,"facts":2,"indices":3,"iknow":4,"aggs":5,"error":7,:6)
	Set ^IRIS.Temp.DeepSeeTracking($namespace, pCubeName,tStep) = $LB(phase,$G(count),$G(pct),$G(errors))
	// WAL024
	// DTB130 - use the generic name for update tracking
	Set ^IRIS.Temp.CubeManagerUpdateTracking(+$J,##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCubeName),tStep) = $LB(phase,$G(count),$G(pct),$G(errors))
	Quit
]]></Implementation>
</Method>

<Method name="%LogBuildError">
<Description>
Log a %Status to the ^DeepSee.BuildErrors global.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String="",pRecordID:%Integer=0,pStatus:%Status=$$$OK</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method Added by DTB836
	Set tSC = $$$OK
	Try {
		If (pCubeName="") {
			Set tSC = $$$ERROR($$$GeneralError,"Cube name must be supplied to %LogBuildError")
			Quit
		}
		If 'pRecordID {
			Set tSC = $$$ERROR($$$GeneralError,"Record number must be supplied to %LogBuildError")
			Quit
		}

		
		Set tCubeNameU = $$$UPPER(pCubeName)
		
		S:($G($$$DeepSeeBuildErrorsGLVN(tCubeNameU,pRecordID))="") x = $I($$$DeepSeeBuildErrorsGLVN(tCubeNameU))		// Prevent double-counting
		Set $$$DeepSeeBuildErrorsGLVN(tCubeNameU,pRecordID) = pStatus
		Set $$$DeepSeeBuildErrorsGLVN(tCubeNameU,pRecordID,"info") = $LB($H,$J)
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%BuildStatus">
<Description>
Commandline utility for monitoring data cube build progress</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<Implementation><![CDATA[
	If ($DATA(^IRIS.Temp.DeepSeeTracking($namespace, pCubeName)) = 0) {
		Set date = $zdate($PIECE(^IRIS.Temp.DeepSeeBuildStats.prevBuildFinished($namespace, pCubeName), ",", 1))
		Set time = $ztime($PIECE(^IRIS.Temp.DeepSeeBuildStats.prevBuildFinished($namespace, pCubeName), ",", 2))
		Write "There is no build in progress. Last build was finished on " _ date _ " " _ time _ "."
		Quit 
	}
	Set tIsComplete = 0
	Set tStep = $O(^IRIS.Temp.DeepSeeTracking($namespace, pCubeName,""),1,info)
	Set tOutput = ""
	Set table = ""
	While (tStep '= "" && tIsComplete = 0) {
		Set tPhase = $LG(info,1)
		Set:tPhase="complete"!(tPhase="error") tIsComplete = 1 
		Set tCount = $LG(info,2)
		Set tPct = $LG(info,3) 
		Set tErr = $LG(info,4)
		Set tMsg = $Case(tPhase,"delete":"Deleting facts","facts": "Building "_ $FN(tCount,",",0)_ " facts","indices":"Building "_$FN(tCount,",",0)_" indices","aggs":"Computed "_$FN(tCount,",",0)_" aggregates","iknow":"Processing iKnow measures","error":"Error",:"Complete")
		
		If (tPhase '= "complete") {Set table(tPhase) = tMsg}
		Set prop = $O(table(""))
		Write $CHAR(13)
		While (prop '= "") {
			Write table(prop), " | "
			Set prop = $O(table(prop))
		}
		If (tErr = "") {
			Write $CHAR(13), tOutput
		}
		Else {
			Write !, tErr
		}
		Set tStep = $O(^IRIS.Temp.DeepSeeTracking($namespace, pCubeName,tStep),1,info)
	}
	Write !, "COMPLETE"
	While (1) {
		If (^IRIS.Temp.DeepSeeTracking.buildInProgress($namespace) = 0) {
			Kill ^IRIS.Temp.DeepSeeTracking($namespace, pCubeName)
			Quit
		}
	}
]]></Implementation>
</Method>

<Method name="%FixBuildErrors">
<Description>
For the given cube, iterate over all facts in the build error log and attempt to
reprocess each fact. If the processing succeeds, remove the item from the error log.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCount = 0
		Set tErrorCount = 0
		Set tCubeNameU = $$$UPPER(pCube)
		Set tSourceId = $O($$$DeepSeeBuildErrorsGLVN(tCubeNameU,""))
		
		// DTB631 - Find the source class for the cube to verify the logged ID
		Set tCubeClass = ..%GetCubeClass(tCubeNameU)
		Set tSC = $zobjclassmethod(tCubeClass,"%GetSourceInfo",.tSourceInfo)
		If $$$ISERR(tSC) Quit
		Set tSourceClass = tSourceInfo("sourceClass")
		
		While (tSourceId'="") {
			Set tSC2 = ..%ProcessFact(pCube,tSourceId,0)
			If $$$ISOK(tSC2)||((tSourceClass'="")&&'$classmethod(tSourceClass,"%ExistsId",tSourceId)) {		// DTB631
				Write:pVerbose "Fact '",tSourceId,"' corrected",!
				Set tCount = tCount + 1
				// remove error from list
				Kill $$$DeepSeeBuildErrorsGLVN(tCubeNameU,tSourceId)
				Set $$$DeepSeeBuildErrorsGLVN(tCubeNameU) = $G($$$DeepSeeBuildErrorsGLVN(tCubeNameU)) - 1
			}
			Else {
				Set tErrorCount = tErrorCount + 1
				If (pVerbose) {
					Do $System.Status.DisplayError(tSC2)
					Write !
				}
			}
			Set tSourceId = $O($$$DeepSeeBuildErrorsGLVN(tCubeNameU,tSourceId))
		}

		Write:pVerbose !!,$FN(tCount,",")," fact(s) corrected for '",pCube,"'",!
		Write:pVerbose $FN(tErrorCount,",")," error(s) remaining for '",pCube,"'",!
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%PrintBuildErrors">
<Description>
Display the list of errors encountered in the most recent build of the given cube.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String=""</FormalSpec>
<Implementation><![CDATA[
	If (pCube'="") {
		// PFS060 - Check for existence of cube and inform user if cube does not exist
		Set tCubeExists = ..%CubeExists(pCube)
		If 'tCubeExists {
			Write $$$FormatText($$$Text("Cube '%1' does not exist"),pCube),!
			Quit
		}
		Set tCubeNameU = $$$UPPER(pCube)
		Set tCount = 0
		Set k = $O($$$DeepSeeBuildErrorsGLVN(tCubeNameU,""))
		While (k'="") {
			Set tCount = tCount + 1
			Set tSC = $G($$$DeepSeeBuildErrorsGLVN(tCubeNameU,k))
			Set tTime = $LG($G($$$DeepSeeBuildErrorsGLVN(tCubeNameU,k,"info")),1)		// DTB836 - Check for time stamp
			Write $J($FN(tCount,","),5),$J("",3),"Source ID: ",k		// DTB291 - Print source ID
			Write:(tTime'="") !,?8,"Time: ",$ZDT(tTime)		// DTB836
			Write !,?8,$System.Status.GetErrorText(tSC),!!
			Set k = $O($$$DeepSeeBuildErrorsGLVN(tCubeNameU,k))
		}
		Write $FN(tCount,",")," build error(s) for '",pCube,"'",!
	} 
	Else {
		// PFS060 - Provide useful feedback to the user if no cube name is supplied
		Write $$$Text("Please enter a cube name"),!
	}
]]></Implementation>
</Method>

<Method name="%PrecomputeAggregates">
<Description><![CDATA[
Precompute aggregate values for the given cube (if its precompute property is non-zero).<br/>
If <var>pAsync</var> is true, then background tasks are used.<br/>
If <var>pVerbose</var> is true, then status information is written to the console.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pAsync:%Boolean=1,pVerbose:%Boolean=1,pTracking:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.tSC)
		If $$$ISERR(tSC) Quit

		If ('..%IsBaseCube(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"Precompute cannot be called on a SubjectArea: " _ pCubeName)
			Quit
		}

		// compute preaggregates
		Set tPrecompute = $zobjclassmethod(tClassName,"%GetPrecomputeLevel")
		If (tPrecompute = 0) {
			// nothing to do
			Quit
		}

		Set tStart = $ZH
		Do:pTracking UpdateTracking("aggs",0,0)

		Set tFactClass = $zobjclassmethod(tClassName,"%GetFactClass")

		// aggregrate pre-computed values and move into cell cache
		Set tCube = $$$UPPER(pCubeName)
		Set tChunksPerBucket = $$$DeepSeeChunksPerBucket(pCubeName)

		Set tPercentComplete = 0

		Set tSC = ##class(%DeepSee.Query.Engine).%GetBucketList(pCubeName,.tBucketList,.tActiveChunk)
		If $$$ISERR(tSC) Quit
		If (pAsync) {
			Set tSC = ##class(%DeepSee.WorkMgr).%CreateTaskGroup(.tGroupId,1,"PRECOMPUTE")		// DTB704 - This is now handled by the %DeepSee.WorkMgr
			If $$$ISERR(tSC) Quit
		}

		Set tCount = 0
		Set tLastBucket = $O(tBucketList(""),-1)
		Set tBucketNo = $O(tBucketList(""))
		While (tBucketNo '= "") {
			Set tSlotNo = $G(tBucketList(tBucketNo))

			Set tStartChunk = ((tBucketNo-1)*tChunksPerBucket)+1
			Set tEndChunk = tStartChunk + tChunksPerBucket - 1
			If ((tActiveChunk >= tStartChunk)&&(tActiveChunk <= tEndChunk)) {
				Set tEndChunk = tActiveChunk - 1
			}

			If ('pAsync) {
				// construct process private GLVN to hold results
				// We use a global to avoid <STORE> errors and indirection to avoid contention!
				Set tAggGLVN = "^||DeepSee.Agg."_$ZCRC(tCube,7)
				Kill @tAggGLVN
				Set tSC = $zobjclassmethod(tFactClass,"%PrecomputeAggregates",tStartChunk,tEndChunk,tAggGLVN,pVerbose,,.tCount)
				If $$$ISERR(tSC) {
					Kill @tAggGLVN
					Quit
				}
				Kill $$$DeepSeeCellsGLVN(tCube,tSlotNo)
				Merge $$$DeepSeeCellsGLVN(tCube,tSlotNo) = @tAggGLVN
				Kill @tAggGLVN
				Write:pVerbose !,"Elapsed time: ",$ZH-tStart,"s",!
			}
			Else {
				// queue task
				Set tSC = ##class(%DeepSee.WorkMgr).%QueueTask(tGroupId, "PRECOMPUTE",pCubeName,"",tStartChunk,tEndChunk,tSlotNo)		// DTB704 - This is now handled by the %DeepSee.WorkMgr
				If $$$ISERR(tSC) Quit
			}
			Set tBucketNo = $O(tBucketList(tBucketNo))
		}

		If (pAsync) {
			// now wait on precompute tasks to complete
			If ('pVerbose && 'pTracking) {
				Set tSC = ##class(%DeepSee.WorkMgr).%WaitForTaskGroup(tGroupId)		// DTB704 - This is now handled by the %DeepSee.WorkMgr
				If $$$ISERR(tSC) Quit
			}
			Else {
				Set tTimeOut = 2
				Set tCompleted = 0
				Set tPct = 0
				While ('tCompleted) {
					Set tFacts = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
					Set tCount = +$G($$$DeepSeeTaskGroupGLVN(tGroupId,"count"))
					Set tComplete = +$G($$$DeepSeeTaskGroupGLVN(tGroupId,"complete"))
					Set:tCount>0 tPercentComplete = (tComplete/tCount)*100
					Write:pVerbose $C(13,27)_"[0J"_"Precomputing aggregates... "_$J($FN(tFacts,",",0),10)_" fact(s) processed. "_$J($FN(+$G(tPercentComplete),",",0),3)_"% tasks complete"
					Do:pTracking UpdateTracking("aggs",tFacts,tPercentComplete)
					Set tSC = ##class(%DeepSee.WorkMgr).%WaitForTaskGroup(tGroupId,.tCompleted,tTimeOut)		// DTB704 - This is now handled by the %DeepSee.WorkMgr
					If $$$ISERR(tSC) Quit
					Set tPct = tPct + 1
				}
				Set tFacts = +$G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
				Write:pVerbose $C(13,27)_"[0J"
				Write:pVerbose "Aggregates complete: ",$FN(tFacts,",",0)," fact(s). ",$ZH-tStart,"s",!
				Do:pTracking UpdateTracking("aggs",tFacts,tPercentComplete)
				Kill $$$DeepSeeTempUpdate($namespace,tGroupId)
				If $$$ISERR(tSC) Quit
			}
		}
 	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If (pVerbose && $$$ISERR(tSC)) {
		Do $System.Status.DisplayError(tSC)
	}
	Quit tSC

UpdateTracking(phase,count,pct,errors)
	Set tStep = $Case(phase,"delete":1,"facts":2,"indices":3,"aggs":4,:5)
	Set ^IRIS.Temp.DeepSeeTracking($namespace, pCubeName,tStep) = $LB(phase,$G(count),$G(pct),$G(errors))
	Quit
]]></Implementation>
</Method>

<Method name="%ComputeAggregateGroup">
<Description><![CDATA[
Precompute the aggregates witin the given cube and the given group name within the cube's
CellCache specification.<br/>
Set <var>pGroupName</var> to "*" for all groups.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pGroupName:%String,pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.tSC)
		If $$$ISERR(tSC) Quit

		// get information from cube
		Set tSC = $zobjclassmethod(tClassName,"%GetCellCachePreLoads",.tInfo)
		If $$$ISERR(tSC) Quit

		If (pGroupName="*") {
			Set tGroupName = $O(tInfo(""))
		}
		Else {
			Set tGroupName = pGroupName
		}
		While (tGroupName'="") {
			Merge tCombo = tInfo($$$UPPER(tGroupName))
			If '$D(tCombo) {
				Write:pVerbose "Group not found: ",tGroupName,!
				Quit
			}

			Write:pVerbose "Group: ",tGroupName,!
			Set tSC = ..%ComputeAggregateCombos(pCubeName,.tCombo,pVerbose)
			If $$$ISERR(tSC) Quit

			If (pGroupName="*") {
				Set tGroupName = $O(tInfo(tGroupName))
			}
			Else {
				Quit
			}
		}
 	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ComputeAggregateCombos">
<Description><![CDATA[
Loop over fact table for cube and precompute the aggregates for the specified combinations
in <var>pCombo</var>.<br/>
pCombo(n) = "FactName1,FactName2,MsrName1"]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCubeName:%String,&pCombos,pVerbose:%Boolean=1,pTracking:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tStart = $ZH
		Set tClassName = ..%GetCubeClass(pCubeName,.tSC)
		If $$$ISERR(tSC) Quit

		Set tFactTable = ..%GetCubeFactTable(pCubeName,.tSC)
		Set tCubeName = $$$UPPER(pCubeName)
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

		// find list of facts we need and their #s
		Set n = $O(pCombos(""))
		While (n'="") {
			For f = 1:1:$L(pCombos(n),",") {
				Set tFactName = $P(pCombos(n),",",f)
				Set tFactNo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"fact","prop",tFactName))
				If (tFactNo="") {
					Set tSC = $$$ERROR($$$GeneralError,"Fact not found in cube: "_tFactName)
					Quit
				}
				// JMD973: pick up factName alias
				Set tAlias = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"fact","prop",tFactName,"alias"))
				Set:tAlias'="" tFactName = tAlias

				Set tFactList(tFactName) = tFactNo
				Set tWorkList(n,f) = tFactName
			}
			If $$$ISERR(tSC) Quit
			Set n = $O(pCombos(n))
		}
		If $$$ISERR(tSC) Quit

		If '$D(tFactList) {
			Quit
		}

		// process for each "bucket"
		Set tSC = ##class(%DeepSee.Query.Engine).%GetBucketList(pCubeName,.tBucketList,.tActiveChunk)
		If $$$ISERR(tSC) Quit

		Set tChunksPerBucket = $$$DeepSeeChunksPerBucket(pCubeName)
		Set tCount = 0
		Set tLastBucket = $O(tBucketList(""),-1)
		Set tBucketNo = $O(tBucketList(""))
		While (tBucketNo '= "") {
			Set tSlotNo = $G(tBucketList(tBucketNo))

			Set tStartChunk = ((tBucketNo-1)*tChunksPerBucket)+1
			Set tEndChunk = tStartChunk + tChunksPerBucket - 1
			If ((tActiveChunk >= tStartChunk)&&(tActiveChunk <= tEndChunk)) {
				Set tEndChunk = tActiveChunk - 1
			}

			// use process private global to hold results
			// We use a global to avoid <STORE> errors and indirection to avoid contention!
			Kill ^||DeepSee.Agg(tCubeName)
			Set tSC = ..%ComputeAggregateForBucket(pCubeName,tStartChunk,tEndChunk,.tFactList,.tWorkList,pVerbose,.tCount)
			If $$$ISERR(tSC) {
				Kill ^||DeepSee.Agg(tCubeName)
				Quit
			}

			// merge new values in on top of current values
			Merge $$$DeepSeeCellsGLVN(tCubeIndex,tSlotNo) = ^||DeepSee.Agg(tCubeName)
			Kill ^||DeepSee.Agg(tCubeName)

			Set tBucketNo = $O(tBucketList(tBucketNo))
		}

		Write:pVerbose $C(13,27)_"[0J"
		Write:pVerbose "Precomputing complete:"
		Write:pVerbose " ",$FN(tCount,",",0)_" fact(s) processed"
		Write:pVerbose !,"Elapsed time: ",$ZH-tStart,"s",!
 	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If (pVerbose && $$$ISERR(tSC)) {
		Do $System.Status.DisplayError(tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ComputeAggregateForBucket">
<Description>
Compute aggregate combinations for one "bucket".</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCubeName:%String,pStartChunk:%Integer,pEndChunk:%Integer,&pFactList,&pWorkList,pVerbose:%Boolean=1,&pCount:%Integer]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCubeName = $$$UPPER(pCubeName)
		Set tFactTable = ..%GetCubeFactTable(pCubeName,.tSC)
		Set tLastCount = pCount
		Set tStartID = ((pStartChunk-1)*64000)+1
		Set tEndID = pEndChunk*64000

		// create sql statement
		Set tSELECT = "%ID"
		Set f = $O(pFactList(""))
		While (f'="") {
			Set tSELECT = tSELECT _ "," _ f
			Set f = $O(pFactList(f))
		}
		Set tSQL = "SELECT " _ tSELECT _ " FROM " _ tFactTable _
					" WHERE %ID BETWEEN ? AND ?"

		// execute query, compute values
		Set tRS = ##class(%ResultSet).%New()
		Set tSC = tRS.Prepare(tSQL)
		If $$$ISERR(tSC) Quit

		Set tSC = tRS.Execute(tStartID,tEndID)
		If $$$ISERR(tSC) Quit

		While (tRS.Next(.tSC)) {
			If $$$ISERR(tSC) Quit
			Set pCount = pCount + 1
			If (pVerbose && ((pCount#25000)=0)) {
				Write $C(13,27)_"[0J"
				Write "Precomputing..."
				Write " ",$FN(pCount,",",0)_" fact(s)"
			}

			// process each set in the work list
			Set n = $O(pWorkList("")) 
			While (n'="") {
				Set tKeyMask = ""
				Set tMeasure = ""
				Set tMeasureNo = ""
				Set f = $O(pWorkList(n,""),1,tFactName) 
				While (f'="") {
					Set tFactNo = pFactList(tFactName)
					// construct key
					If ($E(tFactNo)="M") {
						Set tMeasureNo = +$E(tFactNo,2,*)
						Set tMeasure = tRS.Data(tFactName)
					}
					Else {
						Set tValue = tRS.Data(tFactName)
						Set $List(tKeyMask,tFactNo) = tValue
					}
					Set f = $O(pWorkList(n,f),1,tFactName) 
				}

				// update counts
				If (tKeyMask'="") {
					// convert mask to index
					Set tKeyIndex = ""
					For f=1:1:$LL(tKeyMask) {
						Set tKeyIndex = tKeyIndex _ ":" _ $LG(tKeyMask,f)
					}
					If (tMeasure="") {
						// count
						Set x = $I(^||DeepSee.Agg(tCubeName,tKeyIndex))
					}
					Else {
						// aggregates
						Set agg = $G(^||DeepSee.Agg(tCubeName,tKeyIndex,tMeasureNo))
						Set min = $LG(agg,2),max=$LG(agg,3),count=$LG(agg,4)
						Set min = $S((min="")||(min>tMeasure):tMeasure,1:min)
						Set max = $S((max="")||(max<tMeasure):tMeasure,1:max)
						Set ^||DeepSee.Agg(tCubeName,tKeyIndex,tMeasureNo) = $LB(tMeasure+$LG(agg,1),min,max,count+1)
					}
				}
				// next item
				Set n = $O(pWorkList(n)) 
			}
		}
 	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If (pVerbose && $$$ISERR(tSC)) {
		Do $System.Status.DisplayError(tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%PurgeObsoleteCache">
<Description><![CDATA[
Delete all unused buckets from the result cache
for cube <var>pCubeName</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB274
	Set tSC = $$$OK
	Set tLock = 0
	Try {
		Set pCubeName = $$$UPPER(pCubeName)
		If (pCubeName = "") {
			Set tSC = $$$ERROR($$$GeneralError,"Cube name missing")
			Quit
		} 
		If ('..%IsBaseCube(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"Purge is not allowed on a Subject Area")
			Quit
		}
		
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

		// lock the inactive list for this cube
		Lock +$$$DeepSeeBucketsGLVN(tCubeIndex,"inactive"):10
		If ('$Test) {
			Set tSC = $$$ERROR($$$GeneralError,"%PurgeObsoleteCache unable to acquire lock")
			Quit
		}
		Set tLock = 1

		// walk down the inactive list
		Set tSlot = $O($$$DeepSeeBucketsGLVN(tCubeIndex,"inactive",""))
		While (tSlot '= "") {
			// kill cell cache for this node
			Kill $$$DeepSeeCellsGLVN(tCubeIndex,tSlot)

			// kill all results cached for this node
			Set tKey = $O($$$DeepSeeResultsGLVN(tCubeIndex,""))
			While (tKey '= "") {
				Kill $$$DeepSeeResultsGLVN(tCubeIndex,tKey,"data",tSlot)
				Set tKey = $O($$$DeepSeeResultsGLVN(tCubeIndex,tKey))
			}

			// remove node from inactive list
			Kill $$$DeepSeeBucketsGLVN(tCubeIndex,"inactive",tSlot)

			// add node to free list
			Set $$$DeepSeeBucketsGLVN(tCubeIndex,"free",tSlot) = ""

			// next slot
			Set tSlot = $O($$$DeepSeeBucketsGLVN(tCubeIndex,"inactive",tSlot))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	// unlock the inactive list
	Lock:tLock -$$$DeepSeeBucketsGLVN(tCubeIndex,"inactive")
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ProcessFact">
<Description><![CDATA[
For the specified cube, update one fact from the source table (with id of <var>pSourceId</var>).
If the fact does not yet exist, it is inserted, if does exist it is updated.<br/>
If <var>pVerbose</var> is true, then status information is written to the console.<br/>
<var>pMissingReferences</var> how missing references to related cubes were encountered.
Refer to the <method>%SynchronizeCube</method> for details.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pSourceId:%String="",pVerbose:%Boolean=0,*pMissingReferences:%Integer,pFactList:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pMissingReferences = 0
		Set tUpdateLimitedList = (pFactList'="")		// DTB - Use a compact variable to indicate selective fact updates
		Set tCubeName = $$$UPPER(pCubeName)
		Set tCubeIndex = $$$DeepSeeIndex(tCubeName)
		Set tClassName = ..%GetCubeClass(pCubeName,.tSC)
		If $$$ISERR(tSC) Quit

		If (pSourceId="") Quit

		If ('..%IsBaseCube(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"%ProcessFact cannot be called on a SubjectArea: " _ pCubeName)
			Quit
		}
		
		If (tUpdateLimitedList)&&'$$$dsSupportsSelectedList(tCubeIndex) {
			// DTB900 - Consult the namedFactNums setting for this cube and quit with an error if it is not enabled
			Set tSC = $$$ERROR($$$GeneralError,"%SynchronizeCube cannot be called using pFactList without enabling namedFactNums for this cube.")
			Quit
		}
		Else {
			// DTB900 - Convert to a list build format since it is more universally supported
			// DTB961 - Reinforce the list by including the cube in the call to normalize
			Set tFactList = ..%NormalizeFactList(pFactList,.tSC,tCubeIndex)
			If $$$ISERR(tSC) Quit
		}
		// DTB900 - Check the supplied fact list against the cube's fact table
		If '..%IsValidFactList(tCubeIndex,tFactList,.tSC) {
			Set tSC = $$$ERROR($$$GeneralError,"Invalid fact list supplied to %ProcessFact: '" _ $ListToString(tFactList,", ") _ "'")
			Quit
		}
		If $$$ISERR(tSC) Quit

		// JMD1450 Test for missing references
		New %dsMissingRef
		Set %dsMissingRef = 0
		If (tUpdateLimitedList) {
			// DTB886 - Dispatch to %UpdateFactsList
			Set tSC = $classmethod(tClassName,"%UpdateFactsList",pFactList,pSourceId,,0,pVerbose)
			If $$$ISERR(tSC) Quit
		}
		Else {
			Set tSC = $classmethod(tClassName,"%UpdateFacts",pSourceId,,0,pVerbose)
			If $$$ISERR(tSC) Quit
		}

		If (%dsMissingRef) {
			Set pMissingReferences = %dsMissingRef
		}
		Kill %dsMissingRef

		// update lastDataUpdate
		// DTB899 - Do not update if pFactList is supplied. INSERTS were not processed in selective build
		If 'tUpdateLimitedList {
			Set tSC = ##class(%DeepSee.Utils).%SetCubeDSTime(tCubeName,$I($$$DeepSeeUpdateQueue))		// DTB838
			If $$$ISERR(tSC) Quit
		}
		Set $$$DeepSeeUpdateQueue("cubes",tCubeName,"lastDataUpdate") = $ZTIMESTAMP		// DTB422
 	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If (pVerbose && $$$ISERR(tSC)) {
		Do $System.Status.DisplayError(tSC)
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%DeleteFact">
<Description><![CDATA[
For the specified cube, delete one fact from the source table (with id of <var>pSourceId</var>).
If <var>pVerbose</var> is true, then status information is written to the console.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pSourceId:%String="",pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pSourceId="") Quit

		Set tCubeName = $$$UPPER(pCubeName)
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		Set tClassName = ..%GetCubeClass(pCubeName,.tSC)
		If $$$ISERR(tSC) Quit

		If ('..%IsBaseCube(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"%DeleteFact cannot be called on a SubjectArea: " _ pCubeName)
			Quit
		}

		Set tSC = $zobjclassmethod(tClassName,"%DeleteFact",pSourceId)
		If $$$ISERR(tSC) Quit
		Write:pVerbose $$$Text("Fact deleted","%DeepSee"),!
		
		// DTB838 - update timestamps
		Set tSC = ##class(%DeepSee.Utils).%SetCubeDSTime(tCubeIndex,$I($$$DeepSeeUpdateQueue))
		If $$$ISERR(tSC) Quit
		Set $$$DeepSeeUpdateQueue("cubes",tCubeIndex,"lastDataUpdate") = $ZTIMESTAMP
 	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If (pVerbose && $$$ISERR(tSC)) {
		Do $System.Status.DisplayError(tSC)
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%SynchronizeCube">
<Description><![CDATA[
For the specified cube, find and apply all changes from the source data that have been made since the
last call to this method.
If <var>pVerbose</var> is true, then status information is written to the console.<br><br>
On return, <var>pFactsUpdated</var> will return the number of facts updated.<br><br>
By default, reads from the source table use READ COMMITTED mode, you can turn this off
(if you can tolerate reads of values from uncommitted transactions) by setting
<var>pReadCommitted</var> to 0.<br><br>
If this cube has facts that reference (via relationships) facts within another cube and any
of those remote facts are missing (because the related cube has not been synchronized), then
this method will report success and the missing references will be treated as build errors.<br>
To avoid this type of error, it is better to plan your synchronization so that the related cubes are 
synchronized first (in the same order the cubes are built).<br><br>
The <var>pCheckReferences</var> argument is deprecated and no longer has any effect on updates.<br><br>
<var>pAsync</var> controls whether DeepSee performs the synchronize in multiple background processes.
If this argument is true, the system uses multiple processes and does not return until they are all complete.
If this argument is false, the system uses a single process and does not return until it is complete.<br> 
By default this method runs in the synchronous mode to avoid any potential interference
with agents involved in background processing. If asynchronous mode is turned on, the synchronization work
will be divided among all available Low priority agents.<br><br>
<var>pSynchronizeStatistics</var> returns an array of information about the synchronize. <br>
The array has four subscripts. For example, if tStats is the argument used, as in: <br>
do ##class(%DeepSee.Utils).%SynchronizeCube("PATIENTS",1,,,,,.tStats) the array might look like the following: <br>
		tStats("elapsedTime")=.000643          <br/>
		tStats("errors")=1                     <br/>
		tStats("factCount")=5                  <br/>
		tStats("missingReferences")=1          <br/>
<br>
If the <var>pFactList</var> is supplied the build will only update the columns listed in that fact list. 
The list must consist of the specific fact names and can have either a comma-delimited or $LB format.<br><br>
If any errors occur during the synchronize process but all source records are successfully checked,
this cube will treat processing for this timestamp as complete. The expectation is that any
individual update errors can and should be resolved individually or through the <method>%FixBuildErrors</method>
method and not by the synchronize itself.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCubeName:%String,pVerbose:%Boolean=1,*pFactsUpdated:%Integer,pReadCommitted:%Boolean=1,pCheckReferences:%Boolean=1,pAsync:%Boolean=0,&pSynchronizeStatistics:%String="",pFactList:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tIsLocked = 0
		Set pFactsUpdated = 0
		Set tUpdateLimitedList = (pFactList'="")		// DTB906 - Use a compact variable to indicate selective fact updates
		
		// +DTB130 - if a cube uses versions, synchronize the active version when called using the generic cube name.
		// If a version name is passes in via pCubeName, synchronize it 
		Set tActiveVersionNo = ##class(%DeepSee.CubeVersion.Utils).%GetActiveCubeVersion(pCubeName)
		If (tActiveVersionNo'="") {
			Set pCubeName = ##class(%DeepSee.CubeVersion.Utils).%GetVersionedCubeName(pCubeName,tActiveVersionNo)
			W:pVerbose "Synchronizing cube version "_pCubeName,!
		}
		// -DTB130
		
		Set tCubeName = $$$UPPER(pCubeName)
		Set tClassName = ..%GetCubeClass(pCubeName,.tSC)
		If $$$ISERR(tSC) Quit

		// JMD1450
		New %dsMissingRef
		Set tMissingRefs = 0

		// JMD1033
		New %dsReadCommitted
		Set %dsReadCommitted = +pReadCommitted

		If ('..%IsBaseCube(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"Synchronize cannot be called on a SubjectArea: " _ pCubeName)
			Quit
		}

		// do not allow concurrent calls or calls during build
		// but allow queries
		// wait a long time (30 seconds)
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		
		If (tUpdateLimitedList)&&'$$$dsSupportsSelectedList(tCubeIndex) {
			// DTB891 - Consult the namedFactNums setting for this cube and quit with an error if it is not enabled
			Set tSC = $$$ERROR($$$GeneralError,"%SynchronizeCube cannot be called using pFactList without enabling namedFactNums for this cube.")
			Quit
		}
		Else {
			// DTB891 - Convert to a list build format since it is more universally supported
			// DTB961 - Reinforce the list by including the cube in the call to normalize
			Set tFactList = ..%NormalizeFactList(pFactList,.tSC,tCubeIndex)
			If $$$ISERR(tSC) Quit
		}
		// DTB900 - Check the supplied fact list against the cube's fact table
		If '..%IsValidFactList(tCubeIndex,tFactList,.tSC) {
			Set tSC = $$$ERROR($$$GeneralError,"Invalid fact list supplied to %SynchronizeCube: '" _ $ListToString(tFactList,",") _ "'")
			Quit
		}
		If $$$ISERR(tSC) Quit
		
		If tUpdateLimitedList {
			// DTB906 - If a selected fact list is in play,
			Set tSC = ..%LockFactList(tCubeIndex,tFactList,.tIsLocked,30)
		}
		Else {
			Lock +^DeepSee.Build(tCubeIndex,"SYNC"):30 Else  Set tSC = $$$ERROR($$$GeneralError,"Unable to obtain the lock needed to synchronize cube: " _ pCubeName)
			Set tIsLocked = 1
		}
		If $$$ISERR(tSC) Quit

		// track time spent in user expressions
		Kill ^IRIS.Temp.DeepSeeBuildStats($namespace,tCubeIndex)

		Set tStart = $ZH		// DTB404 - Always set this

		Set tFactClass = $zobjclassmethod(tClassName,"%GetFactClass")

		// get details on source class
		Set tSC = $zobjclassmethod(tClassName,"%GetSourceInfo",.tSourceInfo)
		If $$$ISERR(tSC) Quit
		
		Set tSourceClass = $G(tSourceInfo("sourceClass"))

		Set tSourceDSTIME = $$$UPPER($G(tSourceInfo("dstime")))
		If (tSourceDSTIME="") {
			Set tSC = $$$ERROR($$$GeneralError,"Data source for this cube does not support DSTIME.")
			Quit	
		}
		
		Set tClassList(tSourceClass) = ""

		// get list of additional source tables to test
		Set tStarCls = $O($$$DeepSeeMetaGLVN("cubes",tCubeName,"depends",""),1,f)
		While (tStarCls'="") {
			Set tStarList(tStarCls) = f // f = field expression

			// find table(s) that reference the source field(s)
			Set tSC = ..%FindDimensionTableForProperty(tCubeName,f,.tDimList)
			Merge tStarListTables(tStarCls) = tDimList

			Set tStarCls = $O($$$DeepSeeMetaGLVN("cubes",tCubeName,"depends",tStarCls),1,f)
		}

		// find our last sync point (timestamp)
		Set tLastTimeStamp = ##class(%DeepSee.Utils).%GetCubeDSTime(tCubeName)		// DTB838 - Use API

		// also test all possible subclasses of source class
		Merge tClassList = tSourceInfo("sourceSubClass")

		// check if there are outstanding changes to the source table(s)
		// use merged list
		Merge tMergeList = tClassList
		Merge tMergeList = tStarList
		
		If (tLastTimeStamp = $G($$$DeepSeeUpdateQueue)) {
			Set tChanges = 0
			// check each class
			Set tClass = $O(tMergeList(""))
			While ((tClass'="")&&('tChanges)) {
				If ($D($$$DeepSeeUpdateBuffer(tClass))) {
					Set tChanges = 1
				}
				Set tClass = $O(tMergeList(tClass))
			}
			If ('tChanges) {
				// DTB422 - Consider this a data update - cube was up-to-date as of xxx
				Set $$$DeepSeeUpdateQueue("cubes",tCubeName,"lastDataUpdate") = $ZTIMESTAMP
				Write:pVerbose "No changes detected.",!
				Quit
			}
		}
		
		// DTB422 - Safely transfer update IDs in each class from the buffer to the
		// concurrency protected update global. This is done within the
		// synchronize lock so only one process may do this at a time.
		Set tClass = $O(tClassList(""))
		While tClass'="" {
			Set tSC = ..%ProcessUpdateBuffer(tClass)
			If $$$ISERR(tSC) $$$ThrowStatus(tSC)
			Set tClass = $O(tClassList(tClass))
		}

		// DTB422 - Cube updates no longer care about the source's dsinterval setting, everything will get translated to an increment-style
		// update log.
		Set tNewTimeStamp = $I($$$DeepSeeUpdateQueue)
		
		Set tCounter = 0
		Set tFactsUpdated = 0
		Set tErrors = 0

		// apply all changes to reference clases 
		// we care about update, and ignore deletes and inserts
		// as they will be handled if and when the main source table changes

		Set tClass = $O(tStarList(""))
		While (tClass'="") {
			Set ts = +tLastTimeStamp
			While ((ts'="")&&(ts<tNewTimeStamp)) {
				Set id = $O($$$DeepSeeUpdateQueue(tClass,ts,""),1,reason)
				While (id'="") {
					Set tCounter = tCounter + 1
					Set tDelta = 0
					// call fact class (once per change)
					If ($G(reason)=0) {
						// update
						Kill tDimList
						Merge tDimList = tStarListTables(tClass)
						
						// NB (DTB891): If this is revived the fact list needs to be taken into consideration!
						// JMD783 	Set tSC = $zobjclassmethod(tClassName,"%UpdateFacts","","",,pVerbose,,.tDelta,tStarList(tClass),id,.tDimList)
					}
					ElseIf ($G(reason)=2) {
						// delete (ignore)
					}
					If $$$ISERR(tSC) {
						// JMD1474: ignore error and continue
						Set tErrors = tErrors + 1
						Set tSC = $$$OK
					}
					Else {
						Set tFactsUpdated = tFactsUpdated + tDelta
					}
					If (pVerbose && '(tCounter#100)) {
						Write $C(13,27)_"[0J"
						Write $FN(tFactsUpdated,",",0)," fact(s) updated"
					}
					Set id = $O($$$DeepSeeUpdateQueue(tClass,ts,id),1,reason)
				}
				If $$$ISERR(tSC) Quit
				Set ts = $O($$$DeepSeeUpdateQueue(tClass,ts))
			}
			If $$$ISERR(tSC) Quit
			Set tClass = $O(tStarList(tClass))
		}
		If $$$ISERR(tSC) Quit

		Set tTaskCount = 0
		If pAsync {		// DTB741 - Only check in on agents if in async mode
			Set tAgentCount = ##class(%DeepSee.Utils).%GetAgentCount()
			If '(+tAgentCount>0) {
				// DTB704 - Set the default agent count to the number of available cores
				// DTB862 - Fix test condition to protect against null agent count
				Set tAgentCount = ##class(%SYSTEM.CPU).%New().nCores
			}
		
			Set tTaskCount = tAgentCount
		}

		// get the list of modified source class records since last sync point
		// and apply them
		Set tClass = $O(tClassList(""))
		While (tClass'="") {
			Set ts = +tLastTimeStamp
			While ((ts'="")&&(ts<tNewTimeStamp)) {
				Set tTempFileKey = $I($$$DeepSeeTempSourceId)		// DTB300
				Set id = $O($$$DeepSeeUpdateQueue(tClass,ts,""),1,reason)
				While (id'="") {
					Set tCounter = tCounter + 1
					// call fact class (once per change)
					If pAsync {
						// DTB300 - Queue up a temp file. Divide evenly among available agents
						Set tChunk = tCounter#tTaskCount+1
						Set tOffset = tCounter\tTaskCount+1
						// PFS094 - Include reason into temp file so deletes can be asynchronous
						Set:id'="" $$$DeepSeeTempSourceId(tTempFileKey,tChunk,tOffset) = $LB(id,$G(reason))
					}
					Else {
						// PFS094 - Only handle delete here if in synchronous mode
						// PFS013 - Properly remove fact from cube if update reason = 2
						If '$zobjclassmethod(tClassName,"%CheckSourceId",id) || ($G(reason)=2) {
							// DTB300 - Deletion is still only done synchronously
							Set tSC = $classmethod(tClassName,"%DeleteFact",id)
						} Else {
							// JMD1450 Test for missing references
							Set %dsMissingRef = 0
							If ($G(pFactList)'="") {
								// DTB891 - Respond to the pFactList in the cube defintiion
								Set tSC = $classmethod(tClassName,"%UpdateFactsList",tFactList,id)
							}
							Else {
								Set tSC = $classmethod(tClassName,"%UpdateFacts",id)
							}
							
							If (pCheckReferences && %dsMissingRef) {
								Set tMissingRefs = tMissingRefs + 1
							}
							Kill %dsMissingRef
							
							If $$$ISERR(tSC) {
								// JMD1474: ignore error and continue
								Set tErrors = tErrors + 1
								Set tSC = $$$OK
							}
							Else {
								Set tFactsUpdated = tFactsUpdated + 1
							}
							If (pVerbose && '(tCounter#100)) {
								Write $C(13,27)_"[0J"
								Write $FN(tFactsUpdated,",",0)," fact(s) updated"
							}
						}
					}
					
					Set id = $O($$$DeepSeeUpdateQueue(tClass,ts,id),1,reason)
				}
				If $$$ISERR(tSC) Quit
				
				If pAsync {
			  		// DTB300 - use background tasks to process the temp file for this timestamp
			  		If pVerbose {
				  		//Write $C(13,27)_"[0J"
				  		Write !,"Synchronize time interval " _ ts _ " using " _ tTaskCount _ " background agents",!
			  		}
			  		
			  		Set %dsMissingRef = 0
					Set tSC = ##class(%DeepSee.WorkMgr).%CreateTaskGroup(.tGroupId,1,"UPDATEFACTSTEMP")		// DTB704 - This is now handled by the %DeepSee.WorkMgr
					If $$$ISERR(tSC) {
						Do $System.Status.DisplayError(tSC)
						Quit
					}
					
					Kill $$$DeepSeeTempUpdate($namespace,tGroupId)
					
					// Queue a task to update facts for each "chunk" in high-priority synchronize mode.
					Set tChunk = $O($$$DeepSeeTempSourceId(tTempFileKey,""))
					While (tChunk '= "") {
						// DTB704 - This is now handled by the %DeepSee.WorkMgr
						Set tSC = ##class(%DeepSee.WorkMgr).%QueueTask(tGroupId, "UPDATEFACTSTEMP",tCubeName,"",tTempFileKey,tChunk,pAsync,tFactList)		// DTB891 - Queue up the pFactList
						If $$$ISERR(tSC) Quit
						Set tChunk = $O($$$DeepSeeTempSourceId(tTempFileKey,tChunk))
					}
					If $$$ISERR(tSC) Quit
					
					Set tSC = ##class(%DeepSee.WorkMgr).%WaitForTaskGroup(tGroupId)
					If $$$ISERR(tSC) Quit
					
					// Read the statistics recorded by the background agents
					//Set tFactsUpdated=$G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
					Set tFactsUpdated = tFactsUpdated + $G($$$DeepSeeTempUpdate($namespace,tGroupId,"facts"))
					Set tErrors=$G($$$DeepSeeTempUpdate($namespace,tGroupId,"errors"))
					If (pCheckReferences) {
						Set tMissingRefs = tMissingRefs + $G($$$DeepSeeTempUpdate($namespace,tGroupId,"missing"))
					}
					
					// kill temp file
					Kill $$$DeepSeeTempSourceId(tTempFileKey)
				}
				
				Set ts = $O($$$DeepSeeUpdateQueue(tClass,ts))
			}
			If $$$ISERR(tSC) Quit
			Set tClass = $O(tClassList(tClass))
		}
		If $$$ISERR(tSC) Quit

		// update sync point (timestamp)
		// DTB422 - No such thing as an interval type anymore. Always update to allow a purge up to this timestamp
		// WAL243 - update DSTIME regardless of whether we have missing refs/errors
		// DTB899 - Do not update if pFactList is supplied. INSERTS were not processed in selective build
		If 'tUpdateLimitedList {
			Set tSC = ..%SetCubeDSTime(tCubeName,tNewTimeStamp)
		}
		Set $$$DeepSeeUpdateQueue("cubes",tCubeName,"lastDataUpdate") = $ZTIMESTAMP		// DTB422

		If (pVerbose) {
			Write $C(13,27)_"[0J"
			Write $FN(tFactsUpdated,",",0), " fact(s) updated" _ $S(pAsync:" asynchronously",1:""),!
			Write:tErrors $FN(tErrors,",",0), " error(s)",!
			Write:tMissingRefs $FN(tMissingRefs,",",0), " missing reference(s)",!
			Write "Elapsed time: ",$ZH-tStart,"s",!
		}
		
		Set pFactsUpdated = +$G(tFactsUpdated)		// DTB448
		
		// + WAL270 -- return synchronize statistics
		// DTB404 - Protect read of statistics with $Get()
		// DTB423 - Remove formatting from statistics
		Set pSynchronizeStatistics("factCount") = +$G(tFactsUpdated)
		Set pSynchronizeStatistics("errors") = +$G(tErrors)
		Set pSynchronizeStatistics("missingReferences") = +$G(tMissingRefs)
		Set pSynchronizeStatistics("elapsedTime") = $ZH-$G(tStart)
		If ($G(tCubeIndex)'="") {
			// DTB432 - Add additional synchronize statistics
			Set pSynchronizeStatistics("expressionTime") = +$G(^IRIS.Temp.DeepSeeBuildStats($namespace,tCubeIndex,"expr"))
			Set pSynchronizeStatistics("iKnowTime") = +$G(^IRIS.Temp.DeepSeeBuildStats($namespace,tCubeIndex,"iknow"))
		}
		// - WAL270
 	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If (tIsLocked) {
		If tUpdateLimitedList {
			// DTB906 - Release all columns in the fact list
			Set tSC = ..%UnlockFactList(tCubeIndex,tFactList)
		}
		Else {
			Lock -^DeepSee.Build(tCubeIndex,"SYNC")
		}
	}
	If (pVerbose && $$$ISERR(tSC)) {
		Do $System.Status.DisplayError(tSC)
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%ProcessUpdateBuffer">
<Description><![CDATA[
Process the ^OBJ.DSTIME update buffer into the concurrency-protected
update global. To protect an update entry in the ^OBJ.DSTIME buffer within
a transaction, the process setting the buffer should use
<example language="cos">
	Lock +^DeepSee.Build(pClassName,ID)
</example>
The <var>ID</var> is not needed for concurrency protection between the transactional process
and <method>%ProcessUpdateBuffer</method>, but will prevent lock contention between
transactional processes if this is used.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName="",pNoKill=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB422
	Set tSC = $$$OK

	Try {
		If (pClassName = "") {
			Set tSC = $$$ERROR($$$GeneralError,"No class name supplied to process updates.")
			Quit
		}
		
		// Take out a special lock on the class in order to prevent two processes from attempting to perform this
		// buffer processing. Without this, two cubes based on the same class getting synchronized at the same time
		// could trigger the original problem again!
		Lock +^DeepSee.Build(pClassName,"Process DSTIME"):30 
		If '$Test {
			Set tSC = $$$ERROR($$$GeneralError,"Unable to obtain the lock needed to process the OBJ.DSTIME update buffer: " _ pClassName)
			Quit
		}
		
		If ..%HasUpdates(pClassName) {
			// Interval vs. Increment is ignored for the buffered update. Only increment exists in
			// the local update global.
			// N.B. The increment of the top node is controlled in the synchronize call.
			// This transfer acts like a production update - the method setting the
			// update entry does not bump the top node!
			Set tNewTimestamp = +$G($$$DeepSeeUpdateQueue)

			Set tSourceTimestamp = $O($$$DeepSeeUpdateBuffer(pClassName,""))
			While (tSourceTimestamp'="") {
				Set tID = $O($$$DeepSeeUpdateBuffer(pClassName,tSourceTimestamp,""),1,tType)
				While tID'="" {
					Set $$$DeepSeeUpdateQueue(pClassName,tNewTimestamp,tID) = tType
					// Remove this ID from the buffer
					Kill:'pNoKill $$$DeepSeeUpdateBuffer(pClassName,tSourceTimestamp,tID)
					
					Set tID = $O($$$DeepSeeUpdateBuffer(pClassName,tSourceTimestamp,tID),1,tType)
				}
				
				Set $$$DeepSeeUpdateQueue("classes",pClassName,"lastTimestamp") = tSourceTimestamp		// DTB503
	
				Set tSourceTimestamp = $O($$$DeepSeeUpdateBuffer(pClassName,tSourceTimestamp))
			}
		}
		Lock -^DeepSee.Build(pClassName,"Process DSTIME")		// Release the lock
	}
	Catch ex {
		Set tSC = ex.AsStatus()
		Lock -^DeepSee.Build(pClassName,"Process DSTIME")		// Release the lock
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ClearUpdateBuffer">
<Description><![CDATA[
Clear the update buffer for a given class. This will completely remove the current contents
of ^OBJ.DSTIME(<var>pClassName</var>).]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB422
	Set tSC = $$$OK
	Try {
		If (pClassName = "") {
			Set tSC = $$$ERROR($$$GeneralError,"No class name supplied to process updates.")
			Quit
		}
		
		If ..%HasUpdates(pClassName) {
			// Loop through all timestamps and IDs under this source class.
			Set tSourceTimestamp = $O($$$DeepSeeUpdateBuffer(pClassName,""))
			While (tSourceTimestamp'="") {
				Set tID = $O($$$DeepSeeUpdateBuffer(pClassName,tSourceTimestamp,""),1,tType)
				While tID'="" {
					// Remove this ID from the buffer
					Kill $$$DeepSeeUpdateBuffer(pClassName,tSourceTimestamp,tID)
					
					Set tID = $O($$$DeepSeeUpdateBuffer(pClassName,tSourceTimestamp,tID),1,tType)
				}
	
				Set tSourceTimestamp = $O($$$DeepSeeUpdateBuffer(pClassName,tSourceTimestamp))
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%HasUpdates">
<Description><![CDATA[
Test the ^OBJ.DSTIME update buffer for new updates in the class <var>pClassName</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB422
	Set tHasUpdates = 0
	Try {
		If (pClassName = "") {
			// Noting to test for updates
			Quit
		}
		
		Set tHasUpdates = $D($$$DeepSeeUpdateBuffer(pClassName))
	}
	Catch ex {
		Set tHasUpdates = 0
	}
	
	Quit tHasUpdates
]]></Implementation>
</Method>

<Method name="%SetCubeDSTime">
<Description>
Update the sync timestamp for the given cube.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pVersion:%Integer=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If ('..%IsBaseCube(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"%SetCubeDSTime cannot be called on a SubjectArea: " _ pCubeName)
			Quit
		}
		
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

		// update sync point (timestamp)
		Set $$$DeepSeeUpdateQueue("cubes",tCubeIndex,"dstime") = pVersion
 	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCubeDSTime">
<Description>
Query the sync timestamp for the given cube.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pVersion:%Integer=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB422
	Set tDsTime = ""
	Try {
		If ('..%IsBaseCube(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"%SetCubeDSTime cannot be called on a SubjectArea: " _ pCubeName)
			Quit
		}
		
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

		// update sync point (timestamp)
		Set tDsTime = +$G($$$DeepSeeUpdateQueue("cubes",tCubeIndex,"dstime"))		// DTB838 - Protect query of the global if the update queue hasn't been written to yet
 	}
	Catch(ex) {
		// Swallow the error
	}
	Quit tDsTime
]]></Implementation>
</Method>

<Method name="%PurgeListings">
<Description><![CDATA[
Purge all entries in the listing cache older than <var>pStartDay</var>. If this is
omitted, the start day used will be the current day.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pVerbose:%Integer=0,pStartDay=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCount = 0
		Set tDay = $S(pStartDay'="":pStartDay,1:+$H)		// DTB531
		// find all days in cache prior to today
		Set tDay = $O($$$DeepSeeListingResultsGLVN(tDay),-1)
		While (tDay'="") {
			Write:pVerbose "Deleting listings for ",$ZDT(tDay,3),!
			Kill $$$DeepSeeListingResultsGLVN(tDay)
			Set tCount = tCount + 1
			Set tDay = $O($$$DeepSeeListingResultsGLVN(tDay),-1)
		}

		Write:pVerbose "Completed: ",tCount," listing(s) purged",!
 	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%PurgeDSTIME">
<Description><![CDATA[
<p><method>%PurgeDSTIME</method> purges all nodes in ^DeepSee.Update that have already been processed by all cubes,
and by all classes that extend <class>%DeepSee.TimeSync</class>.
This method checks the DSTIME value for each cube, and for each class that extends %DeepSee.TimeSync, 
and computes the oldest DSTIME value that has not yet been
synchronized. All DSTIME values older than that time are purged from the DSTIME index.</p>
<p>If a class has entries in the DSTIME index and no cubes use that class as a source class then those DSTIME
entries are not purged.</p>
<p>
<table border=1>
<th>
Parameters
</th>
<tr>
		<td>pVerbose</td>
		<td>Input</td>
		<td>
			If true then status messages will be displayed on the current device.
		</td>
</tr>
<tr>
		<td>pPurged</td>
		<td>Output</td>
		<td>
			An array of DSTIME entries that have been purged. For example:
			<pre>
		purged("DeepSee.Study.CityRainfall")=1
		purged("DeepSee.Study.Patient")=2
		purged("HoleFoods.Transaction")=0
			</pre>
			The array subscript is the class name and the value is the DSTIME value that was purged.
		</td>
</tr>
</table>
</p>
<br>
	<p>
	<b>Return value</b>: This method returns a %Status value indicating success or failure.
	</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pVerbose:%Integer=0,*pPurged:%Library.String(MAXLEN="")</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//  Build array of source classes and the cubes that use them
	try {
		kill pPurged
		set tCube = $order($$$DeepSeeMetaGLVN("cubes",""))
		while (tCube '= "") {
			set tIsCube = ..%IsBaseCube(tCube)
			if tIsCube {
				// get cube class
				Set tClassName = ..%GetCubeClass(tCube,.tSC)
				If (tClassName'="") {
					// get details on cube's source class
					Set tSC = $zobjclassmethod(tClassName,"%GetSourceInfo",.tSourceInfo)
					If $$$ISERR(tSC) Quit

					// create list of cube's source class and subclasses (if any)
					Kill tCubeSources
					set tSourceClass = $Get($$$DeepSeeMetaGLVN("cubes",tCube,"sourceClass"))
					If (tSourceClass'="") {
						Set tCubeSources(tSourceClass) = ""
					}
					Merge tCubeSources = tSourceInfo("sourceSubClass")			

					// look at each source class
					Set tSourceClass = $O(tCubeSources(""))
					While (tSourceClass'="") {
						set tCubeTime = ##class(%DeepSee.Utils).%GetCubeDSTime(tCube)		// DTB422 - DSTIME stamp is in the update global		// DTB838 - Use API

						// For each source class in ^DeepSee.Update, find the oldest to-be-processed timestamp from the cubes
						if '$Data(tSourceClassList(tSourceClass)) { 
							set tSourceClassList(tSourceClass) = tCubeTime
						}
						elseif (tCubeTime < tSourceClassList(tSourceClass)) { 
							set tSourceClassList(tSourceClass) = tCubeTime
						}
						set tSourceClassList(tSourceClass,tCube) =  tCubeTime

						Set tSourceClass = $O(tCubeSources(tSourceClass))
					}
				}
			}
			set tCube = $order($$$DeepSeeMetaGLVN("cubes",tCube))
		}
		// JMM581:
		// Now iterate over non-cube "consumer" classes, and add their source classes to the list if not already
		// present, or adjust the oldest to-be-processed timestamp if older than the oldest found previously
		set tConsumerClass = $order($$$DeepSeeDSTIMENonCubeConsumers(""))
		while (tConsumerClass '= "") {
			// For each source class of this consumer, add to list of source classes, or if already present,
			// adjust oldest to-be-processed timestamp
			set tSourceClass = $order($$$DeepSeeDSTIMECheckpoint(tConsumerClass,""))
			while (tSourceClass'="") {
				set tCheckpointTime = $g($$$DeepSeeDSTIMECheckpoint(tConsumerClass,tSourceClass))
				if '$Data(tSourceClassList(tSourceClass)) { 
					set tSourceClassList(tSourceClass) = tCheckpointTime
				}
				elseif (tCheckpointTime < tSourceClassList(tSourceClass)) { 
					set tSourceClassList(tSourceClass) = tCheckpointTime
				}
				if $Data(tSourceClassList(tSourceClass,tConsumerClass)) {
					// TBD: This would mean a consumer classname was the same as a cube name. 
					// However, the existing code never uses this once it's been set.
				}
				else {
					set tSourceClassList(tSourceClass,tConsumerClass) =  tCheckpointTime
				}
				set tSourceClass = $order($$$DeepSeeDSTIMECheckpoint(tConsumerClass,tSourceClass))
			}
			set tConsumerClass = $order($$$DeepSeeDSTIMENonCubeConsumers(tConsumerClass))
		}

		set tSourceClass = $Order($$$DeepSeeUpdateQueue(""))
		while (tSourceClass '= "") {
			// For the source class, kill all entries in ^DeepSee.Update < the oldest timestamp to-be-processed.
			// (since they have aleady been processed by all cubes that use the source class)
			// Also, kill all DSTIME entries for the source class if there are no cubes defined.
			// Jeff Miller 6/17/14: The above line appears to be incorrect, no DSTIME entries are killed for
			// a source class if there are no cubes (or, now, non-cube consumer classes) defined.
			// What should we do if the oldest cube time is null? Wouldn't this indicate that no cubes have yet
			// been sync'ed and that a %BuildCube call should be used?

			if (tSourceClass '= $$$DeepSeeDSTIMECheckpointSubscript)&&(tSourceClass'="cubes") {
				if pVerbose {
					write !,"Processing class '",tSourceClass,"'. "
					if $Data(tSourceClassList(tSourceClass)) {
						write "Oldest DSTIME synchronized: ",$Select(tSourceClassList(tSourceClass):tSourceClassList(tSourceClass),1:"<<all>>")
					}
					else { write "No cubes using this class as a source have been found!" }
				}
				if $Get(tSourceClassList(tSourceClass)) '="" {
					set tIndex = $Order($$$DeepSeeUpdateQueue(tSourceClass,""))
					while (tIndex '= "") && (tIndex < tSourceClassList(tSourceClass)) {
						kill $$$DeepSeeUpdateQueue(tSourceClass,tIndex)
						set pPurged(tSourceClass) = tIndex
						if pVerbose {
							write !,$Char(9),"purged DSTIME('",tSourceClass,"',",tIndex,")"
						}
						set tIndex = $o($$$DeepSeeUpdateQueue(tSourceClass,tIndex))
					}
				}
			}
			set tSourceClass = $o($$$DeepSeeUpdateQueue(tSourceClass))
	 	}
	 	if pVerbose {
		 	write !,"Complete."
		 	if '$Data(pPurged) {
			 	write " No DSTIME entries were purged."
		 	}
	 	}
	 	set tSC = $$$OK
	}
	catch tException {
		set tSC = tException.AsStatus()
		if pVerbose {
			write !,"An error occurred: "
			do $system.OBJ.DisplayError(tSC)
		}
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%PurgeUpdateBuffer">
<Description><![CDATA[
Purge the ^OBJ.DSTIME update buffer when there are no cubes present to clear entries
via updates.<br>
<var>pClass</var> [Required] - The class to be purged from the ^OBJ.DSTIME update buffer.
The "*" wildcard may be used to purge all classes present in the buffer.<br>
<var>pPurgeUpTo</var> [Required] - This is the oldest timestamp that must be retained in the purge.
Every entry older than this will be removed. The "*" wildcard may be used to remove all entries for
the given <var>pClass</var>.<br>
<var>pIncrement</var> - If true, the purge method will automatically advance the top node of ^OBJ.DSTIME
to advance the timestamp of all non-interval type entries to support the next purge. This parameter is set to
1 by default.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String="",pPurgeUpTo:%String="",pIncrement:%Boolean=1,pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB503
	Set tClassRequest = $G(pClass)			// Name of the class to be purged from ^OBJ.DSTIME
	Set tPurgeTo = $G(pPurgeUpTo)			// The final timestamp that should be purged
	Set tPurgeAll = ($G(pPurgeUpTo)="*")	// If true, purge everything under the class
	
	Set tSC = $$$OK
	Try {
		// Test input arguments
		If (tClassRequest="") {
			Set tSC = $$$ERROR($$$GeneralError,$$$Text("Class name must be provided to purge DeepSee update buffer."))
			Quit
		}
		
		If (tPurgeTo="") {
			Set tSC = $$$ERROR($$$GeneralError,$$$Text("Timestamp must be provided to purge DeepSee update buffer."))
			Quit
		}

		
		// Increment the top counter 
		Set:pIncrement x = $I($$$DeepSeeUpdateBuffer)
		
		// Determine the list of classes that should be purged
		If tClassRequest="*" {
			Set tClass = $O($$$DeepSeeUpdateBuffer(""))
			While tClass'="" {
				Set tClasses(tClass)=""
				Set tClass = $O($$$DeepSeeUpdateBuffer(tClass))
			}
		}
		Else {
			Set tClasses(tClassRequest) = ""
		}

		// Work through the list of classes and execute the purge
		Set tClass = $O(tClasses(""))
		While tClass'="" {
			If '##class(%Dictionary.CompiledClass).%ExistsId(tClass) {
				Set tSC = $$$ERROR(5351,tClass)
				$$$ThrowStatus(tSC)
			}
			
			If tPurgeAll {
				Write:pVerbose !,"Purging all entries for class " _ tClass
				Kill $$$DeepSeeUpdateBuffer(tClass)
			}
			Else {
				// Find the last actual timestamp in the global which collates before the requested purgeTo timestamp
				//Set tPurgeTo = $O($$$DeepSeeUpdateBuffer(tClass,tPurgeTo),-1)
				
				Set tTimestamp = $O($$$DeepSeeUpdateBuffer(tClass,""))
				While ((tTimestamp'="")&&(tPurgeTo ] tTimestamp)) {
					Write:pVerbose !,"Purging "_tClass _ ":" _ tTimestamp
					Kill $$$DeepSeeUpdateBuffer(tClass,tTimestamp)
					
					Set tTimestamp = $O($$$DeepSeeUpdateBuffer(tClass,tTimestamp))		// Work backward from the target purge timestamp
				}
			}
			
			Set tClass = $O(tClasses(tClass))
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%KillCube">
<Description>
Delete all indices and cache values for the given cube.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pForce=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.tSC)
		If $$$ISERR(tSC) Quit

		If ##class(%DeepSee.CubeVersion.Utils).%IsActiveVersion(pCubeName)&&'pForce {
			// DTB216 - Prevent unintentional kill of active cube
			Set tSC = $$$ERROR($$$GeneralError,pCubeName _ " is the active version. %KillCube must be forced for an active cube version: " _ pCubeName)
			Quit
		}

		If ('..%IsBaseCube(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"%KillCube cannot be called on a SubjectArea: " _ pCubeName)
			Quit
		}

		Set tFactClass = $zobjclassmethod(tClassName,"%GetFactClass")
		Set tSC = $zobjclassmethod(tClassName,"%KillFacts")
		If $$$ISERR(tSC) Quit
		
		Kill $$$DeepSeeBuildErrorsGLVN($$$DeepSeeIndex(pCubeName))		// DTB603 - Remove build errors
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%KillKPICacheForCube">
<Description>
Delete any KPI cache values for the given cube.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCubeName = $$$UPPER(pCubeName)
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

		If ('..%IsBaseCube(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"%KillKPICacheForCube cannot be called on a SubjectArea: " _ pCubeName)
			Quit
		}
		If $D($$$DeepSeeKPIGLVN("-index-",tCubeIndex)) {
			Set tKPI = $O($$$DeepSeeKPIGLVN("-index-",tCubeIndex,""))
			While (tKPI'="") {
				Kill $$$DeepSeeKPIGLVN(tKPI)
				Kill $$$DeepSeeKPIGLVN("-index-",tCubeIndex,tKPI)
				Set tKPI = $O($$$DeepSeeKPIGLVN("-index-",tCubeIndex,tKPI))
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCountName">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return the logical name of its %COUNT measure.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tName = "%COUNT"
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
		If $$$ISOK(pStatus) {
			Set tName = $zobjclassmethod(tClassName,"%GetCountName")
		}
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}
	Quit tName
]]></Implementation>
</Method>

<Method name="%GetCountCaption">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return the display name of its %COUNT measure.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tName = ""
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
		If $$$ISOK(pStatus) {
			Set tName = $zobjclassmethod(tClassName,"%GetCountCaption")
		}
	}
	Catch(ex) {
		Set tName = ""
		Set pStatus = ex.AsStatus()
	}
	If (tName="") {
		Set tName = ..%GetCountName(pCubeName)
		If ($$$UPPER(tName) ="%COUNT") {
			Set tName = $$$Text("Count","%DeepSee")
		}
	}
	Quit tName
]]></Implementation>
</Method>

<Method name="%GetCubeFactClass">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return the class name of its fact table.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tFactClass = ""
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
		If $$$ISOK(pStatus) {
			Set tFactClass = $zobjclassmethod(tClassName,"%GetFactClass")
		}
	}
	Catch(ex) {
		Set tFactClass = ""
		Set pStatus = ex.AsStatus()
	}

	Quit tFactClass
]]></Implementation>
</Method>

<Method name="%GetCubeFactTable">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return the SQL name of its fact table.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tFactTable = ""
	Set pStatus = $$$OK
	Try {
		Set tFactClass = ..%GetCubeFactClass(pCubeName,.tSC)
		If $$$ISERR(tSC) Quit

		Set tFactTable = ##class(%DeepSee.Generator).%GetSQLTableName(tFactClass)
	}
	Catch(ex) {
		Set tFactTable = ""
		Set pStatus = ex.AsStatus()
	}

	Quit tFactTable
]]></Implementation>
</Method>

<Method name="%GetCubeFactCount">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return the number of rows within its fact table.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tCount = 0
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
		If $$$ISOK(pStatus) {
			Set tCount = $zobjclassmethod(tClassName,"%GetFactCount")
		}
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}

	Quit tCount
]]></Implementation>
</Method>

<Method name="%GetCubeMemberCount">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return the number of members within the given dimension level.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status,pDimName:%String="",pHierName:%String="",pLevelName:%String=""</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tCount = 0
	Set pStatus = $$$OK
	Try {
		Set tCube = $$$UPPER(pCubeName)
		If ((pLevelName'="")&&(pHierName'="")&&(pDimName'="")) {
			Set tMbrNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",$$$UPPER(pDimName),$$$UPPER(pHierName),$$$UPPER(pLevelName)))
		}
		ElseIf ((pHierName'="")&&(pDimName'="")) {
			Set tMbrNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",$$$UPPER(pDimName),$$$UPPER(pHierName)))
		}
		ElseIf (pDimName'="") {
			Set tMbrNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",$$$UPPER(pDimName)))
		}
		Else {
			Quit
		}

		If (tMbrNode = "") {
			Set pStatus = $$$ERROR($$$GeneralError,"Level not found")
			Quit
		}

		Set tDimNo = +$LG(tMbrNode,1)
		Set tHierNo = +$LG(tMbrNode,2)
		Set tLevelNo = +$LG(tMbrNode,3)
		Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
		Set tClass = $LG(tInfo,6)
		If ((tClass'="")&&$$$comClassDefined(tClass)) {
			Try {
				If $zobjclassmethod(tClass,"%IsA","%DeepSee.ComputedDimension.Base") {
					// provide more info for computed dims
					Set tCount = $zobjclassmethod(tClass,"%Count",tCube,tDimNo,tHierNo,tLevelNo)
				}
				ElseIf $zobjclassmethod(tClass,"%IsA","%DeepSee.Time.AbstractLevel") {
					Set tCount = $zobjclassmethod(tClass,"%Count",tCube,tDimNo,tHierNo,tLevelNo)
				}
				Else {
					Set tCount = $zobjclassmethod(tClass,"%Count")
				}
			}
			Catch(ex) {
				// swall errors
			}
		}
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}

	Quit tCount
]]></Implementation>
</Method>

<Method name="%GetCubeName">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return its name in its original case.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tName = ""
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
		If $$$ISOK(pStatus) {
			Set tName = $zobjclassmethod(tClassName,"%GetCubeName")
		}
		If (tName="")&&(tClassName'="") {
			// DTB949 - If we still have no cube name at this point, look directly at the metadata
			// to try to fill it in.
			Set tName = $G($$$DeepSeeMetaGLVN("classes",tClassName))
		}
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}

	Quit tName
]]></Implementation>
</Method>

<Method name="%IsCubeAbstract">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
test if it is abstract.<br/>
An abstract cube does not contain any data and cannot be queried.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tAbstract = 0
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
		If $$$ISOK(pStatus) {
			Set tAbstract = $zobjclassmethod(tClassName,"%IsAbstract")
		}
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}

	Quit tAbstract
]]></Implementation>
</Method>

<Method name="%IsCubeCompound">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
test if it is a compound cube (composed of two or more cubes joined together).<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pJoinList:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tCompound = 0
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
		If $$$ISOK(pStatus) {
			Set tCompound = $zobjclassmethod(tClassName,"%IsCompound",.pJoinList)
		}
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}

	Quit tCompound
]]></Implementation>
</Method>

<Method name="%GetCubeModifiedDate">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return the date and time that the cube definition was last modifed.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%DeepSee.Datatype.dateTime</ReturnType>
<Implementation><![CDATA[
	Set tDate = ""
	Set pStatus = $$$OK
	Try {
		Set tDate = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"lastSchemaUpdate"))
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}

	Quit tDate
]]></Implementation>
</Method>

<Method name="%GetKPIModifiedDate">
<Description><![CDATA[
Given the logical name, <var>pKPI</var> of a DeepSee KPI,
return the date of the time the KPI definition was modified (in $H format).]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKPI:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%DeepSee.Datatype.dateTime</ReturnType>
<Implementation><![CDATA[
	Set tDate = ""
	Set pStatus = $$$OK
	Try {
		Set tDate = $G($$$DeepSeeMetaGLVN("kpis",$$$UPPER(pKPI),"lastSchemaUpdate"))
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}

	Quit tDate
]]></Implementation>
</Method>

<Method name="%GetCubeCaption">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube, return its caption.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tCaption = ""
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
		If $$$ISOK(pStatus) {
			Set tCaption = $zobjclassmethod(tClassName,"%GetCubeCaption")
		}
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}

	Quit tCaption
]]></Implementation>
</Method>

<Method name="%GetKPICaption">
<Description><![CDATA[
Given the logical name, <var>pKPI</var> of a DeepSee KPI, return its caption.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKPI:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tCaption = ""
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetKPIClass(pKPI,.pStatus)
		If $$$ISOK(pStatus) {
			Set tCaption = $zobjclassmethod(tClassName,"%GetKPICaption")
		}
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}

	Quit tCaption
]]></Implementation>
</Method>

<Method name="%CubeExists">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
test if it exists.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String="",*pStatus:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set pStatus = $$$OK
	If ($G(pCubeName)="") {
		// DTB790 - Return an error if called without a Cube name
		Set pStatus = $$$ERROR($$$GeneralError,"Cube name must be supplied")
		Quit 0
	}
	Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
	Quit (tClassName'="")
]]></Implementation>
</Method>

<Method name="%KPIExists">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
test if it exists.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKPIName:%String="",*pStatus:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB297
	Set pStatus = $$$OK
	If ($G(pKPIName)="") {
		// DTB790 - Return an error if called without a KPI name
		Set pStatus = $$$ERROR($$$GeneralError,"KPI name must be supplied")
		Quit 0
	}
	Set tClassName = ..%GetKPIClass(pKPIName,.pStatus)
	Quit (tClassName'="")
]]></Implementation>
</Method>

<Method name="%CheckPrivilege">
<Description>
Test that the current user holds privileges on the given cube.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// JMD1472 treat "disabled" as no privilege
	Set tDisabled = +$G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"disabled"))
	Quit:tDisabled 0

	Set tResource = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"resource"))
	Quit ((tResource="")||$System.Security.Check(tResource,"READ")||$System.Security.Check(tResource,"USE"))
]]></Implementation>
</Method>

<Method name="%GetCubeClass">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return the class name of the cube definition.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tClassName = ""
	Set pStatus = $$$OK
	Try {
		// No privilege is same as does not exist
		If ((pCubeName'="")&&($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName)))'="")&&..%CheckPrivilege(pCubeName)) {
			Set tClassName = $$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName))
		}
		Else {
			Set pStatus = $$$ERROR($$$GeneralError,"Cannot find Subject Area: '" _ pCubeName _ "'")
		}
	}
	Catch(ex) {
		Set tClassName = ""
		Set pStatus = ex.AsStatus()
	}

	Quit tClassName
]]></Implementation>
</Method>

<Method name="%GetCubeActionClass">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return the class name of it associated actionClass, if any.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tClassName = ""
	Set pStatus = $$$OK
	Try {
		Set tClassName = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"actionClass"))
	}
	Catch(ex) {
		Set tClassName = ""
		Set pStatus = ex.AsStatus()
	}

	Quit tClassName
]]></Implementation>
</Method>

<Method name="%GetCubeDescription">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube return its class description.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tDesc = ""
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
		If $$$ISERR(pStatus) Quit

		Set tDesc = $$$comClassKeyGet(tClassName,$$$cCLASSdescription)
	}
	Catch(ex) {
		Set tDesc = ""
		Set pStatus = ex.AsStatus()
	}

	Quit tDesc
]]></Implementation>
</Method>

<Method name="%GetKPIName">
<Description><![CDATA[
Given the logical name, <var>pKPIName</var> of a DeepSee KPI,
return its name in its original case.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKPIName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tName = ""
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetKPIClass(pKPIName,.pStatus)
		If ($$$ISOK(pStatus)&&(tClassName'="")) {
			Set tName = $zobjclassmethod(tClassName,"%GetKPIName",pKPIName)
		}
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}

	Quit tName
]]></Implementation>
</Method>

<Method name="%IsKPIPublic">
<Description><![CDATA[
Given the logical name, <var>pKPIName</var> of a DeepSee KPI, test if it is public.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKPIName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tPublic = 0
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetKPIClass(pKPIName,.pStatus)
		If ($$$ISOK(pStatus)&&(tClassName'="")) {
			Set tPublic = $classmethod(tClassName,"%IsPublic")
		}
	}
	Catch(ex) {
		Set pStatus = ex.AsStatus()
	}
	Quit tPublic
]]></Implementation>
</Method>

<Method name="%GetKPIDescription">
<Description><![CDATA[
Given the logical name, <var>pKPIName</var> of a DeepSee KPI return its class description.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKPIName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tDesc = ""
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetKPIClass(pKPIName,.pStatus)
		If $$$ISERR(pStatus) Quit

		Set tDesc = $$$comClassKeyGet(tClassName,$$$cCLASSdescription)
	}
	Catch(ex) {
		Set tDesc = ""
		Set pStatus = ex.AsStatus()
	}

	Quit tDesc
]]></Implementation>
</Method>

<Method name="%GetKPIClass">
<Description><![CDATA[
Given the logical name, <var>pKPIName</var> of a DeepSee KPI,
return the class name of the KPI definition.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKPIName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tClassName = ""
	Set pStatus = $$$OK
	Try {
		// check for extensions
		Set tExt = $P(pKPIName,".",$L(pKPIName,"."))
		If (tExt = "worksheet") {
			Set tClassName = "%DeepSee.KPIWorksheet"
			Quit
		}
		ElseIf (tExt = "worksheet") {
			Set tClassName = "Ens.BusinessMetricKPI"
			Quit
		}
		ElseIf (tExt = "kpi") {
			// strip off ext
			Set pKPIName = $P(pKPIName,".",1,$L(pKPIName,".")-1)
		}

		Set tClassName = ""

		// JMD900: test for built-in plug-ins
		If ($E($$$UPPER(pKPIName),1,9)="%DEEPSEE.") {
			Set tClassIndex = $$$UPPER("%DeepSee.PlugIn."_$P(pKPIName,".",2))
			If ($D(^rINDEXCLASS(tClassIndex),tInfo)) {
				// Get correct case of name
				Set tClassName = $LG(tInfo,2)
			}
		}
		ElseIf ((pKPIName'="")&&($G($$$DeepSeeMetaGLVN("kpis",$$$UPPER(pKPIName)))'="")) {
			Set tClassName = $$$DeepSeeMetaGLVN("kpis",$$$UPPER(pKPIName))
		}

		// No privilege is same as does not exist
		If (tClassName'="") {
			If ('$zobjclassmethod(tClassName,"%CheckResource")) {
				Set tClassName = ""
			}
		}

		If (tClassName="") {
			Set pStatus = $$$ERROR($$$GeneralError,"Cannot find KPI: '" _ pKPIName _ "'")
		}
	}
	Catch(ex) {
		Set tClassName = ""
		Set pStatus = ex.AsStatus()
	}

	Quit tClassName
]]></Implementation>
</Method>

<Method name="%GetKPIList">
<Description><![CDATA[
Return a list of all currently defined DeepSee KPIs visible to the current user.
This is used by utilities.<br/>
This list takes the form:<br/>
pList(NAME) = $LB(name,caption,moddate,type) ]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pList</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC  = $$$OK
	Kill pList

	// JMD900: find all built-in plug-ins
	// These are in the %DeepSee.PlugIn package
	Set tCLASS = "%DEEPSEE.PLUGIN."
	Set tCLASS = $O(^rINDEXCLASS(tCLASS))
	While ($E(tCLASS,1,16)="%DEEPSEE.PLUGIN.") {
		Set tClassName = $LG(^rINDEXCLASS(tCLASS),2)
		If $$$comClassDefined(tClassName) {
			Set tAbstract = +$$$comClassKeyGet(tClassName,$$$cCLASSabstract)
			If ('tAbstract && $classmethod(tClassName,"%IsA","%DeepSee.KPIPlugIn")) {
				If ($classmethod(tClassName,"%IsPublic")) {
					Set tName = $classmethod(tClassName,"%GetKPIName",.tSC)
					If $$$ISERR(tSC) Quit
					If (tName'="") {
						Set tKPI = $$$UPPER(tName)
						Set tDate = ""
						Set tCaption = $classmethod(tClassName,"%GetKPICaption")
						Set pList(tKPI) = $LB(tName,tCaption,tDate,"kpi")
					}
				}
			}
		}
		Set tCLASS = $O(^rINDEXCLASS(tCLASS))
	}
	If $$$ISERR(tSC) Quit tSC
	
	// Now get local plug-ins from KPI global
	Set tKPI = $O($$$DeepSeeMetaGLVN("kpis",""))
	While (tKPI '= "") {
		If (..%IsKPIPublic(tKPI)) {
			// get original name
			Set tName = ..%GetKPIName(tKPI,.tSC)
			If $$$ISERR(tSC) Quit
			If (tName'="") {
				Set tDate = ..%GetKPIModifiedDate(tKPI)
				Set pList(tKPI) = $LB(tName,..%GetKPICaption(tKPI),tDate,"kpi")
			}
		}
		Set tKPI = $O($$$DeepSeeMetaGLVN("kpis",tKPI))
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetKPIPlugInList">
<Description><![CDATA[
Return a list of all currently defined DeepSee "Plug-in" KPIs visible to the current user.
If <var>pBaseName</var> is provided, then only list plug-ins visible to this base cube.<br/>
This is used by utilities.<br/>
This list takes the form:<br/>
pList(NAME) = $LB(name,caption,moddate,type)<br/>
pList(NAME,"props",propName) = ""<br/>]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pList,pBaseName:%String="",pPlugInType:%String="",pUseCubeVersion:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Kill pList
	
	// DTB336
	Set tBaseName = pBaseName
	Set:'pUseCubeVersion tBaseName = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(tBaseName)

	Do ..%GetKPIList(.tList)
	Set tKPI = $O(tList(""))
	While (tKPI'="") {
		Set tKPIClass = ..%GetKPIClass(tKPI,.tSC)
		If $$$ISERR(tSC) Quit

		If ((tKPIClass'="")&&($classmethod(tKPIClass,"%IsA","%DeepSee.KPIPlugIn"))) {
			Set tSkip = 0
			If (pPlugInType'="") {
				Set tType = $$$UPPER($classmethod(tKPIClass,"%GetPlugInType"))
				If (tType'=$$$UPPER(pPlugInType)) {
					Set tSkip = 1
				}
			}
			If ('tSkip&&(tBaseName'="")) {
				Set tSkip = 1
				Set tKPICubes = $$$UPPER($classmethod(tKPIClass,"%GetBaseCube"))
				For n=1:1:$L(tKPICubes,",") {
					Set tCube = $P(tKPICubes,",",n)
					If (tCube="*") {
						Set tSkip = 0
						Quit
					}
					ElseIf (tCube'="") {
						Kill tCubeList
						Do ..%GetCubeList(.tCubeList,"",1,tCube)
						If ($D(tCubeList($$$UPPER(tBaseName)))) {
							Set tSkip = 0
							Quit
						}
					}
				}
			}
			If ('tSkip) {
				// Get properties for this KPI
				Kill tPropList
				Do $classmethod(tKPIClass,"%GetKPIPropertyInfo",.tPropList)

				Set pList(tKPI) = tList(tKPI)
				Merge pList(tKPI,"props") = tPropList
			}
		}

		Set tKPI = $O(tList(tKPI))
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetWorksheetList">
<Description><![CDATA[
Return a list of all currently defined DeepSee worksheets visible to the current user.
This is used by utilities.<br/>
This list takes the form:<br/>
pList(NAME) = $LB(name,caption,moddate,type)<br/>
If <var>pHidden</var> is true, then include trash and local items.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pList,pHidden:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Kill pList
	Try {
		Set tFlag = $zu(115,8,0)
		Set tStatement = ##class(%SQL.Statement).%New(,"DEFAULT_SCHEMA")
		Set tSC = tStatement.%Prepare("SELECT ID FROM %DeepSee_UserLibrary.Worksheet")
		If $$$ISERR(tSC) Quit

		Set tRS = tStatement.%Execute()
		While (tRS.%Next(.tSC)) {
			If $$$ISERR(tSC) Quit
			If (tRS.ID '="") {
				Set tItem = ##class(%DeepSee.UserLibrary.FolderItem).%OpenId(tRS.ID)
				If ($IsObject(tItem)) {
					Set tDate = $ZDTH(tItem.timeModified,3)
					Set tFullName = $P(tItem.fullName,".",1) // name without extension
					If (pHidden || ($E(tFullName,1)'="$")|| ($E(tFullName,1,3)="$$$")) {
						If (tItem.%CheckResource()) {
							Set pList(tItem.fullName) = $LB(tFullName,tItem.name,tDate,"worksheet")
						}
					}
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Set tFlag = $zu(115,8,tFlag)
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetMetricList">
<Description><![CDATA[
Return a list of all currently defined Business Metrics visible to the current user.
This is used by utilities.<br/>
This list takes the form:<br/>
pList(NAME) = $LB(name,caption,moddate,type) ]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pList</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pList
	If (##class(%Library.EnsembleMgr).IsEnsembleNamespace()) {
		Try {
			Set tSC = $classmethod("Ens.BusinessMetricKPI","%GetBusinessMetricList",.pList)
		}
		Catch(ex) {
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetDefaultMember">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return the default cube element (dimension and possibly level) as a string ("[Product].[Name]").<br/>
Note: this is no longer used by DeepSee.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSpec = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"defmbr"))
	If (tSpec = "") {
		Set tMeasure = ..%GetDefaultMeasure(pCubeName)
		If (tMeasure '= "") {
			Set tSpec = "[Measures]."_tMeasure
		}
		Else {
			Set tDim = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"defdim"))
			Set tSpec = tDim
		}
	}
	If (tSpec = "") {
		Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
		If $$$ISERR(pStatus) Quit
		Set tSpec = "[Measures].["_..%GetCountName(pCubeName)_"]"
	}
	Quit tSpec
]]></Implementation>
</Method>

<Method name="%GetDefaultMeasure">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return the name of the default Measure.
Note: this is no longer used by DeepSee.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tMeasure = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"defmsr"))
	Quit tMeasure
]]></Implementation>
</Method>

<Method name="%GetDefaultHierarchy">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
and a dimension name, return the name of the default Hierarchy (this
is only defined if there is no more than one hierarchy for this dimension).]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pDimName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tHierName = ""

	Set tHier = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),""))
	If (tHier'="") {
		Set tInfo = $$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),tHier)
		Set tDimNo = +$LG(tInfo,1)
		Set tHierNo = +$LG(tInfo,2)
		Set tLevelNo = +$LG(tInfo,3)
		Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbr#",tDimNo,tHierNo,tLevelNo))
		If ($LG(tMbrInfo,1)="all") {
			// skip all level
			Set tHier = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),tHier))
			If (tHier="") {
				Quit ""
			}
			Set tInfo = $$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),tHier)
			Set tDimNo = +$LG(tInfo,1)
			Set tHierNo = +$LG(tInfo,2)
			Set tLevelNo = +$LG(tInfo,3)
			Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbr#",tDimNo,tHierNo,tLevelNo))
		}

		Set tHierName = $LG(tMbrInfo,3)

		// see if there is another hierarchy
		Set tHier = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),tHier))
		If (tHier'="") {
			Set tInfo = $$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),tHier)
			Set tDimNo = +$LG(tInfo,1)
			Set tHierNo = +$LG(tInfo,2)
			Set tLevelNo = +$LG(tInfo,3)
			Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbr#",tDimNo,tHierNo,tLevelNo))
			If ($LG(tMbrInfo,1)="all") {
				// skip all level
				Set tHier = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),tHier))
			}
			If (tHier'="") {
				Set tHierName = ""
			}
		}
	}
	Quit tHierName
]]></Implementation>
</Method>

<Method name="%GetDefaultLevel">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
and a dimension and hierarchy name, return the name of the default Level (this
is only defined if there is no more than one level for this hierarchy).]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pDimName:%String,pHierName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tLevelName = ""

	Set tLevel = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),$$$UPPER(pHierName),""))
	If (tLevel'="") {
		Set tInfo = $$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),$$$UPPER(pHierName),tLevel)
		Set tDimNo = +$LG(tInfo,1)
		Set tHierNo = +$LG(tInfo,2)
		Set tLevelNo = +$LG(tInfo,3)
		Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbr#",tDimNo,tHierNo,tLevelNo))

		If ($LG(tMbrInfo,1)="all") {
			// skip all level
			Set tLevel = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),$$$UPPER(pHierName),tLevel))
			Set tInfo = $$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),$$$UPPER(pHierName),tLevel)
			Set tDimNo = +$LG(tInfo,1)
			Set tHierNo = +$LG(tInfo,2)
			Set tLevelNo = +$LG(tInfo,3)
			Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbr#",tDimNo,tHierNo,tLevelNo))
		}

		Set tLevelName = $LG(tMbrInfo,4)

		// see if there is another level
		Set tLevel = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),$$$UPPER(pHierName),tLevel))
		If (tLevel'="") {
			Set tInfo = $$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),$$$UPPER(pHierName),tLevel)
			Set tDimNo = +$LG(tInfo,1)
			Set tHierNo = +$LG(tInfo,2)
			Set tLevelNo = +$LG(tInfo,3)
			Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbr#",tDimNo,tHierNo,tLevelNo))
			If ($LG(tMbrInfo,1)="all") {
				// skip all level
				Set tLevel = $O($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"mbrs",$$$UPPER(pDimName),$$$UPPER(pHierName),tLevel))
			}
			If (tLevel'="") {
				Set tLevelName = ""
			}
		}
	}
	Quit tLevelName
]]></Implementation>
</Method>

<Method name="%IsBaseCube">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube known to exist,
return true if it is a base cube (and not a Subject Area).]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"baseCube"))="")
]]></Implementation>
</Method>

<Method name="%GetBaseCube">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee subject area known to exist,
return its base cube.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"baseCube"))
]]></Implementation>
</Method>

<Method name="%GetSourceClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"sourceClass"))
]]></Implementation>
</Method>

<Method name="%GetRelatedCube">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
and the name of a relationship in the cube, return the name of the cube referred to by the
relationship.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pRelationName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCubeName),"relations",$$$UPPER(pRelationName),"relatedCube"))
]]></Implementation>
</Method>

<Method name="%IsRelationship">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
and the name of a dimension, test if the dimension is a relationship.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pDimension:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tIsRelation = 0
	Set pCubeName = $$$UPPER(pCubeName)
	Set pDimension = $$$UPPER(pDimension)
	If (pDimension'="") {
		Set tDimNode = $G($$$DeepSeeMetaGLVN("cubes",pCubeName,"mbrs",pDimension))
		If (tDimNode'="") {
			Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",pCubeName,"mbr#",$LG(tDimNode,1),$LG(tDimNode,2),$LG(tDimNode,3)))
			Set tIsRelation = $LG(tDimInfo,1) = "r"
		}
	}
	Quit tIsRelation
]]></Implementation>
</Method>

<Method name="%GetDimensionList">
<Description><![CDATA[
Return a list of the dimensions (and measures) within the specified cube.<br/>
On return, <var>pInfo</var> will contain array of the form:<br/>
pInfo(DimNo,HierNo,LevelNo) = $LB(type,DimName,HierName,LevelName)<br/>
type can be "d","h","l","m","r" or "all" for dimension, hierarchy, level, measure, relationship or all level.<br/>
Note that all measures are found under DimNo 0 and have no LevelName.
Dimensions whose name starts with "%" are not listed.<br/>
Dimensions that only contain calculated members are returned as:<br/>
pInfo(-1,hierNo,memberNo)<br/>
If <var>pUseInFilter</var> is true, then only return levels whose useInFilter flag is true.<br/>
If <var>pExtendedInfo</var> is true, also return $LB(factNumber, factID, SQL column ID, isEnabled, inProgress) settings.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,&pInfo,pIncludeCalcMbrs:%Boolean=0,pUseInFilter:%Boolean=0,pExtendedInfo=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pInfo
		Set tCube = $$$DeepSeeIndex(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		// walk over dimension index
		Set tDimNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",""))
		While (tDimNo '= "") {
			Set tHierNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,""))
			While (tHierNo '= "") {
				Set tLevelNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,""),1,info)
				While (tLevelNo '= "") {
					Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,0,0))
					Set tHidden = +$LG(tDimInfo,17)
					Set tType = $LG(info,1)
					Set tDimName = $LG(info,2)
					Set tHierName = $LG(info,3)
					Set tLevelName = $LG(info,4)
					Set tLevelUseForFilter = $S('pUseInFilter:1,1:$LG(info,19,1)) // JMD1278
					If ('tHidden && ($E(tDimName,1,1)'="%") && (tLevelUseForFilter)) {
						Set pInfo(tDimNo,tHierNo,tLevelNo) = $LB(tType,tDimName,tHierName,tLevelName)
						
						If pExtendedInfo {
							// DTB918 - Add the internal reference codes for this fact
							Set tFactNo = $LG(info,5)
							If (tFactNo'="") {
								Set tFactID = $S(($E(tFactNo))="M":$G($$$DeepSeeMetaGLVN("cubes",tCube,"msr#",tFactNo)),1:$G($$$DeepSeeMetaGLVN("cubes",tCube,"fact#",tFactNo)))
								Set tSqlColID = $G($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tFactID,"alias"),tFactID)
								Set tIsEnabled = $$$dsFactEnabled(tCube,tFactID)	//$G($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tFactID,"enabled"),1)
								Set tInProgress = $$$dsFactInProgress(tCube,tFactID)		//$G($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tFactID,"inProgress"),0)
							}
							Else {
								// Null settings are returned if the tFactID is null. This will occur in the event
								// lookups fail.
								Set tFactID = ""
								Set tSqlColID = ""
								Set tIsEnabled = ""
								Set tInProgress = ""
							}
							Set pInfo(tDimNo,tHierNo,tLevelNo) = pInfo(tDimNo,tHierNo,tLevelNo) _ $LB(tFactNo,tFactID,tSqlColID,tIsEnabled,tInProgress)
						}
					}
					Set tLevelNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo),1,info)
				}
				Set tHierNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo))
			}
			Set tDimNo = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo))
		}

		If (pIncludeCalcMbrs) {
			// Calculated members
			// combine local list with those defined in the cube
			// calcMbrs(dim,mbr) = $LB(dim,mbr,spec)
			Merge tCalcMbrs = $$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs")
			
			// +DTB268 - Add shared calculated members
			Set tSC = ##class(%DeepSee.Utils).%GetSharedCalcMembers(tCube,.tSharedCalcMbrs)
			Set tSharedCalcIdx = $O(tSharedCalcMbrs(""),1,tSharedCalcData)
			While tSharedCalcIdx'="" {
				Set tSharedCalcDimKey = $$$UPPER($LG(tSharedCalcData,1))
				Set tSharedCalcKey = $$$UPPER($LG(tSharedCalcData,2))
				Set tSC = ##class(%DeepSee.Utils).%GetSharedCalcMemberInfo(tCube,tSharedCalcDimKey,tSharedCalcKey,.tMbrInfo)
				If $D(tMbrInfo) {
					// $LB(dimension,name,expression,format,hidden)
					Set tSharedCalcMbrs(tSharedCalcDimKey,tSharedCalcKey) = $LB(tMbrInfo("dimension"),tMbrInfo("name"),tMbrInfo("expression"),tMbrInfo("format"))		// DTB461 - Remove solveOrder in the hidden position
				}
				
				Set tSharedCalcIdx = $O(tSharedCalcMbrs(tSharedCalcIdx),1,tSharedCalcData)
			}
			
			Merge tCalcMbrs = tSharedCalcMbrs		// DTB461
			// -DTB268

			Set tHierNo = 0
			Set tDim = $O(tCalcMbrs(""))
			While (tDim '= "") {
				If ((tDim '= "MEASURES")&&('$D($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim)))) {
					Set tHierNo = tHierNo + 1
					Set tLevelNo = 0
					Set k = $O(tCalcMbrs(tDim,""))
					If (k'="") {
						Set tDimInfo = tCalcMbrs(tDim,k)
						Set tDimName = tDim
						Set tDimCaption = $LG(tDimInfo,1)
						Set pInfo(-1,tHierNo,tLevelNo) = $LB("d",tDimCaption)
					}
				}
				Set tDim = $O(tCalcMbrs(tDim))
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetMemberTree">
<Description><![CDATA[
Get the members (dimensions, measures, and actual members of dimensions) of the specified cube as a tree format that can
be displayed within a <class>%ZEN.Component.dynaTree</class>.<br/>
<var>pCube</var> is the cube name.<br/>
<var>pTree</var> is an array returned by reference that contains the member data.<br/>
<var>pSkipMeasures</var> is used internally and indicates that measures (as well as named filters) should not be listed.<br/>
<var>pRoot</var> is used to specify that an incremental load of children is requested; if provided it is the spec of a parent node.<br/>
<var>pLocalCalcMembers</var> is used to pass in additional calculated members.<br/>
<var>pLocalNamedSets</var> is used to pass in additional named sets.<br/>
<var>pVisited</var> and <var>pRelatedBy</var> are not used.<br/>
<var>pSkeleton</var> indicates that members and relationships are not displayed.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,&pTree,&pVisited:%String,pSkipMeasures:%Boolean=0,pRoot:%String="",&pLocalCalcMembers:%List,&pLocalNamedSets:%List,pRelatedBy:%String="",pLevel:%Integer=0,pSkeleton:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// create a new session (or use the one currently in scope)
		// this will cause user-init code to be run
		Set tSession = $G($$$DeepSeeSession)
		If ('$IsObject(tSession)) {
			Do ##class(%DeepSee.Session).%CreateSession($S($IsObject($G(%session)):%session.SessionId,1:$J),.tSC)
			Set tSession = $G($$$DeepSeeSession)
		}

		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit
		// JMD1193: only fetch 100 at first
		Set tMemberBucket = 100
		// allow for 5x before switching to groups
		Set tMaxMembers = tMemberBucket*5
		Set tStartMbr = ""
		Set tEndMbr = ""
		Set tSkipProps = 0

		// n.b. ignore visited and related by 

		If ('..%CheckPrivilege(tCube)) Quit
		
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		Set tCountName = ..%GetCountName(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		If (pRoot'="") {
			// get children for a single node
			// add members of this level to tree
			Kill pTree
			Set pTree = 1
			Set tRootSpec = pRoot

			// JMD1193: if pRoot starts with @@@ this is one group of a large dimension
			If ($E(pRoot,1,3)="@@@") {
				// @@@:start:end:spec
				Set tStartMbr = $P(pRoot,":",2)
				Set tEndMbr = $P(pRoot,":",3)
				Set tRootSpec = $P(pRoot,":",4,999)
				Set tSkipProps = 1
				Set tMaxMembers = tEndMbr
			}

			// if pRoot starts with @@ then this is a request to load the dimensions
			// of a related cube 
			ElseIf ($E(pRoot,1,2)="@@") {
				// @@cube@@relation[^prefix}
				Set tParentCube = $P($P(pRoot,"^",1),"@@",2)
				Set tRelationName = $P($P(pRoot,"^",1),"@@",3)
				Set tPrefix = $P(pRoot,"^",2)
				Set tRelatedCube = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(tParentCube),"relations",$$$UPPER(tRelationName),"relatedCube"))

				// Get dimensions of relationship (sans measures)
				Kill tRelTree
				Set tSC = ##class(%DeepSee.Utils).%GetMemberTree(tRelatedCube,.tRelTree,.pVisited,1,"",,,"",pLevel+1)
				If $$$ISERR(tSC) Quit

				If $D(tRelTree) {
					// copy subtree into this one (from the Dimensions Node)
					Set tXName = tPrefix_$S(tPrefix="":"",1:".")_"["_$$$dsEscapeIdent(tRelationName)_"]" // JSL4451 - invoke $$$dsEscapeIdent
					Do ..%CopyTree(tXName,.pTree,0,.tRelTree,2)
				}
				Quit
			}

			// parse spec
			Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(tCube,tRootSpec,.tDimNo,.tHierNo,.tLevelNo,.tRelationName,.tRelationSpec,.tSpecInfo)
			If $$$ISERR(tSC) Quit
			If (tRelationName '="") {
				Set tRelatedCube = $G($$$DeepSeeMetaGLVN("cubes",tCube,"relations",$$$UPPER(tRelationName),"relatedCube"))

				Kill tRelTree
				Set tSC = ##class(%DeepSee.Utils).%GetMemberTree(tRelatedCube,.tRelTree,.pVisited,1,tRelationSpec,,,"",pLevel+1)
				If $$$ISERR(tSC) Quit

				// add to output tree; add relation to spec
				Set k = $O(tRelTree(""))
				While (k'="") {
					Set tInfo = $G(tRelTree(k))
					If ($LG(tInfo,1)'="") {
						Set tMbrSpec = "["_$$$dsEscapeIdent(tRelationName) _"]"_ "." _ $LG(tInfo,2) // JSL4451 - invoke $$$dsEscapeIdent
						Set $List(tInfo,2) = tMbrSpec
						Set pTree($I(pTree)) = tInfo
						Set pTree(0,"ch",pTree) = ""
					}
					Set k = $O(tRelTree(k))
				}
				Quit
			}

			Set tLevelNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
			Set tDim = $LG(tLevelNode,2)
			Set tHier = $LG(tLevelNode,3)
			Set tLevel = $LG(tLevelNode,4)

			// pick up dimension properties
			If ('tSkipProps) {
				Set tPropNo = 0
				Set tProp = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo,"prop",""))
				While (tProp '= "") {
					Set tPropInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo,"prop",tProp))
					Set tPropName = $LG(tPropInfo,4)
					Set tPropCaption = $zobjclassmethod(tClassName,"%GetMemberCaption",tDim,tHier,tLevel,tProp)
					Set tPropDescription=""
					try {
						Set tPropDescription = $zobjclassmethod(tClassName,"%GetMemberDescription",tDim,tHier,tLevel,tProp) // JSL4475
					} catch {}
					Set tPropHidden = +$LG(tPropInfo,17)
					If ('tPropHidden) {
						Set tHasMembers = 1
						Set tPropNo = tPropNo + 1
						Set tIcon = "deepsee/ds2_cards_44.png"
						Set tMbrSpec = ##class(%DeepSee.Query.Parser).%BuildEscapedSpec($LB(tDim,tHier,tLevel))_".CurrentMember.Properties("""_tPropName_""")" // JSL4451 - invoke $$$dsEscapeIdent
						Set pTree($I(pTree)) = $LB(tPropCaption,tMbrSpec,0,"",0,tIcon,$s(tPropDescription'="":tPropDescription,1:$$$Text("Property: ","%DeepSee") _ tPropCaption),"color:darkblue;") // JSL4475 use tPropDescription
						Set pTree(0,"ch",pTree) = ""
					}
					Set tProp = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo,"prop",tProp))
				}
			}

			// JMD1193 remember state of tree, so we can delete nodes
			// find out if this is a time dimension
			Set tStartOfMembers = pTree
			Set tTimeClass = $LG($G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,0)),6)
			Set tIsTime = (tTimeClass'="")
			If (tIsTime) {
				Set tMaxMembers = 5000
			}

			// members
			If ((tDim'="")&&(tHier'="")&&(tLevel'="")) {
				//Set tMbrSpec = "["_tDim_"].["_tHier_"].["_tLevel_"]"		// DTB127 - Unescaped, quoted identifiers should not be used in specs
				Set tMbrSpecEscape = ##class(%DeepSee.Query.Parser).%BuildEscapedSpec($LB(tDim,tHier,tLevel))		// DTB268
				// JMD-- do not show calc members amongst the levels

				// JMD1193: pass along start/end if present
				If ('tIsTime && (tStartMbr'="")&&(tEndMbr'="")) {
					New %dsStartMbr
					Set %dsStartMbr = tStartMbr
					New %dsEndMbr
					Set %dsEndMbr = tEndMbr
				}
				Set tSC = ..%GetDimensionMembers(tCube,tMbrSpecEscape,"",.tMembers,$S(tMaxMembers="":"",1:tMaxMembers+1),,,-1)		// DTB127 - Use the escaped spec
				If $$$ISERR(tSC) {
					Quit
				}
			}

			Set tMCount = 0
			Set m = $O(tMembers(""),1,tMbrInfo)
			While ((m'="")&&(tMCount < tMaxMembers)) {
				Set tMCount = tMCount + 1
				Set tTooltip = $LG(tMbrInfo,5)
				If (tTooltip="") {
					Set tTooltip = $LG(tMbrInfo,2)
				}
				Else {
					Set tTooltip = $LG(tMbrInfo,2) _ " - " _ tTooltip
				}
				// + WAL145 -- If the key returned is already wrapped in "&[" and "]" peel those off so the
				//             logic below doesn't double them.
				Set tMbrKey = $LG(tMbrInfo,4)
				If ($E(tMbrKey,1,2)="&[")||($E(tMbrKey)="[") {
					// DTB315 - Check for quote before parsing
					Do ##class(%DeepSee.Query.Parser).%ParseMemberSpec(tMbrKey,.tParseInfo)
					Set:($G(tParseInfo(1))'="") tMbrKey = tParseInfo(1) 
				}
				Set pTree($I(pTree)) = $LB($LG(tMbrInfo,2),tMbrSpecEscape_".&["_$$$dsEscapeIdent(tMbrKey)_"]",0,"",0,,tTooltip)
				// - WAL145
				Set pTree(0,"ch",pTree) = ""
				Set m = $O(tMembers(m),1,tMbrInfo)
			}
			If (tMCount = 0) {
				Set pTree($I(pTree)) = $LB($$$Text("No members","%DeepSee"),"",0,"",0,,"","font-style:italic;")
				Set pTree(0,"ch",pTree) = ""
			}
			ElseIf (('tIsTime)&&(m'="")) {
				// JMD1193: there are more members to fetch
				// do not show them; instead provide another level of tree to group them

				// remove all members from tree
				Set kx = $O(pTree(tStartOfMembers))
				While (kx'="") {
					Kill pTree(kx)
					Kill pTree(0,"ch",kx)
					Set kx = $O(pTree(kx))
				}
				Set pTree = tStartOfMembers

				// find total members
				Set tTotalMemberCount = ..%GetCubeMemberCount(tCube,.tSC,tDim,tHier,tLevel)
				If (tTotalMemberCount < ((tMemberBucket*tMemberBucket)+1)) {
					// create a set of groups with special @@@: marker
					Set tPage = tMemberBucket
					For kn = 1:tPage:tTotalMemberCount {
						Set tLastNo = $S((kn+tPage-1)>tTotalMemberCount:tTotalMemberCount,1:(kn+tPage-1))
						Set tLabel = "#"_kn_" - #"_tLastNo
						Set pTree($I(pTree)) = $LB(tLabel,"@@@"_":"_kn_":"_tLastNo_":"_tRootSpec,1,"",0,,"")
						Set pTree(0,"ch",pTree) = ""
					}
				} Else {
					// PFS004 - Show meaningful message when a dimension has too many members to display in Analyzer Member Tree
					Set pTree($I(pTree)) = $LB($$$Text("Too many members to display","%DeepSee"),"",0,"",0,,"","font-style:italic;")
					Set pTree(0,"ch",pTree) = ""
				}
			}
		}
		Else {
			// get entire tree (non-member nodes)

			// Calculated members
			// combine local list with those defined in the cube
			Kill tCalcMbrs
			Merge tCalcMbrs = $$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs")
			
			// +DTB268 - Add shared calculated members
			Set tSC = ##class(%DeepSee.Utils).%GetSharedCalcMembers(tCube,.tSharedCalcArray)
			Set tSharedCalcIdx = $O(tSharedCalcArray(""),1,tSharedCalcData)
			While tSharedCalcIdx'="" {
				Set tSharedCalcDimKey = $$$UPPER($LG(tSharedCalcData,1))
				Set tSharedCalcKey = $$$UPPER($LG(tSharedCalcData,2))
				Set tSC = ##class(%DeepSee.Utils).%GetSharedCalcMemberInfo(tCube,tSharedCalcDimKey,tSharedCalcKey,.tMbrInfo)
				If $D(tMbrInfo) {
					// $LB(dimension,name,expression,format,hidden)
					Set tSharedCalcMbrs(tSharedCalcDimKey,tSharedCalcKey) = $LB(tMbrInfo("dimension"),tMbrInfo("name"),tMbrInfo("expression"),tMbrInfo("format"))		// DTB461 - Remove solveOrder in the hidden position
				}
				
				Set tSharedCalcIdx = $O(tSharedCalcArray(tSharedCalcIdx),1,tSharedCalcData)
			}
			Merge tCalcMbrs = tSharedCalcMbrs
			// -DTB268
			
			Merge tCalcMbrs = pLocalCalcMembers

			Kill tFilterList
			Set tSC = ..%GetNamedFilters(tCube,.tFilterList)
			If $$$ISERR(tSC) Quit

			Kill tVariableList
			Set tSC = ..%GetPivotVariables(tCube,.tVariableList)
			If $$$ISERR(tSC) Quit

			// plug-ins
			Set tSC = ..%GetKPIPlugInList(.tPlugInList,tCube,"Pivot")
			If $$$ISERR(tSC) Quit

			Set tDimCount = 0
			Set tMsrCount = 0
			Set tFilterCount = 0
			Set tPlugInCount = 0
			Set tQMsrCount = 0
			Set tVariableCount = 0
			Kill pTree
			Set tMsrRoot = 1
			Set tDimRoot = 2
			// JMD1223 change pTree from 3 to 2
			Set pTree = 2
			Set tFilterRoot = ""
			Set tNamedSetsRoot = ""
			Set tPlugInRoot = ""
			Set tQMsrRoot = ""
			Set tVariableRoot = ""

			// named filters
			If $D(tFilterList) {
				Set f = $O(tFilterList(""))
				While (f'="") {
					Set tFilterInfo = tFilterList(f)
					Set tIcon = "deepsee/ds2_gear_44.png"
					// value is %FILTER-- pivot will look up the spec
					If (tFilterRoot="") {
						Set tFilterRoot = $I(pTree)
					}
					Set pTree($I(pTree)) = $LB($LG(tFilterInfo,1),"%FILTER",0,"",0,tIcon,$LG(tFilterInfo,2))
					Set pTree(tFilterRoot,"ch",pTree) = ""
					Set tFilterCount = tFilterCount + 1
					Set f = $O(tFilterList(f))
				}
			}

			// pivot variables
			If $D(tVariableList) {
				Set f = $O(tVariableList(""))
				While (f'="") {
					Set tVariableInfo = tVariableList(f)
					Set tIcon = "deepsee/ds2_keyhole_44.png"
					// value is $variable.variableName -- pivot will resolve this
					If (tVariableRoot="") {
						Set tVariableRoot = $I(pTree)
					}
					Set pTree($I(pTree)) = $LB($LG(tVariableInfo,2),"$variable."_$LG(tVariableInfo,1),0,"",0,tIcon,$LG(tVariableInfo,5))
					Set pTree(tVariableRoot,"ch",pTree) = ""
					Set tVariableCount = tVariableCount + 1
					Set f = $O(tVariableList(f))
				}
			}

			// JMD905: quality measures
			If $D(tQMsrList) {
				If (tQMsrRoot="") {
					Set tQMsrRoot = $I(pTree)
				}

				// first split into catalog/set/id
				Set q = $O(tQMsrList(""))
				While (q'="") {
					Set tQName = $LG(tQMsrList(q),1)
					Set tQCatalog = $P(tQName,"/",1)
					Set tQSet = $P(tQName,"/",2)
					Set tQId = $P(tQName,"/",3)
					Set tQList(tQCatalog,tQSet,tQId) = $LB(tQName,$LG(tQMsrList(q),2))
					Set q = $O(tQMsrList(q))
				}

				// now add to tree
				Set tIcon = "deepsee/ds2_beaker_44.png"
				Set tQCatalog = $O(tQList(""))
				While (tQCatalog'="") {
					Set pTree($I(pTree)) = $LB(tQCatalog,,1,"",0,"",$$$Text("Catalog","%DeepSee"))
					Set pTree(tQMsrRoot,"ch",pTree) = ""
					Set tQCatNo = pTree
					Set tQMsrCount = tQMsrCount + 1

					Set tQSet = $O(tQList(tQCatalog,""))
					While (tQSet'="") {
						Set pTree($I(pTree)) = $LB(tQSet,,1,"",0,"",$$$Text("Set","%DeepSee"))
						Set pTree(tQCatNo,"ch",pTree) = ""
						Set tQSetNo = pTree

						Set tQId = $O(tQList(tQCatalog,tQSet,""))
						While (tQId'="") {
							// JMD1098 Get groups and elements of the qmsr
							Set tSC = ##class(%DeepSee.QualityMeasure.Utils).%GetQualityElements($LG(tQList(tQCatalog,tQSet,tQId),1),.tQElList)

							Set tSpec = "[%QualityMeasure].["_$$$dsEscapeIdent($LG(tQList(tQCatalog,tQSet,tQId),1))_"]" // JSL4451 - invoke $$$dsEscapeIdent
							Set pTree($I(pTree)) = $LB(tQId,tSpec,''$D(tQElList),"",0,tIcon,$LG(tQList(tQCatalog,tQSet,tQId),2),"font-weight:bold;")
							Set pTree(tQSetNo,"ch",pTree) = ""
							Set tQIdNo = pTree

							// add groups to tree
							Set tQGroup = $O(tQElList(""))
							While (tQGroup'="") {
								Set tSpec = "[%QualityMeasure].["_$$$dsEscapeIdent($LG(tQList(tQCatalog,tQSet,tQId),1))_"/"_$$$dsEscapeIdent(tQGroup)_"]" // JSL4451 - invoke $$$dsEscapeIdent
								Set pTree($I(pTree)) = $LB(tQGroup,tSpec,1,"",0,"",$$$Text("Group","%DeepSee"),"color:#608060;")
								Set pTree(tQIdNo,"ch",pTree) = ""
								Set tQGroupNo = pTree

								Set tQElement = $O(tQElList(tQGroup,""))
								While (tQElement'="") {
									Set tSpec = "[%QualityMeasure].["_$$$dsEscapeIdent($LG(tQList(tQCatalog,tQSet,tQId),1))_"/"_$$$dsEscapeIdent(tQGroup)_"/"_$$$dsEscapeIdent(tQElement)_"]" // JSL4451 - invoke $$$dsEscapeIdent
									Set pTree($I(pTree)) = $LB(tQElement,tSpec,0,"",0,"",$$$Text("Element","%DeepSee"),"color:#606080;")
									Set pTree(tQGroupNo,"ch",pTree) = ""

									Set tQElement = $O(tQElList(tQGroup,tQElement))
								}
								Set tQGroup = $O(tQElList(tQGroup))
							}


							Set tQId = $O(tQList(tQCatalog,tQSet,tQId))
						}
						Set tQSet = $O(tQList(tQCatalog,tQSet))
					}
					Set tQCatalog = $O(tQList(tQCatalog))
				}
			}

			// JMD900: plug ins
			If $D(tPlugInList) {
				Set f = $O(tPlugInList(""))
				While (f'="") {
					If $D(tPlugInList(f,"props")) {
						Set tPlugInInfo = tPlugInList(f)
						// value is %FILTER-- pivot will look up the spec
						If (tPlugInRoot="") {
							Set tPlugInRoot = $I(pTree)
						}
						Set tPlugInName = $LG(tPlugInInfo,1)
						Set tPlugInCaption = $LG(tPlugInInfo,2)
						Set tToolTip = $LG(tPlugInInfo,2)
						Set pTree($I(pTree)) = $LB(tPlugInCaption,,1,"",0,"",tToolTip)
						Set pTree(tPlugInRoot,"ch",pTree) = ""
						Set tParentNo = pTree
						
						Set tIcon = "deepsee/ds2_zap_44.png"
						Set k = $O(tPlugInList(f,"props",""))
						While (k'="") {
							Set tProp = $G(tPlugInList(f,"props",k))
							Set tPropCaption = $G(tPlugInList(f,"props",k,"caption"),tProp)

							// KPI reference (with %CONTEXT)
							Set tSpec = "%KPI("_$$$quote(tPlugInName)_","_$$$quote(tProp)_",,""%CONTEXT"")"

							Set pTree($I(pTree)) = $LB(tPropCaption,tSpec,0,"",0,tIcon,tPropCaption)
							Set pTree(tParentNo,"ch",pTree) = ""
							Set k = $O(tPlugInList(f,"props",k))
						}
						
						Set tPlugInCount = tPlugInCount + 1
					}
					Set f = $O(tPlugInList(f))
				}
			}

			// walk over dimension list
			// build ordered list of dimensions
			Set tDim = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",""))
			While (tDim '= "") {
				Set tDimNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim))
				Set tDimNo = +$LG(tDimNode,1)
				Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,0,0))
				Set tHidden = +$LG(tDimInfo,17)
				If ('tHidden) {
					// make sure dim #s collate correctly
					Set tOrderedDims($TR($J(tDimNo,4)," ",0)_":"_tDim) = tDim
				}
				Set tDim = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim))
			}

			// walk over dimension list
			// build list of levels and measures
			Set tDimKey = $O(tOrderedDims(""))
			While (tDimKey '= "") {
				Set tDim = tOrderedDims(tDimKey)
				Set tDimNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim))
				Set tDimNo = $LG(tDimNode,1)
				If (tDimNo'="") {
					Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,0,0))
					Set tDimName = $LG(tDimInfo,2)
					Set tShowHier = $LG(tDimInfo,18)

					If ($E(tDimName,1,1)'="%") {
						Set tAllName = $LG(tDimInfo,4)
						Set tDimCaption = $zobjclassmethod(tClassName,"%GetMemberCaption",tDim)
						Set tDimDescription=""
						try {
							Set tDimDescription = $zobjclassmethod(tClassName,"%GetMemberDescription",tDim) // JSL4475
						} catch {}
						Set tIsRelation = ''$D($$$DeepSeeMetaGLVN("cubes",tCube,"relations",tDim))

						If (tIsRelation) {
							Set tRelatedCube = $LG(tDimInfo,6)
							Set tCardinality = $LG(tDimInfo,7)
							Set tInverse = $LG(tDimInfo,8)

							// add relation to tree
							// lazy-load its dimensions on demand!
							// use special string to specify cube and relation name:
							// @@cube@@relation

							If (..%CheckPrivilege(tRelatedCube)) {
								Set ni = $I(pTree)
								If (pSkeleton) {
									Set tHasChildren = 0
									Set tRelCode = tDimName
								}
								Else {
									Set tHasChildren = 1
									Set tRelCode = "@@"_tCube_"@@"_tDimName
								}
								Set pTree(ni) = $LB(tDimCaption,tRelCode,tHasChildren,"",0,,$s(tDimDescription'="":tDimDescription,1:tDimCaption),"font-weight:bold;color:rgb(10,92,116);font-style:italic;")
								Set pTree(tDimRoot,"ch",ni) = ""
								Set tDimCount = tDimCount + 1 //JKG JSL4469
							}
						}
						Else {
							If (tDim'="MEASURES") {
								// add dimension to tree
								// $LB(caption, value, hasChildren, link, expanded, icon, tooltip, style)

								Set tDimCount = tDimCount + 1
								Set tHasChild = $D($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim))=11

								// JMD1206: use first level and not %TopMembers
								//Set pTree($I(pTree)) = $LB(tDimCaption,"["_tDimName_"]" _ ".%TopMembers",tHasChild,"",0,,tDimCaption,"font-weight:bold;color:#606060;")

								// find first hier/level
								Set tXDimNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",$$$UPPER(tDim)))
								Set xd = +$LG(tDimNode,1)
								Set xh = 1
								Set xl = +$LG(tDimNode,3)
								Set tXDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",xd,xh,xl))
								Set tXType = $LG(tXDimInfo,1)
								While (tXType '= "l") {
									Set xl = xl + 1
									Set tXDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",xd,xh,xl))
									If tXDimInfo="" Quit
									Set tXType = $LG(tXDimInfo,1)
								}
								Set tXHierName = $LG(tXDimInfo,3)
								Set tXLevelName = $LG(tXDimInfo,4)
								Set tTopSpec = "["_$$$dsEscapeIdent(tDimName) _"]"_".["_$$$dsEscapeIdent(tXHierName) _"]"_".["_$$$dsEscapeIdent(tXLevelName) _"]"_".Members" // JSL4451 - invoke $$$dsEscapeIdent

								Set pTree($I(pTree)) = $LB(tDimCaption,tTopSpec,tHasChild,"",0,,$s(tDimDescription'="":tDimDescription,1:tDimCaption),"font-weight:bold;color:#606060;") // JSL4475 - use tDimDescription
								Set pTree(tDimRoot,"ch",pTree) = ""
								Set tDimParent = pTree

								// add all level, if present
								If (tAllName '= "") {
									Set tAllCaption = $zobjclassmethod(tClassName,"%GetMemberCaption",tDim,$$$UPPER(tAllName))
									If (tAllCaption '= "") {
										Set pTree($I(pTree)) = $LB(tAllCaption,"["_$$$dsEscapeIdent(tDimName)_"].["_$$$dsEscapeIdent(tAllName)_"]",0,"",0,,tAllCaption) // JSL4451 - invoke $$$dsEscapeIdent
										Set pTree(tDimParent,"ch",pTree) = ""
									}
								}

								// add calculated members in *this* dimension
								If ($D(tCalcMbrs(tDim))) {
									Set tMbr = $O(tCalcMbrs(tDim,""))
									While (tMbr '= "") {
										Set tInfo = tCalcMbrs(tDim,tMbr)
										Set tMbrCaption = $LG(tInfo,2)
										Set tMbrHidden = +$LG(tInfo,5)
										If ('tMbrHidden) {
											Set c = $zobjclassmethod(tClassName,"%GetMemberCaption",tDim,tMbrCaption)
											Set:c'="" tMbrCaption = c
											Set tMbrDescription=""
											try {
												Set tMbrDescription = $zobjclassmethod(tClassName,"%GetMemberDescription",tDim,$LG(tInfo,2)) // JSL4476
											} catch {}
											Set tDimCount = tDimCount + 1
											Set tHasChild = 0

											Set tIcon = "deepsee/deepsee/ds2_beaker2_44.png"
											Set tStyle = "color:rgb(91,92,67);"
											// use different color for locally defined items
											If ($D(pLocalCalcMembers(tDim,tMbr)))||($D(tSharedCalcMbrs(tDim,tMbr))) {
												Set tStyle = "color:rgb(91,92,167);"
											}
											
											// DTB268 - Flag the calc member as shared
											Set tSharedToken="" 
											If ($D(tSharedCalcMbrs(tDim,tMbr)))&&('$D(pLocalCalcMembers(tDim,tMbr))) {
												Set tSharedToken = "%SHAREDCALC."
											}
											
											Set pTree($I(pTree)) = $LB(tMbrCaption,tSharedToken_"["_$$$dsEscapeIdent(tDim)_"].["_$$$dsEscapeIdent(tMbr)_"]",tHasChild,"",0,tIcon,$s(tMbrDescription'="":tMbrDescription,1:tMbrCaption),tStyle) // JSL4451 - invoke $$$dsEscapeIdent
											Set pTree(tDimParent,"ch",pTree) = ""
										}
										Set tMbr = $O(tCalcMbrs(tDim,tMbr))
									}
								}
							}

							// walk over hierarchy list
							// build ordered list of hierarchies
							Kill tOrderedHiers
							Set tHierCount = 0
							Set tHier = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,""))
							While (tHier '= "") {
								Set tHierNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier))
								Set tHierNo = $LG(tHierNode,2)
								Set tHierLevelInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,$LG(tHierNode,3)))
								Set tHierType = $LG(tHierLevelInfo,1) // actual level associated with hierarchy name
								If (tHierType'="all") {
									Set tHierCount = tHierCount + 1
								}
								If (tHierNo '= "a") {
									// n.b. "a" is a dimension attribute-- not used
									Set tOrderedHiers($TR($J(tHierNo,4)," ",0)_":"_tHier) = tHier
								}
								Set tHier = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier))
							}

							Set tHierKey = $O(tOrderedHiers(""))
							While (tHierKey '= "") {
								Set tHier = tOrderedHiers(tHierKey)
								Set tHierNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier))
								Set tHierNo = $LG(tHierNode,2)
								Set tHierInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,0))
								Set tHierLevelInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,$LG(tHierNode,3)))
								Set tHierType = $LG(tHierLevelInfo,1) // actual level associated with hierarchy name
								Set tHierName = $LG(tHierInfo,3)
								Set tHierCaption = $zobjclassmethod(tClassName,"%GetMemberCaption",tDim,tHier)
								Set tHierDescription=""
								try {
									Set tHierDescription = $zobjclassmethod(tClassName,"%GetMemberDescription",tDim,tHier) // JSL4475
								} catch {}
								Set tHidden = +$LG(tHierInfo,17)

								If (tHierType '= "all") {
									If (tDim = "MEASURES") {
										// measures use different hidden slot!
										Set tHidden = +$LG(tHierInfo,11)
										If ('tHidden && 'pSkipMeasures) {
											Set tMsrType = $LG(tHierLevelInfo,8)
											If (tHierName=$$$UPPER(tCountName)) {
												Set tMsrSourceCube = $LG(tHierLevelInfo,14)
												If (tMsrSourceCube'="") {
													// measure in compound cube
													Set tHierCaption = ##class(%DeepSee.Utils).%GetCountCaption(tMsrSourceCube)
												}
											}
											Set tMsrCount = tMsrCount + 1
											Set tIcon = $Case(tMsrType,"date":"deepsee/ds2_clock_44.png",:"deepsee/ds2_location_44.png")
											Set pTree($I(pTree)) = $LB(tHierCaption,"[Measures].["_$$$dsEscapeIdent(tHierName)_"]",0,"",0,tIcon,$s(tHierDescription'="":tHierDescription,1:tHierCaption)) // JSL4451 - invoke $$$dsEscapeIdent
											Set pTree(tMsrRoot,"ch",pTree) = ""
										}
									}
									Else {
										If ('tHidden) {
											// list levels in level # order
											Kill tLevelList
											Set tLevel = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier,""))
											While (tLevel '= "") {
												Set tLevelNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier,tLevel))
												Set tLevelNo = $LG(tLevelNode,3)
												Set tLevelInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
												Set tLevelType = $LG(tLevelInfo,1)
												Set tLevelName = $LG(tLevelInfo,4)
												Set tLevelCaption = $zobjclassmethod(tClassName,"%GetMemberCaption",tDim,tHier,tLevel)
												Set tLevelDescription=""
												try {
													Set tLevelDescription = $zobjclassmethod(tClassName,"%GetMemberDescription",tDim,tHier,tLevel) // JSL4475
												} catch {}
												Set tLevelHidden = $LG(tLevelInfo,17)

												If (tLevelType '= "all") { // we are not interested in the all level
													If ('tLevelHidden) {
														// are there properties
														Set tPropNo = 0
														Set tProp = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo,"prop",""))
														While (tProp '= "") {
															Set tPropInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo,"prop",tProp))
															Set tPropName = $LG(tPropInfo,4)
															Set tPropCaption = $zobjclassmethod(tClassName,"%GetMemberCaption",tDim,tHier,tLevel,tProp)
															Set tPropDescription=""
															try {
																Set tPropDescription = $zobjclassmethod(tClassName,"%GetMemberDescription",tDim,tHier,tLevel,tProp) // JSL4475
															} catch {}
															Set tPropHidden = +$LG(tPropInfo,17)
															If ('tPropHidden) {
																Set tHasMembers = 1
																Set tPropNo = tPropNo + 1
																Set tIcon = "deepsee/ds2_cards_44.png"
																Set tLevelList(tLevelNo,tPropNo) = $LB(tPropCaption,"["_$$$dsEscapeIdent(tDimName)_"].["_$$$dsEscapeIdent(tHierName)_"].["_$$$dsEscapeIdent(tLevelName)_"].CurrentMember.Properties("""_tPropName_""")",0,"",0,tIcon,$s(tPropDescription'="":tPropDescription,1:$$$Text("Property: ","%DeepSee") _ tPropCaption),"color:darkblue;") // JSL4451 - invoke $$$dsEscapeIdent
															}
															Set tProp = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo,"prop",tProp))
														}
							 							// JMD
							 							// Set tMemberCount = ..%GetCubeMemberCount(tCube,.tSC,tDimName,tHierName,tLevelName)
							 							Set tMemberCount = 1
														If $$$ISERR(tSC) Quit
														If (((tMemberCount > 0) && 'pSkeleton) || ($G(tPropNo)>0)) {
															Set tLevelLabel = tDimCaption_"."_tHierCaption_"."_tLevelCaption
															Set tHasMembers = 1
														}
														Else {
															Set tLevelLabel = tDimCaption_"."_tHierCaption_"."_tLevelCaption 
															Set tHasMembers = 0
														}
														Set tLevelList(tLevelNo) = $LB(tLevelCaption,"["_$$$dsEscapeIdent(tDimName)_"].["_$$$dsEscapeIdent(tHierName)_"].["_$$$dsEscapeIdent(tLevelName)_"]",tHasMembers,"",0,,$s(tLevelDescription'="":tLevelDescription,1:tLevelLabel)) // JSL4451 - invoke $$$dsEscapeIdent
													}
												}
												Set tLevel = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier,tLevel))
											}
											If $$$ISERR(tSC) Quit

											Set tHierParent = tDimParent
											If ((tShowHier=1)||((tShowHier'=0)&&(tHierCount>1))) {
												// show the hierarchy
												Set tHierLabel = tDimCaption_"."_tHierCaption
												Set pTree($I(pTree)) = $LB(tHierCaption,"",1,"",0,,tHierLabel)
												Set pTree(tDimParent,"ch",pTree) = ""
												Set tHierParent = pTree
											}

											// now add levels to tree
											Set tNo = $O(tLevelList(""))
											While (tNo'="") {
												Set tMbrSpec = $LG(tLevelList(tNo),2) // don't invoke $$$dsEscapeIdent!
												Set $List(tLevelList(tNo),2) = tMbrSpec _ ".Members"
												Set pTree($I(pTree)) = tLevelList(tNo)
												Set pTree(tHierParent,"ch",pTree) = ""
												Set tNodeNo = pTree

												Set tNo = $O(tLevelList(tNo))
											}
										}
									}
								}
								Set tHierKey = $O(tOrderedHiers(tHierKey))
								If $$$ISERR(tSC) Quit
							}
						} // relation
					} // dimname
				} // dimno

				Set tDimKey = $O(tOrderedDims(tDimKey))
				If $$$ISERR(tSC) Quit
			}
			If $$$ISERR(tSC) Quit

			Set tDim = $O(tCalcMbrs(""))
			While (tDim '= "") {
				Set tIcon = "deepsee/ds2_beaker2_44.png"
				If (tDim = "MEASURES") {
					If ('pSkipMeasures) {
						Set tMbr = $O(tCalcMbrs(tDim,""))
						While (tMbr '= "") {
							Set tInfo = tCalcMbrs(tDim,tMbr)
							Set tMbrCaption = $LG(tInfo,2)
							Set tMbrHidden = +$LG(tInfo,5)
							If ('tMbrHidden) {
								Set c = $zobjclassmethod(tClassName,"%GetMemberCaption",tDim,tMbrCaption)
								Set tMbrDescription = $zobjclassmethod(tClassName,"%GetMemberDescription",tDim,tMbrCaption)
								Set:c'="" tMbrCaption = c
								Set tMsrCount = tMsrCount + 1
								Set tHasChild = 0

								Set tStyle = "color:rgb(91,92,67);"
								// use different color for locally defined items
								If ($D(pLocalCalcMembers(tDim,tMbr)))||($D(tSharedCalcMbrs(tDim,tMbr))) {
									Set tStyle = "color:rgb(91,92,167);"
								}
								// DTB268 - Flag the calc member as shared
								Set tSharedToken="" 
								If ($D(tSharedCalcMbrs(tDim,tMbr)))&&('$D(pLocalCalcMembers(tDim,tMbr))) {
									Set tSharedToken = "%SHAREDCALC."
								}
								
								Set pTree($I(pTree)) = $LB(tMbrCaption,tSharedToken_"["_$$$dsEscapeIdent(tDim)_"].["_$$$dsEscapeIdent(tMbr)_"]",tHasChild,"",0,tIcon,$s(tMbrDescription'="":tMbrDescription,1:tMbrCaption),tStyle) // JSL4451 - invoke $$$dsEscapeIdent
								Set pTree(tMsrRoot,"ch",pTree) = ""
							}
							Set tMbr = $O(tCalcMbrs(tDim,tMbr))
						}
					}
				}
				ElseIf ('$D($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim))) {
					// Get info from first member
					Set k = $O(tCalcMbrs(tDim,""))
					If (k'="") {
						Set tDimInfo = tCalcMbrs(tDim,k)
						Set tDimName = tDim
						Set tDimCaption = $LG(tDimInfo,1)
						Set tDimDescription=""
						try {
							Set tDimDescription = $zobjclassmethod(tClassName,"%GetMemberDescription",tDim) // JSL4476
						} catch {}
						// !!! ALL MEMBERS
						// make sure this isn't a "regular" dimension
						// JMD1006: only add entry if there are non-hidden children
						Set tParentCreated = 0

						While (k'="") {
							Set tMbrInfo = tCalcMbrs(tDim,k)
							Set tMbrHidden = +$LG(tMbrInfo,5)
							If ('tMbrHidden) {
								// JMD1006
								If ('tParentCreated) {
									Set pTree($I(pTree)) = $LB(tDimCaption,"["_$$$dsEscapeIdent(tDimName)_"]" _ ".AllMembers",1,"",0,,$s(tDimDescription'="":tDimDescription,1:tDimCaption),"font-weight:bold;color:rgb(80,120,80);") // JSL4451 - invoke $$$dsEscapeIdent
									Set pTree(tDimRoot,"ch",pTree) = ""
									Set tDimParent = pTree
									Set tParentCreated = 1
								}
								
								// DTB268 - Color all local members
								Set tStyle = "color:rgb(91,92,67);"
								// use different color for locally defined items
								If ($D(pLocalCalcMembers(tDim,k)))||($D(tSharedCalcMbrs(tDim,k))) {
									Set tStyle = "color:rgb(91,92,167);"
								}
								//DTB268 - Flag the calc member as shared
								Set tSharedToken="" 
								If ($D(tSharedCalcMbrs(tDim,k)))&&'($D(pLocalCalcMembers(tDim,k))) {
									Set tSharedToken = "%SHAREDCALC."
								}
								
								Set tMbrSpec = tSharedToken_"["_$$$dsEscapeIdent(tDim)_"].["_$$$dsEscapeIdent($LG(tMbrInfo,2))_"]" // JSL4451 - invoke $$$dsEscapeIdent
								Set tDimDescription=$zobjclassmethod(tClassName,"%GetMemberDescription",tDim,$LG(tMbrInfo,2))
								Set pTree($I(pTree)) = $LB($LG(tMbrInfo,2),tMbrSpec,0,"",0,tIcon,$s(tDimDescription'="":tDimDescription,1:$LG(tMbrInfo,2)),tStyle) // JSL4476	// DTB268 - Add icon and style
								Set pTree(tDimParent,"ch",pTree) = ""
							}
							Set k = $O(tCalcMbrs(tDim,k))
						}
					}
				}
				Set tDim = $O(tCalcMbrs(tDim))
			}

			// Named sets
			// combine local list with those defined in the cube
			Merge tNamedSets = $$$DeepSeeMetaGLVN("cubes",tCube,"namedSets")
			Merge tNamedSets = pLocalNamedSets

			Set tSet = $O(tNamedSets(""))
			While (tSet '= "") {
				Set tInfo = tNamedSets(tSet)
				Set tSetCaption = $LG(tInfo,1)
				Set tSetCaption = $zobjclassmethod(tClassName,"%GetMemberCaption","%%NAMEDSETS",tSetCaption)
				Set tSetDescription = $zobjclassmethod(tClassName,"%GetMemberDescription","%%NAMEDSETS",$LG(tInfo,1))
				Set tDimCount = tDimCount + 1
				Set tHasChild = 0
	
				If (tNamedSetsRoot="") {
					Set tNamedSetsRoot = $I(pTree)
				}
				Set tIcon = "deepsee/ds2_sun_44.png"
				Set pTree($I(pTree)) = $LB(tSetCaption,"["_$$$dsEscapeIdent(tSet)_"]",tHasChild,"",0,tIcon,$s(tSetDescription'="":tSetDescription,1:tSetCaption),"font-weight:bold;color:rgb(91,92,67);") // JSL4451 - invoke dsEscapeIdent
				Set pTree(tNamedSetsRoot,"ch",pTree) = ""
				Set tSet = $O(tNamedSets(tSet))
			}

			// now add the top nodes
			If (tDimCount >= 0) {
				Set tHasChild = tDimCount > 0
				Set pTree(0,"ch",tDimRoot) = ""
				Set pTree(tDimRoot) = $LB($$$Text("Dimensions","%DeepSee"),"",tHasChild,"",1,,$$$Text("Dimensions","%DeepSee"),"font-weight:bold;")
			}
			If ((tMsrCount >= 0) && 'pSkipMeasures) {
				Set tHasChild = tMsrCount > 0
				Set pTree(0,"ch",tMsrRoot) = ""
				Set pTree(tMsrRoot) = $LB($$$Text("Measures","%DeepSee"),"",tHasChild,"",1,,$$$Text("Measures","%DeepSee"),"font-weight:bold;")
			}
			If ((tFilterCount > 0) && (tFilterRoot'="") && 'pSkipMeasures) {
				Set tHasChild = tFilterCount > 0
				Set pTree(0,"ch",tFilterRoot) = ""
				Set pTree(tFilterRoot) = $LB($$$Text("Named Filters","%DeepSee"),"",tHasChild,"",1,,$$$Text("Named Filters","%DeepSee"),"font-weight:bold;")
			}
			If ((tQMsrCount > 0) && (tQMsrRoot'="")) {
				Set tHasChild = tQMsrCount > 0
				Set pTree(0,"ch",tQMsrRoot) = ""
				Set pTree(tQMsrRoot) = $LB($$$Text("Quality Measures","%DeepSee"),"",tHasChild,"",1,,$$$Text("Quality Measures","%DeepSee"),"font-weight:bold;")
			}
			If ((tPlugInCount > 0) && (tPlugInRoot'="")) {
				Set tHasChild = tPlugInCount > 0
				Set pTree(0,"ch",tPlugInRoot) = ""
				Set pTree(tPlugInRoot) = $LB($$$Text("Plug-ins","%DeepSee"),"",tHasChild,"",1,,$$$Text("Plug-ins","%DeepSee"),"font-weight:bold;")
			}
			If ($D(tNamedSets) && (tNamedSetsRoot'="") ) {
				Set tHasChild = ''$D(tNamedSets)
				Set pTree(0,"ch",tNamedSetsRoot) = ""
				Set pTree(tNamedSetsRoot) = $LB($$$Text("Named Sets","%DeepSee"),"",tHasChild,"",1,,$$$Text("Named Filters","%DeepSee"),"font-weight:bold;")
			}
			If ((tVariableCount > 0) && (tVariableRoot'="")) {
				Set tHasChild = tVariableCount > 0
				Set pTree(0,"ch",tVariableRoot) = ""
				Set pTree(tVariableRoot) = $LB($$$Text("Pivot Variables","%DeepSee"),"",tHasChild,"",1,,$$$Text("Pivot Variables","%DeepSee"),"font-weight:bold;")
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetPivotTree">
<Description>
Get list of saved pivots for a cube for display within a tree.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,&pTree,pCurrPivot:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// create a new session (or use the one currently in scope)
		// this will cause user-init code to be run
		Set tSession = $G($$$DeepSeeSession)
		If ('$IsObject(tSession)) {
			Do ##class(%DeepSee.Session).%CreateSession($S($IsObject($G(%session)):%session.SessionId,1:$J),.tSC)
			Set tSession = $G($$$DeepSeeSession)
		}

		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		If ('..%CheckPrivilege(tCube)) Quit

		Set pCurrPivot = $P(pCurrPivot,".",1)

		// list of pivots
		Set tSC = ..%GetPivotList(.tPivotList,0,pCube)
		If $$$ISERR(tSC) Quit

		Set tPivotCount = 0
		Kill pTree
		Set pTree = 0
		Set tPivotRoot = ""

		If $D(tPivotList) {
			If (tPivotRoot="") {
				Set tPivotRoot = $I(pTree)
			}

			// JMD1417 replace old logic
			// list of items by full name
			Kill tItems
			Set k = $O(tPivotList(""))
			While (k'="") {
				Set tFullName = $LG(tPivotList(k),1)
				Set tItems(tFullName) = k
				Set k = $O(tPivotList(k))
			}

			// now emit items into folders
			Kill tFolderRoot
			Set tFolderRoot(-1E14) = tPivotRoot

			Set k = $O(tItems(""))
			While (k'="") {
				Set tIndex = tItems(k)
				Set tPivotName = $LG(tPivotList(tIndex),2) 
				Set tFullName = k
				Set tStyle = ""
				If (tFullName = pCurrPivot) {
					Set tStyle = "font-weight:bold; color:darkblue;"
				}

				If (tFullName["/") {
					Set tFolder =$P(tFullName,"/",1,$L(tFullName,"/")-1)
					Set tName = $P(tFullName,"/",$L(tFullName,"/"))

					// pull apart folder; test if we have seen the pieces of the folder
					Set tRoot = tPivotRoot
					For fn = 1:1:$L(tFolder,"/") {
						Set tFName = $P(tFolder,"/",fn)
						Set tFNameFull = $P(tFolder,"/",1,fn)
						If '$D(tFolderRoot(tFNameFull)) {
							Set pTree($I(pTree)) = $LB(tFName,"",1)
							Set pTree(tRoot,"ch",pTree) = ""
							Set tRoot = pTree
							Set tFolderRoot(tFNameFull) = tRoot
						}
						Else {
							Set tRoot = tFolderRoot(tFNameFull)
						}
					}
				}
				Else {
					Set tFolder = -1E14
					Set tName = tFullName
				}

				Set pTree($I(pTree)) = $LB(tPivotName,tFullName,0,"",0,"","",tStyle)
				Set pTree(tFolderRoot(tFolder),"ch",pTree) = ""
				Set tPivotCount = tPivotCount + 1

				Set k = $O(tItems(k))
			}
		}

		If ((tPivotCount > 0) && (tPivotRoot'="")) {
			Set tHasChild = tPivotCount > 0
			Set pTree(0,"ch",tPivotRoot) = ""
			Set pTree(tPivotRoot) = $LB($$$Text("Pivots","%DeepSee"),"",tHasChild,"",1,,$$$Text("Pivots saved for this Subject Area","%DeepSee"),"font-weight:bold;")
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetQualityMeasureTree">
<Description>
Get list of quality measures for display within a tree.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,&pTree]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// create a new session (or use the one currently in scope)
		// this will cause user-init code to be run
		Set tSession = $G($$$DeepSeeSession)
		If ('$IsObject(tSession)) {
			Do ##class(%DeepSee.Session).%CreateSession($S($IsObject($G(%session)):%session.SessionId,1:$J),.tSC)
			Set tSession = $G($$$DeepSeeSession)
		}

		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		If ('..%CheckPrivilege(tCube)) Quit

		// quality measures
		Set tSC = ##class(%DeepSee.QualityMeasure.Utils).%GetQualityMeasuresForCube(.tQMsrList,pCube)
		If $$$ISERR(tSC) Quit

		Set tQMsrCount = 0
		Kill pTree
		Set pTree = 1
		Set tQMsrRoot = ""

		// JMD905: quality measures
		If $D(tQMsrList) {
			If (tQMsrRoot="") {
				Set tQMsrRoot = $I(pTree)
			}

			// first split into catalog/set/id
			Set q = $O(tQMsrList(""))
			While (q'="") {
				Set tQName = $LG(tQMsrList(q),1)
				Set tQCatalog = $P(tQName,"/",1)
				Set tQSet = $P(tQName,"/",2)
				Set tQId = $P(tQName,"/",3)
				Set tCaption = $LG(tQMsrList(q),2)
				Set:tCaption="" tCaption = tQId
				Set tDesc = $LG(tQMsrList(q),3)
				Set tQList(tQCatalog,tQSet,tQId) = $LB(tQName,tCaption,tDesc)
				Set q = $O(tQMsrList(q))
			}

			// now add to tree
			Set tIcon = "deepsee/ds2_beaker_44.png"
			Set tQCatalog = $O(tQList(""))
			While (tQCatalog'="") {
				Set pTree($I(pTree)) = $LB(tQCatalog,,1,"",0,"",$$$Text("Catalog","%DeepSee"))
				Set pTree(tQMsrRoot,"ch",pTree) = ""
				Set tQCatNo = pTree
				Set tQMsrCount = tQMsrCount + 1

				Set tQSet = $O(tQList(tQCatalog,""))
				While (tQSet'="") {
					Set pTree($I(pTree)) = $LB(tQSet,,1,"",0,"",$$$Text("Set","%DeepSee"))
					Set pTree(tQCatNo,"ch",pTree) = ""
					Set tQSetNo = pTree

					Set tQId = $O(tQList(tQCatalog,tQSet,""))
					While (tQId'="") {
						// JMD1098 Get groups and elements of the qmsr
						Set tSC = ##class(%DeepSee.QualityMeasure.Utils).%GetQualityElements($LG(tQList(tQCatalog,tQSet,tQId),1),.tQElList)

						Set tSpec = "[%QualityMeasure].["_$$$dsEscapeIdent($LG(tQList(tQCatalog,tQSet,tQId),1))_"]" // JSL4451 invoke $$$dsEscapeIdent
						Set pTree($I(pTree)) = $LB($LG(tQList(tQCatalog,tQSet,tQId),2),tSpec,''$D(tQElList),"",0,tIcon,$LG(tQList(tQCatalog,tQSet,tQId),3),"font-weight:bold;")
						Set pTree(tQSetNo,"ch",pTree) = ""
						Set tQIdNo = pTree

						// add groups to tree
						Set tQGroup = $O(tQElList(""))
						While (tQGroup'="") {
							Set tSpec = "[%QualityMeasure].["_$$$dsEscapeIdent($LG(tQList(tQCatalog,tQSet,tQId),1)_"/"_tQGroup)_"]" // JSL4451 invoke $$$dsEscapeIdent
							Set pTree($I(pTree)) = $LB(tQGroup,tSpec,1,"",0,"",$$$Text("Group","%DeepSee"),"color:#608060;")
							Set pTree(tQIdNo,"ch",pTree) = ""
							Set tQGroupNo = pTree

							Set tQElement = $O(tQElList(tQGroup,""))
							While (tQElement'="") {
								Set tSpec = "[%QualityMeasure].["_$$$dsEscapeIdent($LG(tQList(tQCatalog,tQSet,tQId),1)_"/"_tQGroup_"/"_tQElement)_"]" // JSL4451 invoke $$$dsEscapeIdent
								Set pTree($I(pTree)) = $LB(tQElement,tSpec,0,"",0,"",$$$Text("Element","%DeepSee"),"color:#606080;")
								Set pTree(tQGroupNo,"ch",pTree) = ""

								Set tQElement = $O(tQElList(tQGroup,tQElement))
							}
							Set tQGroup = $O(tQElList(tQGroup))
						}


						Set tQId = $O(tQList(tQCatalog,tQSet,tQId))
					}
					Set tQSet = $O(tQList(tQCatalog,tQSet))
				}
				Set tQCatalog = $O(tQList(tQCatalog))
			}
		}


		If ((tQMsrCount > 0) && (tQMsrRoot'="")) {
			Set tHasChild = tQMsrCount > 0
			Set pTree(0,"ch",tQMsrRoot) = ""
			Set pTree(tQMsrRoot) = $LB($$$Text("Quality Measures","%DeepSee"),"",tHasChild,"",1,,$$$Text("Quality Measures","%DeepSee"),"font-weight:bold;")
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%CopyTree">
<Description><![CDATA[
Copy source tree (from root) into <var>pTree</var> at the given parent node.
Return number of nodes copied.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pName:%String,&pTree,pParent:%Integer,&pSource,pRoot:%Integer]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tCount = 0
	Set k = $O(pSource(pRoot,"ch",""))
	While (k '= "") {
		Set tNode = pSource(k)
		Set tVal = $LG(tNode,2)
		If ((tVal'="")) {
			Set tName = pName
			Set:$E(tName)'="[" tName = "["_tName_"]"
			If ($E(tVal,1,2)="@@") {
				// relation ref
				Set tVal = tVal_"^"_tName
			}
			Else {
				Set tVal = ""_tName_"."_tVal
			}
			Set $List(tNode,2) = tVal
		}
		Set tCount = tCount + 1
		Set pTree($I(pTree)) = tNode
		Set pTree(pParent,"ch",pTree) = ""
		If $D(pSource(k,"ch")) {
			Set tCount = tCount + ..%CopyTree(pName,.pTree,pTree,.pSource,k)
		}
		Set k = $O(pSource(pRoot,"ch",k))
	}
	Quit tCount
]]></Implementation>
</Method>

<Method name="%GetDimensionInfo">
<Description><![CDATA[
Return the dimension,hierarchy, and level number of the specified element
within the specified cube.<br/>
<var>pCubeName</var> is the name of the cube.<br/>
<var>pSpec</var> specifies the dimension in the form:
"Dim.Hier.Level" or "Dim.Hier.Level.member".<br/>
If <var>pStrict</var> is false, then find a level: Hier or Level can be omitted if they are not ambiguous.<br/>
<var>pSpecInfo</var> is the array produced by parsing <var>pSpec</var>.
This is returned as a convenience.<br/>
<var>pLocalCalcMembers</var> is an optional list of locally defined calculated members.
<var>pLocalNamedSets</var> is an optional list of locally defined named sets.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCubeName:%String,pSpec:%String,*pDimNo,*pHierNo,*pLevelNo,*pRelationName:%String,*pRelationSpec:%String,*pSpecInfo:%String,&pLocalCalcMembers,pStrict:%Boolean=1,&pLocalNamedSets]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set (pDimNo,pHierNo,pLevelNo) = ""
		Set pRelationName = ""
		Set pRelationSpec = ""
		Set tCube = $$$UPPER(pCubeName)
		Set tIsTop = 0

		// JMD920: prevent undefined
		If (tCube="") Quit

		// JMD1276
		If ($E(pSpec,1,5)="%VAR:") {
			Set pDimNo = -2
			Set pHierNo = 0
			Set pLevelNo = 0
			Quit
		}

		// DTB043 - Test for %OR() wrapped around expression; remove it
		If ($E(pSpec,1,4)="%OR(") {
			Set pSpec = $E(pSpec,5,$L(pSpec)-1)
		}

		// replace %TopMembers
		// to make filters in pivotTable work
		If (pSpec [ ".%TopMembers") {
			Set tIsTop = 1
			Set tDim = $Replace(pSpec,".%TopMembers","")
			If ($E(tDim)="[") {
				Set tDim = $E(tDim,2,*-1)
			}
			// guess which hier and level to use!
			Set tDimNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",$$$UPPER(tDim)))
			Set d = +$LG(tDimNode,1)
			Set h = 1
			Set l = +$LG(tDimNode,3)
			Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",d,h,l))
			Set tType = $LG(tDimInfo,1)
			While (tType '= "l") {
				Set l = l + 1
				Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",d,h,l))
				If tDimInfo="" Quit
				Set tType = $LG(tDimInfo,1)
			}
			Set tHier = $LG(tDimInfo,3)
			Set tLevel = $LG(tDimInfo,4)

			Set pSpec = "["_tDim _"]"_".["_tHier _"]"_".["_tLevel _"]"_".Members"
		}
		ElseIf ($E(pSpec,1,1)="{") {
			// spec is a set expression: analyze first element
			Set pSpec = $E(pSpec,2,$L(pSpec)-1)
			If ($L(pSpec,"],[")>1) {
				Set pSpec = $P(pSpec,"],[",1) _ "]"
			}
		}

		Kill pSpecInfo
		Set tSC = ##class(%DeepSee.Query.Parser).%ParseMemberSpec(pSpec,.pSpecInfo,.tQuoted)
		If $$$ISERR(tSC) Quit

		Set tDim = $$$UPPER($G(pSpecInfo(1)))
		Set tHier = $$$UPPER($G(pSpecInfo(2)))
		Set tLevel = $$$UPPER($G(pSpecInfo(3)))

		// check if tDim is a relationship
		If ((tDim'="")&&$D($$$DeepSeeMetaGLVN("cubes",tCube,"relations",tDim))) {
			Set pRelationName = tDim
			Set pRelationSpec = $P(pSpec,".",2,$L(pSpec,"."))  // remove first piece
			Quit
		}
		
		// Test for quality measures
		// JMD905 - test for special [%QualityMeasure] dimension
		If ((tDim="%QUALITYMEASURE")&&(tHier'="")) {
			// look up the qmsr
			Set tQMsrClass = $G($$$DeepSeeQMsrGLVN("qmsrNames",tHier))
			If (tQMsrClass="") {
				Set tSC = $$$ERROR($$$GeneralError,"Quality Measure not found: " _ tHier)
				Quit
			}
			Set pDimNo = -2
			Set pHierNo = 0
			Set pLevelNo = 0
			Quit
		}

		// DTB575 - Test for $NAMEDFILTER token
		If (tDim="$NAMEDFILTER") {
			Set pDimNo = -2
			Set pHierNo = 0
			Set pLevelNo = 0
			Quit
		}

		// Named sets
		// combine local list with those defined in the cube
		Merge tNamedSets = $$$DeepSeeMetaGLVN("cubes",tCube,"namedSets")
		Merge tNamedSets = pLocalNamedSets
		If ((tDim'="")&&$D(tNamedSets(tDim))&&'$D($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim))) {
			Set pDimNo = -2
			Set pHierNo = 0
			Set pLevelNo = 0
			Quit
		}

		// check for calculated members
		// combine local list with those defined in the cube
		Merge tCalcMbrs = $$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs")
		
		// +DTB268 - Add shared calculated members
		Set tSC = ##class(%DeepSee.Utils).%GetSharedCalcMembers(tCube,.tSharedCalcArray)
		Set tSharedCalcIdx = $O(tSharedCalcArray(""),1,tSharedCalcData)
		While tSharedCalcIdx'="" {
			Set tSharedCalcDimKey = $$$UPPER($LG(tSharedCalcData,1))
			Set tSharedCalcKey = $$$UPPER($LG(tSharedCalcData,2))
			Set tSC = ##class(%DeepSee.Utils).%GetSharedCalcMemberInfo(tCube,tSharedCalcDimKey,tSharedCalcKey,.tMbrInfo)
			If $D(tMbrInfo) {
				// $LB(dimension,name,expression,format,hidden)
				Set tSharedCalcMbrs(tSharedCalcDimKey,tSharedCalcKey) = $LB(tMbrInfo("dimension"),tMbrInfo("name"),tMbrInfo("expression"),tMbrInfo("format"))		// DTB461 - Remove solveOrder in the hidden position
			}
			
			Set tSharedCalcIdx = $O(tSharedCalcArray(tSharedCalcIdx),1,tSharedCalcData)
		}
		Merge tCalcMbrs = tSharedCalcMbrs
		// -DTB268
		
		Merge tCalcMbrs = pLocalCalcMembers

		// first test for calc mbrs within their own dimension
		If ((tDim'="")&&$D(tCalcMbrs(tDim))&&'$D($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim))) {
			Set pDimNo = -1
			Set pHierNo = 0
			Set pLevelNo = 0
			Quit
		}

		// resolve missing terms
		If (('pStrict) && (tDim'="")) {
			If ((tHier="")||('$D($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier)))) {
				Set tHier = ..%GetDefaultHierarchy(pCubeName,tDim)
				If (tHier'="") {
					// slide items down
					Set n = $O(pSpecInfo(""),-1)
					While ((n'="")&&(n>1)) {
						Set pSpecInfo(n+1) = pSpecInfo(n)
						Set n = $O(pSpecInfo(n),-1)
					}
					Set pSpecInfo(2) = tHier
					Set tHier = $$$UPPER(tHier)
					Set tLevel = $$$UPPER($G(pSpecInfo(3)))
				}
			}

			If ((tHier'="")&&((tLevel="")||('$D($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier,tLevel))))) {
				Set tLevel = ..%GetDefaultLevel(pCubeName,tDim,tHier)
				If (tLevel'="") {
					// slide items down
					Set n = $O(pSpecInfo(""),-1)
					While ((n'="")&&(n>2)) {
						Set pSpecInfo(n+1) = pSpecInfo(n)
						Set n = $O(pSpecInfo(n),-1)
					}
					Set pSpecInfo(3) = tLevel
					Set tLevel = $$$UPPER(tLevel)
				}
			}
		}

		// look at cube metadata
		If (tLevel '= "") {
			Set tMbr = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier,tLevel))
		}
		ElseIf (tHier '= "") {
			Set tMbr = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier))
		}
		ElseIf (tDim '= "") {
			Set tMbr = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim))
		}
		Else {
			Quit
		}

		Set pDimNo = $LG(tMbr,1)
		Set pHierNo = $LG(tMbr,2)
		Set pLevelNo = $LG(tMbr,3)
		If (tIsTop) {
			//Set pLevelNo = pLevelNo + 1 // !!!check for ALL
		}

		If ((pDimNo="")||(pHierNo="")||(pLevelNo="")) {		// DTB641 - fix typo
			// test again for calc member within dimension
			If ((tDim'="")&&$D(tCalcMbrs(tDim))) {
				Set pDimNo = -1
				Set pHierNo = 0
				Set pLevelNo = 0
				Quit
			}

			Set tSC = $$$ERROR($$$GeneralError,"%GetDimensionInfo: Invalid Member spec: " _ pCubeName _ ":" _ pSpec)
			Quit
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetDimensionSpec">
<Description>
Given the dimension,hierarchy, and level number for a dimension
within the specified cube, return it's specification string.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pSpec:%String,pDimNo:%Integer,pHierNo:%Integer=0,pLevelNo:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCube = $$$UPPER(pCubeName)
		Set tIsTop = 0

		Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",pDimNo,pHierNo,pLevelNo))

		Set tDim = $LG(tDimInfo,2)
		Set tHier = $LG(tDimInfo,3)
		Set tLevel = $LG(tDimInfo,4)

		Set pSpec = "["_tDim _"]"
		Set:tHier'="" pSpec = pSpec _ ".["_tHier _"]"
		Set:tLevel'="" pSpec = pSpec _ ".["_tLevel _"]"
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCubeMeasures">
<Description><![CDATA[
Return the measures within the given cube as an array of form:<br/>
pMeasures(n) = $LB(name,caption,type,hidden,factName)<br/>
If <var>pSkipCalculated</var> is true, then do not include calculated measures.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,&pMeasures,pSkipCalculated:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pMeasures
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit
		
		Set tCountName = $$$UPPER(..%GetCountName(pCube,.tSC))
		If $$$ISERR(tSC) Quit

		Set tCount = 0
		Set tMsr = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs","MEASURES",""))
		While (tMsr '= "") {
			Set tMsrNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs","MEASURES",tMsr))
			Set tDimNo = $LG(tMsrNode,1)
			Set tMsrNo = $LG(tMsrNode,2)

			Set tMsrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tMsrNo,0))
			Set tMsrName = $LG(tMsrInfo,3)
			Set tMsrType = $LG(tMsrInfo,8)
			Set tMsrHidden = $LG(tMsrInfo,11)
			Set tMsrCaption = $zobjclassmethod(tClassName,"%GetMemberCaption","MEASURES",tMsr)

			// JMD900: pick up fact name
			Set tMsrIndexNo = $LG(tMsrInfo,5)
			Set tMsrFactName = ""
			If (tMsrIndexNo'="") {
				Set tMsrFactName = $G($$$DeepSeeMetaGLVN("cubes",tCube,"msr#",tMsrIndexNo))
			}

			If (tMsrName = tCountName) {
				Set tMsrCaption = ..%GetCountCaption(tCube,.tSC)
				If $$$ISERR(tSC) Quit
			}

			Set tCount = tCount + 1
			Set pMeasures(tCount) = $LB(tMsrName,tMsrCaption,tMsrType,tMsrHidden,tMsrFactName)

			Set tMsr = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs","MEASURES",tMsr))
		}
		If $$$ISERR(tSC) Quit

		If ('+pSkipCalculated) {
			// calculated measures
			// +DTB587 - Collect cube- and user-defined calculated measures 
			Merge tCalcMbrs = $$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs")
			
			Set tSC = ##class(%DeepSee.Utils).%GetSharedCalcMembers(tCube,.tSharedCalcMbrs)
			If $$$ISERR(tSC) Quit
			
			Set tSharedCalcIdx = $O(tSharedCalcMbrs(""),1,tSharedCalcData)
			While tSharedCalcIdx'="" {
				Set tSharedCalcDimKey = $$$UPPER($LG(tSharedCalcData,1))
				Set tSharedCalcKey = $$$UPPER($LG(tSharedCalcData,2))
				Set tSC = ##class(%DeepSee.Utils).%GetSharedCalcMemberInfo(tCube,tSharedCalcDimKey,tSharedCalcKey,.tMbrInfo)
				If $D(tMbrInfo) {
					// $LB(dimension,name,expression,format,hidden)
					Set tSharedCalcMbrs(tSharedCalcDimKey,tSharedCalcKey) = $LB(tMbrInfo("dimension"),tMbrInfo("name"),tMbrInfo("expression"),tMbrInfo("format"))		// DTB461 - Remove solveOrder in the hidden position
				}
				
				Set tSharedCalcIdx = $O(tSharedCalcMbrs(tSharedCalcIdx),1,tSharedCalcData)
			}
			
			Merge tCalcMbrs = tSharedCalcMbrs
			// -DTB587
			
			Set tDim = $O(tCalcMbrs(""))
			While (tDim '= "") {
				If (tDim = "MEASURES") {
					Set tMbr = $O(tCalcMbrs(tDim,""),1,tInfo)
					While (tMbr '= "") {
						// PFS066 - Use tMbrName to get tMbrCaption from %GetMemberCaption, use tMbrName if no caption specified
						Set tMbrName = $LG(tInfo,2)
						Set tMbrCaption = $zobjclassmethod(tClassName,"%GetMemberCaption","Measures",tMbrName)
						Set:tMbrCaption="" tMbrCaption = tMbrName
						Set tMbrType = "numeric"

						Set tCount = tCount + 1
						// PFS066 - Name should be first list item in output, not caption
						Set pMeasures(tCount) = $LB(tMbrName,tMbrCaption,tMbrType)
						Set tMbr = $O(tCalcMbrs(tDim,tMbr),1,tInfo)
					}
				}
				Set tDim = $O(tCalcMbrs(tDim))
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetNamedFilters">
<Description><![CDATA[
Return all named filters for a given cube as an array of form:<br/>
pFilters(n) = $LB(name,tooltip,spec,cube)<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,&pFilters,pUseCubeVersion:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		
		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336
		
		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) {
			// JMD932: fail without error
			Set tSC = $$$OK
			Quit
		}

		// get any named filters from our base cube
		Set tBaseCube = ..%GetBaseCube(tCube)
		If (tBaseCube'="") {
			Set tSC = ..%GetNamedFilters(tBaseCube,.tBaseFilters)
			If $$$ISERR(tSC) Quit
			Merge pFilters = tBaseFilters
		}

		If ('$D($$$DeepSeeFiltersGLVN(tCube))) Quit

		Set tFilter = $O($$$DeepSeeFiltersGLVN(tCube,""))
		While (tFilter '= "") {
			Set tFilterNode = $G($$$DeepSeeFiltersGLVN(tCube,tFilter))
			Set tFilterName = $LG(tFilterNode,1)
			Set tFilterTip = $LG(tFilterNode,2)
			Set tFilterSpec = $LG(tFilterNode,3)
			Set pFilters($I(pFilters)) = $LB(tFilterName,tFilterTip,tFilterSpec,tCube)
			Set tFilter = $O($$$DeepSeeFiltersGLVN(tCube,tFilter))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%DeleteNamedFilter">
<Description><![CDATA[
Delete the given named filter for the given cube.
If <var>pFilterName</var> is "*", then delete all named filters for the cube.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,pFilterName:%String="",pUseCubeVersion:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pFilterName="") Quit
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		
		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336

		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		If (pFilterName="*") {
			Kill $$$DeepSeeFiltersGLVN(tCube)
		}
		Else {
			Kill $$$DeepSeeFiltersGLVN(tCube,$$$UPPER(pFilterName))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetNamedFilterInfo">
<Description><![CDATA[
Return details on the given named filter in the array <var>pInfo</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,pFilterName:%String,*pInfo,pUseCubeVersion:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pInfo
		If (pFilterName="") Quit
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		
		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336

		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		Set tInfo = $G($$$DeepSeeFiltersGLVN(tCube,$$$UPPER(pFilterName)))
		If (tInfo'="") {
			Set pInfo("name") = $LG(tInfo,1)
			Set pInfo("tooltip") = $LG(tInfo,2)
			Set pInfo("spec") = $LG(tInfo,3)
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%SaveNamedFilter">
<Description>
Save a named filter.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,pFilterName:%String,pTooltip:%String,pSpec:%String,pUseCubeVersion:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pFilterName="") Quit
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit

		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336

		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		// save filter
		Set $$$DeepSeeFiltersGLVN(tCube,$$$UPPER(pFilterName)) = $LB(pFilterName,pTooltip,pSpec)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetSharedCalcMembers">
<Description><![CDATA[
Return all shared calculated members for a given cube as an array of form:<br/>
pCalcMbrs(n) = $LB(name,tooltip,dimension,cube)<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,&pCalcMbrs,pUseCubeVersion:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added byDTB268
	Kill pCalcMbrs
	Set tSC = $$$OK
	Try {
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit

		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336

		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) {
			// JMD932: fail without error
			Set tSC = $$$OK
			Quit
		}

		// get any shared calculated members from our base cube
		Set tBaseCube = ..%GetBaseCube(tCube)
		If (tBaseCube'="") {
			Set tSC = ..%GetSharedCalcMembers(tBaseCube,.tBaseMembers)
			If $$$ISERR(tSC) Quit
			Merge pCalcMbrs = tBaseMemebrs
		}

		If ('$D($$$DeepSeeSharedCalcGLVN(tCube))) Quit

		Set tSharedDim = $O($$$DeepSeeSharedCalcGLVN(tCube,""))
		While (tSharedDim'="") {
			Set tSharedCalc = $O($$$DeepSeeSharedCalcGLVN(tCube,tSharedDim,""),1,tCalcNode)
			While (tSharedCalc '= "") {
				Set tCalcDim = $LG(tCalcNode,1)
				Set tCalcName = $LG(tCalcNode,2)
				Set pCalcMbrs($I(pCalcMbrs)) = $LB(tCalcDim,tCalcName,"["_tCalcDim_"].["_tCalcName_"]",tCube)
				Set tSharedCalc = $O($$$DeepSeeSharedCalcGLVN(tCube,tSharedDim,tSharedCalc),1,tCalcNode)
			}
			Set tSharedDim = $O($$$DeepSeeSharedCalcGLVN(tCube,tSharedDim))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%DeleteSharedCalcMember">
<Description><![CDATA[
Delete the given shared calculated member for the given cube.
If <var>pCalcMbrName</var> is "*", then delete all shared calculated members for the cube.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String="",pCalcMbrName:%String="",pDimension:%String="",pUseCubeVersion:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added byDTB268
	Set tSC = $$$OK
	Try {
		If (pCalcMbrName="") Quit
		If (pDimension="")&&(pCalcMbrName'="*") Quit
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit

		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336

		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		If (pCalcMbrName="*") {
			Kill $$$DeepSeeSharedCalcGLVN(tCube)
		}
		Else {
			Kill $$$DeepSeeSharedCalcGLVN(tCube,$$$UPPER(pDimension),$$$UPPER(pCalcMbrName))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetSharedCalcMemberInfo">
<Description><![CDATA[
Return details on the given shared calculated member in the array <var>pInfo</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,pDimension:%String="",pCalcMbrName:%String="",*pInfo,pUseCubeVersion:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added byDTB268
	Set tSC = $$$OK
	Try {
		Kill pInfo
		If (pCalcMbrName="") Quit
		If (pDimension="") Quit
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit

		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336

		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		// $LB(pDimension,pCalcMbrName,pValueExpression,pFormatString,pSolveOrder)
		Set tInfo = $G($$$DeepSeeSharedCalcGLVN(tCube,$$$UPPER(pDimension),$$$UPPER(pCalcMbrName)))
		If (tInfo'="") {
			Set pInfo("dimension") = $LG(tInfo,1)
			Set pInfo("name") = $LG(tInfo,2)
			Set pInfo("expression") = $LG(tInfo,3)
			Set pInfo("format") = $LG(tInfo,4)
			Set pInfo("solveOrder") = $LG(tInfo,5)
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%SaveSharedCalcMember">
<Description>
Store the details of a calulated member in the shared location.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String="",pCalcMbrName:%String="",pDimension="",pValueExpression="",pFormatString="",pSolveOrder,pUseCubeVersion:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added byDTB268
	Set tSC = $$$OK
	If (pCalcMbrName="") {
		Set tSC = $$$ERROR($$$GeneralError,"Shared calculated member must define a name")
		Quit
	}
	If (pDimension="") {
		Set tSC = $$$ERROR($$$GeneralError,"Shared calculated member must define a dimension")
		Quit
	}
		
	Try {
		Set tCube = $$$UPPER(pCube)
		If (tCube="") {
			Set tSC = $$$ERROR($$$GeneralError,"No cube defined for shared calculated member")
			Quit
		}
		
		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336
		
		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit
		
		// This matches the format of calc members in 
		Set $$$DeepSeeSharedCalcGLVN(tCube,$$$UPPER(pDimension),$$$UPPER(pCalcMbrName)) = $LB(pDimension,pCalcMbrName,pValueExpression,pFormatString,pSolveOrder)
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetPivotVariables">
<Description><![CDATA[
Return all pivot variables for a given cube as an array of form:<br/>
pVariables(n) = $LB(name,caption,defValue,context,desc)<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,&pVariables,pUseCubeVersion:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		
		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336

		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) {
			// fail without error
			Set tSC = $$$OK
			Quit
		}

		// get any variables from our base cube
		Set tBaseCube = ..%GetBaseCube(tCube)
		If (tBaseCube'="") {
			Set tSC = ..%GetPivotVariables(tBaseCube,.tBaseVariables)
			If $$$ISERR(tSC) Quit
			Merge pVariables = tBaseVariables
		}

		If ('$D($$$DeepSeeVariablesGLVN(tCube))) Quit

		Set tVariable = $O($$$DeepSeeVariablesGLVN(tCube,""))
		While (tVariable '= "") {
			Set tVariableNode = $G($$$DeepSeeVariablesGLVN(tCube,tVariable))
			Set tVariableName = $LG(tVariableNode,1)
			Set tVariableCaption = $LG(tVariableNode,2)
			Set:tVariableCaption="" tVariableCaption = tVariableName
			Set tVariableDesc = $LG(tVariableNode,3)
			Set tVariableDefValue = $LG(tVariableNode,4)
			Set tVariableContext = $LG(tVariableNode,5)
			Set pVariables($I(pVariables)) = $LB(tVariableName,tVariableCaption,tVariableDefValue,tVariableContext,tVariableDesc)
			Set tVariable = $O($$$DeepSeeVariablesGLVN(tCube,tVariable))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%DeletePivotVariable">
<Description><![CDATA[
Delete the given pivot variable for the given cube.
If <var>pVariableName</var> is "*", then delete all pivot variables for the cube.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,pVariableName:%String="",pUseCubeVersion:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pVariableName="") Quit
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit

		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336

		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		If (pVariableName="*") {
			Kill $$$DeepSeeVariablesGLVN(tCube)
		}
		Else {
			Kill $$$DeepSeeVariablesGLVN(tCube,$$$UPPER(pVariableName))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetPivotVariableInfo">
<Description><![CDATA[
Return details on the given pivot variable in the array <var>pInfo</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,pVariableName:%String,*pInfo,pUseCubeVersion:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pInfo
		If (pVariableName="") Quit
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		
		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336

		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		Set tInfo = $G($$$DeepSeeVariablesGLVN(tCube,$$$UPPER(pVariableName)))
		If (tInfo'="") {
			Set pInfo("name") = $LG(tInfo,1)
			Set pInfo("displayName") = $LG(tInfo,2)
			Set pInfo("description") = $LG(tInfo,3)
			Set pInfo("defaultValue") = $LG(tInfo,4)
			Set pInfo("context") = $LG(tInfo,5)
			Set pInfo("type") = $LG(tInfo,6)
			Set pInfo("sourceType") = $LG(tInfo,7)
			Set pInfo("sourceName") = $LG(tInfo,8)
			Set pInfo("valueList") = $LG(tInfo,9)
			Set pInfo("displayList") = $LG(tInfo,10)
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%SavePivotVariable">
<Description><![CDATA[
Save a pivot variable.
The variable's attributes are in the array <var>pInfo</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,pVariableName:%String,&pInfo:%String,pUseCubeVersion:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pVariableName="") Quit
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit

		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336

		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		// save variable
		Set $$$DeepSeeVariablesGLVN(tCube,$$$UPPER(pVariableName)) = $LB(pVariableName,
																	$G(pInfo("displayName")),
																	$G(pInfo("description")),
																	$G(pInfo("defaultValue")),
																	$G(pInfo("context")),
																	$G(pInfo("type")),
																	$G(pInfo("sourceType")),
																	$G(pInfo("sourceName")),
																	$G(pInfo("valueList")),
																	$G(pInfo("displayList"))
																	)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetPivotVariableValues">
<Description><![CDATA[
Find all values for a given pivot variable.<br/>
Return pValues(n) = $LB(text,spec)]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,pVariableName:%String,*pValues,pUseCubeVersion:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pVariableName="") Quit
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit

		Set:'pUseCubeVersion tCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(pCube)		// DTB336

		// check permission
		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		Set tInfo = $G($$$DeepSeeVariablesGLVN(tCube,$$$UPPER(pVariableName)))
		If (tInfo'="") {
			Set tSourceType = $LG(tInfo,7)
			Set tSourceName = $LG(tInfo,8)

			If (tSourceType="kpi") {
				// get "Value" column from KPI
				Set tKPIName = $P(tSourceName,".",1)
				Set tKPIClass = ##class(%DeepSee.Utils).%GetKPIClass(tKPIName)

				Set tSC = $classmethod(tKPIClass,"%GetKPIValueArray",tKPIName,.tValues,$LB("%series","Value"))
				If $$$ISERR(tSC) Quit

				Set k = $O(tValues(""))
				While (k'="") {
					Set pValues($I(pValues)) = $LB($LG(tValues(k),1),$LG(tValues(k),2))
					Set k = $O(tValues(k))
				}
				If $$$ISERR(tSC) Quit
			}
			ElseIf (tSourceType="termlist") {
				Set tTermList = $P(tSourceName,".",1)
				Set tSC = ##class(%DeepSee.TermList).%GetValueArray(tTermList,.tArray)
				If $$$ISERR(tSC) Quit

				Set k = $O(tArray(""))
				While (k'="") {
					Set pValues($I(pValues)) = $LB(k,tArray(k))
					Set k = $O(tArray(k))
				}
			}
			// + WAL157 -- we need to return values for manual pivot variables too
			ElseIf (tSourceType="manual") {
				// DTB569 - Replace escaped commas with a special character
				Set tValueList = $Replace($LG(tInfo,9),"\,",$C(1))
				Set tCaptionList = $Replace($LG(tInfo,10),"\,",$C(1))
				
				For i=1:1:$L(tValueList,",") {
					Set tValue = $P(tValueList,",",i)
					Set tCaption = $P(tCaptionList,",",i)
					Set tCaption = $S(tCaption'="":tCaption,1:tValue)
					
					// DTB569 - Replace escaped commas in the individual items
					Set tValue = $Replace(tValue,$C(1),",")
					Set tCaption = $Replace(tCaption,$C(1),",")
					
					Set pValues(i) = $LB(tCaption,tValue)		// DTB525 - Caption comes first!
				}
			}
			// - WAL157
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCubeSearchableMeasures">
<Description><![CDATA[
Return the searchable measures within the given cube as an array of form:<br/>
pMeasures(n) = $LB(name,caption,type)]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,&pMeasures]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pMeasures
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		Set tCount = 0
		Set tMsr = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs","MEASURES",""))
		While (tMsr '= "") {
			Set tMsrNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs","MEASURES",tMsr))
			Set tDimNo = $LG(tMsrNode,1)
			Set tMsrNo = $LG(tMsrNode,2)

			Set tMsrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tMsrNo,0))
			Set tMsrName = $LG(tMsrInfo,3)
			Set tMsrType = $LG(tMsrInfo,8)
			Set tMsrSearch = +$LG(tMsrInfo,13)
			If (tMsrSearch) {
				Set tMsrCaption = $zobjclassmethod(tClassName,"%GetMemberCaption","MEASURES",tMsr)
				Set tCount = tCount + 1
				Set pMeasures(tCount) = $LB(tMsrName,tMsrCaption,tMsrType)
			}
			Set tMsr = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs","MEASURES",tMsr))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetDimensionCaption">
<Description>
Return the localized display name for a given element within the given cube.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,pDimNo:%Integer,pHierNo:%Integer,pLevelNo:%Integer,&pCaption:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pCaption = ""

		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		If ((pDimNo="")||(pHierNo="")||(pLevelNo="")) Quit

		Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",pDimNo,pHierNo,pLevelNo))
		Set tDimName = $LG(tInfo,2)
		Set tHierName = $LG(tInfo,3)
		Set tLevelName = $LG(tInfo,4)

		Set pCaption = $zobjclassmethod(tClassName,"%GetMemberCaption",$$$UPPER(tDimName),$$$UPPER(tHierName),$$$UPPER(tLevelName))
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetMemberCaption">
<Description>
Return the localized display name for a given element within the given cube given a dimension,
hierarchy, and level name.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,pDimName:%String,pHierName:%String="",pLevelName:%String="",&pCaption:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// This returns the level caption, not a member caption
	Set tSC = $$$OK
	Try {
		Set pCaption = ""

		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		Set pCaption = $zobjclassmethod(tClassName,"%GetMemberCaption",$$$UPPER(pDimName),$$$UPPER(pHierName),$$$UPPER(pLevelName))

		If (pCaption="")&&(pHierName="")&&(pLevelName="") {
			// DTB454 - Test to see if this is a shared calculated member. 
			// This is not generated during the class compile!
			Set tSC = ##class(%DeepSee.Utils).%GetSharedCalcMembers(pCube,.tSharedCalcMbrs)
			If $$$ISERR(tSC) Quit
			
			Set tSharedCalcIdx = $O(tSharedCalcMbrs(""),1,tSharedCalcInfo)
			While (tSharedCalcIdx'="") {
				Set tDimName = $LG(tSharedCalcInfo,1)
				If $$$UPPER(tDimName)=$$$UPPER(pDimName) {
					Set pCaption = tDimName
					Set tSharedCalcIdx=""
				}
				Else {
					Set tSharedCalcIdx = $O(tSharedCalcMbrs(tSharedCalcIdx),1,tSharedCalcInfo)
				}
			}

		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetMemberDescription">
<Description>
Return the localized description for a given element within the given cube given a dimension,
hierarchy, and level name.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,pDimName:%String,pHierName:%String="",pLevelName:%String="",&pDescription:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// This method added by JSL4475
	Set tSC = $$$OK
	Try {
		Set pDescription = ""

		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		Set pDescription = $zobjclassmethod(tClassName,"%GetMemberDescription",$$$UPPER(pDimName),$$$UPPER(pHierName),$$$UPPER(pLevelName))
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%MemberHasChildren">
<Description>
Test if a given element within the given cube has child levels.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,pDimNo:%Integer,pHierNo:%Integer,pLevelNo:%Integer,&pHasChildren:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pHasChildren = 0

		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		Set tNextLevel = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",pDimNo,pHierNo,pLevelNo))
		If (tNextLevel'="") {
			Set pHasChildren = 1
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetMeasureFact">
<Description>
Given a cube and a measure name, i.e. "Patient Count", return the fact table column name for that measured.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,pMeasureName:%String,*pMeasureFact:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by WAL190
	Set tSC = $$$OK
	Try {
		Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(pCube,"[Measures].["_pMeasureName_"]",.tDNO,.tHNO,.tLNO)
		If $$$ISERR(tSC) Quit
		
		Set tSC = ##class(%DeepSee.Utils).%GetDimensionFact(pCube,tDNO,tHNO,0,.pMeasureFact)
		If $$$ISERR(tSC) Quit
	}
	Catch (ex) {
		Set tSC = ex.AsStatus()	
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetDimensionFact">
<Description>
Return the fact name associated with a given element within the given cube.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,pDimNo:%Integer,pHierNo:%Integer,pLevelNo:%Integer,&pFactName:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pFactName = ""
		If ((pDimNo="")||(pHierNo="")||(pLevelNo="")) {
			Quit
		}

		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",pDimNo,pHierNo,pLevelNo))
		Set tType = $LG(tInfo,1)
		If (tType="m") || (tType="l") {
			// find fact for measure
			Set tMsr = $LG(tInfo,5)
			Set:tMsr'="" pFactName = $G($$$DeepSeeMetaGLVN("cubes",tCube,$case(tType,"m":"msr#","l":"fact#"),tMsr))
			// check for alias
			Set:pFactName'="" tAlias = $G($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",pFactName,"alias"))
			Set:$G(tAlias)'="" pFactName=tAlias
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetDimensionProperties">
<Description><![CDATA[
Return the properties of a given level within the given cube as an array of form:<br/>
pProperties(n) = $LB(name,caption,type)]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,pDimName:%String,pHierName:%String,pLevelName:%String,&pProperties]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pMeasures
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		Set tClassName = ..%GetCubeClass(pCube,.tSC)
		If $$$ISERR(tSC) Quit

		Set tLevelNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",$$$UPPER(pDimName),$$$UPPER(pHierName),$$$UPPER(pLevelName)))
		If (tLevelNode="") {
			Quit
		}

		Set tDimNo = $LG(tLevelNode,1)
		Set tHierNo = $LG(tLevelNode,2)
		Set tLevelNo = $LG(tLevelNode,3)

		Set tCount = 0
		Set tProp = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo,"prop",""))
		While (tProp '= "") {
			Set tPropInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo,"prop",tProp))
			Set tPropName = $LG(tPropInfo,4)
			Set tPropType = $LG(tPropInfo,5)
			Set tPropCaption = $zobjclassmethod(tClassName,"%GetMemberCaption",$$$UPPER(pDimName),$$$UPPER(pHierName),$$$UPPER(pLevelName),$$$UPPER(tProp))

			Set tCount = tCount + 1
			Set pProperties(tCount) = $LB(tPropName,tPropCaption,tPropType)
			Set tProp = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo,"prop",tProp))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCubeLevels">
<Description><![CDATA[
Return a list of all levels within the given cube.<br/>
On return <var>pLevels</var> contains a list of all levels of the form:<br/>
pLevels(n) = $LB(type,dimName,hierName,levelName)<br/>
Type is "l" for level, "m" for measure (in which case there is no levelName) or
"r" for relationship (in which case there is only a dimension name).<br/>
If <var>pSkipAll</var> is true, do not return any "all" levels.<br/>
If <var>pSkipComputed</var> is true, do not return any levels for computed dimensions.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,&pLevels,pSkipAll:%Boolean=0,pSkipComputed:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		// walk over dimension list
		Set tDim = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",""))
		While (tDim '= "") {
			Set tDimNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim))
			Set tDimNo = $LG(tDimNode,1)
			If (tDimNo'="") {
				Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,0,0))
				Set tDimName = $LG(tDimInfo,2)
				Set tIsRelation = ''$D($$$DeepSeeMetaGLVN("cubes",tCube,"relations",$$$UPPER(tDimName)))

				If (tIsRelation) {
					Set tRelatedCube = $G($$$DeepSeeMetaGLVN("cubes",tCube,"relations",$$$UPPER(tDimName),"relatedCube"))
					Set pLevels($I(tIndex)) = $LB("r",tDimName)
				}
				ElseIf (tDim="MEASURES") {
					Set tHier = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,""))
					While (tHier '= "") {
						Set tHierNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier))
						Set tHierNo = $LG(tHierNode,2)
						Set tHierInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,0))
						Set tHierName = $LG(tHierInfo,3)
						Set tHidden = +$LG(tHierInfo,11)
						If ('tHidden) {
							Set pLevels($I(tIndex)) = $LB("m",tDimName,tHierName)
						}
						Set tHier = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier))
					}
				}
				ElseIf (tDim'="MEASURES") {
					Set tHier = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,""))
					While (tHier '= "") {
						Set tHierNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier))
						Set tHierNo = $LG(tHierNode,2)
						If (tHierNo '= "a") {
							Set tHierInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,0))
							Set tHierLevelInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,$LG(tHierNode,3)))
							Set tHierType = $LG(tHierLevelInfo,1) // actual level associated with hierarchy name
							Set tHierName = $LG(tHierInfo,3)
							Set tHidden = +$LG(tHierInfo,11)
							If (tHierType '= "all") {
								Set tLevel = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier,""))
								While (tLevel '= "") {
									Set tLevelNode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier,tLevel))
									Set tLevelNo = $LG(tLevelNode,3)
									Set tLevelInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
									Set tLevelType = $LG(tLevelInfo,1)
									Set tLevelName = $LG(tLevelInfo,4)
									Set tLevelClass = $LG(tLevelInfo,6)
									If (('pSkipAll)||(tLevelType'="all")) {
										If (('pSkipComputed)||'$classmethod(tLevelClass,"%IsA","%DeepSee.ComputedDimension.Base")) {
											If ($$$UPPER(tLevelName)'="%SEARCH") {
												Set pLevels($I(tIndex)) = $LB("l",tDimName,tHierName,tLevelName)
											}
										}
									}
									Set tLevel = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier,tLevel))
								}
								If $$$ISERR(tSC) Quit
							}
						}
						Set tHier = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim,tHier))
					}
					If $$$ISERR(tSC) Quit
				} // is relation
			} // dimno

			Set tDim = $O($$$DeepSeeMetaGLVN("cubes",tCube,"mbrs",tDim))
			If $$$ISERR(tSC) Quit
		}
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCubeListings">
<Description><![CDATA[
Return an array of all (non-default) listings for the given cube.
The array is of the form:<br/>
pListings(name) = $LB(caption,fields,order,type,source,edit)<br/>
If there are no listings, then <var>pListings</var> will be undefined.<br/>
If <var>pType</var> is defined, then only return listings of the given type.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,*pListings:%List,pType:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pListings
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		Set tCubeClass = ..%GetCubeClass(tCube,.tSC)
		If $$$ISERR(tSC) Quit

		// walk over listings in cube metatdata
		Set tListing = $O($$$DeepSeeMetaGLVN("cubes",tCube,"listing",""))
		While (tListing '= "") {
			Set tFields = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"fieldList"))
			Set tOrder = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"orderBy"))
			Set tType = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"listingType"),"table")
			Set tResource = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"resource"))

			// JMD989: use (localized) display name for caption
			Set tCaption = $classmethod(tCubeClass,"%GetListingCaption",tListing) 
			Set:tCaption="" tCaption=tListing
			Set tDescription=""
			try {
				Set tDescription = $classmethod(tCubeClass,"%GetListingDescription",tListing)  // JSL4477
			} catch {}
			If ((pType="")||(pType=tType)) {
				If ((tResource="")||($System.Security.Check(tResource,"USE"))) {
					Set pListings(tListing) = $s(tDescription'="":$LB(tCaption,tFields,tOrder,tType,"cube",0, tDescription),1:$LB(tCaption,tFields,tOrder,tType,"cube",0))	// Add source and edit rights to the $LB JSL4477 - add tDescription in 7th place
				}
			}
			Set tListing = $O($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing))
		}

		// +DTB082 - Check for the existence of any listings defined via listing groups.
		// If the current cube or subject area is set to prevent use of listing groups, 
		// do not load from the alternative source.
		Set tListing = $O($$$DeepSeeListingGroupGLVN("cubes",tCube,"listing",""))
		Set tListingGroupsDisabled = $G($$$DeepSeeMetaGLVN("cubes",tCube,"disableListingGroups"),0)
		
		While (tListing '= "")&&'tListingGroupsDisabled {
			Set tFields = $G($$$DeepSeeListingGroupGLVN("cubes",tCube,"listing",tListing,"fieldList"))
			Set tOrder = $G($$$DeepSeeListingGroupGLVN("cubes",tCube,"listing",tListing,"orderBy"))
			Set tType = $G($$$DeepSeeListingGroupGLVN("cubes",tCube,"listing",tListing,"listingType"),"table")
			Set tResource = $G($$$DeepSeeListingGroupGLVN("cubes",tCube,"listing",tListing,"resource"))

			// JMD989: use (localized) display name for caption
			Set tListGroup = $G($$$DeepSeeListingGroupGLVN("cubes",tCube,"listing",tListing,"group"))
			Set:tListGroup'="" tGroupClass = $G($$$DeepSeeListingGroupGLVN("groups",tListGroup))
			Set:tGroupClass'="" tCaption = $classmethod(tGroupClass,"%GetListingCaption",tListing) 
			Set:tCaption="" tCaption=tListing
			Set tDescription=""
			try {
				Set tDescription = $classmethod(tGroupClass,"%GetListingDescription",tListing)  // JSL4477 // DTB139 - call method from group class
			} catch {}
			If ((pType="")||(pType=tType)) {
				If ((tResource="")||($System.Security.Check(tResource,"USE"))) {
					// DTB084 - communicate listing group edit rights
					Set tEditRights = $S(tResource'="":$System.Security.Check(tResource,"WRITE"),1:1)
					Set pListings(tListing) = $s(tDescription'="":$LB(tCaption,tFields,tOrder,tType,"listingGroup",tEditRights,tDescription),1:$LB(tCaption,tFields,tOrder,tType,"listingGroup",tEditRights)) // JSL4477 - add tDescription in 7th place
				}
			}
			Set tListing = $O($$$DeepSeeListingGroupGLVN("cubes",tCube,"listing",tListing))
		}
		// -DTB082
 
		// are there listing fields?
		Kill tList
		Set tSC = ##class(%DeepSee.Utils).%GetCubeListingFields(tCube,.tList)
		If $$$ISERR(tSC) Quit
		If $D(tList) {
			Set pListings("$$$CUSTOM") = $LB($$$Text("Custom Listing","%DeepSee"))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCubeListingFields">
<Description><![CDATA[
Return an array of all defined listing fields for the given cube.
The array is of the form:<br/>
pListings(name) = $LB(caption,expression)<br/>
If there are no listing fields, then <var>pFields</var> will be undefined.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,*pFields:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pFields
		Set tCube = $$$UPPER(pCube)
		If (tCube="") Quit
		If ('$D($$$DeepSeeMetaGLVN("cubes",tCube))) Quit

		Set tCubeClass = ..%GetCubeClass(tCube,.tSC)
		If $$$ISERR(tSC) Quit

		// walk over fields
		Set tField = $O($$$DeepSeeMetaGLVN("cubes",tCube,"listingFields",""))

		While (tField '= "") {
			Set tExpr = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listingFields",tField,"fieldExpression"))
			Set tResource = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listingFields",tField,"resource"))

			// use (localized) display name for caption
			Set tCaption = $classmethod(tCubeClass,"%GetListingFieldCaption",tField) 
			Set tDescription=""
			try {
				Set tDescription = $classmethod(tCubeClass,"%GetListingFieldDescription",tField) // JSL4477
			} catch {}
			Set:tCaption="" tCaption=tField
			If ((tResource="")||($System.Security.Check(tResource,"USE"))) {
				Set pFields(tField) = $s(tDescription'="":$LB(tCaption,tExpr,tDescription),1:$LB(tCaption,tExpr)) // JSL4477 tDescription
			}
			Set tField = $O($$$DeepSeeMetaGLVN("cubes",tCube,"listingFields",tField))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetDimensionMembers">
<Description><![CDATA[
Return a list of members of the specified dimension
for the specified cube.<br/>
<var>pCubeName</var> is the name of the cube.<br/>
<var>pSpec</var> specifies the dimension in the form:
"Dim.Hier.Level".<br/>
<var>pContext</var> is used to indicate a particular calling context. This affects the behavior when trimming the list of members using related filters.<br/>
The list is returned via <var>pMembers</var>. This takes the form:<br/>
pMembers(n) = $LB(value,name,memberId,memberKey,[description])<br/>
Return the member class as a convenience.<br/>
If <var>pRelatedFilters</var> is provided, it is an array of other filter values to use to
restrict the set of members. It takes the form:<br/>
pRelatedFilters(spec) = key<br/>
If <var>pCalcMode</var> is 1, then only return calculated members.
If <var>pCalcMode</var> is -1, then only return non-calculated members.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCubeName:%String,pSpec:%String,pContext:%String="",*pMembers,pMaxMembers:%Integer=100,*pMemberClass:%String,&pRelatedFilters,pCalcMode:%Integer=0,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// JMD910
		Kill pMembers

		Set n = 0
		// +PFS022 - Use active version unless version is specified
		Set tActiveVersionNo = ##class(%DeepSee.CubeVersion.Utils).%GetActiveCubeVersion(pCubeName)
		If (tActiveVersionNo'="") {
			Set pCubeName = ##class(%DeepSee.CubeVersion.Utils).%GetVersionedCubeName(pCubeName,tActiveVersionNo)
		}
		// -PFS022
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		Set tMaxMembers = pMaxMembers // Maximum number of members to return

		Set tCubeClass = ..%GetCubeClass(pCubeName,.tSC)
		If $$$ISERR(tSC) Quit

		If (pSpec="") {
			// nothing to do
			Quit
		}

		// Get info on the specified dimension
		Kill tRelationName
		Kill tRelationSpec
		// JMD1397: Use tCubeIndex
		Set tSC = ..%GetDimensionInfo(tCubeIndex,pSpec,.tDimNo,.tHierNo,.tLevelNo,.tRelationName,.tRelationSpec)
		If $$$ISERR(tSC) Quit

		If (tRelationName'="") {
			// +DTB164 - Pre-process the related filters to assist in passing context information to a related cube
			Set s = $O(pRelatedFilters("")) 
			While s'="" {
				If pRelatedFilters(s) = "" {
					// This is more than a spec/key pair. Attempt to break it into an array of individual specs (heterogeneous %OR)
					Set TestSC = ..%FilterSpecToArray(tCubeIndex,s,.pRelatedFilters)
				}
				Set s = $O(pRelatedFilters(s))
			}

			// Look at the current subject area's filterspec to see if it contains this relationship. 
			// If it does, attempt to extract those elements for context.
			Set tRelatedFilterSpec = $classmethod(tCubeClass,"%GetFilterSpec")
			If $$$UPPER(tRelatedFilterSpec)[$$$UPPER(tRelationName) {
				Set TestSC = ..%FilterSpecToArray(tCubeIndex,tRelatedFilterSpec,.pRelatedFilters)
			}	
			// -DTB164

			Set tRelatedCube = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"relations",$$$UPPER(tRelationName),"relatedCube"))

			// JMD1305: pass along relevant pRelatedFilters 
			Kill tRelFiltersX
			Set s = $O(pRelatedFilters(""))
			While (s'="") {
				// DTB038: Only pass related filter specs that belong to this related cube
				If $E(s,1,3)="%OR" {
					// DTB164 - Examine the contents of a heterogeneous %OR and attempt to construct a new complex spec for the cube in question
					Set tRelSpec = $O(pRelatedFilters(s,""),1,tRelKey)
					Set tORSet = ""
					Set tRelSpecCount = 0
					While tRelSpec'="" {
						Kill tSpecRelationName
						Set tSC = ..%GetDimensionInfo(pCubeName,tRelSpec,,,,.tSpecRelationName)
						If (tRelationName=tSpecRelationName)&&$$$ISOK(tSC) {
							Set tRelSpecCount = tRelSpecCount+1
							Kill tSpecInfoX
							Set tSC = ##class(%DeepSee.Query.Parser).%ParseMemberSpec(tRelSpec,.tSpecInfoX,.tQuoted,.tMemKey)
							If $$$ISERR(tSC) Continue		// DTB164 - Try other filters even if one fails
							Set tSpecX = ""
							Set s2 = $O(tSpecInfoX(1))
							While (s2'="") {
								Set tSpecX = tSpecX _ $S(tSpecX="":"",1:".") _ $S(+$G(tMemKey(s2)):"&",1:"") _ "["_ tSpecInfoX(s2) _ "]"
								Set s2 = $O(tSpecInfoX(s2))
							}
							
							// Process the current spec and add it to a set (assume heterogeneous)
							// key could be a set of values {a,b}
							If ($E(tRelKey,1)="{") {
								Set tORSpec = ""
								Set tRelKey=$E(tRelKey,2,$L(tRelKey)-1)
								For sx = 1:1:$L(tRelKey,",&") {
									Set tORSpec = tORSpec _ $S(tORSpec'="":",",1:"") _ tORSpec _"."_$S(sx=1:"",1:"&")_$P(tRelKey,",&",sx)
								}
							}
							ElseIf ($E(tRelKey,1,4)="%NOT") {
								// (JMD1104) deal with %NOT
								Set tORSpec = tSpecX _"."_tRelKey
							}
							ElseIf (($E(tRelKey,1,2)'="&[")||(tRelSpec["&[")) {
								// (JMD951)  if there is already a key; don't tack one on!
								// (JMD1095) if key does not have &[] (or is missing) then it is not a key
								Set tORSpec = tSpecX
							}
							Else {
								Set tORSpec = tSpecX _"."_tRelKey
							}
							
							Set tORSet = tORSet _ $S($L(tORSet):",",1:"") _ tORSpec
						}
						
						Set tRelSpec = $O(pRelatedFilters(s,tRelSpec),1,tRelKey)
					}
					
					If (tORSet'="") {
						Set:(tRelSpecCount>1) tORSet = "%OR({" _ tORSet _ "})"
						Set tRelFiltersX(tORSet) = ""
					}
				}
				Else {
					Kill tSpecRelationName
					Set tSC = ..%GetDimensionInfo(pCubeName,s,.tRelDimNo,.tRelHierNo,.tRelLevelNo,.tSpecRelationName)
					If (tRelationName=tSpecRelationName)&&$$$ISOK(tSC) {
						Kill tSpecInfoX
						Set tSC = ##class(%DeepSee.Query.Parser).%ParseMemberSpec(s,.tSpecInfoX,.tQuoted,.tMemKey)
						If $$$ISERR(tSC) Continue		// DTB164 - Try other filters even if one fails
						Set tSpecX = ""
						Set s2 = $O(tSpecInfoX(1))
						While (s2'="") {
							Set tSpecX = tSpecX _ $S(tSpecX="":"",1:".") _ $S(+$G(tMemKey(s2)):"&",1:"") _ "["_ tSpecInfoX(s2) _ "]"
							Set s2 = $O(tSpecInfoX(s2))
						}
						Set:tSpecX'="" tRelFiltersX(tSpecX) = pRelatedFilters(s)
					}
				}
				Set s = $O(pRelatedFilters(s))
			}
			// JMD1410: swallow the error
			// most likely there is a reference to a local calculated member that
			// we do not have access to at this point
			Set tSC = $$$OK
			If $$$ISERR(tSC) Quit
			Set tSC = ..%GetDimensionMembers(tRelatedCube, tRelationSpec, "", .pMembers, pMaxMembers,,.tRelFiltersX,pCalcMode,pSearchKey)  // DTB080
			If $$$ISERR(tSC) Quit
			// add relation name back onto value?
			Quit
		}

		// check for calculated members
		// DTB743 - Consult the user settings for filters before folding in members
		Set tSuppressCalc = (pContext="filter") && ( +$G(tLevelNo) && '+$G(^DeepSee.UserPortalSettings("Controls","showCalculated")) )
		If (pCalcMode'=-1) && ('tSuppressCalc) {
			Set tDimName = ""
			If (tDimNo = -1) {
				// dimension only containing calc members
				Set tDimName = $$$UPPER(##class(%DeepSee.Query.Parser).%UnquoteIdent(pSpec))
			}
			Else {
				// get dim name
				Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo))
				Set tDimName = $$$UPPER($LG(tInfo,2))
			}

			// If there are calculated members for this dimension, fold them into the member list
			If (tDimName'="") {
				Set tMbr = $O($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"calcMbrs",tDimName,""))
				While (tMbr'="") {
					Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"calcMbrs",tDimName,tMbr))
					Set tName = $LG(tInfo,2)
					// + WAL146 -- Check to see if this calculated member has a display name
					Set tCaption = $zobjclassmethod(tCubeClass,"%GetMemberCaption",$$$UPPER(tDimName),$$$UPPER(tName))
					Set:($G(tCaption)="") tCaption = tName
					Set pMembers($I(n)) = $LB("["_tName_"]",tCaption,tName,tName)
					// - WAL146
					Set tMbr = $O($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"calcMbrs",tDimName,tMbr))
				}
				
				// +DTB454 - Add shared calc members to the member list
				Set tSC = ##class(%DeepSee.Utils).%GetSharedCalcMembers(tCubeIndex,.tSharedCalcMembers)
				If $$$ISERR(tSC) Quit
				
				Set tSharedCalcIdx = $O(tSharedCalcMembers(""),1,tSharedCalcInfo)
				While tSharedCalcIdx'="" {
					If ($$$UPPER($LG(tSharedCalcInfo,1))=tDimName) {
						Set tName = $LG(tSharedCalcInfo,2)
						Set tCaption = $zobjclassmethod(tCubeClass,"%GetMemberCaption",$$$UPPER(tDimName),$$$UPPER(tName))
						Set:($G(tCaption)="") tCaption = tName
						Set pMembers($I(n)) = $LB("["_tName_"]",tCaption,tName,tName)
					}
					
					Set tSharedCalcIdx = $O(tSharedCalcMembers(tSharedCalcIdx),1,tSharedCalcInfo)
				}
				// -DTB454
			}
		}

		// no more to do
		If (pCalcMode=1) Quit

		If (tDimNo = -1) {
			// this is a dimension of only calculated members-- nothing more to do
			Quit
		}

		Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo))
		Set pMemberClass = $LG(tInfo,6)
		Set tRollupKey = ""
		Set tHierInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,0))
		Set tMbrClass = $LG(tHierInfo,6)
		Set:tMbrClass="" tMbrClass = "%DeepSee.Query.memberData"

		// JMD1329: check for MDX computed dims
		// get dim name
		Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo))
		Set tDimName = $$$UPPER($LG(tInfo,2))
		Set tDimClass = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"computedDims",tDimName))
		Set tBehavior="" ; JSL4431
		Set:tDimClass'="" tBehavior=$classmethod(tDimClass,"%GetBehavior") ; JSL4431 - only call classmethod once because results stored in variable
		If ((tBehavior="MDX")||(tBehavior="SQL")) { // JSL4431 - add SQL as behavior
			// for MDX computed, get list directly from the dimension class
			// not from query so that we get the unprocessed member names

			Set tDimObj = $classmethod(tDimClass,"%Create",pCubeName,"",tDimNo,tHierNo,tLevelNo)
			If '$IsObject(tDimObj) {
				Set tSC = $$$ERROR($$$GeneralError,"Unable to create computed dimension object: " _ tDimClass)
				Quit
			}
			// JMD1366 also look at both pre-defined and run-time lists
			Kill tMemberList
			Set tSC = tDimObj.%GetAllMembers(.tMemberList,pCubeName,tDimNo,tHierNo,tLevelNo)
			If $$$ISERR(tSC) Quit

			// copy results
			Set n = 0
			Set k = $O(tMemberList(""),1,data)
			While (k'="") {
				Set n = n + 1
				Set tMbrId = $LG(data,1)
				Set tValue = $LG(data,2)
				Set tMbrKey = $LG(data,3)
				Set tDesc = $LG(data,4)			// DTB219
				Set pMembers(n) = $LB("["_tValue_"]",tValue,tMbrId,tMbrKey,tDesc)
				Set k = $O(tMemberList(k),1,data)
			}
			Quit
		}
		Else {
			// we need to provide a fake axis global so that GetMembers has a place to put the results
			Set tParent = 1
			New %axis
			Set tAxisKey = $I($$$DeepSeeAxisGLVN(tCubeIndex,"tempAxisKey"),-1)		// DTB483 - Obtain a key unique to this current call
			Set %axis = tAxisKey
			Set tNodeNo = 1
			Lock +$$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey):5 Else  Set tSC=$$$ERROR($$$GeneralError,"Unable to get lock in %GetDimensionMembers")
			If $$$ISERR(tSC) Quit
			Kill $$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey)

			#; see if there are filters associated with the cube
			#; if so, add to the filter list
			Set tFilters = 0
			Set tFilterSpec = $classmethod(tCubeClass,"%GetFilterSpec")
			If (tFilterSpec'="") {
				Set tFilters($I(tFilters)) = tFilterSpec
			}

			#; JMD947: convert related filters to %FILTER clauses
			#; Build spec from related filters, if any
			If ($D(pRelatedFilters)) {
				Set s = $O(pRelatedFilters(""))
				While (s'="") {
					// from a widget, *s* may be the complete spec
					If (pRelatedFilters(s)="") {
						Set tFilters($I(tFilters)) = s 
					}
					Else {
						Set tKey = pRelatedFilters(s)
						// key could be a set of values {a,b}
						If ($E(tKey,1)="{") {
							Set tSpec = ""
							Set tKey=$E(tKey,2,$L(tKey)-1)
							For sx = 1:1:$L(tKey,",&") {
								Set tSpec = tSpec _ $S(tSpec'="":",",1:"") _ s _"."_$S(sx=1:"",1:"&")_$P(tKey,",&",sx)
							}
							// JMD1423: wrap set with %OR
							// (assumed heterogeneous set!)
							// Set tSpec = "{"_tSpec_"}"
							Set tSpec = "%OR({"_tSpec_"})"
						}
						ElseIf ($E(tKey,1,4)="%NOT") {
							// JMD1104 deal with %NOT
							Set tSpec = s _"."_tKey
						}
						ElseIf (($E(tKey,1,2)'="&[")||(s["&[")) {
							// JMD951  if there is already a key; don't tack one on!
							// JMD1095 if key does not have &[] (or is missing) then it is not a key
							Set tSpec = s
						}
						Else {
							Set tSpec = s _"."_tKey
						}
						Set tFilters($I(tFilters)) = tSpec
					}
					Set s = $O(pRelatedFilters(s))
				}
			}

			If ($D(tFilters)) {
				// JMD947: make sure slicer axis is processed
				Set tMDX = "SELECT FROM ["_pCubeName_"]"
				Set k = $O(tFilters(""))
				While (k'="") {
					// special case for %NOT!
					// %NOT of multiple items comes in as spec.%NOT {set}
					If (tFilters(k)[".%NOT ") {
						Set tSpec1 = $P(tFilters(k),".%NOT ",1)
						Set tKeys1 = $P(tFilters(k),".%NOT ",2)
						If ($E(tKeys1)="{") {
							Set tSpec2 = ""
							// set of values
							Set tKeys1 = $E(tKeys1,2,$L(tKeys1)-1)
							// process each one
							Set kc = 0
							For p = 1:1:$L(tKeys1,"],") {
								Set tKeyX = $P(tKeys1,"],",p)
								Set:$E(tKeyX,$L(tKeyX))'="]" tKeyX = tKeyX _ "]"
								If (tKeyX'="") {
									Set tSpec2 = tSpec2_$S(kc:",",1:"")_tSpec1_"."_tKeyX_".%NOT"
									Set kc = kc+1
								}
							}
							If (tSpec2'="") {
								If (kc>1) {
									Set tMDX = tMDX _ " %FILTER (" _ tSpec2_")"
								}
								Else {
									Set tMDX = tMDX _ " %FILTER " _ tSpec2
								}
							}
						}
						Else {
							Set tMDX = tMDX _ " %FILTER " _ tSpec1_"."_tKeys1_".%NOT"
						}
					}
					// JMD1067: skip .Members in filter
					ElseIf ($$$UPPER(tFilters(k))'[".MEMBERS") {
						Set tFilter = $ZSTRIP(tFilters(k),"<W")
						
						// DTB644 - Some filters can come in with a %FILTER in front!
						If $E(tFilter,1,7)="%FILTER" {
							Set tFilter = $E(tFilter,8,*)
						}
						
						Set tMDX = tMDX _ " %FILTER " _ tFilter
					}
					Set k = $O(tFilters(k))
				}
				
				If (tMDX'="") {
					Set tRS = ##class(%DeepSee.ResultSet).%New()
					Set tSC = tRS.%PrepareMDX(tMDX)
					If $$$ISERR(tSC) Quit
					Set tSC = tRS.%Execute()
					If $$$ISERR(tSC) Quit

					// pass query along
					New %query
					Set %query = tRS.%GetQuery()
				}
			}

			// JMD947: pass flag to force member restriction by slicer
			New %dsRestrictBySlicer
			Set %dsRestrictBySlicer = 1

			// JMD1193: force a TOP clause in the members query
			New %dsMaxMembers
			Set %dsMaxMembers = pMaxMembers

			// JMD1283: add an additional WHERE to the members query
			// this is used by the filter search box
			If (pSearchKey'="") {
				New %dsMemberSearch
				Set %dsMemberSearch = pSearchKey
			}

			If pContext="filter" {
				// DTB599
				New %reduce		// DTB758
				Set %reduce = 1
			}

			Set tSC = $zobjclassmethod(tMbrClass,"%GetMembers",tCubeIndex,tDimNo,tHierNo,tLevelNo,"",tParent,tAxisKey,.tNodeNo)
			If $$$ISERR(tSC) Quit

			// special case for NOW
			If ($zobjclassmethod(tMbrClass,"%HasFeature",tCubeIndex,tDimNo,tHierNo,tLevelNo,"NOW")) {
				Set n = n + 1
				Set pMembers(n) = $LB("[NOW]",$$$Text("NOW","%DeepSee"),"NOW","NOW")
			}
		}

		// copy results into output array
		Set tKey = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent,"ch",""))
		While ((tKey '= "")&&(n<tMaxMembers)) {
			Set n = n + 1
			Set tNode = $$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tKey)
			Set tValue = $LG(tNode,5)
			Set tMbrId = $LG(tNode,6)
			Set tMbrKey = $LG(tNode,13)
			Set tDesc = $LG(tNode,23)
			Set pMembers(n) = $LB("["_tValue_"]",tValue,tMbrId,tMbrKey,tDesc)
			Set tKey = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",tParent,"ch",tKey))
		}

		Kill $$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey)
		Lock -$$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey)
		
		// DTB483 - Keep the counter limited
		Set tUserLimit = $system.License.GetUserLimit()
		Set $$$DeepSeeAxisGLVN(tCubeIndex,"tempAxisKey") = -((-tAxisKey)#$S(tUserLimit<1000:1000,1:tUserLimit))
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%FilterSpecToArray">
<Description><![CDATA[
Convert a string <var>pSpec</var> into array form and add it to the array <var>pFilterArray</var>. The
value for <var>pSpec</var> may be any valid MDX WHERE clause referencing non-calculated members.
If a member being inserted into the array already exists, the selection data will be replaced by the 
intersection of the preexisting member or set and the new member or set provided by the argument.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCube:%String,pSpec:%String,&pFilterArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB164
	Set tSC = $$$OK
	Try {
		// Normalize the cube name
		Set tSC = ##class(%DeepSee.Query.Parser).%ParseMemberSpec(pCube,.tInfo)
		If $$$ISERR(tSC) Quit
		Set tCube = "[" _ $$$dsEscapeIdent(tInfo(1)) _ "]"
		
		// Create a query that can be parsed into an object
		Set tMDX = "SELECT " _ pSpec _ " ON 0 FROM " _ tCube
		Set tSC = ##class(%DeepSee.Query.Parser).%ParseMDX(tMDX,.tQuery)
		If $$$ISERR(tSC) Quit
		
		Set tSpecOBJ = tQuery.axes.GetAt(1).children.GetAt(1)
		
		// Recursively examine the object representation of the original pSpec looking for sets, ranges, or members
		Set tSC = ..%SlicerNodeToSpecArray(tSpecOBJ,.pFilterArray)
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%SlicerNodeToSpecArray">
<Description><![CDATA[
Perfroms the actual work of recursively walking a slicer tree and representing it as an array if possible.
Contents of the <var>pFilterArray</var> can be returned in two different forms:<br>
Single argument: pFilterArray(levelSpec) = key<br>
heterogeneous %OR: pFilterArray(ORText,levelSpec) = key]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[node:%DeepSee.Query.node,&pFilterArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB164
	Set tSC = $$$OK
	Try {
		If node.%IsA("%DeepSee.Query.memberSpec") {
			// Look through the resolved spec array to see if this is a range or a single member
			Set tSC = node.%ResolveValue()
			If $$$ISERR(tSC) Quit
			
			Set tIsRange=0
			Set tMemberKeyNos(1) = $O(node.%memberKeys(""))
			If $O(node.%memberKeys(tMemberKeyNos(1)))'="" {
				Set tMemberKeyNos(2) = $O(node.%memberKeys(tMemberKeyNos(1)))
				Set tIsRange=1
			}
			
			Set tIdentIdx = $O(node.%resolvedSpec(""))
			Set tLevelSpec = ""
			While (tIdentIdx'="") {
				If (tIdentIdx=tMemberKeyNos(1))||(node.%resolvedSpec(tIdentIdx)=":") {
					Quit
				}

				Set tLevelSpec = tLevelSpec _ $S($L(tLevelSpec):".",1:"") _ "[" _ $$$dsEscapeIdent(node.%resolvedSpec(tIdentIdx)) _ "]"
				Set tIdentIdx = $O(node.%resolvedSpec(tIdentIdx))
			}
			
			Set tKey = $S((tMemberKeyNos(1)'=""):"&[" _ $$$dsEscapeIdent(node.%resolvedSpec(tMemberKeyNos(1))) _ "]",1:"")
			If tIsRange {
				Set:(tMemberKeyNos(2)'="") tKey = tKey _ ":" _ "&[" _ $$$dsEscapeIdent(node.%resolvedSpec(tMemberKeyNos(2))) _ "]"
			}

			Set pFilterArray(tLevelSpec) = tKey
		} 
		ElseIf node.%IsA("%DeepSee.Query.range") {
			// DTB164 - Not Implemented - Does not seem to be used!
		}
 		ElseIf node.%IsA("%DeepSee.Query.set") {
	 		Set tUniqueSpecCount = 0
	 		Set tParentFunction = $S(node.parent.%IsA("%DeepSee.Query.setFunction"):node.parent.function,1:"")
	 		
	 		For ii=1:1:node.children.Count() {
		 		Kill tSetItemArray
		 		Set tSetItemNode = node.children.GetAt(ii)
		 		
		 		Set tSC = ..%SlicerNodeToSpecArray(tSetItemNode,.tSetItemArray)
		 		
 				Set tItemSpec = $O(tSetItemArray(""),1,tKey) 
 				While tItemSpec'="" {
	 				Set tItemSpecU = $$$UPPER(tItemSpec)
					Set:'$D(tSetSpecs(tItemSpecU)) tUniqueSpecCount = tUniqueSpecCount+1

					If tKey'="" {
						Set tSetSpecs(tItemSpecU,$I(tSetSpecs(tItemSpecU))) = tKey
					}
					Else {
						Set tSetSpecs(tItemSpecU) = ""
					}
	 				Set tItemSpec = $O(tSetItemArray(tItemSpec),1,tKey)
 				}
	 		}
	 		
	 		If ($O(tSetSpecs(""))'=$O(tSetSpecs(""),-1)) {
		 		// Set contents containing multiple level specs cannot be represented individually in the array format. 
		 		//   A.&[Key1]||B.&[Key2] 
		 		// gets logically converted to
		 		//   A.&[Key1]&&B.&[Key2]
		 		// To prevent this, add the entire set as the spec. The result is similar to what the Adanced Filter editor provides as 
		 		// context.
		 		If (tParentFunction="%OR") {
			 		// This is a heterogeneous %OR
			 		Set tORString = node.parent.%ToString()
		 		}
		 		Else {
			 		// Wrap the set in an %OR
			 		Set tORString = "%OR(" _ node.%ToString() _ ")"
		 		}
		 		Set pFilterArray(tORString) = ""
		 		
		 		// Process and record all members under each spec. This allows for examination of the specs for relationship identifiers
		 		// prior to reconstructing a new %OR statmement to be executed on another cube
				Set tSpec = $O(tSetSpecs(""))
				While tSpec'="" {
					Set tKeySet = ""
					Set tKeyCount = $G(tSetSpecs(tSpec),0)
					For k=1:1:tKeyCount {
						Set tKeySet = tKeySet _ $S($L(tKeySet):",",1:"") _ tSetSpecs(tSpec,k)
					}
					
					Set:((tKeySet'="")&&(tKeyCount>1)) tKeySet = "{" _ tKeySet _ "}"
					
					Set pFilterArray(tORString,tSpec) = tKeySet
					Set tSpec = $O(tSetSpecs(tSpec))
		 		}
	 		}
			Else {
				// Process all members of the single spec
				Set tSpec = $O(tSetSpecs(""))
				Set tKeySet = ""
				Set tKeyCount = $G(tSetSpecs(tSpec),0)
				For k=1:1:tKeyCount {
					Set tKeySet = tKeySet _ $S($L(tKeySet):",",1:"") _ tSetSpecs(tSpec,k)
				}
				
				Set:((tKeySet'="")&&(tKeyCount>1)) tKeySet = "{" _ tKeySet _ "}"
				
				Set pFilterArray(tSpec) = tKeySet
			}
 		}
		Else {
			// Recurse to look for members and sets
			For ii=1:1:node.children.Count() {
				Set tChild = node.children.GetAt(ii)
				Set tSC = ..%SlicerNodeToSpecArray(tChild,.pFilterArray)
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetLevelNameForKey">
<Description><![CDATA[
Give a cube, a level within the cube, and the key value of a member of the level,
return the name of the level member.<br/>
<var>pCubeName</var> is the name of the cube.<br/>
<var>pSpec</var> specifies the dimension in the form:
"Dim.Hier.Level".<br/>
<var>pKey</var> is a key value. This may include the &[] around the key value.<br/>
<var>pValue</var> is the returned display value.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pSpec:%String,pKey:%String,*pValue:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCube = $$$UPPER(pCubeName)
		Set pValue = ""
		If (pCubeName="")||(pKey="") Quit

		Set pKey = $ZSTRIP(pKey,"<>W")

		// See if key needs parsing
		Set tIsNot = 0
		If ($E(pKey,1,5)="%NOT ") {
			Set pKey = $E(pKey,6,$L(pKey))
			Set tIsNot = 1
		}

		// n.b, if the key is *supposed* to start and end with {} then we are in trouble!
		If (($E(pKey,1)="{")&&($E(pKey,$L(pKey))="}")) {
			// set of values
			Set pKey = $E(pKey,2,$L(pKey)-1)
			// process each one
			Set pValue = ""
			For p = 1:1:$L(pKey,"],") {
				Set tKey = $P(pKey,"],",p)
				Set:$E(tKey,$L(tKey))'="]" tKey = tKey _ "]"
				Set tSC = ..%GetLevelNameForKey(pCubeName,pSpec,tKey,.tValue)
				If ($$$ISOK(tSC)&&(tValue'="")) {
					Set pValue = pValue _ $S(pValue="":"",1:"+") _ tValue
				}
			}
			If (tIsNot && (pValue'="")) {
				Set pValue = "NOT " _ pValue
			}
			Quit
		}

		// JMD1275 test for range
		If (pKey["]:&[") {
			Set tKey1 = $P(pKey,"]:&[",1)_"]"
			Set tKey2 = "&["_$P(pKey,"]:&[",2)
			Set tSC = ..%GetLevelNameForKey(pCubeName,pSpec,tKey1,.tValue1)
			If $$$ISERR(tSC) Quit
			Set tSC = ..%GetLevelNameForKey(pCubeName,pSpec,tKey2,.tValue2)
			If $$$ISERR(tSC) Quit
			Set pValue = tValue1 _ ":" _ tValue2
			Quit
		}

		If ($E(pKey,1,2)="&[") {
			// DTB112 - removing &[ and ] using $E() is not robust--parse the key to properly expose the identifier
			Do ##class(%DeepSee.Query.Parser).%ParseMemberSpec(pKey,.tInfo)
			Set pKey = tInfo(1)
		}

		Set tSC = ..%GetDimensionInfo(pCubeName,pSpec,.tDimNo,.tHierNo,.tLevelNo,.tRelationName,.tRelationSpec,.tSpecInfo)
		If $$$ISERR(tSC) Quit

		If (tRelationName'="") {
			Set tRelatedCube = $G($$$DeepSeeMetaGLVN("cubes",tCube,"relations",$$$UPPER(tRelationName),"relatedCube"))
			Set tSC = ..%GetLevelNameForKey(tRelatedCube, tRelationSpec, pKey, .pValue)
			If $$$ISERR(tSC) Quit
		}
		ElseIf (tDimNo=-1) {
			// calculated member: name = key
			Set pValue = pKey
		}
		ElseIf (tDimNo=-2) {
			// named set: name = key
			Set pValue = pKey
		}
		Else {
			// check for calc member within this dimension
			// get dim name
			Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
			Set tDimName = $$$UPPER($LG(tInfo,2))
			If ((tDimName'="")&&(pKey'="")) {
				If $D($$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs",tDimName,$$$UPPER(pKey))) {
					Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"calcMbrs",tDimName,$$$UPPER(pKey)))
					Set pValue = $LG(tInfo,2)
					Quit
				}
			}

			Set tHierInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,0))
			Set tMbrClass = $LG(tHierInfo,6)
			Set:tMbrClass="" tMbrClass = "%DeepSee.Query.memberData"
			Set tMbrProvider = $zobjclassmethod(tMbrClass,"%New")
			Set tMbrProvider.%cube = tCube
			Set tMbrProvider.%levelNumber = tLevelNo
			Set tSC = $zobjmethod(tMbrProvider,"%FindMemberByKey",pKey,tDimNo,tHierNo,.tExists,.pValue,0)
			If $$$ISERR(tSC) Quit
		}

		If (tIsNot && (pValue'="")) {
			Set pValue = "NOT " _ pValue
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ParseKeyForDisplay">
<Description><![CDATA[
Parse a filter key value and convert all keys to display values in the context of <var>pKPIClass</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKey:%String,*pValue:%String,pKPIClass:%String="",pFilterName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by WAL209
	Set tSC = $$$OK
	Try {
		Set pValue = ""

		Set pKey = $ZSTRIP(pKey,"<>W")

		// See if key needs parsing
		Set tIsNot = 0
		If ($E(pKey,1,5)="%NOT ") {
			Set pKey = $ZSTRIP($E(pKey,5,$L(pKey)),"<>W")		// DTB609 - Support an optional space after the %NOT
			Set tIsNot = 1
		}

		// n.b, if the key is *supposed* to start and end with {} then we are in trouble!
		If (($E(pKey,1)="{")&&($E(pKey,$L(pKey))="}")) {
			// This is a set of values. First identify the comma-delimited set
			Set pKey = $E(pKey,2,$L(pKey)-1)
			// process each one
			Set pValue = ""
			
			// DTB609 - Choose most appropriate set delimiter.
			If (pKey["],&[") {
				Set tUrlDelimiter = "],&["
			}
			ElseIf (pKey["],[") {
				Set tUrlDelimiter = "],["
			}
			Else {
				Set tUrlDelimiter = ","
			}

			For p = 1:1:$L(pKey,tUrlDelimiter) {
				Set tKey = $P(pKey,tUrlDelimiter,p)
				If (tUrlDelimiter="],&[") {
					// DTB609 - Leave this with a key
					Set:($E(tKey,1,2)'="&[") tKey = "&[" _ tKey
					Set:($E(tKey,$L(tKey))'="]") tKey = tKey _ "]"
				}
				ElseIf (tUrlDelimiter = "],[") {
					// DTB609 - Leave the key as an exposed member name
					Set:($E(tKey)="[") tKey = $E(tKey,2,*)
					Set:($E(tKey,$L(tKey))="]") tKey = $E(tKey,1,*-1)
				}

				Set tSC = ..%ParseKeyForDisplay(tKey,.tValue,pKPIClass,pFilterName)		// DTB609
				If ($$$ISOK(tSC)&&(tValue'="")) {
					Set pValue = pValue _ $S(pValue="":"",1:" + ") _ tValue
				}
			}
			If (tIsNot && (pValue'="")) {
				Set pValue = "NOT " _ pValue
			}
			Quit
		}

		// JMD1275 test for range
		If (pKey["]:&[") {
			Set tKey1 = $P(pKey,"]:&[",1)_"]"
			Set tKey2 = "&["_$P(pKey,"]:&[",2)
			Set tSC = ..%ParseKeyForDisplay(tKey1,.tValue1,pKPIClass,pFilterName)		// DTB609
			If $$$ISERR(tSC) Quit
			Set tSC = ..%ParseKeyForDisplay(tKey2,.tValue2,pKPIClass,pFilterName)		// DTB609
			If $$$ISERR(tSC) Quit
			Set pValue = tValue1 _ ":" _ tValue2
			Quit
		}

		If ($E(pKey,1,2)="&[") {
			// DTB112 - removing &[ and ] using $E() is not robust--parse the key to properly expose the identifier
			Do ##class(%DeepSee.Query.Parser).%ParseMemberSpec(pKey,.tInfo)
			Set pKey = tInfo(1)
			Set pValue = pKey
			
			Set pValue = $classmethod(pKPIClass,"%GetFilterDisplayValue",pFilterName,pKey)		// DTB609
		}
		Else {
			If (($E(pKey,1)'="[")&&($E(pKey,$L(pKey))="]")) Set pKey = $E(pKey,1,$L(pKey)-1)
			Set pKey=$classmethod(pKPIClass,"%GetFilterDisplayValue",pFilterName,pKey)		// DTB609
			Set pKey = $REPLACE(pKey,","," + ")
			Set pValue = pKey	
		}

		If (tIsNot && (pValue'="")) {
			Set pValue = "NOT " _ pValue
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetMemberKeyForID">
<Description><![CDATA[
Given a cube and the dimension, heirarchy, and level numbers, translate the member ID 
into the member key.
<var>pCubeName</var> is the name of the cube.<br/>
<var>pID</var> is an ID in the dimension's star table.<br/>
<var>pKey</var> is the returned key corresponding to that ID.<br/>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pDimNo:%Integer,pHierNo:%Integer,pLevelNo:%Integer,pID:%String,*pKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB247
	Set tSC = $$$OK
	Set pKey = ""
	Try {
		Set tCubeKey = $$$UPPER(pCubeName)
		Set tLevelInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeKey,"mbr#",pDimNo,pHierNo,pLevelNo))
	
		// Look up the the table and property name
		Set tLevelClass = $LG(tLevelInfo,6)
		Set tKeyProperty = $LG(tLevelInfo,12)
		
		If ($P(tLevelClass,".",1,2)="%DeepSee.Time") {
			// Key and ID are the same for time dimensions, there is no lookup
			Set pKey = pID
			Quit
		}

		Set tLevelTable = ##class(%DeepSee.Utils).%GetSQLTableName(tLevelClass)
		Set tKeyFieldName = ##class(%DeepSee.Utils).%GetSQLColumnName(tLevelClass,tKeyProperty)
		
		// BUild the SQL statement to retrieve the key corresponding to the ID
		Set tSQL = "SELECT " _ tKeyFieldName _ " FROM " _ tLevelTable _ " WHERE ID = " _ pID 
		Set tStatement = ##class(%SQL.Statement).%New()
		Set tSC = tStatement.%Prepare(tSQL)
		If $$$ISERR(tSC) Quit
		
		Set tResult = tStatement.%Execute()
		If $$$ISERR(tSC) Quit
	
		If tResult.%Next() {
			Set pKey = tResult.%GetData(1)
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetModel">
<Description><![CDATA[
Given the logical name, <var>pCubeName</var> of a DeepSee cube,
return an instance of the <class>%DeepSee.Model.cube</class>
meta-data object that describes the cube.<br/>
Return "" if the given cube does not exist.<br/>
This method does not work on SubjectAreas; use %GetSubjectAreaModel.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%DeepSee.Model.cube</ReturnType>
<Implementation><![CDATA[
	Set tCube = ""
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.pStatus)
		If $$$ISOK(pStatus) {
			// GetModel only works for *compiled* cubes!
			If ($System.OBJ.IsUpToDate(tClassName)) {
				If $zobjclassmethod(tClassName,"%IsA","%DeepSee.CubeDefinition") {
					Set tCube = $zobjclassmethod(tClassName,"%GetModel")
				}
				Else {
					Set pStatus = $$$ERROR($$$GeneralError,"Class is not cube definition")
					Quit
				}
			}
			Else {
				// get model from XData directly
				Set tClassDefinition = ##class(%Dictionary.ClassDefinition).%OpenId(tClassName,0,.pStatus)
				If $$$ISERR(pStatus) Quit
				#; find the XDATA block named Cube
				Set tXData = ##class(%Dictionary.XDataDefinition).IDKEYOpen(tClassName,"Cube",0,.pStatus)
				If $$$ISERR(pStatus) Quit
				If $IsObject(tXData) {
					#; get XDATA as stream
					Set tStream = tXData.Data
					Do tStream.Rewind()

					If (tStream.Size > 0) {
						#; render the stream into cube meta-data object (with children)
						Set tReader = ##class(%XML.Reader).%New()

						Set pStatus = tReader.OpenStream(tStream)
						If $$$ISERR(pStatus) Quit

						Do tReader.Correlate("cube","%DeepSee.Model.cube")

						#; there should only be one cube defined
						Do tReader.Next(.tCube,.tSC)
						If $$$ISERR(tSC) Quit
						If '$IsObject(tCube) {
							Set pStatus = $$$ERROR($$$GeneralError,"No <cube> element defined in Cube block.")
							Quit
						}
					}
				}
				If (tCube = "") {
					Set pStatus = $$$ERROR($$$GeneralError,"Class does not contain a cube definition")
					Quit
				}
			}
		}
		If $IsObject(tCube) Set tCube.Timestamp = $ZDT($$$defClassKeyGet(tClassName,$$$cCLASStimechanged),3,,6)
	}
	Catch(ex) {
		Set tCube = ""
		Set pStatus = ex.AsStatus()
	}
	Quit tCube
]]></Implementation>
</Method>

<Method name="%GetSubjectAreaModel">
<Description><![CDATA[
Given the logical name, <var>pName</var> of a DeepSee subject,
return an instance of the <class>%DeepSee.Model.SubjectArea.subjectArea</class>
meta-data object that describes the cube.<br/>
Return "" if the given cube does not exist.<br/>
This method does not work on base cubes; use %GetModel.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%DeepSee.Model.SubjectArea.subjectArea</ReturnType>
<Implementation><![CDATA[
	Set tSubjectArea = ""
	Set pStatus = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pName,.pStatus)
		If $$$ISOK(pStatus) {
			// get model from XData directly
			Set tClassDefinition = ##class(%Dictionary.ClassDefinition).%OpenId(tClassName)
			#; find the XDATA block named Cube
			Set tIndex = tClassDefinition.XDatas.FindObjectId(tClassName_"||SubjectArea")
			If tIndex'="" {
				#; get XDATA as stream
				Set tStream = tClassDefinition.XDatas.GetAt(tIndex).Data
				Do tStream.Rewind()

				If (tStream.Size > 0) {
					#; render the stream into cube meta-data object (with children)
					Set tReader = ##class(%XML.Reader).%New()

					Set tSC = tReader.OpenStream(tStream)
					If $$$ISERR(tSC) Quit

					Do tReader.Correlate("subjectArea","%DeepSee.Model.SubjectArea.subjectArea")

					#; there should only be one subjectArea defined
					Do tReader.Next(.tSubjectArea,.tSC)
					If $$$ISERR(tSC) Quit
					If '$IsObject(tSubjectArea) {
						Set tSC = $$$ERROR($$$GeneralError,"No <subjectArea> element defined in SubjectArea block.")
						Quit
					}
				}
			}
			If (tSubjectArea = "") {
				Set tSC = $$$ERROR($$$GeneralError,"Class does not contain a subject area definition")
				Quit
			}
		}
		If $IsObject(tSubjectArea) Set tSubjectArea.Timestamp = $ZDT($$$defClassKeyGet(tClassName,$$$cCLASStimechanged),3,,6)
	}
	Catch(ex) {
		Set tSubjectArea = ""
		Set pStatus = ex.AsStatus()
	}

	Quit tSubjectArea
]]></Implementation>
</Method>

<Method name="%GetFunctionSet">
<Description><![CDATA[
Builds a list of functions (methods) for a given FunctionSet class
This list is returned in <var>funcset</var>.<br/>
The list is of the form list(NAME) = $LB(class,name,specparsed,return).<br/>
This method is not currently used.
[Previously private]]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&funcset,pClass:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK

	// loop over all methods of the class
	Set method="" For { Set method=$$$comMemberNext(pClass,$$$cCLASSmethod,method)  Quit:""=method
		Set name = $$$UPPER(method)
		Set:'$D(funcset(name)) funcset(name) = $LB(pClass,method,
								$$$comMemberKeyGet(pClass,$$$cCLASSmethod,method,$$$cMETHformalspecparsed),
								$$$comMemberKeyGet(pClass,$$$cCLASSmethod,method,$$$cMETHreturntype)
								)
	}

	// now find all subclasses of funcset
	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tSC = tRS.Execute(pClass)  Quit:$$$ISERR(tSC) tSC
	While (tRS.Next(.tSC)) {
		Quit:$$$ISERR(tSC)
		Set tSC = ..%GetFunctionSet(.funcset,$G(tRS.Data("Name")))  Quit:$$$ISERR(tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetTimeLevelClasses">
<Description>
Builds a list of available time level classes.
The list is of the form pClasses(calendar,NAME) = class.
[Previously private]</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set tSC = $$$OK

	Try {		// DTB856 - Add Try/Catch
		// Find all subclasses of Time Level class
		Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
		Set tSC = tRS.Execute("%DeepSee.Time.AbstractLevel")  
		If $$$ISERR(tSC) Quit
		While (tRS.Next(.tSC)) {
			If $$$ISERR(tSC) Quit
			Set tName = $G(tRS.Data("Name"))
			Set tShortName = $$$UPPER($P(tName,".",$L(tName,".")))
			Set tCalendar = $classmethod(tName,"%GetCalendar")		// DTB177
			If $D(pClasses(tCalendar,tShortName)) {
				Set tSC = $$$ERROR($$$GeneralError,"Ambiguous Time Level Class: "_tName)
				Quit
			}
			Set pClasses(tCalendar,tShortName) = tName		// DTB177 - Insert calendar into time function reference table
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetTimeLevelType">
<Description><![CDATA[
Protected lookup of the type of a time function. If the argument <var>pClassName</var> 
is not a valid time class (extends <class>%DeepSee.Time.AbstractLevel</class>), then the 
method returns an empty string.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB188
	Set tType = ""
	Try {
		If (pClassName'="") &&
				##class(%Dictionary.CompiledClass).%ExistsId(pClassName) &&
				$ClassMethod(pClassName,"%IsA","%DeepSee.Time.AbstractLevel") {
			Set tType = $PARAMETER(pClassName,"DIMTYPE")
		}
	}
	Catch ex {
		Set tType = ""
	}
	Quit tType
]]></Implementation>
</Method>

<Method name="%GetTimeLevelCalendar">
<Description><![CDATA[
Protected lookup of the calendar used for a time function. If the argument <var>pClassName</var> 
is not a valid time class (extends <class>%DeepSee.Time.AbstractLevel</class>), then the 
method returns an empty string.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB188
	Set tType = ""
	Try {
		If (pClassName'="") &&
				##class(%Dictionary.CompiledClass).%ExistsId(pClassName) &&
				$ClassMethod(pClassName,"%IsA","%DeepSee.Time.AbstractLevel") {
			Set tType = $PARAMETER(pClassName,"CALENDAR")
		}
	}
	Catch ex {
		Set tType = ""
	}
	Quit tType
]]></Implementation>
</Method>

<Method name="%ExcelFormatDate">
<Description>
Given a date in $H format and a calendar, return the number of days since Jan 0 1900
This is excel's version of $H and is needed to export dates as dates to excel</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDate:%String,pCalendar:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// WAL264 -- if we encounter any error just return pDate
	Try {
		Set tExcelDate = pDate
		
		Set tStartDate = $ZDATEH("Dec 30 1899",6,,,,,,,,1) // WAL242 && SK -- use localeopt
		Set tEndDate = pDate		// DTB628
		
		Set:($G(tEndDate)'="") tExcelDate = $system.SQL.DATEDIFF("d",tStartDate,tEndDate)	
	}
	Catch ex {
		Set tExcelDate = pDate	
	}
	Quit tExcelDate
]]></Implementation>
</Method>

<Method name="%Analyze">
<Description><![CDATA[
Loop over all indices for a given cube and show details.<br/>
<var>pCubeName</var> is the name of the cube.<br/>
<var>pFlags</var> is a set of flags that can control what is analyzed:
flags include "i" (include indices), "f" (include facts), "c" (include cell cache).
The default is "i".<br/>
<var>pVerbose</var> indicates that status information is to be displayed while the analysis is done.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pFlags:%String="i",pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pCubeName="") {
			Write "No cube name specified",!
			Quit
		}
		Set tCube = $$$DeepSeeIndex(pCubeName)
		Set tFactClass = $$$UPPER(..%GetCubeFactClass(tCube))
		If (tFactClass="") {
			Write "Cube not found: ",pCubeName,!
			Quit
		}

		Set tIncludeIndices = pFlags["i"
		Set tIncludeCells = pFlags["c"
		Set tIncludeFacts = pFlags["f"

		Set tStart = $ZH
		// fact table
		If (tIncludeFacts) {
			Set tFacts = 0
			Set tFactSize = 0
			Set tID = $O($$$DeepSeeFactGLVN(tFactClass,""),1,data)
			While (tID '= "") {
				If (pVerbose&&'(tID#1000)) Write $C(13,27)_"[0J"_"Analyzing facts: "_tID
				Set tFacts = tFacts + 1
				Set tFactSize = tFactSize + $L(data)
				Set tID = $O($$$DeepSeeFactGLVN(tFactClass,tID),1,data)
			}
		}

		// indices
		If (tIncludeIndices) {
			Set tIndex = $O($$$DeepSeeIndexGLVN(tCube,""))
			While (tIndex '= "") {
				If (pVerbose) Write $C(13,27)_"[0J"_"Analyzing index: "_tIndex

				If ($E(tIndex) = "$") {
					#; extent index
					Set tChunk = $O($$$DeepSeeIndexGLVN(tCube,tIndex,""),1,data)
					While (tChunk '= "") {
						Set tSize(tIndex) = $L(data) + $G(tSize(tIndex))
						Set tChunk = $O($$$DeepSeeIndexGLVN(tCube,tIndex,tChunk),1,data)
					}
				}
				ElseIf ($E(tIndex) = "%") {
					// non-dimension index
				}
				Else {
					Set tValue = $O($$$DeepSeeIndexGLVN(tCube,tIndex,""))
					While (tValue '= "") {
						Set tValueCount(tIndex) = $G(tValueCount(tIndex)) + 1
						Set tChunk = $O($$$DeepSeeIndexGLVN(tCube,tIndex,tValue,""),1,data)
						While (tChunk '= "") {
							Set tSize(tIndex) = $L(data) + $G(tSize(tIndex))
							Set tChunk = $O($$$DeepSeeIndexGLVN(tCube,tIndex,tValue,tChunk),1,data)
						}
						Set tValue = $O($$$DeepSeeIndexGLVN(tCube,tIndex,tValue))
					}
				}
				Set tIndex = $O($$$DeepSeeIndexGLVN(tCube,tIndex))
			}

			If (pVerbose) Write $C(13,27)_"[0J"
		}

		// cell cache
		Set tCells = 0
		Set tBuckets = 0
		If (tIncludeCells) {
			Set tSlot = $O($$$DeepSeeCellsGLVN(tCube,""))
			While (tSlot '= "") {
				Set tBuckets = tBuckets + 1
				Set tKey = $O($$$DeepSeeCellsGLVN(tCube,tSlot,""))
				While (tKey '= "") {
					Set tCells = tCells + 1
					Set tMsr = $O($$$DeepSeeCellsGLVN(tCube,tSlot,tKey,""))
					If (tMsr '= "") {
						While (tMsr '= "") {
							Set tCells = tCells + 1
							Set tMsr = $O($$$DeepSeeCellsGLVN(tCube,tSlot,tKey,tMsr))
						}
					}
					If (pVerbose&&'(tCells#10000)) Write $C(13,27)_"[0J"_"Analyzing cell cache: "_ $FN(tCells,",",0) _ "/" _ tBuckets
					Set tKey = $O($$$DeepSeeCellsGLVN(tCube,tSlot,tKey))
				}
				Set tSlot = $O($$$DeepSeeCellsGLVN(tCube,tSlot))
			}
			If (pVerbose) Write $C(13,27)_"[0J"
		}

		// output
		If (tIncludeIndices) {
			Write !,"----------------------------------------------------------------"
			Write !,?4,"Index",?34,"Approx. Size",?53,"Cardinality"
			Set tTotal = 0
			Set tTotalCardinality = 0
			Set tIndex = $O(tSize(""))
			While (tIndex'="") {
				Set tIndexName = $S($E(tIndex)="$":"Extent Index",
					$E(tIndex)="M":$G($$$DeepSeeMetaGLVN("cubes",tCube,"msr#",tIndex),tIndex),
					1:$G($$$DeepSeeMetaGLVN("cubes",tCube,"fact#",tIndex),tIndex))
				// WAL052 -- Use alias so output can be interpreted
				If ($D($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tIndexName,"alias"))) {
					Set tIndexName = $$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tIndexName,"alias")
				}
				// WAL052
				Write !,$E(tIndex,1,3),?4,$E(tIndexName,1,24),?28,$J($FN(tSize(tIndex),",",0),18),?40,$J($FN($G(tValueCount(tIndex)),",",0),18)
				Set tTotal = tTotal + tSize(tIndex)
				Set tTotalCardinality = tTotalCardinality + $G(tValueCount(tIndex))
				Set tIndex = $O(tSize(tIndex))
			}
	
			Write !,"----------------------------------------------------------------"
			Write !,?4,"Total: ",?28,$J($FN(tTotal,",",0),18)," bytes",?60,tTotalCardinality
			Write !
		}
		If (tIncludeFacts) {
			Write !,?4,"Fact Table: ",?28,$J($FN(tFactSize,",",0),18)," bytes in ",$FN(tFacts,",",0)," fact(s)"
		}
		If (tIncludeCells) {
			Write !,?4,"Cell Cache: ",?28,$J($FN(tCells,",",0),18)," cell(s) in ",tBuckets," bucket(s)"
		}
		If (pVerbose) {
			Write !,?4,"Elapsed time: ",?32,$J($FN($ZH-tStart,",",3),18),"s"
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If (pVerbose && $$$ISERR(tSC)) {
		Do $System.Status.DisplayError(tSC)
		Quit
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%AnalyzeMissing">
<Description><![CDATA[
Examine the levels and measures for a given cube and report on how many missing values there are.<br/>
<var>pCubeName</var> is the name of the cube.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tSC = ..%GetCubeLevels(pCube,.tLevels,1,1)
		If $$$ISERR(tSC) Quit

		Set tFactCount = ..%GetCubeFactCount(pCube)

		If (tFactCount>0) {
			Write !,"-----------------------------------------------------------------------------"
			Write !,?4,"Level",?50,$J("#Missing",18),?69,$J("%Missing",8)

			Set n = $O(tLevels(""))
			While (n'="") {
				Set tMDX = ""
				Set tType = $LG(tLevels(n),1)
				If (tType="l") {
					Set tSpec = "["_$LG(tLevels(n),2)_"].["_$LG(tLevels(n),3)_"].["_$LG(tLevels(n),4)_"]"
					Set tMDX = "SELECT "_tSpec_".&[<null>] ON ROWS FROM ["_pCube_"]"
				}
				ElseIf (tType="m") {
					Set tCountName=##class(%DeepSee.Utils).%GetCountName(pCube,.tSC)
					If $$$ISERR(tSC) Quit
					If ($LG(tLevels(n),3)'=tCountName) {
						Set tSpec = "["_$LG(tLevels(n),2)_"].["_$LG(tLevels(n),3)_"]"
						Set tMDX = "SELECT FROM ["_pCube_"] WHERE %SEARCH.&["_tSpec_" IS NULL]"
					}
				}
				ElseIf (tType="r") {
					// find null ref for relation
					Set tRelation = $LG(tLevels(n),2)
					Set tNullRef = $G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(pCube),"relations",$$$UPPER(tRelation),"nullReplacement"))
					If (tNullRef'="") {
						Set tSpec = "["_tRelation_"]"
						Set tMDX = "SELECT FROM ["_pCube_"] WHERE "_tSpec_".&["_tNullRef_"]"
					}
				}

				If (tMDX'="") {
					Set tRS = ##class(%DeepSee.ResultSet).%New()
					Set tSC = tRS.%PrepareMDX(tMDX)
					If $$$ISERR(tSC) Quit
					Set tSC = tRS.%Execute()
					If $$$ISERR(tSC) Quit
					Set tCount = tRS.%GetOrdinalValue()
					Write !,$Case(tType,"l":"Lvl","m":"Msr","r":"Rel",:tType),?4,$E(tSpec,1,44),?50,$J($FN(tCount,",",0),18),?70,$J($FN((tCount/tFactCount)*100,",",2),6),"%"
				}
				Set n = $O(tLevels(n))
			}
		}

		Write !!,?4,"TOTAL FACTS",?50,$J($FN(tFactCount,",",0),18)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		Do $System.Status.DisplayError(tSC)
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetDimensionTables">
<Description><![CDATA[
Return an array of the dimension tables (class names) used for a given cube.
If <var>pCardinality</var> is true, compute the size of each table.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,*pStarTables,pCardinality:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pStarTables
		If (pCubeName="") {
			Write "No cube name specified",!
			Quit
		}
		Set tCube = $$$DeepSeeIndex(pCubeName)

		Set tStar = $O($$$DeepSeeMetaGLVN("cubes",tCube,"star",""))
		While (tStar'="") {
			Set tSize = 0
			If (pCardinality) {
				Set tSize = $Classmethod(tStar,"%Count")
			}
			Set pStarTables(tStar) = tSize
			Set tStar = $O($$$DeepSeeMetaGLVN("cubes",tCube,"star",tStar))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%BuildDimensionTableIndices">
<Description><![CDATA[
Rebuild the indices for every dimension table used for cube <var>pCubeName</var>.
If <var>pCubeName</var> is "*", then perform this on every cube within the current namespace
that is visible to the current user.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pCubeName="") {
			Write:pVerbose "No cube name specified",!
			Quit
		}

		If (pCubeName="*") {
			// get list of all cubes
			Set tSC = ..%GetCubeList(.tList,"cubes",1)
		}
		Else {
			Set tList(pCubeName) = ""
		}

		// loop over list
		Set tCubeName = $O(tList(""))
		While (tCubeName'="") {
			Write:pVerbose "Cube: ",tCubeName,!
			Set tSC = ..%GetDimensionTables(tCubeName,.tTables,1)
			If $$$ISERR(tSC) Quit
			Set k = $O(tTables(""))
			While (k'="") {
				Write:pVerbose k,"..."
				Do $classmethod(k,"%BuildIndices")
				Write:pVerbose " done",!
				Set k = $O(tTables(k))
			}
			Set tCubeName = $O(tList(tCubeName))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ReadFacts">
<Description>
Read portion of fact table into memory.
Used during index loading.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pStartId:%Integer,pEndId:%Integer</FormalSpec>
<Implementation><![CDATA[
	Set tCube = $$$UPPER(pCubeName)
	Set tFactClass = $$$UPPER(..%GetCubeFactClass(tCube))
	Set tID = $O($$$DeepSeeFactGLVN(tFactClass,pStartId),1,data)
	While ((tID '= "")&&(+tID < pEndId)) {
		Set tID = $O($$$DeepSeeFactGLVN(tFactClass,tID),1,data)
	}
]]></Implementation>
</Method>

<Method name="%CompressIndices">
<Description>
Loop over all indices for the given cube and compress them.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// DTB272 - Add Try/Catch block and return status
	Set tSC = $$$OK
	Try {
		Set tCube = $$$UPPER(pCubeName)
		If (tCube="") {
			Set tSC = $$$ERROR($$$GeneralError,"No cube name specified")
			Quit
		}
		If ('..%IsBaseCube(pCubeName)) {
			Set tSC = $$$ERROR($$$GeneralError,"%CompressIndices cannot be called on a SubjectArea: " _ pCubeName) 
			Quit
		}

		Set tIndex = $O($$$DeepSeeIndexGLVN(tCube,""))
		While (tIndex '= "") {
			// We assume that non-bitmap indices start with %
			If ($E(tIndex) = "$") {
			}
			ElseIf ($E(tIndex) = "%") {
				// non-dimension index
			}
			Else {
				If (pVerbose) Write $C(13,27)_"[0J"_"Compressing index: ",tIndex
				Set n = 0
				Set tValue = $O($$$DeepSeeIndexGLVN(tCube,tIndex,""))
				While (tValue '= "") {
					Set n = n + 1
					Write:(pVerbose&&'(n#100)) $C(13,27)_"[0J"_"Compressing index: ",tIndex," (",tValue,")"
					Set tChunk = $O($$$DeepSeeIndexGLVN(tCube,tIndex,tValue,""),1,data)
					While (tChunk '= "") {
						If ($BitCount(data,1)=0) {
							Kill $$$DeepSeeIndexGLVN(tCube,tIndex,tValue,tChunk)
						}
						Else {
							Set $$$DeepSeeIndexGLVN(tCube,tIndex,tValue,tChunk) = $BitLogic(data)
						}
						Set tChunk = $O($$$DeepSeeIndexGLVN(tCube,tIndex,tValue,tChunk),1,data)
					}
					Set tValue = $O($$$DeepSeeIndexGLVN(tCube,tIndex,tValue))
				}
			}
			Set tIndex = $O($$$DeepSeeIndexGLVN(tCube,tIndex))
		}
		If (pVerbose) Write $C(13,27)_"[0J"_"Complete"
	}
	Catch ex {
		Set tSC =ex.AsStatus()
	}

	If (pVerbose&&$$$ISERR(tSC)) Write $system.Status.GetOneStatusText(tSC),!		// DTB272 - Display any error message
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%DenormalizeType">
<Description>
Convert a class name of the form %Library.xxx to %xxx.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pType:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$S($E(pType,1,9)="%Library.":"%"_$P(pType,".",2,999),1:pType)
]]></Implementation>
</Method>

<Method name="%GetSQLTableName">
<Description><![CDATA[
Returns the SQL table name for class <var>pClass</var>. Returns the empty string if the supplied <var>pClass</var>
does not have an associated table.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String,pVerifyExists=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tTableName = $S(pClass="":"",1:$$$comClassKeyGet(pClass,$$$cCLASSsqlschemaname)_"."_$$$comClassKeyGet(pClass,$$$cCLASSsqltablename))
	If (tTableName=".") {
		Set tTableName = $Replace(pClass,".","_",,$length(pClass,".")-2)
	}
	
	Quit $S(('pVerifyExists||$system.SQL.TableExists(tTableName)):tTableName,1:"")		// DTB786 - Optionally verify the table does in fact exist
]]></Implementation>
</Method>

<Method name="%GetSQLColumnName">
<Description><![CDATA[
Returns the SQL name of property <var>pProp</var> for class <var>pClass</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String,pProp:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If (pProp = "") {
		Quit ""
	}
	ElseIf (pProp = "%ID") {
		Quit "%ID"
	}
	Set tCol = $Get($$$EXTPROPsqlcolumnname($$$pEXT,pClass,pProp))
	If (tCol'="") {
		Set x = $$QuoteId^%occStorageUtil(tCol,.tColQ)
		Set tCol = tColQ
	}
	Quit tCol
]]></Implementation>
</Method>

<Method name="%GetCubeList">
<Description><![CDATA[
Return an <b>array</b> of all currently defined DeepSee Cubes visible to the current user.
This is used by utilities.<br/>
This array takes the form:<br/>
pList(NAME) = $LB(name,caption,moddate,type)<br/>
<var>pType</var>, if defined, can be "cubes" or "subjectAreas". This will limit the returned
list to those item types.<br/>
<var>pNonAbstract</var>, if true, limits the returned items to non-abstract cubes.<br/>
<var>pBaseCube</var>, if provided, limits the returned items to the base cube and its descendants.<br/>
If there are no cubes, then <var>pList</var> will be <b>undefined</b>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pList,pType:%String="",pNonAbstract:%Boolean=0,pBaseCube:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pList
	Set tIsCube = 1
	Set tCube = $O($$$DeepSeeMetaGLVN("cubes",""))
	While (tCube '= "") {
		Set tIsVersion = ##class(%DeepSee.CubeVersion.Utils).%IsVersion(tCube)		// DTB130 - don't include internal version cubes in the list
		If (..%CheckPrivilege(tCube)&&'tIsVersion) {
			Set tIsCube = ..%IsBaseCube(tCube)
			If (pNonAbstract && tIsCube && ..%IsCubeAbstract(tCube)) {
				// skip
			}
			Else {
				If ((pType="")||((pType="cubes")&&tIsCube)||((pType="subjectAreas")&&'tIsCube)) {
					// JMD900: test base cube
					If ((pBaseCube="")||(pBaseCube=tCube)||($$$UPPER(..%GetBaseCube(tCube))=$$$UPPER(pBaseCube))) {
						// get original cube name (plus type extension)
						Set tType = $S(tIsCube:"cube",1:"subjectArea")
						Set pList(tCube) = $LB(..%GetCubeName(tCube),..%GetCubeCaption(tCube),..%GetCubeModifiedDate(tCube),tType)
					}
				}
			}
		}
		Set tCube = $O($$$DeepSeeMetaGLVN("cubes",tCube))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetCubeListArray">
<Description><![CDATA[
Return an array of all currently DeepSee Cubes and subject areas
in a format that can be used by a finderDialog.
<var>pType</var>, if defined, can be "cubes" or "subjectAreas". This will limit the returned
list to those item types.
<var>pNonAbstract</var>, if true, limits the returned items to non-abstract cubes.]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pParameters,*pMetaData,*%pData,pType:%String="",pNonAbstract:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// These are the names of the returned properties
		Set pMetaData = $LB("name","value","type","date","caption")

		Set tSC = ..%GetCubeList(.tList,pType,pNonAbstract)
		If $$$ISERR(tSC) Quit

		Set tSC = ..%BuildItemListArray(.tList, .pMetaData, .%pData,.pParameters)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetPivotListArray">
<Description>
Return an array of all currently defined DeepSee Pivots
in a format that can be used by a finderDialog.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pParameters,*pMetaData,*%pData]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// These are the names of the returned properties
		Set pMetaData = $LB("name","value","type","date","caption")

		Set tSC = ..%GetPivotList(.tList)
		If $$$ISERR(tSC) Quit

		Set tSC = ..%BuildItemListArray(.tList, .pMetaData, .%pData,.pParameters)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetDashboardListArray">
<Description>
Return an array of all currently defined DeepSee dashboards
in a format that can be used by a finderDialog.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pParameters,*pMetaData,*%pData]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// These are the names of the returned properties
		Set pMetaData = $LB("name","value","type","date","caption")

		Set tSC = ..%GetDashboardList(.tList)
		If $$$ISERR(tSC) Quit

		Set tSC = ..%BuildItemListArray(.tList, .pMetaData, .%pData,.pParameters)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetKPIListArray">
<Description>
Return an array of all currently defined, public DeepSee KPIs
in a format that can be used by a finderDialog.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pParameters,*pMetaData,*%pData]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// These are the names of the returned properties
		Set pMetaData = $LB("name","value","type","date","caption")

		Set tSC = ..%GetKPIList(.tList)
		If $$$ISERR(tSC) Quit

		Set tSC = ..%BuildItemListArray(.tList, .pMetaData, .%pData,.pParameters)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetWorksheetListArray">
<Description>
Return an array of all currently defined DeepSee Worksheets
in a format that can be used by a finderDialog.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pParameters,*pMetaData,*%pData]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// These are the names of the returned properties
		Set pMetaData = $LB("name","value","type","date","caption")

		Set tSC = ..%GetWorksheetList(.tList)
		If $$$ISERR(tSC) Quit

		Set tSC = ..%BuildItemListArray(.tList, .pMetaData, .%pData,.pParameters)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetMetricListArray">
<Description>
Return an array of all currently defined Business Metrics
in a format that can be used by a finderDialog.</Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pParameters,*pMetaData,*%pData]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// These are the names of the returned properties
		Set pMetaData = $LB("name","value","type","date","caption")

		Set tSC = ..%GetMetricList(.tList)
		If $$$ISERR(tSC) Quit

		Set tSC = ..%BuildItemListArray(.tList, .pMetaData, .%pData,.pParameters)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%BuildItemListArray">
<Description><![CDATA[
Helper method.
Convert the items in <var>pList</var> into an array that can be used by a finderDialog.]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pList,*pMetaData,*%pData,&pParameters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define timeUTCHtoLocal(%utc) $zu(193,%utc,0)
	Set tSC = $$$OK
	Try {
		// These are the names of the returned properties
		Set pMetaData = $LB("name","value","type","date","caption")
		Set tSearch = $$$UPPER($G(pParameters("search")))
		// + WAL078
		Set tOrderByCaption = $G(pParameters("orderByCaption"))
		// - WAL078
		// separator character within names
		Set tSep = "/"

		Set tItem="" For  {
			Set tItem = $O(pList(tItem)) Quit:tItem=""

			// get values
			Set tName = $LG(pList(tItem),1)
			Set tCaption = $LG(pList(tItem),2)
			Set:tCaption["$$$" tCaption = ##class(%DeepSee.UserPortal.Utils).%ResolveText($TR(tCaption,"#","/"))

			// apply search to caption
			Set tSkip = 0
			If ((tSearch'="")&&($$$UPPER(tCaption)'[tSearch)) {
				Set tSkip = 1
			}

			If ('tSkip) {
				Set h = $LG(pList(tItem),3)
				Set:h="" h = $H // default to today
				// convert to local time
				Set h = $$$timeUTCHtoLocal(h)
				Set tTime = $ZDT(h,3)
				Set tItemType =	 $LG(pList(tItem),4)

				// apply pParameters("sort") criteria
				If $g(pParameters("sort"))="date" {
					If $d(tBucketINDEX)=0 {
						Set tBucketNAME(-4)=$$$Text("Today","%ZEN")
						Set tBucketNAME(-3)=$$$Text("Yesterday","%ZEN")
						Set tBucketNAME(-2)=$$$Text("Earlier this week","%ZEN")
						Set tBucketNAME(-1)=$$$Text("Last week","%ZEN")
						Set tBucketNAME(0)=$$$Text("Older than last week","%ZEN")
						Set tTodayH=$p($H,",",1),tLastSatH=tTodayH-$zdt(tTodayH,10)-1
						Set tBucketINDEX(tTodayH)=-4
						If tTodayH-1>tLastSatH Set tBucketINDEX(tTodayH-1)=-3
						For tH=tTodayH-2:-1:tLastSatH+1 Set tBucketINDEX(tH)=-2
						For tH=tLastSatH:-1:tLastSatH-6 Set tBucketINDEX(tH)=-1
					}
					Set tBucketIndex=+$get(tBucketINDEX($p($zdth(tTime,3),",",1)))
					Set tBucketName=tBucketNAME(tBucketIndex)
					Set tTempData(tBucketIndex)=$lb(tBucketName,tBucketName,"date","","","")
					Set tTempData(tBucketIndex,tTime,$i(tTempData(tBucketIndex,tTime)))=$lb(tName,tName,tItemType,##class(%ZEN.FinderUtils).mactime(tTime),tCaption)
				} Else {
					Set tRef="%pData(",tLength=$l(tName,tSep)
					For i=1:1:tLength {
						Set tType=$S(i=tLength:tItemType,1:"folder")
						// + WAL078 -- If its requested that we order by caption prefix the index (tName) with the caption
						//             (i=tLength) prevents us from ordering folders by their item captions
						//   DTB804 - Double-quotes existing in the caption must be escaped for the indirection to work
						Set tRef = tRef_""""_$zcvt($S((tOrderByCaption&&(i=tLength)&&($G(tCaption)'="")):$$$iscEscapeDblQuote(tCaption),1:""),"u")_$zcvt($p(tName,tSep,i),"u")_"."_tType_""","
						// - WAL078
						Set tRefSetLeft=$e(tRef,1,*-1)_")"
						Set tDName = $p(tName,tSep,i)
						Set:tDName["$$$" tDName = ##class(%DeepSee.UserPortal.Utils).%ResolveText($TR(tDName,"#","/"))
						Set @tRefSetLeft=$lb(tDName,$p(tName,tSep,1,i),tItemType,##class(%ZEN.FinderUtils).mactime(tTime),tCaption)
					}
				}
			}
        }
        // Convert tTempData(A,B,C) to %pData(A,i++) with B sorted backwards
		If $d(tTempData) {
			Set i="" For  {
				Set i=$o(tTempData(i)) Quit:i=""
				Set %pData(i)=tTempData(i)
				Set index=0
				Set j="" for  {
					Set j=$o(tTempData(i,j),-1) Quit:j=""
					Set k="" for  {
						Set k=$o(tTempData(i,j,k)) Quit:k=""
						Set %pData(i,$i(index))=tTempData(i,j,k)
					}
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetFunctionList">
<Description><![CDATA[
Return a list of all currently defined MDX functions.
This is used by utilities.<br/>
If <var>pAsTree</var> is true, return a format that a tree control can consume.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pList,pAsTree:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// make sure global is defined
	Set tSC = ##class(%DeepSee.Query.setFunction).%BuildFunctionMetaData()
	Set tSC = ##class(%DeepSee.Query.memberFunction).%BuildFunctionMetaData()

	// mark some functions as hidden
	Set tHidden("%ADDPARENTS") = ""
	Set tHidden("%CELL") = ""
	Set tHidden("%CELLZERO") = ""
	Set tHidden("%RANK") = ""
	Set tHidden("%CHILDRENORSELF") = ""

	Kill pList

	If (pAsTree) {
		Set tSetRoot = 1
		Set tMbrRoot = 2
		Set pList(0,"ch",tSetRoot) = ""
		Set pList(tSetRoot) = $LB($$$Text("Set functions","%DeepSee"),"",1,"",1,,$$$Text("Dimensions","%DeepSee"),"font-weight:bold;")
		Set pList(0,"ch",tMbrRoot) = ""
		Set pList(tMbrRoot) = $LB($$$Text("Member functions","%DeepSee"),"",1,"",1,,$$$Text("Measures","%DeepSee"),"font-weight:bold;")
		Set pList = 2
	}

	Set tCat = $O($$$DeepSeeFunctionGLVN(""))
	While (tCat '= "") {
		Set tFunc = $O($$$DeepSeeFunctionGLVN(tCat,""),1,tInfo)
		While (tFunc '= "") {
			Set tImplemented = $LG(tInfo,1)
			Set tReturns = $LG(tInfo,2)
			Set tArgTypes = $LG(tInfo,3)
			Set tArgDesc = $LG(tInfo,4)

			If (tImplemented && '$D(tHidden(tFunc))) {
				Set tArgs = ""
				Set tOptArgs = 0
				For n=$S(tCat="mbr":2,1:1):1:$LL(tArgTypes) {
					Set tIsOpt = $P($LG(tArgDesc,n),":")=0
					Set:tIsOpt tOptArgs = tOptArgs + 1
					If ($LG(tArgTypes,n)=$$$dstFlag) {
						Set tArgName = $TR($P($LG(tArgDesc,n),":",2),",","|")
					}
					Else {
						Set tArgName = ##class(%DeepSee.Query.function).%TypeFlagToString($LG(tArgTypes,n))
					}
					Set tArgs = tArgs _ $S(tArgs'="":",",1:"") _ $S(tIsOpt:"[",1:"") _ tArgName
				}
				Set:tArgs'="" tArgs = "("_tArgs_$TR($J("",tOptArgs)," ","]")_")"

				If (tCat = "mbr") {
					Set tSig = ##class(%DeepSee.Query.function).%TypeFlagToString($LG(tArgTypes,1)) _ "."_tFunc _ tArgs _ " returns " _ ##class(%DeepSee.Query.function).%TypeFlagToString(tReturns)
				}
				Else {
					Set tSig = tFunc_tArgs _ " returns " _ ##class(%DeepSee.Query.function).%TypeFlagToString(tReturns)
				}
				If (pAsTree) {
					Set pList($I(pList)) = $LB(tFunc,tFunc,0,"",0,,tSig)
					Set pList($Case(tCat,"mbr":tMbrRoot,:tSetRoot),"ch",pList) = ""
				}
				Else {
					Set pList(tFunc) = tSig
				}
			}
			Set tFunc = $O($$$DeepSeeFunctionGLVN(tCat,tFunc),1,tInfo)
		}
		Set tCat = $O($$$DeepSeeFunctionGLVN(tCat))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%TestTimeClass">
<Description><![CDATA[
This utility method tests a DeepSee time level class to
verify that it is implemented correctly.<br/>
There are several tests:<br/>
Test 1: test the %Convert, %KeyToValue, and %ValueToKey methods.<br/>
Test 2: test the %Convert, %KeyToValue, and %ValueToKey methods.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String,pTest:%Integer=1,pFormat:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// !!! TEST GETLEVELMEMBERS
	
	Set tSC = $$$OK
	Try {
		// See if class exists
		Set tName = $zobjclassmethod(pClassName,"%GetName")
		Set:tName="" tName = "[Name not defined]"
		Write "Level name: ",tName,!
	
		// build a range of dates
		For n = 1:1:10 {
			Set h = $ZDTH("1900-01-01",3) + (n*455) _ "," _ $R(86400)
			Set tDates(h) = ""
		}

		If (pTest = 1) {
			// convert test
			Write "Logical Value is provided by %Convert method",!
			Write "Display Value is provided by %KeyToValue method on the logical value",!
			Write "Key Value is provided by %ValueToKey method on the display value",!

			Write "-------------------------------",!
			Write "Time",?20,"Logical",?30,"Display",?45,"Key",!

			Set h = $O(tDates(""))
			While (h'="") {
				Set tErr = ""
				Set tConvert = $zobjclassmethod(pClassName,"%Convert",h)
				Set tValue = $zobjclassmethod(pClassName,"%KeyToValue",tConvert,pFormat)
				Set tKey = $zobjclassmethod(pClassName,"%ValueToKey",tValue,pFormat)
				If (tKey'=tConvert) {
					Set tErr = "(Logical != Key)"
				}
			
				Write $E($ZDT(h,6),1,11),?13,$E($ZDT(h,3),12,13),":",
					?20,tConvert,?30,tValue,?45,tKey
				If (tErr'="") {
					Write ?62,tErr
				}

				Write !
				Set h = $O(tDates(h))
			}
			// make sure test for invalid member fails!!!
			Set tValue = "Members"
			Set tKey = $zobjclassmethod(pClassName,"%ValueToKey",tValue,pFormat)
			If (tKey '= "") {
				Write "Error: %ValueToKey should return """" for invalid member: ",tValue,"(",tKey,")",!
			}


		}
		ElseIf (pTest = 2) {
			// range test
			Write "-------------------------------",!
			Write "The %KeyToBaseRange method finds the starting and ending",!
			Write "time (as $H) for a given logical value.",!
			Write "Time",?15,"Logical",?25,"Start",?45,"End",!

			Set h = $O(tDates(""))
			While (h'="") {
				Set tErr = ""
				Set tConvert = $zobjclassmethod(pClassName,"%Convert",h)

				Set tSC = $zobjclassmethod(pClassName,"%KeyToBaseRange",tConvert,.tStartRange,.tEndRange)
				If $$$ISERR(tSC) Quit
			
				Write $E($ZDT(h,6),1,11),":",
					?15,tConvert,?25,$ZDT(tStartRange,3),?45,$ZDT(tEndRange,3)
				If (tErr'="") {
					Write ?60,tErr
				}

				Write !
				Set h = $O(tDates(h))
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	If $$$ISERR(tSC) {
		Do $System.OBJ.DisplayError(tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%LoadCellCache">
<Description>
Compute pre-loaded cell cache entries for the given cube
based on the cell cache specification within the cube's definition.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tClassName = ..%GetCubeClass(pCubeName,.tSC)
		If $$$ISERR(tSC) Quit

		Set tSC = $zobjclassmethod(tClassName,"%GetCellCachePreLoads",.tList)
		If $$$ISERR(tSC) Quit

		Set n = $O(tList(""))
		While (n '= "") {
			Kill tSpec
			Merge tSpec = tList(n)
			Set tSC = ..%ComputeCellCache(pCubeName,.tSpec)
			Set n = $O(tList(n))
		}

	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ComputeCellCache">
<Description>
Generate and execute a query that will force the update of the
cell cache for given cube and levels.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCubeName:%String,&pSpec]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tAxisCount = 0
		Set tMsrCount = 0

		Set tSpec = $O(pSpec(""))
		While (tSpec '= "") {
			Set tFact = pSpec(tSpec)
			If ($E(tFact) = "M") {
				Set tMsrCount = tMsrCount + 1
				Set tMsr(tMsrCount) = tSpec
			}
			Else {
				Set tAxisCount = tAxisCount + 1
				Set tAxis(tAxisCount) = tSpec
			}
			Set tSpec = $O(pSpec(tSpec))
		}

		// construct query
		Set tMDX = "SELECT "
		For a=1:1:tAxisCount {
			If (a < 6) {
				Set tMDX = tMDX _ $S(a>1:",",1:"") _ tAxis(a) _ ".Members ON " _ (a-1)
			}
		}

		// add measures (if any)
		If ((tAxisCount>0)&&(tMsrCount>0)) {
			Set tMDX = tMDX _ ","
		}
		If (tMsrCount>1) {
			Set tMDX = tMDX _ "{"
		}
		For m=1:1:tMsrCount {
			Set tMDX = tMDX _ $S(m>1:",",1:"") _ tMsr(m)
		}
		If (tMsrCount>1) {
			Set tMDX = tMDX _ "}"
		}
		If (tMsrCount>0) {
			Set tMDX = tMDX _ " ON " _ tAxisCount
		}

		Set tMDX = tMDX _ " FROM " _ pCubeName
		
		Set tRS = ##class(%DeepSee.ResultSet).%New()
		Set tRS.%UseCache = 0
		Set tSC = tRS.%PrepareMDX(tMDX)
		If $$$ISERR(tSC) Quit

		// DTB704 - Always use %ExecuteAsynch
		Set tSC = tRS.%ExecuteAsynch(.tQueryKey)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ParseRangeExpression">
<Description><![CDATA[
Parse the given DeepSee range expression.<br/>
A range expression takes the form:<br/>
spec:replace;spec:replace;<br/>
spec takes the form:<br/>
value | (value,value) | [value,value] <br/>
() specifies a non-inclusive edge of a range.<br/>
[] specifies a inclusive edge of a range.<br/>
<var>pContext</var> is used for error reporting.
<var>pCode</var> contains a generated expression that 
implement the range expression (using x as an input value).]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRange:%String,*pOutput,pContext:%String="",*pCode:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pCode = ""
		Kill pOutput
		Set tItem = 0
		Set tState = 0
		Set p = 1
		Set tToken = ""
		Set tIsRange = 0
		Set tValueInc = ""
		Set tIsMultiRange = 0
		While ($$$ISOK(tSC) && (p <= $L(pRange))) {
			Set ch = $E(pRange,p)
			Set p = p + 1
			If (tState = 0) {
				If ((ch = "(")||(ch = "[")) {
					Set tIsRange = 1
					Set tStartCond = $Case(ch,"(":">",:">=")
					Set tToken = ""
					Set tState = 2
				}
				ElseIf (ch=";") {
					// ignore
				}
				ElseIf (ch'=" ") {
					Set tIsRange = 0
					Set tStartCond = "="
					Set tEndCond = ""
					Set tToken = ch
					Set tState = 1
				}
			}
			ElseIf (tState = 1) {
				If (ch=":") {
					Set tValue1 = tToken
					Set tToken = ""
					Set tState = 5
					Set tQuoted = 0
				}
				Else {
					Set tToken = tToken _ ch
				}
			}
			ElseIf (tState = 2) {
				// first part of range
				If (ch=",") {
					Set tValue1 = tToken
					Set tToken = ""
					Set tState = 3
				}
				ElseIf ((ch = ")")||(ch = "]")) {
					// error
					Set tSC = $$$ERROR($$$GeneralError,"Range expression must have 2 values"_pContext)
				}
				ElseIf (ch=":") {
					// This is a multi-range expression
					Set tValue1 = tToken
					Set tToken = ""
					Set tState = 31
					//Set tSC = $$$ERROR($$$GeneralError,"Range expression not closed"_pContext)
				}
				Else {
					Set tToken = tToken _ ch
				}
			}
			ElseIf (tState = 3) {
				// second part of range
				If ((ch = ")")||(ch = "]")) {
					Set tEndCond = $Case(ch,")":"<",:"<=")
					Set tValue2 = tToken
					Set tToken = ""
					Set tState = 4
				}
				ElseIf (ch=",") {
					// error
					Set tSC = $$$ERROR($$$GeneralError,"Range expression must have 2 values"_pContext)
				}
				ElseIf (ch=":") {
					// error
					Set tSC = $$$ERROR($$$GeneralError,"Range expression not closed"_pContext)
				}
				Else {
					Set tToken = tToken _ ch
				}
			}
			ElseIf (tState = 31) {
				// Second part of multi-range
				// wait for :
				If ((ch = ")")||(ch = "]")) {
					Set tSC = $$$ERROR($$$GeneralError,"Multi-Range expression must have 3 values"_pContext)
				}
				ElseIf (ch=",") {
					// error
					Set tSC = $$$ERROR($$$GeneralError,"Invalid Multi-Range Expression"_pContext)
				}
				ElseIf (ch=":") {
					Set tValueInc = tToken
					Set tToken = ""
					Set tState = 32
				}
				Else {
					Set tToken = tToken _ ch
				}
			}
			ElseIf (tState = 32) {
				// Third part of multi-range
				// wait for 0 or ]
				If ((ch = ")")||(ch = "]")) {
					Set tEndCond = $Case(ch,")":"<",:"<=")
					Set tValue2 = tToken
					Set tToken = ""
					Set tState = 4
					Set tIsMultiRange = 1
				}
				ElseIf (ch=",") {
					// error
					Set tSC = $$$ERROR($$$GeneralError,"Invalid Multi-Range Expression"_pContext)
				}
				ElseIf (ch=":") {
					// error
					Set tSC = $$$ERROR($$$GeneralError,"Invalid Multi-Range Expression"_pContext)
				}
				Else {
					Set tToken = tToken _ ch
				}
			}
			ElseIf (tState = 4) {
				// wait for : after range spec
				If (ch = ":") {
					Set tState = 5
					Set tQuoted = 0
				}
			}
			ElseIf (tState = 5) {
				// get replace value
				If ((ch = """") && (tToken="")) {
					Set tQuoted = 1
				}
				ElseIf ((ch = """") && (tQuoted)) {
					Set tQuoted = 0
				}
				ElseIf ('tQuoted&&(ch = ";")) {
					if (tIsMultiRange) {
						For t1=tValue1:tValueInc:tValue2 {
							Quit:t1=tValue2
							Set tReplace = tToken
							Set tItem = tItem + 1
							Set t2 = t1 + tValueInc
							If (t1=tValue1) {
								Set tLeftCond = tStartCond
							}
							Else {
								Set tLeftCond = ">="
							}
							If (t2=tValue2) {
								Set tRightCond = tEndCond
							}
							Else {
								Set tRightCond = "<"
							}
							Set tReplace = $replace(tReplace,"%1",t1)
							Set tReplace = $replace(tReplace,"%2",t2)
							If (tReplace["$$$eval") {
								Set tSC = ..%ExpandRangeMacro(.tReplace,"$$$eval",pContext)
								Quit:$$$ISERR(tSC)
							}
							Set pOutput(tItem) = $LB(1,tLeftCond,t1,tRightCond,t2,tReplace)
						}
						Set tIsMultiRange = 0
					} Else {
						Set tReplace = tToken
						Set tItem = tItem + 1
						Set pOutput(tItem) = $LB(tIsRange,tStartCond,tValue1,tEndCond,tValue2,tReplace)
					}
					Set tState = 0
				}
				Else {
					Set tToken = tToken _ ch
				}
			}
		}

		If ($$$ISOK(tSC) && (tState '= 0)) {
			Set tSC = $$$ERROR($$$GeneralError,"Range expression must end with ;"_pContext)
		}
		If $$$ISERR(tSC) Quit

		// create code
		// JMD1408: add initial test for ""
		Set pCode = "$S((x=""""):"""","
		For n = 1:1:tItem {
			Set tExpr = ""
			Set tIsRange = +$LG(pOutput(n),1)
			Set tStartCond = $LG(pOutput(n),2)
			Set tValue1 = $LG(pOutput(n),3)
			Set tEndCond = $LG(pOutput(n),4)
			Set tValue2 = $LG(pOutput(n),5)
			Set tReplace = $LG(pOutput(n),6)
			If ('tIsRange) {
				Set tExpr = "x=" _ $$$quote(tValue1)
			}
			Else {
				If (tValue1'="") {
					Set tExpr = "(x" _ tStartCond _ $$$quote(tValue1)_ ")"
				}
				If (tValue2'="") {
					Set tExpr = tExpr _ $S(tExpr="":"",1:"&&") _ "(x" _ tEndCond _ $$$quote(tValue2) _ ")"
				}
			}

			If (tExpr'="") {
				Set pCode = pCode _ tExpr _ ":" _ $$$quote(tReplace) _ ","
			}
		}
		Set pCode = pCode _ "1:"""")"
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ExpandRangeMacro">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pReplace:%String,pExp:%String,pContext:%String=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tP1,tP2,tExpIdx,tN,i,ch,tStatement
	
	set tExpIdx = $f(pReplace,pExp)
	set tP1 = $f(pReplace,"(",tExpIdx)
	Quit:tP1=0 $$$ERROR($$$GeneralError,"Macro"_pExp_" is without opening parenthesis: "_pReplace_pContext)
	
	set tN=1
	set tP2 = 0
	for i=tP1:1:$l(pReplace) {
		set ch = $e(pReplace,i)
		if (ch="(") {
			set tN = tN + 1
		}
		ElseIf (ch=")") {
			set tN = tN - 1
			if (tN=0) {
				set tP2 = i
				Quit
			}
		}
	}
	
	Quit:tP2=0 $$$ERROR($$$GeneralError,"Macro"_pExp_" is not closed: "_pReplace_pContext)
	
	Set tStatement = "set %xxx="_$e(pReplace,tP1,tP2-1)
	x tStatement
	Set tExpIdx = tExpIdx - $l(pExp)
	
	set $e(pReplace,tExpIdx,tP2) = %xxx
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%KillLogFile">
<Description>
Delete the given DeepSee log file.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileName:%String="DeepSeeTasks"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill ^DeepSee.LastLogError
		Set tFile = ##class(%Library.File).NormalizeFilename($system.Util.ManagerDirectory() _ pFileName _ "_" _ $namespace _ ".log")
		Lock +^DeepSee.Log(tFile):5 Else   Set tSC=$$$ERROR($$$GeneralError,"Unable to get lock for log file")
		If $$$ISOK(tSC),##class(%Library.File).Exists(tFile) {
			Set tOK = ##class(%Library.File).Delete(tFile)
			If 'tOK {
				Set tSC = $$$ERROR($$$GeneralError,"Unable to delete file: "_tFile)
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $get(tFile)'="" Lock -^DeepSee.Log(tFile)#"I"
	Quit tSC
]]></Implementation>
</Method>

<Method name="%WriteToLog">
<Description><![CDATA[
Appends an error message to a DeepSee log file within the log directory. This method uses
locks to support simultaneous updates from from multiple processes.<br/>
<var>pSource</var> is the source of the error.<br/>
<var>pMsg</var> is the error message.<br/>
<var>pFileName</var> is the name of the log file.
This should not include a file path or file extension.<br/>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSource:%String="",pMsg:%String="",pFileName:%String="DeepSeeTasks"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tLocked = 0
	Try {
		// Put file in mgr directory
		// append namespace to file name
		Set tFile = ##class(%Library.File).NormalizeFilename($system.Util.ManagerDirectory() _ pFileName _ "_" _ $namespace _ ".log")
		Set io = $io
		Lock +^DeepSee.Log(tFile):5 Else   Set tSC=$$$ERROR($$$GeneralError,"Unable to get lock for log file")
		If $$$ISERR(tSC) Quit
		Set tLocked = 1
		// See if the file exists, if not we are the first to create it an need to set the attributes properly so others can write to it also
		set tFileExisted = ##class(%Library.File).Exists(tFile)
		Open tFile:"WSA":0 Else  Set tSC=$$$ERROR($$$FileCanNotOpen,tFile)
		If $$$ISERR(tSC) Quit
		Use tFile
		Set tTime = $zdatetime($ZU(188),3,,3)			// DTB332 - Use $ZU function which accounts for local time
		Write tTime," ",$J($J,10)," ",$J($E(pSource,1,10),10)," ",pMsg,!
		Use io
		Close tFile
		If 'tFileExisted {
				// chmod owner=rw,group=rw,others=rw
			If $$$ISUNIX Do ##class(%File).SetAttributes(tFile,256+128+32+16+4+2)
		}

		// test for file rollover (within lock)
		If (##class(%Library.File).GetFileSize(tFile)>5000000) {
			Set tRolloverFile = ##class(%Library.File).NormalizeFilename($system.Util.ManagerDirectory() _ pFileName _ "_" _ $namespace _ ".old")
			Do ##class(%Library.File).CopyFile(tFile,tRolloverFile,1)
			Do ..%KillLogFile(pFileName)
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
		Use io
	}
	If ($G(tLocked)) {
		Lock -^DeepSee.Log(tFile)#"I"
		Close tFile
	}
	If $$$ISERR(tSC) {
		// Note this error in a global
		Set ^DeepSee.LastLogError = $System.Status.GetOneErrorText(tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetLogFileName">
<Description>
Return the full name of a DeepSee log file.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileName:%String="DeepSeeTasks"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ##class(%Library.File).NormalizeFilename($system.Util.ManagerDirectory() _ pFileName _ "_" _ $namespace _ ".log")
]]></Implementation>
</Method>

<Method name="%GetDataSourceTree">
<Description><![CDATA[
Return the properties of a cube data source in a format that can be consumed
by a Zen dynaTree control.<br/>
<var>pRoot</var> is used to specify that an incremental load of children is requested; if provided it is the spec of a parent node.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClass:%String,*pTree,&pParms,pLevel:%Integer=0,pParentRef:%String="",pRoot:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pClass = "") {
			If (pLevel = 0) {
				Set n = $I(pTree)
				Set pTree(n) = $LB($$$Text("No Data Source","%DeepSee"),"",0,,,,,"color:red;")
				Set pTree(0,"ch",n) = ""
			}
			Quit
		}

		// special case: test for worksheets and kpis
		Set tExt = $P(pClass,".",$L(pClass,"."))
		If ((tExt="kpi")||(tExt="metric")||(tExt="worksheet")) {
			If (tExt="kpi") {
				Set tName = $P(pClass,".",1,$L(pClass,".")-1)
				Set tKPIClass = ##class(%DeepSee.Utils).%GetKPIClass(tName)
				Set tName = ""
			}
			ElseIf (tExt="worksheet") {
				Set tName = pClass
				Set tKPIClass = "%DeepSee.KPIWorksheet"
			}
			Else {
				Set tName = pClass
				Set tKPIClass = "Ens.BusinessMetricKPI"
			}

			New %datacontroller
			Set tCriteria = ##class(%ZEN.proxyObject).%New()
			Set tSC = ##class(%DeepSee.AbstractKPI).%CreateLocalController(.tController,tKPIClass,tName,tCriteria)
			If $$$ISERR(tSC) Quit
			Set %datacontroller = tController

			Set tSC = tController.%GetModelPropertyInfo(.tPropInfo)
			If $$$ISERR(tSC) Quit

			// sort prop info; remove % properties
			Set tProp = $O(tPropInfo(""))
			While (tProp'="") {
				If (tProp '[ "%") {
					Set tInfo(tPropInfo(tProp)) = tProp
				}
				Set tProp = $O(tPropInfo(tProp))
			}

			Set k = $O(tInfo(""))
			While (k'="") {
				Set n = $I(pTree)
				Set tName = tInfo(k)
				Set tDisplayName = tName
				Set pTree(n) = $LB(tDisplayName,tName)
				Set pTree(0,"ch",n) = ""
				Set k = $O(tInfo(k))
			}
			Quit
		}

		If '$$$defClassDefined(pClass) {
			If (pLevel = 0) {
				Set n = $I(pTree)
				Set pTree(n) = $LB($$$FormatText($$$Text("Class not found '%1'","%DeepSee"),pClass),"",0,,,,,"color:red;")
				Set pTree(0,"ch",n) = ""
			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"Class not found: "_pClass)
			}
			Quit
		}

		If '$$$comClassDefined(pClass) {
			If (pLevel = 0) {
				Set n = $I(pTree)
				Set pTree(n) = $LB($$$FormatText($$$Text("Class not compiled '%1'","%DeepSee"),pClass),"",0,,,,,"color:red;")
				Set pTree(0,"ch",n) = ""
			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"Class not compiled:"_pClass)
			}
			Quit
		}

		If (pRoot '= "") {
			// incremental load of children
			// follow chain in pRoot
			Set tPropName = ""
			Set tType = pClass
			For p=1:1:$L(pRoot,".") {
				Set tPropName = $P(pRoot,".",p)
				Set tType = $$$comMemberKeyGet(tType,$$$cCLASSproperty,tPropName,$$$cPROPtype)
			}
			Set tRef = pParentRef _ $S(pParentRef="":"",1:".") _ pRoot
			Set tSC = ..%GetDataSourceTree(tType, .pTree, .pParms, pLevel + 1,tRef)
			If $$$ISERR(tSC) Quit
			Quit
		}

		Set tClsType = $$$getClassType(pClass)
		Set tTopNode = ""
		Set tTopHasChildren = 0
		If (pLevel = 0) {
			// Add class to top of tree

			// check type of class
			If (tClsType '= "persistent") {
				// see if this is a DataConnector
				If ('$zobjclassmethod(pClass,"%IsA","%DeepSee.DataConnector")) {
					Set n = $I(pTree)
					Set pTree(n) = $LB($$$FormatText($$$Text("Data source must be persistent: '%1'","%DeepSee"),pClass),"",0,,,,,"color:red;")
					Set pTree(0,"ch",n) = ""
					Quit
				}
				Else {
					// Ask data connector for list of properties
					Set tSC = $zobjclassmethod(pClass,"%GetPropertyInfo",.tPropInfo)
					If $$$ISERR(tSC) Quit

					Set k = $O(tPropInfo(""))
					While (k'="") {
						Set n = $I(pTree)
						Set tName = $LG(tPropInfo(k),1)
						Set tDisplayName = $LG(tPropInfo(k),2)
						Set pTree(n) = $LB(tDisplayName,tName)
						Set pTree(0,"ch",n) = ""
						Set k = $O(tPropInfo(k))
					}

					Quit
				}
			}

			Set n = $I(pTree)
			Set tTopNode = n
			Set tExpanded = 1
			Set pTree(n) = $LB(pClass,"",tTopHasChildren,,tExpanded)
			Set pTree(0,"ch",n) = ""
		}

		Set tRootNo = +$G(pTree)
		If (tClsType = "persistent") {
			// Add %ID to list of properties
			Set n = $I(pTree)
			Set tRef = pParentRef _ $S(pParentRef="":"",1:".") _ "%ID"
			Set pTree(n) = $LB("%ID",tRef,0)
			Set pTree(tRootNo,"ch",n) = ""
			Set tTopHasChildren = 1
		}

		Set tRS = ##class(%ResultSet).%New("%Dictionary.CompiledClass.MemberSummary")
		Set tSC = tRS.%Execute(pClass,"a")
		Set tClassDef = ##class(%Dictionary.CompiledClass).%OpenId(pClass)
		Set tRow = 0
		While (tRS.Next()) {
			Set tRow = tRow+1
			Set tPropName = tRS.Data("Name")
			// Get info on the property
			Set tType = $$$comMemberKeyGet(pClass,$$$cCLASSproperty,tPropName,$$$cPROPtype)
			Set tPrivate = +$$$comMemberKeyGet(pClass,$$$cCLASSproperty,tPropName,$$$cPROPprivate)
			Set tTransient = +$$$comMemberKeyGet(pClass,$$$cCLASSproperty,tPropName,$$$cPROPtransient)
			Set tSqlComputed = +$$$comMemberKeyGet(pClass,$$$cCLASSproperty,tPropName,$$$cPROPsqlcomputed)
			$$$comMemberArrayGetLvar(tCaption,pClass,$$$cCLASSproperty,tPropName,$$$cXXXXparamvalue,"CAPTION")		// DTB541 - Look for a class-defined default caption for this property
			
			If 'tPrivate {
				if 'tTransient || ( tTransient && tSqlComputed) {
					Set tClsType = $$$getClassType(tType)
					Set tRef = pParentRef _ $S(pParentRef="":"",1:".") _ tPropName // _ ";" _ $S((tCaption'=""):"$$$CAPTION:"_tCaption,1:"")		// DTB541 - Send the default caption along with the value

					Set n = $I(pTree)
					Set pTree(n) = $LB(tPropName,tRef,0,,,,$S(tCaption'="":tCaption,1:tPropName))		// DTB541
					Set pTree(tRootNo,"ch",n) = ""
					Set tTopHasChildren = 1

					If ((tClsType = "persistent")||(tClsType = "serial")) {
						// mark that there are child nodes
						Set $List(pTree(n),3) = 1 	
					}
				}
			}
			If $$$ISERR(tSC) Quit
		}

		// mark if top node has children
		If ((tTopNode'="")&&(tTopHasChildren)) {
			Set $List(pTree(tTopNode),3) = 1
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%SaveCubeDefinition">
<Description>
Utility method to create and save a cube definition class. Used by Architect.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String,pSuper:%String="",pDesc:%String,pModel:%DeepSee.Model.cube,pDomain:%String="",pDependsOn:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pClassName = pClassName

		// open the class definition
		If (##class(%Dictionary.ClassDefinition).%ExistsId(pClassName)) {
			Set tClassDefinition = ##class(%Dictionary.ClassDefinition).%OpenId(pClassName)
			If pSuper = "" Set pSuper = tClassDefinition.Super
			#; delete the old XDATA block named Cube
			Set tIndex = tClassDefinition.XDatas.FindObjectId(pClassName_"||Cube")
			If tIndex'="" Do tClassDefinition.XDatas.RemoveAt(tIndex)

			#; delete the old DOMAIN parameter
			Set tIndex = tClassDefinition.Parameters.FindObjectId(pClassName_"||DOMAIN")
			If tIndex'="" Do tClassDefinition.Parameters.RemoveAt(tIndex)
		}
		Else {
			// create a new class
			Set tClassDefinition = ##class(%Dictionary.ClassDefinition).%New()
			Set tClassDefinition.Name = pClassName
			Set tClassDefinition.ProcedureBlock = 1
		}

		Set tClassDefinition.Super = $S(pSuper="":"%DeepSee.CubeDefinition",1:pSuper)
		Set tClassDefinition.Description = $Replace(pDesc,$C(10),$C(13,10))

		// Only use explicitly provided dependency
		Set tClassDefinition.DependsOn = pDependsOn

		// sequence number controls the order in which class members are displayed
		Set tSeqNo = 0

		#; DOMAIN param
		Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(pClassName_":"_"DOMAIN")
		Set tParmDef.Default = pDomain
		Do tClassDefinition.Parameters.Insert(tParmDef)

		// create XData block to hold the Cube Model
		Set tCubeXData = ##class(%Dictionary.XDataDefinition).%New()
	
		Set tCubeXData.SequenceNumber = $I(tSeqNo)
		Set tCubeXData.Description = "Cube definition from Architect."
		Set tCubeXData.XMLNamespace = "http://www.intersystems.com/deepsee"

		Set tCubeXData.Name = "Cube"
		Set tCubeXData.parent = tClassDefinition

		// use XML writer to format output
		Set tWriter = ##class(%XML.Writer).%New()
		Set tWriter.Indent = 1
		Set tTempStream = ##class(%Stream.TmpCharacter).%New()
		Set tSC = tWriter.OutputToStream(.tTempStream)
		// Set tSC = tWriter.OutputToString()
		If $$$ISERR(tSC) Quit
		Set tSC = tWriter.StartDocument()
		If $$$ISERR(tSC) Quit
		Set tSC = tWriter.RootObject(pModel)
		If $$$ISERR(tSC) Quit
		Set tSC = tWriter.EndDocument()
		If $$$ISERR(tSC) Quit

		//Set tString = tWriter.GetXMLString()

		// contents of xdata block is the xml for the model
		//Set tSC = tCubeXData.Data.Write(tString)
		Set tSC = tCubeXData.Data.CopyFrom(tTempStream)
		If $$$ISERR(tSC) Quit

		// save the cube class
		Set tSC = tClassDefinition.%Save()
		If $$$ISERR(tSC) Quit
		Set pModel.Timestamp = $ZDT(tClassDefinition.TimeChanged,3,,6)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%SaveSubjectAreaDefinition">
<Description>
Utility method to create and save a subject area definition class. Used by Architect.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String,pSuper:%String="",pDesc:%String,pModel:%DeepSee.Model.SubjectArea.subjectArea,pDomain:%String="",pDependsOn:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pClassName = pClassName

		// open the class definition
		If (##class(%Dictionary.ClassDefinition).%ExistsId(pClassName)) {
			Set tClassDefinition = ##class(%Dictionary.ClassDefinition).%OpenId(pClassName)
			#; delete the old XDATA block named SubjectArea
			Set tIndex = tClassDefinition.XDatas.FindObjectId(pClassName_"||SubjectArea")
			If tIndex'="" Do tClassDefinition.XDatas.RemoveAt(tIndex)

			#; delete the old DOMAIN parameter
			Set tIndex = tClassDefinition.Parameters.FindObjectId(pClassName_"||DOMAIN")
			If tIndex'="" Do tClassDefinition.Parameters.RemoveAt(tIndex)
		}
		Else {
			// create a new class
			Set tClassDefinition = ##class(%Dictionary.ClassDefinition).%New()
			Set tClassDefinition.Name = pClassName
			Set tClassDefinition.ProcedureBlock = 1
		}

		Set tClassDefinition.Super = $S(pSuper="":"%DeepSee.SubjectArea",1:pSuper)
		Set tClassDefinition.Description = $Replace(pDesc,$C(10),$C(13,10))

		// Only use explicitly provided dependency
		Set tClassDefinition.DependsOn = pDependsOn

		// sequence number controls the order in which class members are displayed
		Set tSeqNo = 0

		#; DOMAIN param
		Set tParmDef = ##class(%Dictionary.ParameterDefinition).%New(pClassName_":"_"DOMAIN")
		Set tParmDef.Default = pDomain
		Do tClassDefinition.Parameters.Insert(tParmDef)

		// create XData block to hold the Model
		Set tCubeXData = ##class(%Dictionary.XDataDefinition).%New()
	
		Set tCubeXData.SequenceNumber = $I(tSeqNo)
		Set tCubeXData.Description = "SubjectArea definition from Architect."
		Set tCubeXData.XMLNamespace = "http://www.intersystems.com/deepsee/subjectarea"

		Set tCubeXData.Name = "SubjectArea"
		Set tCubeXData.parent = tClassDefinition

		// use XML writer to format output
		Set tWriter = ##class(%XML.Writer).%New()
		Set tWriter.Indent = 1
		Set tSC = tWriter.OutputToString()
		If $$$ISERR(tSC) Quit
		Set tSC = tWriter.StartDocument()
		If $$$ISERR(tSC) Quit
		Set tSC = tWriter.RootObject(pModel)
		If $$$ISERR(tSC) Quit
		Set tSC = tWriter.EndDocument()
		If $$$ISERR(tSC) Quit

		Set tString = tWriter.GetXMLString()

		// contents of xdata block is the xml for the model
		Set tSC = tCubeXData.Data.Write(tString)
		If $$$ISERR(tSC) Quit

		// save the cube class
		Set tSC = tClassDefinition.%Save()
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetPivotList">
<Description><![CDATA[
Return a list of all currently defined DeepSee Pivots visible to the current user.
This is used by utilities.<br/>
This list takes the form:<br/>
pList(NAME) = $LB(name,caption,moddate,type)<br/>
If <var>pHidden</var> is true, then include trash and local items.<br/>
If <var>pCubeName</var> is provided, then only list pivots based on it.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pList,pHidden:%Boolean=0,pCubeName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Kill pList
	Try {
		Set tFlag = $zu(115,8,0)
		Set tStatement = ##class(%SQL.Statement).%New(,"DEFAULT_SCHEMA")
		Set tSC = tStatement.%Prepare("SELECT ID FROM %DeepSee_Dashboard.Pivot")
		If $$$ISERR(tSC) Quit
		
		Set pCubeName = $$$UPPER(pCubeName)

		Set tRS = tStatement.%Execute()
		While (tRS.%Next(.tSC)) {
			If $$$ISERR(tSC) Quit
			If (tRS.ID '="") {
				Set tItem = ##class(%DeepSee.UserLibrary.FolderItem).%OpenId(tRS.ID)
				If ($IsObject(tItem)) {
					Set tDate = $ZDTH(tItem.timeModified,3)
					Set tFullName = $P(tItem.fullName,".",1) // name without extension
					If (pHidden || ($E(tFullName,1)'="$") || ($E(tFullName,1,3)="$$$")) {
						If ((pCubeName="")||(pCubeName=$$$UPPER(tItem.cubeName))) {
							If (tItem.%CheckResource()) {
								Set pList(tItem.fullName) = $LB(tFullName,tItem.name,tDate,"pivot")
							}
						}
					}
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Set tFlag = $zu(115,8,tFlag)
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetDashboardList">
<Description><![CDATA[
Return a list of all currently defined DeepSee dashboards visible to the current user.
This is used by utilities.<br/>
This list takes the form:<br/>
pList(NAME) = $LB(name,caption,moddate,type) ]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pList</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Kill pList
	Try {
		Set tFlag = $zu(115,8,0)
		Set tStatement = ##class(%SQL.Statement).%New(,"DEFAULT_SCHEMA")
		Set tSC = tStatement.%Prepare("SELECT ID FROM %DeepSee_Dashboard.Definition")
		If $$$ISERR(tSC) Quit

		Set tRS = tStatement.%Execute()
		While (tRS.%Next(.tSC)) {
			If $$$ISERR(tSC) Quit
			If (tRS.ID '="") {
				Set tItem = ##class(%DeepSee.UserLibrary.FolderItem).%OpenId(tRS.ID)
				If ($IsObject(tItem)) {
					Set tFName = $P(tItem.folderName,"/",1)
					If (($E(tFName,1)'="$")||($E(tFName,1,3)="$$$")) {
						Set tDate = $ZDTH(tItem.timeModified,3)
						Set tFullName = $P(tItem.fullName,".",1) // name without extension
						If (tItem.%CheckResource()) {
							Set pList(tItem.fullName) = $LB(tFullName,tItem.name,tDate,"dashboard")
						}
					}
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Set tFlag = $zu(115,8,tFlag)
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ConvertDate">
<Description><![CDATA[
Utility method. Convert a date value to %Date ($H) format.<br/>
<var>pDateType</var> indicates the incoming date format.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDate:%String,pDateType:%String</FormalSpec>
<ReturnType>%Date</ReturnType>
<Implementation><![CDATA[
	Set tValue = pDate
	If (pDate'="") {
		If (pDateType = "MVDATE") {
			// multi-value date
			Set tValue = pDate + 46385
		}
		ElseIf (pDateType = "FDATE") {
			// fileman date
			Set tValue = ##class(%Library.FilemanDate).LogicalToOdbc(pDate)
			Set:tValue'="" tValue = $ZDTH(tValue,3,,,,,,,,"Invalid date")
		}
		ElseIf (pDateType = "FTIMESTAMP") {
			// fileman timestamp
			Set tValue = ##class(%Library.FilemanTimeStamp).LogicalToOdbc(pDate)
			Set:tValue'="" tValue = $ZDTH(tValue,3,,,,,,,,"Invalid date")
		}
		ElseIf (pDateType = "TIMESTAMP") {
			Set tValue = $ZDTH(pDate,3,,,,,,,,"Invalid date")
		}
		ElseIf (pDateType = "TIME") {
			Set tValue = "58074,"_pDate
		}
	}
	Quit tValue
]]></Implementation>
</Method>

<Method name="%SetAgentCount">
<Description><![CDATA[
Set the default number of background processes used by DeepSee for the group specified by <var>pType</var>.
Tasks executed by background agents are divided into "build" and "runTime" groups. This method can be used
to set a per-group limit or to set a maximum number of processes that may be active across multiple groups.
The limits can be set with the following value for <var>pType</var>:<br>
- "build" - number of agents that will be requested for a single worker group performing cube build tasks<br>
- "runTime" - number of agents that will be requested for queries and processing of user code such as KPIs<br>
- "buildMax" - the maximum number of agents that can be active for user tasks<br>
- "runTimeMax" - the maximum number of agents that can be active for user tasks]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNumAgents:%Integer="",pType="build",*pStatus:%Status</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set pStatus = $$$OK
	
	// DTB929 - Allowed category types
	Set tTypes("build") = ""
	Set tTypes("buildMax") = ""
	Set tTypes("runTime") = ""
	Set tTypes("runTimeMax") = ""
	
	Set tOldValue = ""
	If '$D(tTypes(pType)) {
		// DTB923 - Separate settings for build and runtime
		Set pStatus = $$$ERROR($$$GeneralError,"Invalid type supplied to %SetAgentCount: " _ pType)
	}
	Else {
		// DTB929 - The routine handles all types
		Set tOldValue = $$SetAgentCount^%SYS.DeepSee(pNumAgents,pType,.pStatus)
	}
	
	Quit tOldValue
]]></Implementation>
</Method>

<Method name="%GetAgentCount">
<Description><![CDATA[
Get the current default agent count for the group specified by <var>pType</var>.
<var>pType</var> can be used to query any of the limits:<br>
- "build" - number of agents that will be requested for a single worker group performing cube build tasks<br>
- "runTime" - number of agents that will be requested for queries and processing of user code such as KPIs<br>
- "buildMax" - the maximum number of agents that can be active for build tasks<br>
- "runTimeMax" - the maximum number of agents that can be active for user tasks]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pType="build",*pStatus:%Status</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set pStatus = $$$OK
	
	// DTB929 - Allowed category types
	Set tTypes("build") = ""
	Set tTypes("buildMax") = ""
	Set tTypes("runTime") = ""
	Set tTypes("runTimeMax") = ""
	
	Set tCount = ""
	// DTB923 - Separate settings for build and runtime
	If '$D(tTypes(pType)) {
		Set pStatus = $$$ERROR($$$GeneralError,"Invalid type supplied to %GetAgentCount: " _ pType)
	}
	Else {
		Set tCount = $$GetAgentCount^%SYS.DeepSee(pType)
	}

	Quit tCount
]]></Implementation>
</Method>

<Method name="%SetDSTimeIndex">
<Description><![CDATA[
Set an entry into the DS Time index used to track changes to transactional classes.<br/>
This is intended for classes that use DSTIME="manual" and wish to maintain the DSTIME index
manually. It should be called whenever an instance of the class is inserted, updated, or deleted.<br/>
<var>pClassName</var> is the (case-sensitive) class name of the transactional class.<br/>
<var>pObjectId</var> is object id of the affected object instance.<br/>
<var>pAction</var> is 0 for updates, 1 for inserts, and 2 for deletes.<br/>
<var>pInterval</var> is the time interval value corresponding to the DSINTERVAL parameter. If this is not greater than zero then 
a standard DSTIME index entry is set, otherwise a DSINTERVAL index entry is set.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String,pObjectId:%String,pAction:%Integer,pInterval:%Integer=0</FormalSpec>
<Implementation><![CDATA[
	if +pInterval '> 0 {
		Set $$$DeepSeeUpdateBuffer(pClassName,$Get($$$DeepSeeUpdateBuffer,0),pObjectId)=pAction
	}
	else {
		$$$DSTIMEH(pClassName,pObjectId,pAction,pInterval,tDST,tDSS)
	}
]]></Implementation>
</Method>

<Method name="%GetErrorPageURL">
<Description>
Return the URL for the DeepSee management portal error page.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pError:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit "_DeepSee.UI.ErrorPage.zen?ERROR="_$ZCVT(pError,"O","URL")
]]></Implementation>
</Method>

<Method name="%GetCollectionProjections">
<Description>
Given a class name, return the set of classes projected for collection properties of the class.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClassname:%String,&pProjectedClass:%String(MAXLEN=255)]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pProjectedClass
	Set tExtent = $$$comClassArrayNext(pClassname,$$$cCLASSextents,"")
	While tExtent '= "" {
		Set tProperty = $ListGet($$$comClassArrayGet(pClassname,$$$cCLASSextents,tExtent))
		If (tProperty '= "") {
			Set pProjectedClass(tProperty) = tExtent
		}
		Set tExtent = $$$comClassArrayNext(pClassname,$$$cCLASSextents,tExtent)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%AddTimeInterval">
<Description><![CDATA[
Add a time interval to a given date (in $H format).<br/>
The interval is of the form "99y99m99d" (years, months, and days).
There can be a leading minus sign.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDate:%Date,pInterval:%String</FormalSpec>
<ReturnType>%Date</ReturnType>
<Implementation><![CDATA[
	If ((pInterval="")||(pInterval="-")) Quit pDate
	If (+pDate=0) Quit ""

	Set tInterval = pInterval
	Set tDate = $ZDT(+pDate,3)
	Set tYear = +$E(tDate,1,4)
	Set tMonth = +$E(tDate,6,7)
	Set tDay = +$E(tDate,9,10)

	// double negative is positive
	If ($E(tInterval,1,2) = "--") {
		Set tInterval = $E(tInterval,3,$L(tInterval))
	}
	
	// JMD986
	// check for leading minus
	Set tSign = 1
	If ($E(tInterval,1,1) = "-") {
		Set tInterval = $E(tInterval,2,$L(tInterval))
		Set tSign = -1
	}
	Set tYearInt = 0
	If (tInterval["y") {
		Set tYearInt = +$P(tInterval,"y",1)*tSign
		Set tInterval = $P(tInterval,"y",2)
	}

	Set tMonthInt = 0
	If (tInterval["m") {
		Set tMonthInt = +$P(tInterval,"m",1)*tSign
		Set tInterval = $P(tInterval,"m",2)
	}

	Set tDayInt = 0
	If (tInterval["d") {
		Set tDayInt = +$P(tInterval,"d",1)*tSign
	}

	If (tDayInt'=0) {
		Set tDay = tDay + tDayInt
		While (tDay>..%DaysInMonth(tYear,tMonth)) {
			Set tDay = tDay - ..%DaysInMonth(tYear,tMonth)
			Set tMonth = tMonth + 1
			If (tMonth>12) {
				Set tYear = tYear + 1
				Set tMonth = tMonth - 12
			}
		}

		While (tDay<1) {
			Set tMonth = tMonth - 1
			If (tMonth<1) {
				Set tYear = tYear - 1
				Set tMonth = tMonth + 12
			}
			Set tDay = tDay + ..%DaysInMonth(tYear,tMonth)
		}
	}
	If (tMonthInt'=0) {
		Set tMonth = tMonth + tMonthInt
		While (tMonth>12) {
			Set tYear = tYear + 1
			Set tMonth = tMonth - 12
		}
		While (tMonth<1) {
			Set tYear = tYear - 1
			Set tMonth = tMonth + 12
		}
	}
	Set tYear = tYear + tYearInt

	// if new month/year is past last day of month, round off to end of month
	If (tDay>..%DaysInMonth(tYear,tMonth)) {
		Set tDay = ..%DaysInMonth(tYear,tMonth)
	}
	Quit $ZDTH(tYear_"-"_$$$iscPadZero(tMonth,2)_"-"_$$$iscPadZero(tDay,2),3)
]]></Implementation>
</Method>

<Method name="%DaysInMonth">
<Description>
Return number of days in the given year and month.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>y,m</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Quit $Case(m,1:31,2:$S(..%IsLeapYear(y):29,1:28),3:31,4:30,5:31,6:30,7:31,8:31,9:30,10:31,11:30,12:31,:0)
]]></Implementation>
</Method>

<Method name="%HijriDaysInMonth">
<Description>
Return number of days in the given year and month.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>y="",m="",calendar="hijriTabular"</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	// Added by DTB180
	Try {
		Set tFormat = $Case(calendar,"hijriTabular":19,"hijriObserved":21,:19)		// DTB182 - Add support for observed hijri

		Set tDayCount = ""
		If ((+y>0)&&(+m>0)) {
			// DTB242 - Protect against improper arguments
			Set tTestDate = $ZDTH("29 "_m_" "_y,tFormat)
			Set tTestDate = +tTestDate+1
			Set tTestDate = $ZDT(tTestDate,tFormat)
			Set tMonth = $P(tTestDate," ",2)
			Set tDayCount = $S((tMonth=m):30,1:29)
		}
	}
	Catch ex {
		// DTB872 - Try/Catch/Throw a more informative error 
		$$$ThrowStatus($System.Status.AppendStatus(ex.AsStatus(),$$$ERROR($$$GeneralError,"Error in %HijriDaysInMonth inputs: y="_y_", m="_m)))
	}

	Quit tDayCount
	
	//Quit $Case(m,1:30,2:29,3:30,4:29,5:30,6:29,7:30,8:29,9:30,10:29,11:30,12:$S(..%IsHijriLeapYear(m):30,1:29),:0)
]]></Implementation>
</Method>

<Method name="%AddHijriTimeInterval">
<Description><![CDATA[
Add a time interval to a given date (in $H format).<br/>
The interval is of the form "99y99m99d" (years, months, and days).
There can be a leading minus sign.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDate:%Date,pInterval:%String,pCalendar:%String="hijriTabular"</FormalSpec>
<ReturnType>%Date</ReturnType>
<Implementation><![CDATA[
	If ((pInterval="")||(pInterval="-")) Quit pDate
	If (+pDate=0) Quit ""
	
	Set tFormat = $Case(pCalendar,"hijriTabular":19,"hijriObserved":21,:19)		// DTB182 - Add support for observed hijri

	Set tInterval = pInterval
	Set tDate = $ZDT(+pDate,tFormat)
	Set tDay = $P(tDate," ",1)
	Set tMonth = $P(tDate," ",2)
	Set tYear = $P(tDate," ",3)

	// double negative is positive
	If ($E(tInterval,1,2) = "--") {
		Set tInterval = $E(tInterval,3,$L(tInterval))
	}
	
	// JMD986
	// check for leading minus
	Set tSign = 1
	If ($E(tInterval,1,1) = "-") {
		Set tInterval = $E(tInterval,2,$L(tInterval))
		Set tSign = -1
	}

	Set tYearInt = 0
	If (tInterval["y") {
		Set tYearInt = +$P(tInterval,"y",1)*tSign
		Set tInterval = $P(tInterval,"y",2)
	}

	Set tMonthInt = 0
	If (tInterval["m") {
		Set tMonthInt = +$P(tInterval,"m",1)*tSign
		Set tInterval = $P(tInterval,"m",2)
	}

	Set tDayInt = 0
	If (tInterval["d") {
		Set tDayInt = +$P(tInterval,"d",1)*tSign
	}

	If (tDayInt'=0) {
		Set tOffsetDate = pDate + tDayInt
		Set tDate = $ZDT(+tOffsetDate,tFormat)
		Set tDay = $P(tDate," ",1)
		Set tMonth = $P(tDate," ",2)
		Set tYear = $P(tDate," ",3)
	}
	If (tMonthInt'=0) {
		Set tMonth = tMonth + tMonthInt
		While (tMonth>12) {
			Set tYear = tYear + 1
			Set tMonth = tMonth - 12
		}
		While (tMonth<1) {
			Set tYear = tYear - 1
			Set tMonth = tMonth + 12
		}
	}
	Set tYear = tYear + tYearInt

	// if new month/year is past last day of month, round off to end of month
	If (tDay>..%HijriDaysInMonth(tYear,tMonth,pCalendar)) {
		Set tDay = ..%HijriDaysInMonth(tYear,tMonth,pCalendar)	 // DTB180
	}
	Quit $ZDTH(tDay_" "_tMonth_" "_tYear,tFormat)
]]></Implementation>
</Method>

<Method name="%IsLeapYear">
<Description>
Return whether the given year is a leap year.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>y</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// DTB181 - Reject anything non-numeric
	Set tIsValidYear = y?.4N
	If 'tIsValidYear Quit 0
	
	If ((y#4) = 0) {
		If '(((y#100) = 0) && ((y#400) '= 0)) {
			Quit 1
		}
	}
	Quit 0
]]></Implementation>
</Method>

<Method name="%IsHijriLeapYear">
<Description>
Return whether the given year is a leap year.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>y,calendar="hijriTabular"</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// DTB181 - Reject anything non-numeric
	Set tIsValidYear = y?.4N
	If 'tIsValidYear Quit 0
	
	Set tFormat = $Case(calendar,"hijriTabular":19,"hijriObserved":21,:19)		// DTB182 - Add support for observed hijri
	
	Set tTestDate = $ZDTH("29 12 "_y,tFormat)
	Set tTestDate = +tTestDate+1
	Set tTestDate = $ZDT(tTestDate,tFormat)
	Set tMonth = $P(tTestDate," ",2)
	Quit (tMonth=12)
]]></Implementation>
</Method>

<Method name="%FormatDate">
<Description><![CDATA[
Format a date value (in $H format) according to the format in <var>pFormat</var>.<br/>
The format string can contain:<br/>
"y" - Year number (4 digits).<br/>
"q" - Quarter number.<br/>
"m" - Month number, with no leading zero.<br/>
"mm" - Month number, with leading zero.<br/>
"mmm" - Short name of month (using server locale).<br/>
"mmmm" - Long name of month (using server locale).<br/>
"d" - Day number, with no leading zero.<br/>
"dd" - Day number, with leading zero.<br/>
"ddd" - Short name of day (using server locale).<br/>
"dddd" - Long name of day (using server locale).<br/>
"\x" - display character "x"<br/>
" " - space<br/>
"/" - "/" <br/>
"-" - "-" <br/>
"." - "." <br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDate:%Date,pFormat:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If (+pDate=0) Quit ""
	If (pFormat="") Quit $ZDT(+pDate,3)
	Set tOut = ""

	Set tDate = $ZDT(pDate,3)
	For p=1:1:$L(pFormat) {
		Set fc = $E(pFormat,p)
		If (fc="\") {
			// escaped literal
			Set p = p + 1
			Set fc = $E(pFormat,p)
			Set tOut = tOut _ fc
		}
		ElseIf ((fc=" ")||(fc="/")||(fc="-")||(fc=".")||(fc=",")||(fc=";")||(fc=":")) {
			// literal
			Set tOut = tOut _ fc
		}
		Else {
			Set k = p + 1
			Set fx = fc
			While ($E(pFormat,k)=fc) {
				Set fx = fx _ fc
				Set p = p + 1
				Set k = p + 1
			}
			If (fc = "y") {
				// year #
				Set tOut = tOut _ $E(tDate,1,4)
			}
			ElseIf (fc = "q") {
				// quarter #
				Set tOut = tOut _ (1+(((+$E(tDate,6,7)-1)\3)))
			}
			ElseIf (fx = "m") {
				// month #, no zero
				Set tOut = tOut _ +$E(tDate,6,7)
			}
			ElseIf (fx = "mm") {
				// month #, with zero
				Set tOut = tOut _ $E(tDate,6,7)
			}
			ElseIf (fx = "mmm") {
				// month short name
				Set tOut = tOut _ $E($ZDT(pDate,5),1,3)
			}
			ElseIf (fx = "mmmm") {
				// month full name
				Set tOut = tOut _ $P($ZDT(pDate,9)," ")
			}
			ElseIf (fx = "d") {
				// day, no zero
				Set tOut = tOut _ +$E(tDate,9,10)
			}
			ElseIf (fx = "dd") {
				// day, with zero
				Set tOut = tOut _ $E(tDate,9,10)
			}
			ElseIf (fx = "ddd") {
				// day, short name
				Set tOut = tOut _ $E($ZDT(pDate,11),1,3)
			}
			ElseIf (fx = "dddd") {
				// day, full name
				Set tOut = tOut _ $P($ZDT(pDate,12)," ")
			}
		}
	}
	Quit tOut
]]></Implementation>
</Method>

<Method name="%UnformatDate">
<Description><![CDATA[
Unformat a date value according to the given format and convert to $H (or "").<br/>
See <method>%FormatDate</method> for information on formats.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pValue:%String,pFormat:%String=""</FormalSpec>
<ReturnType>%Date</ReturnType>
<Implementation><![CDATA[
	If (pValue="") Quit ""
	If (pFormat="") Quit $ZDTH(pValue,3)

	Set tDate = ""
	Set tYear = ""
	Set tMonth = ""
	Set tDay = ""

	Set n = 1
	For p=1:1:$L(pFormat) {
		Set fc = $E(pFormat,p)
		If (fc="\") {
			// escaped literal
			Set p = p + 1
			Set fc = $E(pFormat,p)
			If ($$$UPPER($E(pValue,n))'=$$$UPPER(fc)) {
				// literal has to match (or we may be ambiguous)
				Set tYear = ""
				Quit
			}
			Set n = n + 1
		}
		ElseIf ((fc=" ")||(fc="/")||(fc="-")||(fc=".")||(fc=",")||(fc=";")||(fc=":")) {
			If ($E(pValue,n)'=fc) {
				Set tYear = ""
				Quit
			}
			Set n = n + 1
		}
		Else {
			Set k = p + 1
			Set fx = fc
			While ($E(pFormat,k)=fc) {
				Set fx = fx _ fc
				Set p = p + 1
				Set k = p + 1
			}
			Set tDel=$E(pFormat,k) // JSL4491
			If (fc = "y") {
				// year #
				Set tYear = +$ZSTRIP($E(pValue,n,$L(pValue)),"<>W")\1  // JSL4491 year starts at n and we want natural number (Z+) that starts at n.  
																	   // JSL4491 + operator gives us a number of form a.b and \1 removes the .b if it exists
				Set n = n + $L(tYear)
			}
			ElseIf (fc = "q") {
				// quarter #
				Set q = +$E(pValue,n,n+1)
				Set n = n + $L(q)
				Set tMonth = ((q-1)*3)+1
			}
			ElseIf (fx = "m") {
				Set tMonth = +$E(pValue,n,n+1)
				Set n = n + $L(tMonth)
			}
			ElseIf (fx = "mm") {
				Set tMonth = +$E(pValue,n,n+1)
				Set n = n + 2
			}
			ElseIf (fx = "mmm") {
				Set tName = $E(pValue,n,n+2)
				Set d = $ZDTH(tName_" 1 2000",6)
				Set:d'="" tMonth = +$E($ZDT(d,3),6,7)
				Set n = n + 3
			}
			ElseIf (fx = "mmmm") {
				Set tName = $S((tDel'=""):$P($E(pValue,n,$L(pValue)),tDel,1),1:$E(pValue,n,$L(pValue))) // DTB344 = Account for case with no delimiter
				Set d = $ZDTH(tName_" 1, 2000",9)
				Set:d'="" tMonth = +$E($ZDT(d,3),6,7)
				Set n = n + $L(tName)
			}
			ElseIf (fx = "d") {
				Set tDay = +$E(pValue,n,n+1)
				Set n = n + $L(tDay)
			}
			ElseIf (fx = "dd") {
				Set tDay = +$E(pValue,n,n+1)
				Set n = n + 2
			}
			ElseIf (fx = "ddd") {
				Set tName = $E(pValue,n,n+2)
				Set n = n + 3
			}
			ElseIf (fx = "dddd") {
				Set tName = $S((tDel'=""):$P($E(pValue,n,$L(pValue)),tDel,1),1:$E(pValue,n,$L(pValue))) // DTB344 = Account for case with no delimiter
				Set n = n + $L(tName)
			}
		}
	}

	Set:+tYear<1841 tYear=1841
	Set:+tMonth<1 tMonth=1
	Set:+tDay<1 tDay=1

	Quit:tYear="" ""
	
	Set tDate = tYear_"-"_$$$iscPadZero(tMonth,2)_"-"_$$$iscPadZero(tDay,2)
	Quit $ZDTH(tDate,3,,,,,,,,"")
]]></Implementation>
</Method>

<Method name="%FormatPartialDate">
<Description><![CDATA[
Format a date value (in partial date ODBC format) according to the format in <var>pFormat</var>.<br/>
The format string can contain:<br/>
"y" - Year number (4 digits).<br/>
"q" - Quarter number.<br/>
"m" - Month number, with no leading zero.<br/>
"mm" - Month number, with leading zero.<br/>
"mmm" - Short name of month (using server locale).<br/>
"mmmm" - Long name of month (using server locale).<br/>
"d" - Day number, with no leading zero.<br/>
"dd" - Day number, with leading zero.<br/>
"ddd" - Short name of day (using server locale).<br/>
"dddd" - Long name of day (using server locale).<br/>
"\x" - display character "x"<br/>
" " - space<br/>
"/" - "/" <br/>
"-" - "-" <br/>
"." - "." <br/>
Missing pieces are replaced with the localized text "Unknown".]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDate:%String="",pFormat:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB685
	Try {
		If (+pDate=0) {
			Set tOut = ""
			Quit
		}
		
		Set tUnknownText = $$$Text("Unknown")		// String to be inserted when a date piece is missing
		
		Set tDate = pDate
		
		// Look at the partial date and rebuild a complete ODBC-formatted stand-in
		// if the date is truly partial
		Set tYear = $P(tDate,"-",1)
		Set tMonth = $P(tDate,"-",2)
		Set tDay = $P(tDate,"-",3)
		Set tMonthNull = 0
		Set tDayNull = 0
		
		// Account for null months and days
		If (tMonth="")||(tMonth="00") {
			Set tMonthNull = 1
			Set tMonth = "01"
		}
		If (tDay="")||(tDay="00") {
			Set tDayNull = 1
			Set tDay = "01"
		}
		If (tMonthNull||tDayNull) {
			Set tDate = tYear _ "-" _ tMonth _ "-" _ tDay
		}
		Set tDateH = $ZDH(tDate,3)
		
		Set tOut = ""

		// If no format is supplied, return the original key with "Unknown" substitutes
		If (pFormat="") {
			Set tOut = tYear _ "-" _ $S(tMonthNull:tUnknownText,1:tMonth) _ "-" _ $S(tDayNull:tUnknownText,1:tDay)
			Quit
		}
		
		For p=1:1:$L(pFormat) {
			Set fc = $E(pFormat,p)
			If (fc="\") {
				// escaped literal
				Set p = p + 1
				Set fc = $E(pFormat,p)
				Set tOut = tOut _ fc
			}
			ElseIf ((fc=" ")||(fc="/")||(fc="-")||(fc=".")||(fc=",")||(fc=";")||(fc=":")) {
				// literal
				Set tOut = tOut _ fc
			}
			Else {
				Set k = p + 1
				Set fx = fc
				While ($E(pFormat,k)=fc) {
					Set fx = fx _ fc
					Set p = p + 1
					Set k = p + 1
				}
				If (fc = "y") {
					// year #
					Set tOut = tOut _ $E(tDate,1,4)
				}
				ElseIf (fc = "q") {
					// quarter #
					Set tOut = tOut _ (1+(((+$E(tDate,6,7)-1)\3)))
				}
				ElseIf (fx = "m") {
					// month #, no zero
					//Set tOut = tOut _ $S(tMonthNull:$$$Text("Unknown"),1:+$E(tDate,6,7))
					Set tOut = tOut _ $S(tMonthNull:"0",1:+$E(tDate,6,7))
				}
				ElseIf (fx = "mm") {
					// month #, with zero
					//Set tOut = tOut _ $S(tMonthNull:$$$Text("Unknown"),1:$E(tDate,6,7))
					Set tOut = tOut _ $S(tMonthNull:"00",1:$E(tDate,6,7))
				}
				ElseIf (fx = "mmm") {
					// month short name
					//Set tOut = tOut _ $S(tMonthNull:$$$Text("Unknown"),1:$E($ZDT(tDateH,5),1,3))
					Set tOut = tOut _ $S(tMonthNull:$E($$$Text("Unknown"),1,3),1:$E($ZDT(tDateH,5),1,3))
				}
				ElseIf (fx = "mmmm") {
					// month full name
					Set tOut = tOut _ $S(tMonthNull:$$$Text("Unknown"),1:$P($ZDT(tDateH,9)," "))
				}
				ElseIf (fx = "d") {
					// day, no zero
					//Set tOut = tOut _ $S(tDayNull:$$$Text("Unknown"),1:+$E(tDate,9,10))
					Set tOut = tOut _ $S(tDayNull:"0",1:+$E(tDate,9,10))
				}
				ElseIf (fx = "dd") {
					// day, with zero
					//Set tOut = tOut _ $S(tDayNull:$$$Text("Unknown"),1:$E(tDate,9,10))
					Set tOut = tOut _ $S(tDayNull:"00",1:$E(tDate,9,10))
				}
				ElseIf (fx = "ddd") {
					// day, short name
					//Set tOut = tOut _ $S(tDayNull:$$$Text("Unknown"),1:$E($ZDT(tDateH,11),1,3))
					Set tOut = tOut _ $S(tDayNull:$E($$$Text("Unknown"),1,3),1:$E($ZDT(tDateH,11),1,3))
				}
				ElseIf (fx = "dddd") {
					// day, full name
					Set tOut = tOut _ $S(tDayNull:$$$Text("Unknown"),1:$P($ZDT(tDateH,12)," "))
				}
			}
		}
	}
	Catch ex {
		Set tOut = pDate
	}

	Quit tOut
]]></Implementation>
</Method>

<Method name="%UnformatPartialDate">
<Description><![CDATA[
Unformat a date value according to the given format and convert to $H (or "").<br/>
See <method>%FormatDate</method> for information on formats.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pValue:%String,pFormat:%String=""</FormalSpec>
<ReturnType>%Date</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB685
	If (pValue="") Quit ""
	If (pFormat="") Quit $ZDTH(pValue,3)

	Set tDate = ""
	Set tYear = ""
	Set tMonth = ""
	Set tDay = ""

	Set tUnknownText = $$$Text("Unknown")

	Set n = 1
	For p=1:1:$L(pFormat) {
		Set fc = $E(pFormat,p)
		If (fc="\") {
			// escaped literal
			Set p = p + 1
			Set fc = $E(pFormat,p)
			If ($$$UPPER($E(pValue,n))'=$$$UPPER(fc)) {
				// literal has to match (or we may be ambiguous)
				Set tYear = ""
				Quit
			}
			Set n = n + 1
		}
		ElseIf ((fc=" ")||(fc="/")||(fc="-")||(fc=".")||(fc=",")||(fc=";")||(fc=":")) {
			If ($E(pValue,n)'=fc) {
				Set tYear = ""
				Quit
			}
			Set n = n + 1
		}
		Else {
			Set k = p + 1
			Set fx = fc
			While ($E(pFormat,k)=fc) {
				Set fx = fx _ fc
				Set p = p + 1
				Set k = p + 1
			}
			Set tDel=$E(pFormat,k) // JSL4491
			If (fc = "y") {
				// year #
				Set tYear = +$ZSTRIP($E(pValue,n,$L(pValue)),"<>W")\1  // JSL4491 year starts at n and we want natural number (Z+) that starts at n.  
																	   // JSL4491 + operator gives us a number of form a.b and \1 removes the .b if it exists
				Set n = n + $L(tYear)
			}
			ElseIf (fc = "q") {
				// quarter #
				Set q = +$E(pValue,n,n+1)
				Set n = n + $L(q)
				Set tMonth = ((q-1)*3)+1
			}
			ElseIf (fx = "m") {
				Set tMonth = $E(pValue,n,n+1)
				
				If tMonth="0" {
					Set tMonth = "00"
					Set n = n + 1
				}
				Else {
					Set tMonth = +tMonth
					Set n = n + $L(tMonth)	
				}
			}
			ElseIf (fx = "mm") {
				Set tMonth = $E(pValue,n,n+1)
				
				If tMonth="00" {
					Set tMonth = "00"
					Set n = n + 2
				}
				Else {
					Set tMonth = +tMonth
					Set n = n + 2	
				}
			}
			ElseIf (fx = "mmm") {
				Set tName = $E(pValue,n,n+2)
				
				If tName=$E(tUnknownText,1,3) {
					Set tMonth="00"
					Set n = n + 3
				}
				Else {
					Set d = $ZDTH(tName_" 1 2000",6)
					Set:d'="" tMonth = +$E($ZDT(d,3),6,7)
					Set n = n + 3
				}
			}
			ElseIf (fx = "mmmm") {
				Set tName = $S((tDel'=""):$P($E(pValue,n,$L(pValue)),tDel,1),1:$E(pValue,n,$L(pValue))) // DTB344 = Account for case with no delimiter
				
				If tName=$E(tUnknownText) {
					Set tMonth = "00"
					Set n = n + $L(tUnknownText)
				}
				Else {
					Set d = $ZDTH(tName_" 1, 2000",9)
					Set:d'="" tMonth = +$E($ZDT(d,3),6,7)
					Set n = n + $L(tName)
				}
			}
			ElseIf (fx = "d") {
				Set tDay = $E(pValue,n,n+1)
				
				If tDay="0" {
					Set tDay = "00"
					Set n = n + 1
				}
				Else {
					Set tDay = +tDay
					Set n = n + $L(tDay)	
				}	
			}
			ElseIf (fx = "dd") {
				Set tDay = $E(pValue,n,n+1)
				
				If tDay="00" {
					Set tDay = "00"
					Set n = n + 2
				}
				Else {
					Set tDay = +tDay
					Set n = n + 2	
				}
			}
			ElseIf (fx = "ddd") {
				// DTB - This is indeterminate in the unformatting direction!
				Set tName = $E(pValue,n,n+2)
				
				If tName=$E(tUnknownText,1,3) {
					Set tDay = "00"
					Set n = n + 3
				}
				Else {
					Set tDay = tName
					Set n = n + 3	
				}
			}
			ElseIf (fx = "dddd") {
				// DTB - This is indeterminate in the unformatting direction!
				Set tName = $S((tDel'=""):$P($E(pValue,n,$L(pValue)),tDel,1),1:$E(pValue,n,$L(pValue))) // DTB344 = Account for case with no delimiter
				
				If tName=$E(tUnknownText) {
					Set tDay = "00"
					Set n = n + $L(tUnknownText)
				}
				Else {
					Set tDay = tName
					Set n = n + $L(tName)	
				}
			}
		}
	}

	Set:+tYear<1841 tYear=1841
	Set:(tMonth'="00")&&(+tMonth<1) tMonth=1
	Set:(tDay'="00")&&(+tDay<1) tDay=1

	Quit:tYear="" ""
	
	Set tDate = tYear_"-"_$$$iscPadZero(tMonth,2)_"-"_$$$iscPadZero(tDay,2)
	Quit tDate
]]></Implementation>
</Method>

<Method name="%DayOfWeekToNumber">
<Description><![CDATA[
Method to convert day of week name to a number from 1 to 7 <br> 
  pDayName: full day name (e.g. Monday) or day short name (e.g. Mon)<br>
  pFullName: If true pDayName is the full day name: if false, pDayName is the short day name<br>
  pLocale: if not specified, default to current locale.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDayName,pFullName:%Boolean=1,pLocale:%String=""</FormalSpec>
<Implementation><![CDATA[
	// Method added by DTB392
	set pDayName = $ZCONVERT($g(pDayName),"U")
	// Get the day names for the locale (uses current locale if locale = "")
	Set tFmt=##class(%SYS.NLS.Format).%New(pLocale)
	if pFullName {
		Set tDays=tFmt.WeekdayName
	} Else {
		Set tDays=tFmt.WeekdayAbbr
	}
	set tDays=$ZCONVERT(tDays,"U")
	// Convert to $list format
	set tDaysList =$listfromstring($p(tDays," ",2,*)," ")
	set tDayNumber=$listfind(tDaysList,pDayName)
	if tDayNumber'=0 {
		// tFirstDayofWeek = 0 to 6 (Sunday to Saturday)
		set tFirstDayOfWeek=(-($system.SQL.DAYOFWEEK(62997)-1)#7 + 1 )#7
		// adjust tDayNumber based on tFirstDayOfWeek
		set tDayNumber=tDayNumber-1-tFirstDayOfWeek#7+1
	} Else {
		set tDayNumber=""
	}
	quit tDayNumber
]]></Implementation>
</Method>

<Method name="%Shell">
<Description>
Invoke the DeepSee command line shell.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[	Do ##class(%DeepSee.Shell).%Go()
]]></Implementation>
</Method>

<Method name="%UpdateDimensionProperty">
<Description><![CDATA[
Programmatic API for updating the value of a dimension property after a cube has been built.</br>
<example language="cache">
Set tSC = ##class(%DeepSee.Utils).%UpdateDimensionProperty(
	"Holefoods","[Outlet].[H1].[Region].&[Asia]","Asia2")
</example>
It takes the following arguments:<br/>
<var>pCubeName</var>-name of the cube.<br/>
<var>pSpec</var>-specification of member to update as an MDX expression. This must completely specify a level and a single key value
within the level. For example: "[Product].[P1].[Product Category].&[Candy]"<br/>
You can set the value of a dimension property by adding Properties(propName) to the end of the spec:
"[Outlet].[H1].[City].&[23].Properties(""Population"")"
<var>pValue</var>-if defined, this is new NAME value for a dimension member or the value to use for a dimension property.<br/>
<var>pKey</var>-if defined, this is new KEY value for a dimension member. Ignored for a dimension property.<br/>
There a number of restrictions on this method:<br/>
You cannot update a time dimension.<br/>
You cannot update a member of relationship.<br/>
You cannot update a level property whose isReference is true.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pSpec:%String,pValue:%String,pKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Get info on the specified dimension
		Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(pCubeName,pSpec,.tDimNo,.tHierNo,.tLevelNo,.tRelationName,.tRelationSpec,.tSpecInfo)
		If $$$ISERR(tSC) Quit

		If ('$D(pValue)&&'$D(pKey)) {
			Set tSC = $$$ERROR($$$GeneralError,"Either pValue or pKey must be defined for %UpdateDimensionProperty")
			Quit
		}

		If (tRelationName'="") {
			Set tSC = $$$ERROR($$$GeneralError,"%UpdateDimensionProperty cannot be used with a relationship")
			Quit
		}

		Set tCube = $$$UPPER(pCubeName)
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)		// DTB838
		Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
		Set tClass = $LG(tInfo,6)

		If (($LG(tInfo,1)'="l")||(tClass="")) {
			Set tSC = $$$ERROR($$$GeneralError,"pSpec does not refer to a valid level")
			Quit
		}

		If $zobjclassmethod(tClass,"%IsA","%DeepSee.ComputedDimension.Base") {
			Set tSC = $$$ERROR($$$GeneralError,"%UpdateDimensionProperty cannot be called on a computed dimension")
			Quit
		}
		ElseIf $zobjclassmethod(tClass,"%IsA","%DeepSee.Time.AbstractLevel") {
			Set tSC = $$$ERROR($$$GeneralError,"%UpdateDimensionProperty cannot be called on a time dimension")
			Quit
		}
		// now find specific member within level
		// assume least member of spec is key
		Set k = $O(tSpecInfo(""),-1)
		Set tKey = $S(k="":"",1:$G(tSpecInfo(k)))

		// test for Properties()
		Set tPropName = ""
		If ($$$UPPER($E(tKey,1,12))="PROPERTIES(""") {
			Set tPropName = $P($$$UPPER(tKey),"PROPERTIES(""",2)
			Set tPropName = $P(tPropName,""")",1)
			Set k = $O(tSpecInfo(k),-1)
			Set tKey = $S(k="":"",1:$G(tSpecInfo(k)))
		}

		// get info on dimension table and create SQL statement
		Set tExists = ##class(%DeepSee.Query.member).%GetNodeInfo(pCubeName,tDimNo, tHierNo, tLevelNo, .tFact, .tStarClass, .tStarField, .tStarSort, .tRollup, .tSortDir,,,.tStarKeyField)
		If ('tExists) {
			Set tSC = $$$ERROR($$$GeneralError,"%UpdateDimensionProperty invalid dimension")
			Quit
		}
		If (tStarKeyField="") {
			Set tStarKeyField = "%ID"
		}
		If (tStarField="") {
			Set tSC = $$$ERROR($$$GeneralError,"%UpdateDimensionProperty: this dimension cannot be updated")
			Quit
		}
		Set tStarTable = ##class(%DeepSee.Utils).%GetSQLTableName(tStarClass)
		If (tStarTable = "") {
			Set tSC = $$$ERROR($$$GeneralError,"%UpdateDimensionProperty: Dimension table missing or not found: '" _ tStarClass _ "'")
			Quit
		}

		// See if key exists
		Set tSQL = "SELECT %ID FROM " _ tStarTable _ " WHERE "_tStarKeyField_" =?"
		Set tStatement = ##class(%SQL.Statement).%New(,"DEFAULT_SCHEMA")
		Set tSC = tStatement.%Prepare(tSQL)
		If $$$ISERR(tSC) Quit

		Set tID = ""
		Set tRS = tStatement.%Execute(tKey)
		While (tRS.%Next(.tSC)) {
			If $$$ISERR(tSC) Quit
			Set tID = tRS.ID
			Quit
		}

		If (tID="") {
			Set tSC = $$$ERROR($$$GeneralError,"%UpdateDimensionProperty: Key not found in dimension table: '" _ tKey _ "'")
			Quit
		}

		// update
		Set tFieldList = ""

		Set tPropField = ""
		If (tPropName'="") {
			Set tPropInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo,"prop",tPropName))
			Set tPropField = $LG(tPropInfo,3)
			If (tPropField="") {
				Set tSC = $$$ERROR($$$GeneralError,"%UpdateDimensionProperty: Property not found in dimension table: '" _ tPropName _ "'")
				Quit
			}
			Set tFieldList = tFieldList _ $S(tFieldList="":"",1:",") _ tPropField_"='"_$$$iscEscapeSQL($G(pValue))_"'"
		}
		Else {
			If $D(pValue) {
				Set tFieldList = tFieldList _ $S(tFieldList="":"",1:",") _ tStarField_"='"_$$$iscEscapeSQL(pValue)_"'"
			}
			If $D(pKey) {
				Set tFieldList = tFieldList _ $S(tFieldList="":"",1:",") _ tStarKeyField_"='"_$$$iscEscapeSQL(pKey)_"'"
			}
		}

		Set tSQL = "UPDATE " _ tStarTable _ " SET "_tFieldList_" WHERE %ID = '"_tID_"'"
		Set tStatement = ##class(%SQL.Statement).%New(,"DEFAULT_SCHEMA")
		Set tSC = tStatement.%Prepare(tSQL)
		If $$$ISERR(tSC) Quit

		Set tRS = tStatement.%Execute()
		If (tRS.%SQLCODE'=0) {
			Set tSC = $$$ERROR($$$GeneralError,"%UpdateDimensionProperty: update of dimension table failed: "_ tRS.%SQLCODE)
			Quit
		}
		
		// DTB838 - If successful, advance the DSTIME update counter to signal an update has been recorded
		Set:(##class(%DeepSee.Utils).%GetCubeDSTime(tCubeIndex)=+$G($$$DeepSeeUpdateQueue)) tTimeStamp = $I($$$DeepSeeUpdateQueue)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%WriteDependencyGraph">
<Description>
Write the cube dependency graph for the given cube.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String</FormalSpec>
<Implementation><![CDATA[
	Do ..%GetDependencyGraph(.tGraph,pCubeName)
	Set tCube1 = $O(tGraph(""))
	While (tCube1'="") {
		Set tCube2 = $O(tGraph(tCube1,""))
		While (tCube2'="") {
			Write "Cube ",tCube1," depends on ",tCube2,!
			Set tCube2 = $O(tGraph(tCube1,tCube2))
		}
		Set tCube1 = $O(tGraph(tCube1))
	}
]]></Implementation>
</Method>

<Method name="%GetDependencyGraph">
<Description>
Get the cube dependency graph for the given cube:
pGraph(cube, dependentCube) = ""</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pGraph,pCubeName:%String,pDirection:%String="",pLevel:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCube = $$$UPPER(pCubeName)
		Kill:pDirection="" pGraph

		// find all cubes that depend on this one
		Set tRelation = $O($$$DeepSeeMetaGLVN("cubes",tCube,"relations",""))
		While (tRelation'="") {
			Set tOtherCube = $$$UPPER($G($$$DeepSeeMetaGLVN("cubes",tCube,"relations",tRelation,"relatedCube")))
			Set tIsStored = $G($$$DeepSeeMetaGLVN("cubes",tCube,"relations",tRelation,"storedSide"))
			
			If (tIsStored && (pDirection'="up")) {
				// this cube is dependent on the other one
				Set pGraph(tCube,tOtherCube) = pLevel
				// recurse down
				If '$D(pGraph(tOtherCube)) {
					Set tSC = ..%GetDependencyGraph(.pGraph, tOtherCube, "down", pLevel+1)
				}
			}
			ElseIf ('tIsStored && (pDirection'="down")) {
				// this cube is independent of the other one
				// recurse up
				If '$D(pGraph(tOtherCube)) {
					Set tSC = ..%GetDependencyGraph(.pGraph, tOtherCube, "up", pLevel-1)
				}
				Set pGraph(tOtherCube,tCube) = pLevel
			}
			Set tRelation = $O($$$DeepSeeMetaGLVN("cubes",tCube,"relations",tRelation))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%FindDimensionTableForProperty">
<Description>
Given a cube and a source property name, return the list of dimension tables
that make use of the source property.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pSourceProp:%String,*pList</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pList
		Set tCube = $$$UPPER(pCubeName)
		Set tSourceProp = $$$UPPER(pSourceProp)

		Set j = $O($$$DeepSeeMetaGLVN("cubes",tCube,"star",""))
		While (j'="") {
			Set k = $O($$$DeepSeeMetaGLVN("cubes",tCube,"star",j,"prop",""))
			While (k'="") {
				Set tSource = $G($$$DeepSeeMetaGLVN("cubes",tCube,"star",j,"prop",k,"source"))
				If ($$$UPPER(tSource)=tSourceProp) {
					Set pList(j) = ""
				}
				Set k = $O($$$DeepSeeMetaGLVN("cubes",tCube,"star",j,"prop",k))
			}
			Set j = $O($$$DeepSeeMetaGLVN("cubes",tCube,"star",j))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetPaperSizeList">
<Description><![CDATA[
Return list of standard paper sizes in the form:<br/>
pList(n) = $LB(name,size)<br/>
Where size is "WxH units", e.g., "8.5x11 in"]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pList</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// list of page sizes
	Set pList($I(n)) = $LB($$$Text("Letter","%DeepSee"),"8.5x11 in")
	Set pList($I(n)) = $LB($$$Text("Legal","%DeepSee"),"8.5x14 in")
	Set pList($I(n)) = $LB($$$Text("Statement","%DeepSee"),"5.5x8.5 in")
	Set pList($I(n)) = $LB($$$Text("Executive","%DeepSee"),"7.25x10.5 in")
	Set pList($I(n)) = $LB("11x17","11x17 in")
	Set pList($I(n)) = $LB("A2","420x594 mm")
	Set pList($I(n)) = $LB("A3","297x420 mm")
	Set pList($I(n)) = $LB("A4","210x297 mm")
	Set pList($I(n)) = $LB("A5","148x210 mm")
	Set pList($I(n)) = $LB("A6","105x148 mm")

	// merge in user-extensions
	// ^DeepSee.PaperSizes(n) = $LB(name,dimensions)
	Set k = $O(^DeepSee.PaperSizes(""))
	While (k'="") {
		Set pList($I(n)) = $G(^DeepSee.PaperSizes(k))
		Set k = $O(^DeepSee.PaperSizes(k))
	}

	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%ExportExcelToFile">
<Description><![CDATA[
Export a DeepSee query or KPI to the file <var>pFile</var> in excel format.<br/>
<var>pParms</var> defines the export parameters:<br/>
pParms("TITLE") = title<br/>
pParms("SUBTITLE") = subtitle<br/>
pParms("MDX") = MDX Statement<br/>
pParms("KPI") = KPI class name<br/>
pParms("LISTINGNAME") = Listing name<br/>
pParms("FILTERNAMES") = $C(10)-delimited list of filter names<br/>
pParms("FILTERVALUES") = $C(10)-delimited list of filter values<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pFile:%String,&pParms:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		New %session,%request,%response
		Set %request = ##class(%CSP.Request).%New()
		Set %response = ##class(%CSP.Response).%New()
		Set %session = ##class(%CSP.Session).%New(666)

		// + WAL075 -- no need to encrypt parms
		/*
		// encrypt parms
		If $D(pParms("MDX")) {
			Set pParms("MDX") = ##class(%DeepSee.UI.MDXExcel).Encrypt(pParms("MDX"))
		}
		*/
		// - WAL075
		
		// DTB362 - Test the MDX query to see if there are
		// early indications there will be a problem
		If $G(pParms("MDX"))'="" {
			Set tRS = ##class(%DeepSee.ResultSet).%New()
			Set tSC = tRS.%PrepareMDX($G(pParms("MDX")))
			If $$$ISERR(tSC) Quit
		}
		
		// apply parms
		Set k = $O(pParms(""))
		While (k'="") {
			Set %request.Data(k,1) = pParms(k)
			Set k = $O(pParms(k))
		}
		
		// DTB214 - The export expects FILTER to apply to the results
		If $D(pParms("FILTERNAMES")) {
			Set tFilterNames = pParms("FILTERNAMES")
			Set tFilterValues = pParms("FILTERVALUES")
			For f=1:1:$L(tFilterNames,$C(10)) {
				Set %request.Data("FILTER",f) = $P(tFilterNames,$C(10),f) _ ":" _ $P(tFilterValues,$C(10),f)
			}
		}

		// open the file
		Set io = $io
		If (pFile'="") {
			Open pFile:"WNU":0 Else  Set tSC = $$$ERROR($$$GeneralError,"Unable to open file: "_pFile) Quit
			Use pFile
		}
		Set tSC = ##class(%DeepSee.UI.MDXExcel).OnPage()
		If (pFile'="") {
			Use io
			Close pFile
		}
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ExportPDFToFile">
<Description><![CDATA[
Export a DeepSee query or KPI to the file <var>pFile</var> in PDF format.<br/>
<var>pParms</var> defines the export parameters:<br/>
pParms("TITLE") = title<br/>
pParms("SUBTITLE") = subtitle<br/>
pParms("MDX") = MDX Statement<br/>
pParms("KPI") = KPI class name<br/>
pParms("LISTINGNAME") = Listing name<br/>
pParms("FILTERNAMES") = $C(10)-delimited list of filter names<br/>
pParms("FILTERVALUES") = $C(10)-delimited list of filter values<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pFile:%String,&pParms:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		New %session,%request,%response
		Set %request = ##class(%CSP.Request).%New()
		Set %response = ##class(%CSP.Response).%New()
		Set %session = ##class(%CSP.Session).%New(666)

		// WAL075 (3) -- don't encrypt parms
		//If $D(pParms("MDX")) {
		//	Set pParms("MDX") = ##class(%DeepSee.UI.MDXPDF).Encrypt(pParms("MDX"))
		//}
		
		// DTB362 - Test the MDX query to see if there are
		// early indications there will be a problem
		If $G(pParms("MDX"))'="" {
			Set tRS = ##class(%DeepSee.ResultSet).%New()
			Set tSC = tRS.%PrepareMDX($G(pParms("MDX")))
			If $$$ISERR(tSC) Quit
		}

		// apply parms
		Set k = $O(pParms(""))
		While (k'="") {
			Set %request.Data(k,1) = pParms(k)
			Set k = $O(pParms(k))
		}
				
		// DTB214 - The export expects FILTER to apply to the results
		If $D(pParms("FILTERNAMES")) {
			Set tFilterNames = pParms("FILTERNAMES")
			Set tFilterValues = pParms("FILTERVALUES")
			For f=1:1:$L(tFilterNames,$C(10)) {
				Set %request.Data("FILTER",f) = $P(tFilterNames,$C(10),f) _ ":" _ $P(tFilterValues,$C(10),f)
			}
		}

		// open the file
		Set io = $io
		If (pFile'="") {
			Open pFile:"WNU":0 Else  Set tSC = $$$ERROR($$$GeneralError,"Unable to open file: "_pFile) Quit
			Use pFile
		}
		Set tSC = ##class(%DeepSee.UI.MDXPDF).OnPage()
		If (pFile'="") {
			Use io
			Close pFile
		}
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ComputeAge">
<Description><![CDATA[
Compute the "age" (time difference) between <var>pStart</var> and <var>pEnd</var> as a number
of units specified by <var>pUnits</var> ("years","months","days").]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pStart:%Date,pEnd:%Date,pUnits:%String="years"</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	// JMD1134
	Set tAge = ""
	// WAL079 -- handle negative ages just in case they are needed
	Set tIsNegative = (pStart>pEnd)
	Set:(tIsNegative) tTemp=pStart,pStart=pEnd,pEnd=tTemp
	If (pUnits = "days") {
		Set tAge = +pEnd - pStart
	}
	Else {
		Set tStartDate = $ZDT(pStart,3)
		Set tEndDate = $ZDT(pEnd,3)

		// look at years/months
		Set tStartYear = +$E(tStartDate,1,4)
		Set tEndYear = +$E(tEndDate,1,4)
		Set tStartMonth = +$E(tStartDate,6,7)
		Set tEndMonth = +$E(tEndDate,6,7)
		Set tStartDay = +$E(tStartDate,9,10)
		Set tEndDay = +$E(tEndDate,9,10)

		// WAL079 -- convert year/month to a number of months for easy computation
		Set tMonthAge = (tEndYear*12 + tEndMonth)-(tStartYear*12 + tStartMonth)
		If (pUnits = "years") {
			// WAL079 -- convert months back to years, integer division (so that we round down)
			Set tAge = tMonthAge\12
		}
		ElseIf (pUnits = "months") {
			// WAL079 -- i.e., April 3rd to May 2nd is not a full month
			If (tEndDay<tStartDay) {
				Set tMonthAge = tMonthAge - 1
			}
			Set tAge = tMonthAge
		}
	}
	If (tIsNegative) {
		Set tAge = 0-tAge	
	}
	
	Quit tAge
]]></Implementation>
</Method>

<Method name="%CreateQueryNonce">
<Description>
Sometimes we need to pass a query (or XML) to another process via a URL.
I.E. has trouble with large URL parameters, so the best approach is to store the query
text in a global and pass a one-time token (or nonce) as part of the URL.
Assumes that the query is encrypted.
Returns "ERROR:"_details if there is an error.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pText:%String,pMode:%String="MDX"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tNonce = ""
	Try {
		Set tText = pText
		// + WAL075 -- query is no longer encrypted
		/*
		If (pMode="MDX") {
			// decrypt
			Set tText = ##class(%CSP.Page).Decrypt(tText)
		}
		*/
		// - WAL075
		// convert utf-8
		// WAL075 (3) -- since we didn't encrypt/decrypt we don't need to convert from UTF8
		// Set tText = $ZCVT(tText,"I","UTF8")
		Set tNonce = $I($$$DeepSeeQueryNonceGLVN) 
		Set $$$DeepSeeQueryNonceGLVN(tNonce) = tText
	}
	Catch(ex) {
		Set tSC = $System.Status.GetErrorText(ex.AsStatus())
	}

	If $$$ISERR(tSC) {
		Set tNonce = "ERROR:"_$System.Status.GetErrorText(tSC)
	}
	Quit tNonce
]]></Implementation>
</Method>

<Method name="%CreateParameterNonce">
<Description>
Sometimes we need to pass parameters to another process via a URL.
I.E. has trouble with large URL parameters, so the best approach is to store the parameter
text in a global and pass a one-time token (or nonce) as part of the URL.
Assumes that the parm unencrypted.
Returns "ERROR:"_details if there is an error.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pParm:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tNonce = ""
	Try {
		Set tText = pParm
		// convert utf-8
		Set tText = $ZCVT(tText,"I","UTF8")
		Set tNonce = $I($$$DeepSeeParameterNonceGLVN)
		Set $$$DeepSeeParameterNonceGLVN(tNonce) = tText
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()		// DTB452 - Return a %Status from the Catch block
	}

	If $$$ISERR(tSC) {
		Set tNonce = "ERROR:"_$System.Status.GetErrorText(tSC)
	}
	Quit tNonce
]]></Implementation>
</Method>

<Method name="%GetParameterNonce">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNonce:%Integer</FormalSpec>
<Implementation><![CDATA[
	// DTB916 - Clear out the nonce cache as soon as it is successfully read
	If ($g(pNonce)'="") {
		Set tParameter = $G($$$DeepSeeParameterNonceGLVN(pNonce))
		Kill $$$DeepSeeParameterNonceGLVN(pNonce)
	}
	Else {
		Set tParameter = ""
	}

	Quit tParameter
]]></Implementation>
</Method>

<Method name="%FindCubeMembers">
<Description><![CDATA[
<p>Utility method to retrieve <var>pMaxResults</var> cube members based on a simple search key. By default, this
method will return normal cube members only, but a range of flags serve to indicate which type
of results to return on top, as long as they match the search key (level names, measure
names or computed members).<br/>
Members are returned as <pre>pMembers(n) = $lb(<i>Caption</i>, <i>Spec</i>, ["measure"|"level"|"member"])</pre></p>
<p>Use <var>pDimList</var> to limit the search scope to those dimensions, hierarchies or levels
listed in this comma-separated list of specs.</p>
<p>This method does not return "all" levels, nor will it check cube relationships.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String,pSearchKey:%String,*pMembers,pDimList:%String="",pIncludeLevelNames:%Boolean=0,pIncludeMeasures:%Boolean=0,pIncludeComputed:%Boolean=0,pMaxResults:%Integer=10</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pMembers
		set pMembers = 0
		set tSearchKey = $$$UPPER(pSearchKey)
		set tCube = $$$DeepSeeIndex(pCube)
		
		// parse pDimList
		kill tDimFilter
		set tDimFilter = 0
		if (pDimList'="") {
			set tDimFilter = 1
			for i = 1:1:$l(pDimList,",") {
				set tSpec = $zstrip($p(pDimList,",",i),"<>W")
				set tDimFilter($case($l(tSpec,"."), 1:"D", 2:"H", 3:"D"), $$$UPPER(tSpec)) = ""
			}
		}
		
		// first find all cube levels
		set tSC = ..%GetCubeLevels(pCube, .tLevels)
		quit:$$$ISERR(tSC)
		
		set i = ""
		for {
			set i = $order(tLevels(i),1,tLevelInfo)
			quit:i=""
			
			set tLevelType = $li(tLevelInfo,1)
			continue:(tLevelType="r")
			
			if (tLevelType="m") {
				continue:'pIncludeMeasures
				set tName = $li(tLevelInfo,3)
				set tSC = ..%GetMemberCaption(pCube, "MEASURES", tName,, .tMsrCaption)
				quit:$$$ISERR(tSC)
				
				continue:'$find($$$UPPER(tMsrCaption),tSearchKey)
				set tSpec = "[MEASURES].["_tName_"]"
				
				// check filter
				continue:tDimFilter&&'$d(tDimFilter("D","[MEASURES]"))&&'$d(tDimFilter("H",$$$UPPER(tSpec)))
				
				set pMembers($i(pMembers)) = $lb(tMsrCaption, tSpec, "measure")
				quit:pMembers>=pMaxResults
				continue
			}
			
			set tDim = $li(tLevelInfo,2)
			set tHier = $li(tLevelInfo,3)
			set tLevel = $li(tLevelInfo,4)
			set tSpec = "["_tDim_"].["_tHier_"].["_tLevel_"]"
			
			// filter first
			if tDimFilter && '$d(tDimFilter("D",$$$UPPER($p(tSpec,".",1)))) &&
			  '$d(tDimFilter("H",$$$UPPER($p(tSpec,".",1,2)))) &&
			  '$d(tDimFilter("L",$$$UPPER(tSpec))) {
				 continue
			 }
			 
			// check dimension info
			set tSC = ..%GetDimensionInfo(pCube, tSpec, .tDimNo, .tHierNo, .tLevelNo, .tRelName, .tRelSpec,, .tLocalCalcMbrs, .tLocalNamedSets)
			quit:$$$ISERR(tSC)
			
			// check the level name
			if (pIncludeLevelNames) {
				set tSC = ..%GetDimensionCaption(pCube, tDimNo, tHierNo, tLevelNo, .tLevelCaption)
				quit:$$$ISERR(tSC)
				if $find($$$UPPER(tLevelCaption),tSearchKey) {
					set pMembers($i(pMembers)) = $lb(tLevelCaption, tSpec_".Members", "level")
					quit:pMembers>=pMaxResults
				}
			}
			
			set tMbrClass = $lg($g($$$DeepSeeMetaGLVN("cubes", tCube, "mbr#", tDimNo, tHierNo, 0)),6)
			//set tLvlClass = $lg($g($$$DeepSeeMetaGLVN("cubes", tCube, "mbr#", tDimNo, tHierNo, tLevelNo)),6)
			
			continue:'pIncludeComputed&&(tMbrClass="%DeepSee.Query.memberComputed")
			
			set tSC = ##class(%DeepSee.Dashboard.Utils).%GetMembersForFilter(pCube, tSpec, .tMembers,, pSearchKey)
			quit:$$$ISERR(tSC)
			
			set j = ""
			for {
				set j = $order(tMembers(j),1,tMemberInfo)
				quit:j=""
				set pMembers($i(pMembers)) = $lb($li(tMemberInfo,1), tSpec_"."_$li(tMemberInfo,2), "member")
				quit:pMembers>=pMaxResults
			}
			quit:pMembers>=pMaxResults
		}
		quit:$$$ISERR(tSC)
		quit:pMembers>=pMaxResults
		
		// Not covered:
		//	- "all" level for dimensions
		// 	- cube relationships
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetResourceList">
<Description>
Return resource list containing type=Application only.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tSC = $$$OK
		Set tOutput = ""
		Do ResourceList^%SYS.SECURITY("*",-1,-1,.res)
		Set tItem = $O(res(""))
		While tItem '= "" {
			If $LG(res(tItem),3) = 2147483648 {
				Set tOutput = tOutput _ $S(tOutput'="":",",1:"")_tItem	
			}
			Set tItem = $O(res(tItem))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		Set tOutput = $System.Status.GetErrorText(tSC)
	}
	Quit tOutput
]]></Implementation>
</Method>

<Method name="%CompressList">
<Description>
Given a fact id, see if there are any or groups (1|2|3) that can be compressed
into ranges.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFactId:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Quit:(pFactId'["|") pFactId
	Set tOut = ""
	Set tCount = $L(pFactId,"|")+1	// add extra "" on the end
	Set tRangeStart = ""
	Set tLastID = ""
	For p = 1:1:tCount {
		Set tID = $P(pFactId,"|",p)
		If (tRangeStart="") {
			Set tRangeStart = tID
			Set:tID'="" tOut = tOut _ $S(tOut="":"",1:"|") _ tID
		}
		ElseIf (tID'=(tLastID+1)) {
			// id is not part of a range	(dates?)
			Set:(tRangeStart'=tLastID) tOut = tOut _ ">" _ tLastID
			Set tRangeStart = tID
			Set:tID'="" tOut = tOut _ $S(tOut="":"",1:"|") _ tID
		}
		Set tLastID = tID
	}
	Quit tOut
]]></Implementation>
</Method>

<Method name="%TestForZProcessing">
<Description>
Diagnostic.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pKill:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	Set tCube = $O($$$DeepSeeResultsGLVN(""))
	While (tCube'="") {
		Set tKey = $O($$$DeepSeeResultsGLVN(tCube,""))
		While (tKey'="") {
			If $D($$$DeepSeeResultsGLVN(tCube,tKey,"zprocessing")) {
				Write "zprocessing: ",tCube,":",tKey,!
				Write $G($$$DeepSeeResultsGLVN(tCube,tKey,"query",1)),!
			}
			ElseIf (pKill) {
				Kill $$$DeepSeeResultsGLVN(tCube,tKey)
			}
			Set tKey = $O($$$DeepSeeResultsGLVN(tCube,tKey))
		}
		Set tCube = $O($$$DeepSeeResultsGLVN(tCube))
	}
]]></Implementation>
</Method>

<Method name="%IsDeepSeeEnabled">
<Description>
Indicates whether the default application for this namespace will process DeepSee Pages.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// DTB073 - Provide an API to determine whether a namespace is DeepSee enabled
	Set tEnabled = 0
	
	Try {
		Set tNamespace = $S(pNamespace="":$NAMESPACE,1:$$$UPPER(pNamespace))
		
		If (pNamespace="%SYS") {
			// DTB766 - Quit with 0 if this is the %SYS namespace. The checks below will return 1.
			Set tEnabled = 0
			Quit
		}
		
		Set tApplication = $system.CSP.GetDefaultApp(tNamespace)
		If $E(tApplication,1)'="/" {
			Set tApplication = "/" _ tApplication
		}
		If $E(tApplication,*)'="/" {
			Set tApplication = tApplication _ "/"
		}
		Set tEnabled = $$IsDeepSeeEnabled^%SYS.cspServer(tApplication)
	}
	Catch {
	}
	
	Quit tEnabled
]]></Implementation>
</Method>

<Method name="%IsDataConnector">
<Description>
Test whether pClassName is a DataConnector. This uses a direct global lookup so users do not need to rely 
on access to %Dictionary tables</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String="",pStatus:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB160
	Set tIsConnector = 0
	Set pStatus = $$$OK
	
	Try {
		Set tIsConnector = ($$$comClassKeyGet(pClassName,$$$cCLASSsuper)="%DeepSee.DataConnector")
	}
	Catch ex {
		Set pStatus = ex.AsStatus()
	}
	
	Quit tIsConnector
]]></Implementation>
</Method>

<Method name="%GetMDXFromPivot">
<Description><![CDATA[
Method for programmatically creating a pivot table <br>
The GetMDXforPivot method returns the MDX query for saved pivot. <br> 
<br>
Arguments:<br>
<li>pPivotFullName</li> 
The name of the pivot including folder name<br>
Format: folder/pivot name<br>
Example: My Folder/My Pivot<br>
<br>
<LI>pExecute</LI>
Boolean value (optional):<br>
0 - Do not execute the MDX query (Default) <br>
1 - Execute the MDX query<br> 
<br>
<LI>pResultSet</LI>
Output argument (optional): <br>
Instance of %DeepSee.ResultSet for the MDX query:<br>
This can be used to access the query results, meta data, statistics, etc.
<br>
To get the text of the MDX query, use only the first argument <br>
To get the text of the MDX query and run the query, use the first 2 arguments<br>
To get the text of the MDX query, run the query, and get the ResultSet, use all 3 arguments <br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pPivotFullName="",*pStatus:%Status,pExecute:%Boolean=0,&pParms,*pResultSet:%DeepSee.ResultSet]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB245
	Set pStatus = $$$OK
	Set tMDX = ""
	Set pResultSet = ""
	Try {
		// This is a convenience method rearranging the return from %GetResultSetFromPivot
		Set pResultSet = ##class(%DeepSee.Utils).%GetResultSetFromPivot(pPivotFullName,.pStatus,1,.pParms,.tMDX)
	}
	Catch ex {
		// Return empty string if there is an error
		Set pStatus = ex.AsStatus()
		Set tMDX = ""
	}
	
	Quit tMDX
]]></Implementation>
</Method>

<Method name="%ExecutePivot">
<Description><![CDATA[
Programmatically execute a stored pivot table. The <var>pPivotTableName</var> is the full
Folder/SubFolder/Name of the pivot table. Execute parameters may optionally be passed in through
the <var>pParms</var> array. If desired, the resultset constructed in the execution procedure can
be returned using <var>pResultSet</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pPivotFullName="",&pParms,*pResultSet]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB245
	Set tSC = $$$OK
	Try {
		// This is a convenience method rearranging the return from %GetResultSetFromPivot
		Set pResultSet = ##class(%DeepSee.Utils).%GetResultSetFromPivot(pPivotFullName,.tSC,1,.pParms)
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetResultSetFromPivot">
<Description><![CDATA[
Programmatically create an instance of a <class>%DeepSee.ResultSet</class> from 
a stored pivot table. The <var>pPivotTableName</var> is the full
Folder/SubFolder/Name of the pivot table. By default, the query is only prepared 
and returned ready for execution. The query can be asynchronously executed as part 
of the retrieval process by setting <var>pExecute</var>=1. Execute parameters may optionally be passed in through
the <var>pParms</var> array.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pPivotFullName="",*pStatus:%Status,pExecute:%Boolean=0,&pParms,*pMDX]]></FormalSpec>
<ReturnType>%DeepSee.ResultSet</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB245
	Set pStatus = $$$OK
	Set tResultSet = ""
	Try {
		Set tDataSource = pPivotFullName
		If ($$$LOWER($E(tDataSource,*-5,*))'=".pivot") {
			Set tDataSource = tDataSource_".pivot"
		}
		
		// Load a component to access its methods
		Set tPivotObj = ##class(%DeepSee.Component.pivotTable).%New()

		// Open the saved pivot
		Set tPivotDef = ##class(%DeepSee.UserLibrary.Utils).%OpenFolderItem(tDataSource,.pStatus)
		If '$IsObject(tPivotDef) Quit
		
		// Copy saved pivot information to the pivotTable component
		set pStatus = tPivotDef.%CopyToComponent(tPivotObj)
		If $$$ISERR(pStatus) Quit
		 
		// Get filter info
		Set pStatus = tPivotObj.%GetFilterInfo(.tFilterInfo,.tAdvancedFilters)
		If $$$ISERR(pStatus) Quit
		
		// Call %CreateResultSet, which creates the MDX query
		Set tResultSet = tPivotObj.%CreateResultSet(.pStatus, .pParms , .tFilterInfo , .tAdvancedFilters , .pMDX )
		If $$$ISERR(pStatus) Quit
		
		If pExecute {
			// DTB704 - Always use %ExecuteAsynch
			Set pStatus = tResultSet.%ExecuteAsynch(,.pParms,1)
		}
	}
	Catch ex {
		// Return null object if there is an error
		Set pStatus = ex.AsStatus()
		Set tResultSet = $$$NULLOREF
	}
	Quit tResultSet
]]></Implementation>
</Method>

<Method name="%GetChildSpec">
<ClassMethod>1</ClassMethod>
<FormalSpec>pItemList:%String,pCubeName:%String,pAxisNo:%Integer=0,*pChildSpec:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by WAL166
	// DTB - NOTE: pAxisNo is not used! 
	Set tSC = $$$OK
	Set pChildSpec = ""		// DTB864 - Initialize
	
	Try {
		Set k = $O(pItemList(""),1,tInfo)
		Set tHasChildren = 0
		Set tIsRelation = 0
		Set tSpec = ""
		Set c = 0
		While (k'="") {
			Set c = c + 1
			Set tIsAgg = 0
			Set tDimName = $LG(tInfo,3)
			Set tRelSpec = $LG(tInfo,10)
			Set tIsLastItem = ($O(pItemList(k))="")

			// JMD1361 Check for %OR
			If (tRelSpec'="") {
				If ($E(tRelSpec,1,4)'="%OR(") {
					// strip off children and key
					Set tRelSpec = $P(tRelSpec,".children",1)
					Set tRelSpec = $P(tRelSpec,".&[",1)
				}
			}
			If (tRelSpec'="") {
				// JMD1289 try to find names for relationship
				Set tRCubeCaption = tDimName
				Set tRelCube = $$$UPPER(##class(%DeepSee.Utils).%GetRelatedCube(pCubeName,tDimName))

				// JMD1361
				If ($E(tRelSpec,1,4)="%OR(") {
					// strip off %OR, decorate each item, and reapply %OR
					// assume no commas in spec!
					Set t = $E(tRelSpec,6,*-2)
					If (tRelCube'="") {
						// use first OR term to get caption
						Set tRCubeCaption = ##class(%DeepSee.Utils).%GetCubeCaption(tRelCube)
						Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(tRelCube,$P(t,",",1),.tRelDimNo)
						If $$$ISERR(tSC) Quit
					}
					Set ts = ""
					For tp = 1:1:$L(t,",") {
						Set ts = ts _ $S(ts="":"",1:",") _ "["_tDimName_"]"_"."_$P(t,",",tp)
					}
					Set tItemSpec = "%OR({"_ts_"})"

					Set:tItemSpec'="" tSpec = tSpec _ $S(tSpec="":"",1:",") _ tItemSpec
					If (tIsLastItem) {
						If (c>1) {
							Set tSpec = "("_tSpec_")"
						}
					}
					Set:tIsLastItem tIsRelation = 1
				}
				ElseIf ($$$UPPER(tRelSpec) '[ ".%TOPMEMBERS") {
					If (tRelCube'="") {
						Set tRCubeCaption = ##class(%DeepSee.Utils).%GetCubeCaption(tRelCube)
						Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(tRelCube,tRelSpec,.tRelDimNo)
						If $$$ISERR(tSC) Quit
					}
					Set tItemSpec = "[" _ tDimName _ "]." _ tRelSpec

					// JMD862: Test for and use "All level"
					// we should test if there are children of this related level!
					If ($LG(tInfo,6)'="") {
						Set tItemSpec = tItemSpec _ ".&[" _ $$$dsEscapeIdent($LG(tInfo,6))_"]"
						If (tIsLastItem) {
							Set tChildSpec = tItemSpec_".children"
						}
						Else {
							Set tChildSpec = tItemSpec
						}
					}
					Else {
						If (tRelCube'="") {
							Set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(tRelCube,tRelSpec,.tRelDimNo)
							If $$$ISERR(tSC) Quit
							If (tRelDimNo'="") {
								// is there an All level?
								Set tAllLevel = $LG($G($$$DeepSeeMetaGLVN("cubes",tRelCube,"mbr#",tRelDimNo,0,0)),4)
								If (tAllLevel'="") {
									If (tIsLastItem) {
										Set tChildSpec = tItemSpec_".["_tAllLevel_"].children"
									}
									Else {
										Set tChildSpec = tItemSpec_".["_tAllLevel_"]"
									}
								}
							}
						}
					}
					
					Set:tItemSpec'="" tSpec = tSpec _ $S(tSpec="":"",1:",") _ tItemSpec
					If (tIsLastItem) {
						If (c>1) {
							Set tSpec = "("_tSpec_")"
						}
					}
					Set:tIsLastItem tIsRelation = 1
				}
				Quit:tIsLastItem
			}
			ElseIf (tDimName="") {
				// assume an aggregate; loop over children, build set
				Set tIsAgg = 1
				Set tSetSpec = ""
				// JMD1366: try to be smarter about text for computed dimension
				// with %OR in it!
				Set tText = $LG(tInfo,2)
				Set tAgg = $LG(tInfo,4)

				Set k2 = $O(pItemList(k,""),1,tInfo2)
				While (k2'="") {
					// !!! change to recursive function!
					Set tDimNo = $LG(tInfo2,7)
					Set tHierNo = $LG(tInfo2,8)
					Set tLevelNo = $LG(tInfo2,9)
					Set tSC = ##class(%DeepSee.Utils).%GetDimensionCaption(pCubeName,tDimNo,tHierNo,tLevelNo,.tCaption)
					If $$$ISERR(tSC) Quit

					Set tItemSpec = "["_$LG(tInfo2,3) _ "]"
					Set:$LG(tInfo2,4)'="" tItemSpec = tItemSpec _ ".[" _ $LG(tInfo2,4) _ "]"
					Set:$LG(tInfo2,5)'="" tItemSpec = tItemSpec _ ".[" _ $LG(tInfo2,5) _ "]"
					Set:$LG(tInfo2,6)'="" tItemSpec = tItemSpec _ ".&[" _ $$$dsEscapeIdent($LG(tInfo2,6))_"]"
					Set tSetSpec = tSetSpec _ $S(tSetSpec="":"",1:",") _ tItemSpec
					Set k2 = $O(pItemList(k,k2),1,tInfo2) // WAL166
				}
				Set tSetSpec = "{"_tSetSpec_"}"
				Set tSpec = tSpec _ $S(tSpec="":"",1:",") _ tSetSpec
			}
			Else {
				Set tDimNo = $LG(tInfo,7)
				Set tHierNo = $LG(tInfo,8)
				Set tLevelNo = $LG(tInfo,9)
				Set tSC = ##class(%DeepSee.Utils).%GetDimensionCaption(pCubeName,tDimNo,tHierNo,tLevelNo,.tCaption)
				If $$$ISERR(tSC) Quit
				
				// WAL032 -- handle %OR members
				Set tORSpec=$LG(tInfo,11)
				// WAL032

				// JMD976: test for null relationship
				If (($LG(tInfo,3)'="")&&($LG(tInfo,4)="")&&##class(%DeepSee.Utils).%IsRelationship(pCubeName,$LG(tInfo,3))) {
					Set tItemSpec = "["_$LG(tInfo,3) _ "].&[<null>]"
				}
				ElseIf (tORSpec'="") {
					// WAL032
					Set tBaseItemSpec = "["_$LG(tInfo,3) _ "]"
					Set:$LG(tInfo,4)'="" tBaseItemSpec = tBaseItemSpec _ ".[" _ $LG(tInfo,4) _ "]"
					Set:$LG(tInfo,5)'="" tBaseItemSpec = tBaseItemSpec _ ".[" _ $LG(tInfo,5) _ "]"
					
					Set tSC = ##class(%DeepSee.Utils).%MemberHasChildren(pCubeName,tDimNo,tHierNo,tLevelNo,.tHasChildren)
					If $$$ISERR(tSC) Quit
					
					Set tIsLastItem = ($O(pItemList(k))="")	
					
					// Use next level in hierarchy for final child spec
					If (tIsLastItem && tHasChildren) {
						Set tSC = ##class(%DeepSee.Utils).%GetDimensionSpec(pCubeName,.tChildLevelSpec,tDimNo,tHierNo,tLevelNo+1)
						If $$$ISERR(tSC) Quit
						Set tItemSpecForChild=tChildLevelSpec_".MEMBERS"
					}
					Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
					Set tDimensionInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo))
					Set tMemberClass = $lg(tDimensionInfo,6)
					// Loop through the OR members specs
					For i=1:1:$length(tORSpec,"|") {
						Set tORMember = $p(tORSpec,"|",i)
						Set tORMemberKey = $classmethod(tMemberClass,"%GetMemberSpec",tORMember,"Patients",tDimNo,tHierNo,tLevelNo)
						Set:$G(tORMemberKey)'="" tItemSpec = tBaseItemSpec _ "." _ $G(tORMemberKey)
						Set tCompleteItemSpec = $G(tCompleteItemSpec) _ $S($G(tCompleteItemSpec)="":"",1:",") _ tItemSpec
					}
					// Add %OR to tItemSpec
					Set:$G(tCompleteItemSpec)'="" tCompleteItemSpec="%OR({"_tCompleteItemSpec_"})"
					Set tSpec = tSpec _ $S(tSpec="":"",1:",") _ tCompleteItemSpec
					Set tItemSpec = tCompleteItemSpec
					If (c > 1) {
						Set tChildSpec = "CROSSJOIN("_tChildSpec_","_$S($G(tItemSpecForChild)'="":tItemSpecForChild,1:tItemSpec)
					}
					Else {
						Set tChildSpec = $S($G(tItemSpecForChild)'="":tItemSpecForChild,1:tItemSpec)
					}
				}
				Else {
					Set tItemSpec = "["_$LG(tInfo,3) _ "]"
					Set:$LG(tInfo,4)'="" tItemSpec = tItemSpec _ ".[" _ $LG(tInfo,4) _ "]"
					Set:$LG(tInfo,5)'="" tItemSpec = tItemSpec _ ".[" _ $LG(tInfo,5) _ "]"
					Set:$LG(tInfo,6)'="" tItemSpec = tItemSpec _ ".&[" _ $$$dsEscapeIdent($LG(tInfo,6))_"]"
					Set tSpec = tSpec _ $S(tSpec="":"",1:",") _ tItemSpec
					If (c > 1) {
						Set tChildSpec = "CROSSJOIN("_tChildSpec_","_tItemSpec
					}
					Else {
						Set tChildSpec = tItemSpec
					}
				}
				// WAL032
			}

			// next item
			Set k = $O(pItemList(k),1,tInfo)
			If ('tIsAgg&&(k="")) {
				// last item, test for children
				Set tSC = ##class(%DeepSee.Utils).%MemberHasChildren(pCubeName,tDimNo,tHierNo,tLevelNo,.tHasChildren)
				If $$$ISERR(tSC) Quit

				// WAL032 -- don't add ".children" if we are dealing with a %OR spec
				If (tHasChildren&&($LG(tInfo,11)="")) {
					Set tChildSpec = tChildSpec _ ".children"
				}
				// WAL032
			}
			If ('tIsAgg&&(c > 1)) {
				Set tChildSpec = tChildSpec_")"
			}
		}
		
		// make a tuple
		If ('tIsRelation) {
			If (c > 1) {
				Set tSpec = "("_tSpec_")"
			}
			If ('tHasChildren) {
				Set tChildSpec = ""
			}
		}
		Set pChildSpec = tChildSpec
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}

	If $$$ISERR(tSC) {
		// DTB864 - Make sure the return is the null string if there is an error
		Set pChildSpec = ""
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ProcessCubeListArrayNode">
<Description>
Convert a node of the graph returned by %GetCubeListArray into a comma-delimited 
valueList. This may be called on the graph itself.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pNode,pCurrentString="",&pValueList=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB321
	Set tSC = $$$OK
	Try {
		Set tItem = $O(pNode(""))
		While tItem'="" {
			If ($P(tItem,".",*)="folder") {
				// Folder: recurse
				Merge tNewNode = pNode(tItem)
				Set tNewString = pCurrentString _ $S($L(pCurrentString):"/",1:"") _ $LG(pNode(tItem),1)
				Do ..%ProcessCubeListArrayNode(.tNewNode,tNewString,.pValueList)
			}
			Else {
				// Cube: Add to the list
				// N.B. Security has already been checked in %GetCubeList
				Set pValueList = pValueList _ $S($L(pValueList):",",1:"") _ pCurrentString _ $S($L(pCurrentString):"/",1:"") _ $LG(pNode(tItem),1)
			}

			Set tItem = $O(pNode(tItem))
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ParseSQLFieldList">
<Description><![CDATA[
Split a single fieldList string into the individual fields.</br>
The output <var>pFieldArray</var> returns each SELECT item in</br>
pFieldArray(termNumber) = $LB( $LB(fieldIdenitifier,"AS",logicalHeader), $LB(fieldIdenitifier,"AS",displayHeader))</br></br>
The <var>pLocalize</var> parameter can be used to request behavior of the $$$TEXT macro in the header portion:</br>
0 - Return the original text value from $$$TEXT</br>
1 - Return the header value localized to the language of the current client</br>
When <var>pLocalize</var> is used, a default domain can be provided in <var>pDomain</var>. This domain will be used for translation for each
instance of $$$TEXT that does not specify its own domain.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFieldString="",pDomain="",*pFieldArray,pLocalize:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Kill pFieldArray
	Set pFieldArray = ""
	
	Try {
		If (pFieldString="") {
			Quit
		}
		
		Set tSELECT = pFieldString

		Set tSQLParser = ##class(%DeepSee.SQL.Parser).%New(.tSELECT)
		
		Set tSC = tSQLParser.%Tokenize()
		If $$$ISERR(tSC) Quit
		
		
		Set tSC = tSQLParser.%ParseSelect(tSQLParser.%GetTokenList(),.tSelectItems,.tSpecialTokens)
		
		For itemNo=0:1:tSelectItems.%Size()-1 {
			Set tHeaderPos = -1		// Default: There is no header
			Kill tTextPos
			Set tSelectItemTokens = tSelectItems.%Get(itemNo)
			
			// Search for a header
			If $D(tSpecialTokens("tokens","$$$TEXT[",itemNo)) {
				// First check for the $$$TEXT macro. Mark the position of the macro.
				Set tTextPos = $O(tSpecialTokens("tokens","$$$TEXT[",itemNo,""))
				If $D(tSpecialTokens("tokens","""",itemNo,tTextPos-1)) {
					// If the preceding character is " the header begins on the
					// previous token
					Set tHeaderPos = tTextPos-1
				}
				Else {
					Set tHeaderPos = tTextPos
				}
			}
			ElseIf ($D(tSpecialTokens("tokens","AS",itemNo))) {
				Set tHeaderPos = $O(tSpecialTokens("tokens","AS",itemNo,"")) + 1
			}
			ElseIf ($D(tSpecialTokens("tokens","""",itemNo))) {
				// Delimited identifier. If this is not the first token,
				// consider it a header
				Set tPos = $O(tSpecialTokens("tokens","""",itemNo,""))
				Set:(tPos) tHeaderPos=tPos
			}
			ElseIf (tSelectItemTokens.%Size()>1) {
				// If the final token is not a closing parenthesis,
				// it should be a header
				Set tFinalToken = tSelectItemTokens.%Get(tSelectItemTokens.%Size()-1)
				Set tPenultToken = tSelectItemTokens.%Get(tSelectItemTokens.%Size()-2)
				If (tFinalToken'=")") &&
						(tFinalToken'="]") &&
						(tPenultToken'="->") &&
						'tSQLParser.%IsOperatorToken(tPenultToken) {
					Set tHeaderPos = tSelectItemTokens.%Size()-1
				}
			}
			
			Set tSC = tSQLParser.%ProcessSelectItem(tSelectItemTokens,$G(tHeaderPos,-1),pDomain,.tItemPair,pLocalize)		// DTB827 - Pass localization flag
			If $$$ISERR(tSC) $$$ThrowStatus(tSC)
			
			Set pFieldArray($I(pFieldArray)) = tItemPair
		}		// Single Select Item
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ArrayToList">
<Description>
Convert a single-subscript array to an $LB format</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pParms,*pParmsList:%List]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB882
	Set tSC = $$$OK
	
	Try {
		Set pParmsList = $LB()		// Default return is an empty list
		Set tParmName = $O(pParms(""),1,tParmData)
		While (tParmName'="") {
			Set $LI(pParmsList,$I(tListIdx)) = $LB(tParmName,tParmData)
			Set tParmName = $O(pParms(tParmName),1,tParmData)
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ArrayFromList">
<Description>
Convert a parameters list in $LB format to an array</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pParmsList:%List=$LB(),&pParms]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB882
	Set tSC = $$$OK
	Try {
		For tParmIdx=1:1:$LL(pParmsList) {
			Set tParmDef = $LG(pParmsList,tParmIdx)
			Set:(tParmDef'="") pParms($LG(tParmDef,1)) = $LG(tParmDef,2)
		}
		
		If '$D(pParms) {
			// Return a null variable if nothing was set from the list to prevent <UNDEFINED> references
			Set pParms = ""
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%IsValidFactList">
<Description><![CDATA[
Test a <var>pFactList</var> to make sure it contains only SQL column identifiers that are actually defined in <var>pCube</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCube:%String="",pFactList:%String="",*pStatus:%Status,pReason:%String=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB900
	Set pStatus = $$$OK
	Set tIsValidFactList = 0
	Set pReason = ""
	
	Try {
		// Normalize the incoming pFactList to a $LB for examination
		Set tFactList = ..%NormalizeFactList(pFactList)
		
		If (tFactList=$LB()) {
			// Consider an empty list to be valid and quit
			Set tIsValidFactList = 1 
			Quit
		}

		Set tCubeIndex = $$$DeepSeeIndex(pCube)
		Set tFactTable = ##class(%DeepSee.Utils).%GetCubeFactTable(tCubeIndex)
		Set tRS = ##class(%SQL.Statement).%ExecDirect(.tS,"SELECT * FROM " _ tFactTable)
		Set tFactMeta = tRS.%GetMetaData()
				
		// Check the contents of the non-empty fact list against the cube's metadata
		Set tIsValidFactList = 1
		For ii=1:1:$LL(tFactList) {
			Set tFactNameU = $$$UPPER($LG(tFactList,ii))
			
			// DTB915 - Return the specific invalid column identifiers
			Set tFactIsValid = $D(tFactMeta.columnIndex(tFactNameU))
			If 'tFactIsValid {
				Set pReason = pReason _ $LB($LG(tFactList,ii))
			}

			Set tIsValidFactList = tIsValidFactList && tFactIsValid
		}
		
		If 'tIsValidFactList {
			// DTB908 - Report an error if validation has failed
			Set pStatus = $$$ERROR($$$GeneralError,"Fact list does not contain valid column identifiers for cube:"_tCubeIndex_":"_$ListToString(tFactList,","))
		}
	}
	Catch ex {
		Set tIsValidFactList=0
		Set pStatus = ex.AsStatus()
	}
	
	Quit tIsValidFactList
]]></Implementation>
</Method>

<Method name="%NormalizeFactList">
<Description><![CDATA[
Take as input a <var>pFactList</var> in either comma-delimited string or $LB format and 
return a fact list in $LB format with any empty entries removed.
If <var>pCubeName</var> is supplied, any supporting fields that are required to produce a successful
Selective Build given the cube definition are added to the original list.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFactList="",*pStatus:%Status,pCubeName=""</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set pStatus = $$$OK
	
	Try {
		Set tTest = $S($ListValid(pFactList):pFactList,1:$ListFromString(pFactList,","))
		Set tReturn = ""
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		
		// Collect the non-null terms in the incoming list
		For ii=1:1:$LL(tTest) {
			If $LD(tTest,ii) && ($LG(tTest,ii)'="") {
				Set tTerms($ListGet(tTest,ii)) = ""
			}
		}
		
		// DTB961 - Reinforce the targeted fact list with any other data columns that must
		// be included for a successful build
		Do:(tCubeIndex'="") ..%ReinforceFactList(tCubeIndex,.tTerms)
		
		// Reassemble the list from the processed collection
		Set tFactName = $O(tTerms(""))
		While (tFactName'="") {
			Set tReturn = tReturn _ $LB(tFactName)
			Set tFactName = $O(tTerms(tFactName))
		}
	}
	Catch ex {
		Set pStatus = ex.AsStatus()
	}

	Quit tReturn
]]></Implementation>
</Method>

<Method name="%ReinforceFactList">
<Description><![CDATA[
This examines an array of facts for a given cube as provided in <var>pFacts</var> 
- For levels in a hierarchy all parent levels in that hierarchy will also be included in the list.
- For time levels the common reference column in the fact table on which the time functions operate
will also be added to the list.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCubeIndex="",&pFacts]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB961
	Set tSC = $$$OK
	
	Try {
		Set tCubeIndex = pCubeIndex
		
		// Attempt to identify named lower members of a hierarchy. All parents must also be in the list for 
		// a cube's Selective Build. If the cube index is not supplied, skip this step.
		If (tCubeIndex'="") {
			Merge tCubeProperties = $$$DeepSeeMetaGLVN("cubes",tCubeIndex,"fact","prop")
			
			Set tFactName = $O(pFacts(""))
			While (tFactName'="") {
				Set tDimNo = $G(tCubeProperties(tFactName,"dimNo"))
				Set tHierNo = $G(tCubeProperties(tFactName,"hierNo"))
				Set tLevelNo = $G(tCubeProperties(tFactName,"levelNo"))
				
				If (tDimNo'="") {
					// Add to the list based on the dimension information
					Set tNode = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo))
					If (+tLevelNo>1) {
						// This level may have a parent level in a hierachy. Look up for other "l" nodes. 
						// The "all" member might be the first node in the list.
						Set tParentLevel = $O($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo),-1,tParentNode)
						While ($LG(tParentNode,1)="l") {
							// This hierarchical parent is a true level. Add it to the facts that need to 
							// be processed.
							Set pFacts($LG(tParentNode,7)) = ""
							
							Set tParentLevel = $O($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tParentLevel),-1,tParentNode)
						}
					}
					
					If $classmethod($LG(tNode,6),"%IsA","%DeepSee.Time.AbstractLevel") {
						// This is a time level, which means the fact table will require a non-indexed
						// data column. This will make sure that column is included in the list along with the 
						// actual indexed column for the level originally supplied.
						Set pFacts($LG(tNode,7)) = ""
					}
				}

				Set tFactName = $O(pFacts(tFactName))
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%FindCubeIndexList">
<Description><![CDATA[
Provided a <var>pCubeName</var> and a valid <var>pFactList</var> for that cube, return the list
of buildable indices contained in the original fact list. If no fact list is supplied, the method
returns a null string.<br>
This is best used following normalization of the fact list using <method>%NormalizeFactList</method>
method with the cubename suplied.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName="",*pStatus:%Status,pFactList=""</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB961
	Set pStatus = $$$OK
	Set tIndexList = ""
	
	Try {
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		Set tFactClass = ..%GetCubeFactClass(tCubeIndex)
		Set tFactList = ..%NormalizeFactList(pFactList)
		
		If (tFactList'="") {
			// Look through the supplied fact list and check it against the existence of a 
			Set tPtr = 0
			While $listnext(tFactList,tPtr,tFact) {
				If ##class(%Dictionary.IndexDefinition).%ExistsId(tFactClass_"||"_tFact) {
					Set tIndexList = tIndexList _ $LB(tFact)
				}
			}
		}
	}
	Catch ex {
		Set pStatus = ex.AsStatus()
		Set tIndexList = ""
	}
	
	Quit tIndexList
]]></Implementation>
</Method>

<Method name="%LockFactList">
<Description><![CDATA[
Take out locks for the specific column identifiers in a <var>pFactList</var> under the synchronze lock. This
will prevent a general build or a synchronize but will not prevent selected updates of other 
columns in the fact table.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCubeName:%String,pFactList:%List,&pLocked,pLockTimeout=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB906
	Set tSC = $$$OK
	Set pLocked = 0
	
	Try {
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		//Set tLockedList = $LB()
		
		For ii=1:1:$LL(pFactList) {
			Set tColumnID = $LG(pFactList,ii)
			If (tColumnID'="") {
				Lock +^DeepSee.Build(tCubeIndex,"SYNC",tColumnID):pLockTimeout Else  Set tSC = $$$ERROR($$$GeneralError,"Unable to obtain the lock needed to update cube: " _ pCubeName)
				If $$$ISERR(tSC) Quit
			} 
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	If $$$ISERR(tSC) {
		// If locking failed, run an unlock on all potential resources
		Do ..%UnlockFactList(tCubeIndex,pFactList)
	}
	Else {
		// Lock succeeded, send notification back to the caller
		Set pLocked = 1
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%UnlockFactList">
<Description>
Release the update locks for the selected fact list.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pFactList:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB906
	Set tSC = $$$OK
	
	Try {
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		For ii=1:1:$LL(pFactList) {
			Set tColumnID = $LG(pFactList,ii)
			If (tColumnID'="") {
				Lock -^DeepSee.Build(tCubeIndex,"SYNC",tColumnID)
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%MarkFactsEnabled">
<Description><![CDATA[
Mark dimensions as enabled or disabled according to <var>pEnabled</var>. If the fact list is not supplied, mark all as enabled. Otherwise,
mark only the dimensions supplied in the fact list.<br>
This method can also optionally mark that a dimension is in the process of updating using the <var>pInProgress</var> paraeter. ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String="",pFactList:%String="",pEnabled=1,pInProgress=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB908
	Set tSC = $$$OK
	
	Try {
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		// DTB961 - Reinforce the list by including the cube in the call to normalize
		Set tFactList = ..%NormalizeFactList(pFactList,.tSC,tCubeIndex)
		If $$$ISERR(tSC) Quit
		
		If '..%IsValidFactList(tCubeIndex,tFactList,.tSC) {
			Quit
		}
		
		// Create a temporary index for identifiying the items in the fact list
		For ii=1:1:$LL(tFactList) {
			Set tFactListArray($$$UPPER($LG(tFactList,ii))) = ""
		}

		// Step through the various facts represented by columnIDs and mark enabled based on the fact list.
		// - This covers dimensions and relationships
		Set tFactNo = $O($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"fact#",""),1,tFactID)
		While (tFactNo'="") {
			Do SetFactEnabled(tFactID,pEnabled,pInProgress,.tFactListArray)
			
			Set tFactNo = $O($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"fact#",tFactNo),1,tFactID)
		}
		
		// - This covers measures
		Set tMsrNo = $O($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"msr#",""),1,tMsrID)
		While (tMsrNo'="") {
			Do SetFactEnabled(tMsrID,pEnabled,pInProgress,.tFactListArray)
			
			Set tMsrNo = $O($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"msr#",tMsrNo),1,tMsrID)
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
	
SetFactEnabled(tFactID,enabled,inProgress,tFactListArray)
	// Check for the use of an alias [defined factName] when searching for the facts to 
	// mark enabled. This performs the actual set.
	Set tColID = ""
	If $D(tFactListArray($$$UPPER(tFactID))) {
		// The logical identifier n the metadata is also the SQL column identifier
		Set tColID = tFactID
	}
	Else {
		// The alias needs to be checked since the logical model name did not match
		Set tAlias = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"fact","prop",tFactID,"alias"),tFactID)
		If $D(tFactListArray($$$UPPER(tAlias))) {
			Set tColID = tAlias
		} 
	}
	
	If '$D(tFactListArray) || (tColID'="") {
		If $D($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"fact","prop",tFactID)) {
			Set $$$DeepSeeMetaGLVN("cubes",tCubeIndex,"fact","prop",tFactID,"enabled") = enabled
			Set $$$DeepSeeMetaGLVN("cubes",tCubeIndex,"fact","prop",tFactID,"inProgress") = inProgress
		}
	}

	Quit
]]></Implementation>
</Method>

<Method name="%IsFactEnabled">
<Description>
Check to see if a given dimension is currently queryable for a given cube.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String="",pSpec:%String="",*pStatus:%Status,*pFactName:%String,*pInProgress</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB908
	Set tReturn = 0
	Set pStatus = $$$OK
	Set pInProgress = 0
	
	Try {
		Do ##class(%DeepSee.Query.Parser).%ParseMemberSpec(pCubeName,.tCubeParseInfo)
		Set:($G(tCubeParseInfo(1))'="") tCubeName = tCubeParseInfo(1)
		
		Set tCubeIndex = $$$DeepSeeIndex(tCubeName)
		
		Set pStatus = ..%GetDimensionInfo(tCubeIndex,pSpec,.tDimNo,.tHierNo,.tLevelNo,.tRelation,.tRelationSpec,.tSpecInfo,,0)
		If $$$ISERR(pStatus) Quit
		
		// The plan for relationships is to check the most local relationship reference, and then recursively check deeper levels to make sure all relations and
		// ultimately the actual dimension where it rests in the destination cube
		Set tHasRelation = (tRelation'="")
		
		If tHasRelation {
			// DTB913 - A null reference for a relationship can end up as a single null key, consider this enabled
			Do ##class(%DeepSee.Query.Parser).%ParseMemberSpec(tRelationSpec,.tSpecParseInfo)
			Set tFirstPieceU = $$$UPPER($G(tSpecParseInfo(1)))
			If (tFirstPieceU=$$$UPPER("<null>")) || (tFirstPieceU=$$$UPPER($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"relations",$$$UPPER(tRelation),"nullReplacement"))) {
				Set tReturn = 1
				Quit
			}
			
			Set tFactID = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"relations",$$$UPPER(tRelation),"fact"))
			
			Set pFactName = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"fact","prop",tFactID,"alias"),tFactID)
		}
		Else {
			Set tFactInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo))
			
			Set tType = $LG(tFactInfo,1)
			If (tType="h") {
				// Special case: the spec was not fully qualified, look for a real level
				Set tLevelNo=$O($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo),1,tFactInfo)
				While (tLevelNo'="")&&(tType'="l") {
					Set tType = $LG(tFactInfo,1)
					Set tLevelNo=$O($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo),1,tFactInfo)
				}
			}

			Set tLocation = $S((tType="l"):"fact#",(tType="m"):"msr#",1:"fact#")
			Set tFactNo = $LG(tFactInfo,5)
			// + DTB913 - Special treatment for %COUNT
			If (+$S($E(tFactNo)="M":$E(tFactNo,2,*),1:tFactNo)>1) {
				Set tFactID = $$$DeepSeeMetaGLVN("cubes",tCubeIndex,tLocation,tFactNo)
			}
			ElseIf (($LG(tFactInfo,3)="%COUNT")||(tFactNo=1)||(tType="all")) {
				// There is no metadata for this!
				Set tReturn=1
				Quit
			}
			Else {
				// More sophisticated checking could happen here, but this breaks too much to default to 0! 
				Set tReturn = 1
				Quit
			}
			// - DTB913
			
			Set pStatus = ..%GetDimensionFact(tCubeIndex,tDimNo,tHierNo,tLevelNo,.pFactName)		// DTB911 - Use available API to fetch name
			If $$$ISERR(pStatus) Quit
		}
		
		// Check the enabled status. A missing value should be treated as enabled
		Set tReturn = $$$dsFactEnabled(tCubeIndex,tFactID)
		Set pInProgress = $$$dsFactInProgress(tCubeIndex,tFactID)
		
		// Now recurse into relations if it applies
		If tReturn && tHasRelation && (tRelationSpec'="") {
			Set tRelCube = $$$DeepSeeMetaGLVN("cubes",tCubeIndex,"relations",$$$UPPER(tRelation),"relatedCube")
			Set tReturn = tReturn && ..%IsFactEnabled(tRelCube,tRelationSpec,.pStatus)
			If $$$ISERR(pStatus) Quit
		}
	}
	Catch ex {
		Set pStatus = ex.AsStatus()
		Set tReturn = 0
	}
	
	Quit tReturn
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.WorkMgr">
<Description><![CDATA[
 Utility class that provides an API for managing
 DeepSee tasks.<br/>
 This is an internal utility used by DeepSee.]]></Description>
<IncludeCode>%DeepSee,%syPidtab,%occErrors</IncludeCode>
<IncludeGenerator>%occUtility,%DeepSee</IncludeGenerator>
<Super>%RegisteredObject</Super>
<System>3</System>
<TimeCreated>61131,51012.499422</TimeCreated>

<Parameter name="EVENTNAME">
<Description>
 Name of system used to talk to agents.</Description>
<Default>^DeepSee.Tasks.</Default>
</Parameter>

<Parameter name="TIMEOUT">
<Description>
 Timeout value (seconds) for events.
 If no events are received, then the agent will shut itself down.</Description>
<Default>0</Default>
</Parameter>

<Method name="%SetLoggingOptions">
<Description><![CDATA[
Turn on logging for the DeepSee background agents. These will be reset during a call to <method>%KillLog</method>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pUseArchive=0,pLogSize=100,pLogAll=0</FormalSpec>
<Implementation><![CDATA[
	// Method added by DTB256
	Set $$$DeepSeeAgentLogGLVN("settings","useArchive") = pUseArchive
	Set $$$DeepSeeAgentLogGLVN("settings","logSize") = pLogSize
	Set $$$DeepSeeAgentLogGLVN("settings","logAll") = pLogAll
]]></Implementation>
</Method>

<Method name="%Reset">
<Description><![CDATA[
 Reset the WorkMgr.<br/>
 This stops all running agents, clears out all tasks, and clears the logs.]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tSC = ##class(%DeepSee.WorkMgr).%KillAgents(1)
		If $$$ISERR(tSC) Quit

		Set tSC = ##class(%DeepSee.WorkMgr).%KillLog()
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%IsActive">
<Description>
 WorkQ agents will be made available as needed. This test always returns True</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 1
]]></Implementation>
</Method>

<Method name="%WaitForTaskGroup">
<Description><![CDATA[
 Wrapper for the WorkMgr:WaitForComplete() that parallels the original %DeepSee.TaskMaster version.
The caller may optionally supply an object reference to a <var>pWorkMgr</var> for custom use.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pTaskGroup:%String="",*pCompleted:%Boolean,pTimeOut:%Integer=0,&pWorkMgr:%SYSTEM.WorkMgr=$$$NULLOREF]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pCompleted = 0
	
	Try {		
		Set tReuseWorkMgr = $IsObject(pWorkMgr)&&pWorkMgr.%IsA("%SYSTEM.WorkMgr")		// DTB923
		Set tQueueName = ..%BestQueue(pTaskGroup)		// Find which queue this has been assigned to
		
		// This lock will be taken longer than the queueing locks since it might have to wait for the WorkMgr
		// as directed by pTimeout.
		Lock +$$$DeepSeeAgentsGLVN("workToken",tQueueName)
			Set tToken = $G($$$DeepSeeAgentsGLVN("workToken",tQueueName))		// DTB799 - Read the available token to return with an error if necessary
			
			If tReuseWorkMgr {		// DTB923
				Set tWorkMgr = pWorkMgr
			}
			Else {
				Set tWorkMgr = ..%AttachToQueue(tQueueName,.tSC)
				If $$$ISERR(tSC) $$$ThrowStatus(tSC)
				
				If '$IsObject(tWorkMgr) {
					// DTB799 - Prevent <INVALID OREF> error and return more information
					Set tAttachFailure = 1
					Set tSC = $$$ERROR($$$GeneralError,"Failure to reattach to work queue: " _ tQueueName _" : "_ tToken _":"_ $D($$$DeepSeeAgentsGLVN("workToken",tQueueName),tNewToken) _":"_ $G(tNewToken,"No token node"))
					$$$ThrowStatus(tSC)
				}
			}
			
			If pTimeOut>0 {
				// Do a timed wait
				Set tSC = tWorkMgr.Wait(,.tAtEnd,pTimeOut)
				If $$$ISERR(tSC) $$$ThrowStatus(tSC)
				
				Set:tAtEnd pCompleted = 1
			}
			Else {
				Set tSC = tWorkMgr.WaitForComplete()
				If $$$ISERR(tSC) $$$ThrowStatus(tSC)
				
				Set pCompleted = 1
			}

			If (pCompleted) {
				If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
					Do ..%Log("Task group complete: "_pTaskGroup_" "_$G(%dsCubeName))
				}
				
				Kill $$$DeepSeeTaskGroupGLVN(pTaskGroup)		
				Kill $$$DeepSeeAgentsGLVN("workToken",tQueueName)		// Clear the work token container
			}
			Else {
				If 'tReuseWorkMgr {
					// DTB - If not completed, detach and return
					Set tSC = ..%DetachFromQueue(tQueueName,.tWorkMgr)
					If $$$ISERR(tSC) $$$ThrowStatus(tSC)
				}
			}
		Lock -$$$DeepSeeAgentsGLVN("workToken",tQueueName)
	}
	Catch ex {
		Set tSC = ex.AsStatus()
		
		If ($G(tQueueName)'="") {
			Lock -$$$DeepSeeAgentsGLVN("workToken",tQueueName)
		}
	}
	
	If $$$ISERR(tSC) {
		Do ..%Log("ERROR:%WaitForTaskGroup:: "_$G(tTaskGroup,"Task Group Key Undefined")_" "_$G(%dsCubeName) _" :: "_ $system.Status.GetErrorText(tSC))
		Do:+$G(tAttachFailure) ..%Log("Last Kernel Error:%WaitForTaskGroup:: " _ $zu(56,2))		// DTB799 - In case there is a specific WorkMgr kernel error, log the last kernel error location here.
	}	
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%CreateTaskGroup">
<Description><![CDATA[
Create a unique idenitfier for a task group. 
The caller may optionally request an object reference with <var>pRequestWorkMgr</var>=1 which
will be returned via <var>pWorkMgr</var> for customized use.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pTaskGroup:%String,pWait:%Boolean=0,pName:%String="",pRequestWorkMgr=0,*pWorkMgr=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
		
	Try {
		Set pTaskGroup = "^DeepSee.TG." _ pName _ $I($$$DeepSeeTaskGroupGLVN)
		Set $$$DeepSeeTaskGroupGLVN(pTaskGroup,"wait") = pWait
		
		If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
			Do ..%Log("Task group create " _ pTaskGroup)
		}
		
		If pRequestWorkMgr {
			// DTB923 - Optionally create an instance of the WorkMgr here and return it to the caller
			Set pWorkMgr = ..%InitializeWorkMgr(pTaskGroup,.tSC)
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	If $$$ISERR(tSC) {
		Do ..%Log("ERROR:%CreateTaskGroup: "_$System.Status.GetErrorText(tSC))
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%DestroyTaskGroup">
<Description>
Close down all work being done by this task group</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskGroup:%String="",pPurgeTasks:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	Try {
		Set tQueueName = ..%BestQueue(pTaskGroup)
		
		// Prevent any other calls from picking up this work
		Lock +$$$DeepSeeAgentsGLVN("workToken",tQueueName)
		
		// DTB706 - If there is no work token associated with this task group, don't bother attempting
		// to attach.
		If $D($$$DeepSeeAgentsGLVN("workToken",tQueueName)) {
			
			If ($G($$$DeepSeeAgentsGLVN("workToken",tQueueName))'="") {
				// DTB722 - Attach and tear down the WorkMgr if there is an attachment token defined
				Set tWorkMgr = ..%AttachToQueue(tQueueName,.tSC)
				If $$$ISERR(tSC) $$$ThrowStatus(tSC)
				
				Set tSC = tWorkMgr.Clear(0)
				If $$$ISERR(tSC) $$$ThrowStatus(tSC)
				
				Kill tWorkMgr	
			}
			
			Kill $$$DeepSeeAgentsGLVN("workToken",tQueueName)		// Clear the work token container
		}
		Lock -$$$DeepSeeAgentsGLVN("workToken",tQueueName)
		
		If pPurgeTasks {
			// Clean up globals
			Set tSC = ..%KillTasksForGroup(pTaskGroup)
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
		
		If ($G(tQueueName)'="") {
			Lock -$$$DeepSeeAgentsGLVN("workToken",tQueueName)
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%CreateAgents">
<Description>
 - NOT IMPLEMENTED -
This is handled by the WorkQMgr as part of task queueing operations</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNumAgents:%Integer=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// - NOT IMPLEMENTED -
	Quit $$$NotImplemented
]]></Implementation>
</Method>

<Method name="%AttachToQueue">
<Description><![CDATA[
Look up a token to reattach to a given WorkMgr queue.
After successfully serializing a WorkMgr instance, through either attachment to a pre-existing queue or initialization of a new queue,
the storage location for the provided <var>pQueueName</var> is marked with the null string to provide an indication the queue is
currently open and working.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pQueueName:%String="",*pStatus:%Status=$$$OK</FormalSpec>
<ReturnType>%SYSTEM.WorkMgr</ReturnType>
<Implementation><![CDATA[
	Set tWorkMgr = $$$NULLOREF
	
	Try {
		If $D($$$DeepSeeAgentsGLVN("workToken",pQueueName)) {
			Set tToken = $G($$$DeepSeeAgentsGLVN("workToken",pQueueName))
			If (tToken'="") {
				Set tWorkMgr = $system.WorkMgr.Attach(tToken,.tSC)
				Set $$$DeepSeeAgentsGLVN("workToken",pQueueName) = ""
			}
			Else {
				// This queue attempted to attach to a WorkMgr that has already been reattached
				Set pStatus = $$$ERROR($$$GeneralError,"No WorkMgr token available for "_pQueueName)
			}
		}
		Else {
			Set tWorkMgr = ..%InitializeWorkMgr(pQueueName,.pStatus)		// DTB923
		}
	}
	Catch ex {
		Set pStatus = ex.AsStatus()
	}
	
	Quit tWorkMgr
]]></Implementation>
</Method>

<Method name="%DetachFromQueue">
<Description>
Detach from a given WorkMgr queue and store the current token needed to reattach.
If the storage location has been deleted before detaching from the queue (eg: by a cancellation operation),
then the token is discarded.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pQueueName:%String="",&pWorkMgr:%SYSTEM.WorkMgr=$$$NULLOREF]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	Try {
		// DTB722 - Check the workToken index to confirm the existence of an active slot for this queue. If the slot has been removed,
		// no further work should be done and the queue should simply be closed down.
		If $D($$$DeepSeeAgentsGLVN("workToken",pQueueName)) {
			// Detach and store the attachment token
			Set tSC = pWorkMgr.Detach(.tToken)
			
			If $$$ISERR(tSC) { 
				Quit
			}
			ElseIf (tToken'="") {
				Set $$$DeepSeeAgentsGLVN("workToken",pQueueName) = tToken
			}
		}
		
		Kill pWorkMgr
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%KillAgents">
<Description>
Find all open WorkQ manager instances and shut them down</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPurgeTasks:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	Try {
		// DTB706 - Work through the current workToken and shut down the WorkQ manager
		// instances associated with work dispatched using %DestroyTaskGroup
		Lock +$$$DeepSeeAgentsGLVN("workToken")
		Set tTaskGroup = $O($$$DeepSeeAgentsGLVN("workToken",""),1,tToken)
		While (tTaskGroup'="") {
			If (tToken="") {
				// If this is null when the lock is established, there is no WorkMgr to attach to.
				// Just kill the node.
				Kill $$$DeepSeeAgentsGLVN("workToken",tTaskGroup)
			}
			Else {
				Set tSC = ..%DestroyTaskGroup(tTaskGroup)
				If $$$ISERR(tSC) $$$ThrowStatus(tSC)
			}
			
			Set tTaskGroup = $O($$$DeepSeeAgentsGLVN("workToken",tTaskGroup),1,tToken)
		}
		Lock -$$$DeepSeeAgentsGLVN("workToken")
		
		If (pPurgeTasks) {
			Kill $$$DeepSeeTasksGLVN
			Kill $$$DeepSeeActiveTasksGLVN
			Kill $$$DeepSeeTaskGroupGLVN
		}	
	}
	Catch ex {
		Lock -$$$DeepSeeAgentsGLVN("workToken")
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%KillTasksForGroup">
<Description>
This performs the actual cleanup work to remove all tasks assigned to a particular logical work group.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskGroup:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// DTB706 - This works through the individual tasks assigned to a particular group and removes
	// all associated task information by ID
	Set tSC = $$$OK
	
	Try {
		Set tTaskId = $O($$$DeepSeeTaskGroupGLVN(pTaskGroup,"tasks",""))
		While (tTaskId'="") {
			Kill $$$DeepSeeTasksGLVN(tTaskId)
			Kill $$$DeepSeeActiveTasksGLVN(tTaskId)
			
			Set tTaskId = $O($$$DeepSeeTaskGroupGLVN(pTaskGroup,"tasks",tTaskId))		// DTB722 - Fix infinite loop from missing tTaskId start point
		}

		Kill $$$DeepSeeTaskGroupGLVN(pTaskGroup)
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%QueueTask">
<Description><![CDATA[
 This is called from the foreground to 
 add a task to the queue of background tasks.<br/>
 <var>pTaskGroup</var> must be defined in order to properly assign individual tasks
 to a particular work queue.
 The caller may optionally supply an object reference to a <var>pWorkMgr</var> to add 
 the task to that custom work queue.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pTaskGroup:%String="",pTaskType:%String,pCubeName:%String,pQueryKey:%String="",pData:%String="",pData2:%String="",pData3:%String="",pSQLParams:%String="",pSuppressArchive:%Boolean=0,&pWorkMgr:%SYSTEM.WorkMgr=$$$NULLOREF]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tReuseWorkMgr = $IsObject(pWorkMgr)&&pWorkMgr.%IsA("%SYSTEM.WorkMgr")		// DTB923
		/*
		// DTB - %ExecuteTask takes the following in its list parameters
		Set pTaskId = $LG(pParameters,1)
		Set pTaskType = $LG(pParameters,2)
		Set pCubeName = $LG(pParameters,3)
		Set pQueryKey = $LG(pParameters,4)
		Set pData = $LG(pParameters,5)
		Set pData2 = $LG(pParameters,6)
		Set pData3 = $LG(pParameters,7)
		Set pSQLParams = $LG(pParameters,8)
		*/
		
		Set tTaskId = $I($$$DeepSeeTasksGLVN)
		Set tTaskDetails = $LB(tTaskId,pTaskType,pCubeName,pQueryKey,pData,pData2,pData3,pSQLParams)
		
		If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
			Do ..%Log("Queue " _ pTaskType _ ":" _ pCubeName _ ":" _ pQueryKey _ ":: PARAMETERS:"  _ $ListToString(tTaskDetails,":"))
		}
		
		If (pTaskGroup'="") {
			If ($G($$$DeepSeeTaskGroupGLVN(pTaskGroup,"errorCode"))'="") {
				// don't even queue this task
				Set tSC = $$$DeepSeeTaskGroupGLVN(pTaskGroup,"errorCode")
				Quit
			}
			
			Set $$$DeepSeeTaskGroupGLVN(pTaskGroup,"tasks",tTaskId) = tTaskDetails
			Set x = $I($$$DeepSeeTaskGroupGLVN(pTaskGroup,"count"))
		}
		Else {
			// DTB - %QueueTask has been called without an established group
			Set tSC = $$$ERROR($$$GeneralError,"%QueueTask attempted without a task group")
			Quit
		}
		
		Set tQueueName = ..%BestQueue(pTaskGroup)		// Find which queue this should be assigned to
		
		Set $$$DeepSeeTasksGLVN(tTaskId) = tTaskDetails
		
		// JMD1047: add foreground context to task
		// Set $$$DeepSeeTasksGLVN(tTaskId,"CTX","NAMESPACE") = $ZU(5)
		If $IsObject($G(%session)) {
			Set $$$DeepSeeTasksGLVN(tTaskId,"CTX","SESSIONID") = %session.SessionId
			Set $$$DeepSeeTasksGLVN(tTaskId,"CTX","LANGUAGE") = %session.Language
		}
		
		// Make sure only one process queues to the WorkQ at a time
		Lock +$$$DeepSeeAgentsGLVN("workToken",tQueueName):1
		
		// Attach to the task group's work manager
		If tReuseWorkMgr {		// DTB923
			Set tWorkMgr = pWorkMgr
		}
		Else {
			Set tWorkMgr = ..%AttachToQueue(tQueueName,.tSC)
			If $$$ISERR(tSC) $$$ThrowStatus(tSC)
		}
		
		If '$IsObject(tWorkMgr) {
			Set tSC = $$$ERROR($$$GeneralError,"Failure to instantiate work manager")
			$$$ThrowStatus(tSC)
		}
		
		Set tSC = tWorkMgr.Queue("##class(%DeepSee.WorkMgr).%ExecuteTask",pTaskGroup,tTaskDetails,pSuppressArchive)

		If $$$ISERR(tSC) {
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("ERROR " _ pTaskType _ ":" _ pTaskGroup _ ":" _ tTaskId)
			}
			$$$ThrowStatus(tSC)
		}
		
		If 'tReuseWorkMgr {
			// DTB - If the caller is not maintaining a live object, detach again 
			// The new token is stored under the queuename
			Set tSC = ..%DetachFromQueue(tQueueName,.tWorkMgr)
			If $$$ISERR(tSC) $$$ThrowStatus(tSC)
		}
		
		Lock -$$$DeepSeeAgentsGLVN("workToken",tQueueName)
	}
	Catch(ex) {
		If ($G(tQueueName)'="") {
			Lock -$$$DeepSeeAgentsGLVN("workToken",tQueueName)
		}
		Set tSC = ex.AsStatus()
	}	
	
	If $$$ISERR(tSC) {
		Do ..%Log("ERROR:%QueueTask: "_$System.Status.GetErrorText(tSC))
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%BestQueue">
<Description>
Determine which work queue a task should be assigned to.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskGroup</FormalSpec>
<Implementation><![CDATA[
	// DTB706 - Currently this is a simple passthrough. If there is need to logically group several 
	// named task groups to a single WorkMgr groups this will provide that opportunity.
	Quit pTaskGroup
]]></Implementation>
</Method>

<Method name="%StartAgent">
<Description>
 - NOT IMPLEMENTED -
This is handled by the WorkQMgr.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pAgentId:%String,pPriority:%String</FormalSpec>
<Implementation><![CDATA[
	// - NOT IMPLEMENTED -
	$$$ThrowStatus($$$NotImplemented)
	Quit
]]></Implementation>
</Method>

<Method name="%DequeueTask">
<Description>
This is called in %ExecuteTask to mark the task "active" in the process logging.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskGroup:%String,pParameters:%List,pSuppressArchive:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// This does not do anything other than logging, it does not need to perform any execution function
	Set tSC = $$$OK
	
	Try {
		Set tTaskId = $LG(pParameters,1)
		Set tTaskType = $LG(pParameters,2)
		Set tCubeName = $LG(pParameters,3)
		Set tQueryKey = $LG(pParameters,4)
		Set tData = $LG(pParameters,5)
		Set tData2 = $LG(pParameters,6)
		Set tData3 = $LG(pParameters,7)
		Set tSQLParams = $LG(pParameters,8)
		
		// + DTB901 - Set session context if it exists
		If ($G($$$DeepSeeTasksGLVN(tTaskId,"CTX","SESSIONID"))'="") {
			Kill %session
		
			Set %session = ##class(%CSP.Session).%New($$$DeepSeeTasksGLVN(tTaskId,"CTX","SESSIONID"),0)
			Set %session.Language = $G($$$DeepSeeTasksGLVN(tTaskId,"CTX","LANGUAGE"))
		}
		// - DTB901
		
		If $G($$$DeepSeeAgentLogGLVN("settings","useArchive"),0)&&'pSuppressArchive {		// DTB302 - Check for archive suppression
			Set ^DeepSee.TaskArchive(tTaskId) = pParameters
		}
		
		// Mark this as an active task; remove item from queue
		Set $$$DeepSeeActiveTasksGLVN(tTaskId) = $LB($ZDT($ZTS,3,,3),$J,pTaskGroup) _ pParameters
		Kill $$$DeepSeeTasksGLVN(tTaskId)
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%CloseTask">
<Description>
This is called as the callback to %ExecuteTask which cleans up the management global. This
method will also close out the WorkQ if the group was create with pWait = 0.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskGroup:%String,pParameters:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// This does not do anything other than logging, it does not need to perform any execution function
	Set tSC = $$$OK
	
	Try {
		Set tTaskId = $LG(pParameters,1)
		Set tTaskType = $LG(pParameters,2)
		Set tCubeName = $LG(pParameters,3)
		Set tQueryKey = $LG(pParameters,4)
		Set tData = $LG(pParameters,5)
		Set tData2 = $LG(pParameters,6)
		Set tData3 = $LG(pParameters,7)
		Set tSQLParams = $LG(pParameters,8)
		
		// remove task from active list
		Kill $$$DeepSeeActiveTasksGLVN(tTaskId)
		
		// DTB923 - Note the completion of this task in the group log
		Kill $$$DeepSeeTaskGroupGLVN(pTaskGroup,"tasks",tTaskId)
		Set x = $I($$$DeepSeeTaskGroupGLVN(pTaskGroup,"complete"))
		
		If '$G($$$DeepSeeTaskGroupGLVN(pTaskGroup,"wait"),0) {
			// There will not be a call to wait for this group, close it down now.
			Set tQueueName = ..%BestQueue(pTaskGroup)
			
			Lock +$$$DeepSeeAgentsGLVN("workToken",tQueueName)
			Set tWorkMgr = ..%AttachToQueue(tQueueName,.tSC)
			If $$$ISERR(tSC) Quit
			
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("Task group complete: "_pTaskGroup_" "_$G(%dsCubeName))
			}
			
			// Clean up the task work.
			Kill $$$DeepSeeTaskGroupGLVN(pTaskGroup)
			Kill $$$DeepSeeAgentsGLVN("workToken",tQueueName)
			Kill tWorkMgr
			
			Lock -$$$DeepSeeAgentsGLVN("workToken",tQueueName)
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
		Lock -$$$DeepSeeAgentsGLVN("workToken",$G(tQueueName))
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ExecuteTask">
<Description>
This is run by the worker and will do the actual work of processing tasks via the work queue manager</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskGroup:%String,pParameters:%List,pSuppressArchive:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Log this in the task queue to reflect the task is actually being picked up
		Set tSC = ..%DequeueTask(pTaskGroup,pParameters,pSuppressArchive)
		If $$$ISERR(tSC) Quit
		
		// pParameters = $LB(pTaskType As %String, pCubeName As %String, tQueryKey As %String, pData As %String, pData2 As %String, pData3 As %String, pSQLParams)
		Set tTaskId = $LG(pParameters,1)
		Set tTaskType = $LG(pParameters,2)
		Set tCubeName = $LG(pParameters,3)
		Set tQueryKey = $LG(pParameters,4)
		Set tData = $LG(pParameters,5)
		Set tData2 = $LG(pParameters,6)
		Set tData3 = $LG(pParameters,7)
		Set tSQLParams = $LG(pParameters,8)

		If (tTaskType = "EXECQUERY") {

			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("Start " _ tTaskType _ ":" _ tCubeName _ ":" _ tQueryKey _ ":: PARAMETERS:"  _ $ListToString(pParameters,":"))
			}
			
			Set tSC = ##class(%DeepSee.Utils).%ArrayFromList(tSQLParams,.tParms)		// DTB882 - Unpack the parameters
			If $$$ISERR(tSC) Quit

			// clear stats
  			Kill ^IRIS.Temp.DeepSeeUpdate($ZU(5),pTaskGroup,"Cells")
  			Kill ^IRIS.Temp.DeepSeeUpdate($ZU(5),pTaskGroup,"Calcs")

			// re-open query object and calculate cells
			Set tRS = ##class(%DeepSee.ResultSet).%New()
			Set tSC = tRS.%PrepareKey(tCubeName,tQueryKey)		// DTB904 - %PrepareKey executes parameters now, no need to follow it with an extra call
			If $$$ISERR(tSC) Quit
			
			Do tRS.%SetLockKeys(1)
			If $$$ISERR(tSC) Quit

			// make sure execute uses background tasks
			Set tQuery = tRS.%GetQuery()
			Set tQuery.useAgents = 1
			
			// + DTB868 - This process needs to be a writer to run %ExecuteCells
			Set tSC = tRS.%SetLockMode("exclusive")
			If $$$ISERR(tSC) Quit
			
			While 'tRS.%AcquireLocks(.tSC)&&$$$ISOK(tSC) {
				Hang 0.1		// Wait to get locks and try again
				//Set:$$$ISOK(tSC) tSC = $$$ERROR($$$GeneralError,"Failed to obtain write locks for query::"_tCubeName_":"_tQueryKey)
			}
			If $$$ISERR(tSC) Quit
			// - DTB868

			Set tSC = tRS.%ExecuteCells()
			If $$$ISERR(tSC) Quit

			// update stats
  			Set ^IRIS.Temp.DeepSeeUpdate($ZU(5),pTaskGroup,"Cells") = +$G(tQuery.%Statistics("Cells"))
  			Set ^IRIS.Temp.DeepSeeUpdate($ZU(5),pTaskGroup,"Calcs") = $G(tQuery.%Statistics("Calcs"))
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("End " _ tTaskType _ ":" _ tCubeName _ ":" _ tQueryKey)
			}
			
			Do tRS.%ReleaseLocks()		// DTB868 - Release the locks
		}
		ElseIf (tTaskType = "EXECAXES") {
			// JMD1156
			Set tMDX = tData
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("Start " _ tTaskType _ ":" _ tCubeName _ ":" _ tQueryKey)
			}
			
			Set tSC = ##class(%DeepSee.Utils).%ArrayFromList(tSQLParams,.tParms)		// DTB882 - Unpack the parameters
			If $$$ISERR(tSC) Quit

			// JMD1387 ignore concurrency checks when executing axes in the background
			Set %dsForceQuery=1

			// JMD1395 pass filterSpec from foreground along
			Set %dsFilterSpec=tData2
			
			// PFS079 - Extract variable info to pass into %PrepareMDX
			Set tVars = ""
			For tPos = 1:1:$ListLength(tData3) {
				Set tVar = $LG(tData3,tPos)
				Set tVars($LG(tVar,1)) = $LG(tVar,2)
			}

			// re-prepare query object
			Set tRS = ##class(%DeepSee.ResultSet).%New()
			Set tSC = tRS.%PrepareMDX(tMDX,.tVars)
			If $$$ISERR(tSC) Quit

			// DTB884 - Always execute parameters and reset lock keys after executing parameters
			Do tRS.%ClearLockKeys()
			Set tSC = tRS.%ExecuteParameters(.pParms)
			If $$$ISERR(tSC) Quit
			Do tRS.%SetLockKeys(1)

			Kill %dsForceQuery
			Kill %dsFilterSpec

			// make sure execute uses background tasks
			Set tQuery = tRS.%GetQuery()
			
			// DTB788 - Run the query pre-processing to generate member providers
			Set tSC = tQuery.%PreProcessQuery()
			If $$$ISERR(tSC) Quit
			
			Set tQuery.useAgents = 1
			
			// + DTB868 - This process needs to be a writer to run %ExecuteAxes
			Set tSC = tRS.%SetLockMode("exclusive")
			If $$$ISERR(tSC) Quit
			
			While 'tRS.%AcquireLocks(.tSC)&&$$$ISOK(tSC) {
				Hang 0.1		// Wait to get locks and try again
				//Set:$$$ISOK(tSC) tSC = $$$ERROR($$$GeneralError,"Failed to obtain write locks for query::"_tCubeName_":"_tQueryKey)
			}
			If $$$ISERR(tSC) Quit
			// - DTB868
			
			Set tSC = tRS.%ExecuteAxes()
			// + WAL071 -- Axes only queries must do their own cleanup
			Set tCubeIndex = $$$DeepSeeIndex(tQuery.cube)
			Set tQueryKey = tQuery.%QueryKey
			// - WAL071
			If $$$ISERR(tSC) Quit

			// +DTB458 - Log the subquery keys in the results global if a related cube is involved
			Set tSubqueryCube = tRS.%CubeKey
			Set tSubqueryKey = tRS.%GetQueryKey()
			If ($G(tCubeIndex)'="") && (tQueryKey'="") && (tSubqueryCube'="") && (tSubqueryKey'="") && '((tSubqueryCube=$$$UPPER(tCubeIndex)) && (tQueryKey=tSubqueryKey)) {		// DTB670 - Fix condition to make sure self-referenced subqueries don't get logged
				Set $$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"subquery",tSubqueryCube,tSubqueryKey) = "(9)"		// DTB614 - Use tCubeIndex in direct cache interactions
			}
			// -DTB458
			
			Do tRS.%ReleaseLocks()		// DTB868 - Release the locks

			// update stats
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("End " _ tTaskType _ ":" _ tCubeName _ ":" _ tQueryKey)
			}
		}
		ElseIf (tTaskType = "EXECBUCKET") {
			// execute query for one bucket/section
			Set tBucket = tData
			Set tSlotNo = tData2
			Set tSectionList = tData3 // axis:start:end;
			Kill tSections
			If (tSectionList '= "") {
				For i = 1:1:$L(tSectionList,";") {
					Set x = $P(tSectionList,";",i)
					Set a = $P(x,":",1)
					Set tStart = $P(x,":",2)
					Set tEnd = $P(x,":",3)
					Set tSections(a) = $LB(tStart,tEnd)
				}
			}
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("Start " _ tTaskType _ ":" _ tCubeName _ ":" _ tQueryKey _ ":" _ tBucket _ " {" _tSectionList_"}")
			}

			Set tSC = ##class(%DeepSee.Query.Engine).%ExecuteForBucket(tCubeName,tQueryKey,tBucket,tSlotNo,.tSections,,.tStats)
			If $$$ISERR(tSC) Quit

			// update stats
  			Set x = $I(^IRIS.Temp.DeepSeeUpdate($ZU(5),pTaskGroup,"Computes"),+$G(tStats($$$dsqStatCompute)))
  			Set x = $I(^IRIS.Temp.DeepSeeUpdate($ZU(5),pTaskGroup,"CacheHits"),+$G(tStats($$$dsqStatCache)))

			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("End " _ tTaskType _ ":" _ tCubeName _ ":" _ tQueryKey _ ":" _ tBucket _  " {" _tSectionList_"}")
			}
		}
		ElseIf (tTaskType = "UPDATEFACTS") {
			// update a range of rows within a fact table
			// tData is starting id, tData2 is ending id
			Set tFactList = tSQLParams		// DTB891 - Rename for clarity
			New %dsMissingRef
			Set %dsMissingRef = 0
			Set tExtentHasData = 1		// DTB371 - Assume extent has data at the start
			
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("Start " _ tTaskType _ ":" _ tCubeName _ ":" _ tData _ "->" _ tData2)
			}
			Set tClass = ##class(%DeepSee.Utils).%GetCubeClass(tCubeName,.tSC)
			If $$$ISERR(tSC) Quit
			// Use batch mode
			Set tBatch = 1
			
			// DTB371 - If the startId is 0, check to make sure there is actually data in the table!
			If tData=0 {
				Set tSC = $classmethod(tClass,"%GetSourceIds",.tExtentStartId)
				Set:tExtentStartId="" tExtentHasData=0
			}

			If (tExtentHasData) {
				// DTB371 - Only call update facts if the extent actually contains source records
				If $G(tFactList)'="" {
					// DTB891 - Dispatch to %UpdateFactList if the fact list is defined
					// DTB961 - The %UpdateFactsList now can handle the tBatch setting without the caller
					// needing to alter it before the call
					Set tSC = $classmethod(tClass,"%UpdateFactsList",tFactList,tData,tData2,tBatch,0,pTaskGroup)
				}
				Else {
					Set tSC = $classmethod(tClass,"%UpdateFacts",tData,tData2,tBatch,0,pTaskGroup)
				}
			}
			If $$$ISERR(tSC) {
				// JMD1474: ignore
				Set tSC = $$$OK
				Quit
			}
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("End " _ tTaskType _ ":" _ tCubeName _ ":" _ tData _ "->" _ tData2)
			}
			
			// DTB301
			Set inc=$I(^IRIS.Temp.DeepSeeUpdate($ZU(5),pTaskGroup,"missing"),%dsMissingRef)
		}
		ElseIf (tTaskType = "UPDATEFACTSTEMP") {
			Set tFactList = tSQLParams		// DTB891 - Rename for clarity
			// update a range of rows within a fact table
			// using source ids in a temp file (global)
			// tData is temp file key, tData2 is chunk
			New %dsMissingRef
			Set tExtentHasData=1
			
			// Synchronize will turn off the batch mode, build uses it (the default)
			Set tBatch = '+tData3
			
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("Start " _ tTaskType _ ":" _ tCubeName _ ":" _ tData _ "->" _ tData2 _ " ("_$S(tBatch:"build",1:"synchronize")_")")
			}
			Set tClass = ##class(%DeepSee.Utils).%GetCubeClass(tCubeName,.tSC)
			If $$$ISERR(tSC) Quit

			// Loop over temp file
			Set tFactCount = 0
			Set tErrorCount = 0
			Set %dsMissingRef = 0
			
			// PFS094 - Temp file now contains $LB(<sourceId>,<action>)
			Set tOffset = $O($$$DeepSeeTempSourceId(tData,tData2,""),1,tUpdateInfo)
			Set tSourceId = $LG(tUpdateInfo,1)
			Set tAction = $LG(tUpdateInfo,2)
			
			// DTB371 - If the startId is 0, check to make sure there is actually data in the table!
			If $G(tSourceId)=0 {
				Set tSC = $classmethod(tClass,"%GetSourceIds",.tExtentStartId)
				Set:tExtentStartId="" tExtentHasData=0
			}
			
			If (tExtentHasData) {
				// DTB371 - Only call update facts if the extent actually contains source records
				While (tOffset'="") {
					If tAction=2 {
						// PFS094 - Deletes are now asynchronous
						Set tSC = $classmethod(tClass,"%DeleteFact",tSourceId)
					} Else {
						If $G(tFactList)'="" {
							// DTB891 - Dispatch to %UpdateFactList if the fact list is defined
							// DTB961 - The %UpdateFactsList now can handle the tBatch setting without the caller
							// needing to alter it before the call
							Set tSC = $classmethod(tClass,"%UpdateFactsList",tFactList,tSourceId,,tBatch,0,pTaskGroup)
						}
						Else {
							Set tSC = $classmethod(tClass,"%UpdateFacts",tSourceId,,tBatch,0,pTaskGroup)
						}
					}
					
					If $$$ISERR(tSC) {
						Set tErrorCount = tErrorCount+1
						Set tSC = $$$OK		// DTB300 - This does not halt the task
					}
					Set tOffset = $O($$$DeepSeeTempSourceId(tData,tData2,tOffset),1,tUpdateInfo)
					Set tSourceId = $LG(tUpdateInfo,1)
					Set tAction = $LG(tUpdateInfo,2)
				}
				If $$$ISERR(tSC) Quit
			}

			// DTB300 - Log for reporting
			Set inc=$I(^IRIS.Temp.DeepSeeUpdate($ZU(5),pTaskGroup,"errors"),tErrorCount)
			Set inc=$I(^IRIS.Temp.DeepSeeUpdate($ZU(5),pTaskGroup,"missing"),%dsMissingRef)

			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("End " _ tTaskType _ ":" _ tCubeName _ ":" _ tData _ "->" _ tData2)
			}
		}
		ElseIf (tTaskType = "BUILDINDICES") {
			Set tFactList = tSQLParams		// DTB891 - Rename for clarity
			// build indices for a range of rows within a fact table
			// tData is starting id, tData2 is ending id
			Set tRangeStartId = tData
			Set tRangeEndId = tData2
			Set tDelta = tRangeEndId - tRangeStartId + 1
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("Start " _ tTaskType _ ":" _ tCubeName _ ":" _ tData _ "->" _ tData2)
			}

			Set tClass = ##class(%DeepSee.Utils).%GetCubeFactClass(tCubeName,.tSC)
			If $$$ISERR(tSC) Quit
			Set tSC = $classmethod(tClass,"%BuildIndices",tFactList,,,,tRangeStartId,tRangeEndId)		// DTB891 - Use %BuildIndices
			If $$$ISERR(tSC) Quit
  			Set inc=$I(^IRIS.Temp.DeepSeeUpdate($ZU(5),pTaskGroup,"facts"),tDelta)
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("End " _ tTaskType _ ":" _ tCubeName _ ":" _ tData _ "->" _ tData2)
			}
		}
		ElseIf (tTaskType = "PRECOMPUTE") {
			// precompute aggregates a range of rows within a fact table
			// tData is starting chunk, tData2 is ending chunk, tData3 is the bucket slot number
			Set tStartChunk = tData
			Set tEndChunk = tData2
			Set tSlotNo = tData3
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("Start " _ tTaskType _ ":" _ tCubeName _ ":" _ tData _ "->" _ tData2)
			}

			Set tClass = ##class(%DeepSee.Utils).%GetCubeFactClass(tCubeName,.tSC)
			If $$$ISERR(tSC) Quit

			// construct process private GLVN to hold results
			// We use a global to avoid <STORE> errors and indirection to avoid contention!
			Set tAggGLVN = "^||DeepSee.Agg."_$ZCRC(tCubeName,7)_"."_tSlotNo
			Kill @tAggGLVN
			Set tSC = $zobjclassmethod(tClass,"%PrecomputeAggregates",tStartChunk,tEndChunk,tAggGLVN,,pTaskGroup)
			If $$$ISERR(tSC) {
				Kill @tAggGLVN
				Quit
			}
			Kill $$$DeepSeeCellsGLVN($$$UPPER(tCubeName),tSlotNo)
			Merge $$$DeepSeeCellsGLVN($$$UPPER(tCubeName),tSlotNo) = @tAggGLVN
			Kill @tAggGLVN
			If $G($$$DeepSeeAgentLogGLVN("settings","logAll"),0) {
				Do ..%Log("End " _ tTaskType _ ":" _ tCubeName _ ":" _ tData _ "->" _ tData2)
			}
		}
		ElseIf (tTaskType = "JOININDEX") {
			// execute a "bitflip"
			// Cube,RemoteCube,FactNo,Key
			Set tSC = ##class(%DeepSee.Query.Engine).%CreateJoinIndex(tCubeName, tData, tData2,tData3,tQueryKey)
			If $$$ISERR(tSC) Quit
		}
		ElseIf (tTaskType = "COMPUTEKPI") {
			// JMD900
			// compute values for a KPI
			// KPIClass,CacheKey
			Set tSC = $classmethod(tCubeName,"%ComputeKPI",tQueryKey)
			If $$$ISERR(tSC) Quit
		}
		ElseIf (tTaskType = "TEST") {
			// Used by %Test method
			Set ^DeepSee.TestAgents($I(^DeepSee.TestAgents)) = $J _ ":" _ tData
			Hang 2
		}
		Else {
			Set tSC = $$$ERROR($$$GeneralError,"WorkMgr encountered unknown tasktype: " _tTaskType)
			Quit
		}
		
		Set tSC = ..%CloseTask(pTaskGroup,pParameters)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	// Drop any Gateway connections in case queries were run against external tables
	do DropAll^%apiGTW()
	
	// log errors
	If $$$ISERR(tSC) {
		// make note of the error in our task group
		Set:pTaskGroup'="" $$$DeepSeeTaskGroupGLVN(pTaskGroup,"errorCode") = tSC
		Do ..%Log($System.Status.GetErrorText(tSC))
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%Log">
<Description>
 Log a message to the agent log.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMsg:%String</FormalSpec>
<Implementation><![CDATA[
	// Log is a ring buffer of size LOGSIZE
	Set tID = $I($$$DeepSeeAgentLogGLVN)
	Set tLogSize = $G($$$DeepSeeAgentLogGLVN("settings","logSize"),100)
	Set $$$DeepSeeAgentLogGLVN(tID#tLogSize) = $LB(tID,$ZDT($ZTS,3,,3),+$J,+$G(%dsAgentId),+$G(%dsTaskId),pMsg)

	// also log to log file
	Do ##class(%DeepSee.Utils).%WriteToLog("WorkMgr",pMsg)
]]></Implementation>
</Method>

<Method name="%PrintLog">
<Description>
 Print contents of the (global-based) agent log to the console.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	If $D($$$DeepSeeAgentLogGLVN) {
		// log is ring buffer; first build list sorted by time
		Set tID = $O($$$DeepSeeAgentLogGLVN(""),1,tItem)
		While (tID'="") {
			Set tLogID = $LG(tItem,1) 
			Set tTime = $LG(tItem,2)
			Set tList(tTime,tID) = tItem
			Set tID = $O($$$DeepSeeAgentLogGLVN(tID),1,tItem)
		}

		// now print out items
		Write "#",?3,"Time",?18,"Agt",?24,"Tsk",?28,"Message",!
		Set n = 0
		Set tTime = $O(tList(""))
		While (tTime'="") {
			Set tID = $O(tList(tTime,""),1,tItem)
			While (tID'="") {
				Set n = n + 1
				Set tAgentId = $LG(tItem,4)
				Set tTaskId = $LG(tItem,5)
				Set:tTaskId=0 tTaskId="-"
				Set tMsg = $LG(tItem,6)
				Write n,?3,$P(tTime," ",2),?17,$J(tAgentId,4),?22,$J(tTaskId,5),?28,tMsg,!
				Set tID = $O(tList(tTime,tID),1,tItem)
			}
			Set tTime = $O(tList(tTime))
		}
	}
	Else {
		Write "No events in log.",!
	}

	// now print out current active tasks & agents
	Do ..%PrintActiveTasks()
	Do ..%PrintPendingTasks()
	Do ..%PrintAgents()
	Do ..%PrintTaskGroups()
]]></Implementation>
</Method>

<Method name="%PrintTaskGroups">
<Description>
 Print current task groups to the console.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	If $D($$$DeepSeeTaskGroupGLVN) {
		Set n = 0
		Set tTaskGroup = $O($$$DeepSeeTaskGroupGLVN(""))
		While (tTaskGroup'="") {
			Write:n>0 !,"Current Task Groups:",!
			Set n = n+1
			Set tCount = +$G($$$DeepSeeTaskGroupGLVN(tTaskGroup,"count"))
			Set tComplete = +$G($$$DeepSeeTaskGroupGLVN(tTaskGroup,"complete"))
			Set tErrors = +$G($$$DeepSeeTaskGroupGLVN(tTaskGroup,"error"))
			Set tOpen = tCount - tComplete
			Write:tCount>0 tTaskGroup,?20,$J($FN(tOpen,",",0),7)," open task(s)",?45,$FN(((tComplete/tCount)*100),",",2),"%"
			If (tErrors) {
				Write ?50,tErrors," errors(s)"
			}
			Write !
			Set tTaskGroup = $O($$$DeepSeeTaskGroupGLVN(tTaskGroup))
		}
	}
]]></Implementation>
</Method>

<Method name="%PrintActiveTasks">
<Description>
 Print list of active tasks out to the console.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	/*
	Active Tasks for WorkMgr groups are logged
		$LB( $ZDT($ZTS,3,,3) , $J , pTaskGroup ) _ pParameters
	Where:
		Set tTaskId = $LG(pParameters,1)
		Set tTaskType = $LG(pParameters,2)
		Set tCubeName = $LG(pParameters,3)
		Set tQueryKey = $LG(pParameters,4)
		Set tData = $LG(pParameters,5)
		Set tData2 = $LG(pParameters,6)
		Set tData3 = $LG(pParameters,7)
		Set tSQLParams = $LG(pParameters,8)
	*/
	
	If $D($$$DeepSeeActiveTasksGLVN) {
		Write !,"Tasks actively being worked on:",!
		Write "#",?4,"Tsk",?11,"Job",?15,"Group",?22,"Time",?47,"Type",!
		Set n = 0
		Set tTaskId = $O($$$DeepSeeActiveTasksGLVN(""),1,tDetails)
		While (tTaskId'="") {
			Set n = n + 1
			Set tTime = $P($LG(tDetails,1)," ",2)
			Set tJob = $LG(tDetails,2)
			Set tGroup = $LG(tDetails,3)
			Set tType = $LG(tDetails,5)
			Write n,?3,$J(tTaskId,4),?10,$J(tJob,4),?15,tGroup,?22,tTime,?47,tType,!
			Set tTaskId = $O($$$DeepSeeActiveTasksGLVN(tTaskId),1,tDetails)
		}
	}
]]></Implementation>
</Method>

<Method name="%PrintPendingTasks">
<Description>
Print list of pending (queued) tasks out to the console.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	/*
	Task details for WorkMgr groups are logged
		Set tTaskId = $LG(pParameters,1)
		Set tTaskType = $LG(pParameters,2)
		Set tCubeName = $LG(pParameters,3)
		Set tQueryKey = $LG(pParameters,4)
		Set tData = $LG(pParameters,5)
		Set tData2 = $LG(pParameters,6)
		Set tData3 = $LG(pParameters,7)
		Set tSQLParams = $LG(pParameters,8)
	*/
	If $D($$$DeepSeeTasksGLVN) {
		Set n = 0
		Set tTaskId = $O($$$DeepSeeTasksGLVN(""),1,tDetails)
		While (tTaskId'="") {
			If (n=0) {
				Write !,"Tasks pending in work list:",!
				Write "#",?4,"Type",!
			}
			Set n = n + 1
			Set tType = $LG(tDetails,2)
			Set tCubeName = $LG(tDetails,3)
			Write n,?4,tType,?30,tCubeName,!
			Set tTaskId = $O($$$DeepSeeTasksGLVN(tTaskId),1,tDetails)
		}
	}
]]></Implementation>
</Method>

<Method name="%PrintAgents">
<Description>
 Print list of agents out to the console.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	If $D($$$DeepSeeAgentsGLVN) {
		Do ..%CleanAgentsGlobal()		// DTB530
		
		Write !,"Active Agents:",!
		Write "#",?6,"Job",?13,"Prio",?20,"State",!
		Set tID = $O($$$DeepSeeAgentsGLVN(""),1,tItem)
		While (tID'="") {
			Set tJob = $LG(tItem,1)
			Set tState = $LG(tItem,2)
			Set tPriority = $LG(tItem,3)
			Write tID,?4,$J(tJob,6),?13,tPriority,?20,tState,!
			Set tID = $O($$$DeepSeeAgentsGLVN(tID),1,tItem)
		}

	}
]]></Implementation>
</Method>

<Method name="%KillLog">
<Description>
 Kill the agent log.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMsg:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// DTB300 - Preserve the log settings
	If $D($$$DeepSeeAgentLogGLVN("settings")) {
		Merge tLogSettings = $$$DeepSeeAgentLogGLVN("settings")
	}
	Kill $$$DeepSeeAgentLogGLVN
	Merge $$$DeepSeeAgentLogGLVN("settings") = tLogSettings
	
	Kill ^DeepSee.TaskArchive
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%RunArchivedTask">
<Description>
 Diagnostic method.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskId:%Integer,pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK

	Try {
		If '$G($$$DeepSeeAgentLogGLVN("settings","useArchive"),0) {
			Set tSC = $$$ERROR($$$GeneralError,"Task archive not enabled")
			Quit
		}
		
		Set tSC = ..%CreateTaskGroup(.tTaskGroup,0,"RunArchive")

		#; get details
		Set tDetails = $G(^DeepSee.TaskArchive(pTaskId))
		If (tDetails = "") {
			Set tSC = $$$ERROR($$$GeneralError,"No task data found")
			Quit
		}
		
		Set tTaskType = $LG(tDetails,2)
		Set tCubeName = $LG(tDetails,3)
		Set tData = $LG(tDetails,5)

		Write:pVerbose "EXECUTE: ",tTaskType,":",tCubeName,":",tData,!
		Set tSC = ..%ExecuteTask(tTaskGroup,tDetails,1)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		Do:pVerbose $System.Status.DisplayError(tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%QueueArchivedTask">
<Description><![CDATA[
Diagnostic method to dispatch an archived task to a DeepSee background agent. Several tasks can be grouped into a single
batch of archived tasks by supplying a <var>pTaskGroup</var>. If <var>pSuppressArchive</var> = 1, the re-execution of an
archived task will not get archived.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskId:%Integer,pTaskGroup:%String="",pVerbose:%Boolean=1,pSuppressArchive:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If '$G($$$DeepSeeAgentLogGLVN("settings","useArchive"),0) {
			Set tSC = $$$ERROR($$$GeneralError,"Task archive not enabled")
			Quit
		}
		If '+pTaskId {
			Set tSC = $$$ERROR($$$GeneralError,"Task ID is required to execute archived task")
			Quit
		}

		#; get details
		Set tDetails = $G(^DeepSee.TaskArchive(pTaskId))
		If (tDetails = "") {
			Set tSC = $$$ERROR($$$GeneralError,"No task data found")
			Quit
		}
		
		If (pTaskGroup="") {
			// DTB - %QueueArchivedTask has been called without a token, a new WorkMgr is needed
			Set tSC = $$$ERROR($$$GeneralError,"%QueueArchivedTask attempted without a task group")
			Quit
		}
		
		Set tTaskGroup = pTaskGroup
		
		Set tTaskType = $LG(tDetails,2)
		Set tCubeName = $LG(tDetails,3)
		Set tData = $LG(tDetails,5)
		/*
		Set pTaskType = $LG(pParameters,1)
		Set pCubeName = $LG(pParameters,2)
		Set pQueryKey = $LG(pParameters,3)
		Set pData = $LG(pParameters,4)
		Set pData2 = $LG(pParameters,5)
		Set pData3 = $LG(pParameters,6)
		Set pSQLParams = $LG(pParameters,7)
		*/
		
		Write:pVerbose "EXECUTE: ",tTaskType,":",tCubeName,":",tData,!
		Set tSC = pWorkMgr.Queue("##class(%DeepSee.WorkMgr).%ExecuteTask",tTaskGroup,tDetails,1)	
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%RunArchivedTaskGroup">
<Description><![CDATA[
This is a diagnostic utility which will run a group of tasks from the task archive. Siunce the task archive is a ring buffer,
<var>pTaskEndId</var> may be set to 0 to indicate that the method should run to the end of the log. By default the method will 
re-queue the entire task archive beginning at position #1 for processing by DeepSee background agents. When using background 
processing, if <var>pSuppressArchive</var> = 1, then the re-execution of an archived task will not get archived.
<br>
The method can be switched to execute each task sequentially in the foreground by setting <var>pAsync</var>=0. ]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskStartId:%Integer=1,pTaskEndId:%String=0,pAsync:%Boolean=1,pSuppressArchive:%Boolean=1,pWaitTimeout:%Integer=30,pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB302
	If pTaskEndId=0 {
		Set tTaskEndId = $O(^DeepSee.TaskArchive(""),-1)
	}
	Else {
		Set tTaskEndId = pTaskEndId
	}
	Set tTaskEndId = $O(^DeepSee.TaskArchive(tTaskEndId+1),-1)
	
	Set tMaxTaskCount = tTaskEndId-pTaskStartId		// There could be holes in the list of ID's!
	Set tReportDelta = $Select(tMaxTaskCount<10:1,tMaxTaskCount<100:5,1:50)

	Set tSC = $$$OK
	Try {
		If '$G($$$DeepSeeAgentLogGLVN("settings","useArchive"),0) {
			Set tSC = $$$ERROR($$$GeneralError,"Task archive not enabled")
			Quit
		}
		
		// Get the group from first task
		Set tDetails = $G(^DeepSee.TaskArchive(pTaskStartId))
		If (tDetails = "") {
			Set tSC = $$$ERROR($$$GeneralError,"No task data found for archived task "_pTaskStartId)
			Quit
		}
		
		Set tSC = ..%CreateTaskGroup(.tTaskGroup,pAsync,"RunArchiveGroup")
		Write:pVerbose "Task group for archived task execution is " _ tTaskGroup,!
		
		Set tStartTime = $ZH
		
		Set tTaskCount = 0
		Set tTaskId = $O(^DeepSee.TaskArchive(pTaskStartId-1))
		Write:pVerbose ?2,"Begin queueing tasks...",!
		While (tTaskId'="")&&(tTaskId<=tTaskEndId) {
			Set x = $I(tTaskCount)
			
			If pAsync {
				If pVerbose&&'((tTaskCount)#tReportDelta) {
					Write ?2,"Queueing archived task # "_tTaskId,!
				}
				Set tSC = ..%QueueArchivedTask(tTaskId,tTaskGroup)
			}
			Else {
				If pVerbose&&'((tTaskCount)#tReportDelta) {
					Write ?2,"Executing archived task # "_tTaskId,!
				}
				Set tSC =  ..%RunArchivedTask(tTaskId,0)
			}
			
			If $$$ISERR(tSC) $$$ThrowStatus(tSC)
			Set tTaskId = $O(^DeepSee.TaskArchive(tTaskId))
		}
		
		If pAsync {
			If pVerbose {
				Write "Time to queue " _ tTaskCount _ " tasks: " _ ($ZH-tStartTime) _ "s",!
				Write ?2,"Waiting for task group",!
			}
			
			Set tCompleted = 0
			Set tAttempt = 0
			Set tMaxAttempts=5
			While 'tCompleted&&(tAttempt<tMaxAttempts) {
				Set tSC = ..%WaitForTaskGroup(tTaskGroup,.tCompleted,pWaitTimeout)
				If $$$ISERR(tSC) $$$ThrowStatus(tSC)
				
				If ('tCompleted) {
					Set tAttempt = tAttempt + 1
					Write ?2,"Task Group not completed.",!
				}
			}
			
			If 'tCompleted {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Task Group not completed after %1 attempts",tMaxAttempts))
				Quit
			}
			Else {
				Write:pVerbose ?2,"Task group complete",!
			}
		}
		
		Write:pVerbose "Elapsed Time: " _ ($ZH-tStartTime)
	}
	Catch ex {
		If tTaskGroup'="" {
			Do ..%KillTasksForGroup(tTaskGroup)
		}
		Set tSC = ex.AsStatus()
	}
	
	If $$$ISERR(tSC) {
		Write:pVerbose "ERROR: " _ $system.Status.GetOneStatusText(tSC),!
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="%CountLiveAgents">
<Description>
 - NOT IMPLEMENTED -
There is no longer direct management of agents by this class.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPriority="H",*pStatus,pCleanDeadAgents=0</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set pStatus = $$$NotImplemented
	Quit 0
]]></Implementation>
</Method>

<Method name="%AgentsAvailable">
<Description>
 - NOT IMPLEMENTED -
Agents are always available and created as needed. There is no need to test anymore.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPriority="H",*pStatus</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set pStatus = $$$NotImplemented
	Quit 1
]]></Implementation>
</Method>

<Method name="%CleanAgentsGlobal">
<Description>
 - NOT IMPLEMENTED -
The agents global is no longer used.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$NotImplemented
]]></Implementation>
</Method>

<Method name="%Test">
<Description>
 Perform simple test of DeepSee WorkMgr.
 This will kill any pending task.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskCount=25,pTimeOut=0,pClean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill ^DeepSee.TestAgents
		
		Set tTaskCount = pTaskCount

		Write "Create task group: "
		Set tSC = ..%CreateTaskGroup(.tGroupId,1)	
		If $$$ISERR(tSC) {
			Write !,"Error creating task group:",!
			Do $System.Status.DisplayError(tSC)
			Quit
		}
		Write "'",tGroupId,"'",!

		Write "Create tasks"
		For n=1:1:tTaskCount {
			Set tSC = ..%QueueTask(tGroupId, "TEST","","",n*100)
			If $$$ISERR(tSC) Quit
			Write "."
			Hang .1
		}
		
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}

	Write !
	If $$$ISERR(tSC) {
		Write !,"Error queuing task",!
		Do $System.Status.DisplayError(tSC)
		Write !
		Quit tSC
	}
	Else {
		Write !,"Tasks queued successfully",!
	}

	Set tAttempt = 0
	
Wait
	Write "Waiting for tasks: '",tGroupId,"'"
	Set tSC = ..%WaitForTaskGroup(tGroupId,.tCompleted,pTimeOut)
	If $$$ISERR(tSC) {
		Write !,"Error in WaitForTaskGroup:",!
		Do $System.Status.DisplayError(tSC)
		Quit tSC
	}
	Write !

	If ('tCompleted) {
		Set tAttempt = tAttempt + 1
		Write "Task Group not completed.",!
		Goto:tAttempt<10 Wait
	}

	Write "Task Group completed.",!
	Write "Results: x(task) = JOB:DATA",!
	ZW ^DeepSee.TestAgents

	If (pClean) {
		Write "Kill agents..."
		Do ..%KillAgents()
		Write !
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="%InitializeWorkMgr">
<Description>
Create a new %SYSTEM.WorkMgr instance for use managing this DeepSee task queue.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pQueueName,&pStatus]]></FormalSpec>
<ReturnType>%SYSTEM.WorkMgr</ReturnType>
<Implementation><![CDATA[
	// Method added by DTB923
	
	If (pQueueName["UPDATEFACTS") ||
		(pQueueName["BUILDINDICES") ||
		(pQueueName["PRECOMPUTE") {
		// Build operations use the build agent cap
		Set tType = "build"
	}
	Else {
		// All remaining operations use the runTime agent cap
		Set tType = "runTime"
	}
	
	Set tAgentCountMax = ##class(%DeepSee.Utils).%GetAgentCount(tType _ "Max")
	Set tAgentCount = ##class(%DeepSee.Utils).%GetAgentCount(tType)
	
	// Do not request more agents than the max active setting
	If +tAgentCountMax && (tAgentCount > tAgentCountMax) {
		Set tAgentCount = tAgentCountMax
	}
	
	Set tInitializeArgs($I(tInitializeArgs)) = ""				// %New Argument 1
	Set tInitializeArgs($I(tInitializeArgs)) = tAgentCount		// %New Argument 2

	// DTB929 - Check to see if a category maximum exists, add the category name to the arguments if it does
	If +##class(%DeepSee.Utils).%GetAgentCount(tType _ "Max") {
		Set tInitializeArgs($I(tInitializeArgs)) = $$$dsCategoryName(tType)		// %New Argument 3
	}
	
	Set tWorkMgr = ##class(%SYSTEM.WorkMgr).%New(tInitializeArgs...)
	
	// Note that there is an active WorkMgr for this work group.
	Set $$$DeepSeeAgentsGLVN("workToken",pQueueName) = ""
	
	Quit tWorkMgr
]]></Implementation>
</Method>
</Class>


<Project name="TestPatchForLS" LastModified="2020-06-09 14:50:17.127589">
  <Items>
    <ProjectItem name="%DeepSee.CubeDefinition" type="CLS"></ProjectItem>
    <ProjectItem name="%DeepSee.CubeProjection" type="CLS"></ProjectItem>
    <ProjectItem name="%DeepSee.Generator" type="CLS"></ProjectItem>
    <ProjectItem name="%DeepSee.SubjectArea" type="CLS"></ProjectItem>
    <ProjectItem name="%DeepSee.SubjectAreaProjection" type="CLS"></ProjectItem>
    <ProjectItem name="%DeepSee.Utils" type="CLS"></ProjectItem>
    <ProjectItem name="%DeepSee.WorkMgr" type="CLS"></ProjectItem>
    <ProjectItem name="%DeepSee.Component.pivotTable" type="CLS"></ProjectItem>
    <ProjectItem name="%DeepSee.Dashboard.Pivot" type="CLS"></ProjectItem>
    <ProjectItem name="%DeepSee.UI.Architect" type="CLS"></ProjectItem>
  </Items>
</Project>
</Export>
